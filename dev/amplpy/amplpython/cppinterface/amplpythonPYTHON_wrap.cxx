/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 4.0.2
 *
 * This file is not intended to be easily readable and contains a number of
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG
 * interface file instead.
 * ----------------------------------------------------------------------------- */

#ifdef _MSC_VER
#define SWIG_PYTHON_INTERPRETER_NO_DEBUG
#endif



#ifndef SWIGPYTHON
#define SWIGPYTHON
#endif

#define SWIG_DIRECTORS
#define SWIG_PYTHON_DIRECTOR_NO_VTABLE
#define SWIGPYTHON_BUILTIN


#ifdef __cplusplus
/* SwigValueWrapper is described in swig.swg */
template<typename T> class SwigValueWrapper {
  struct SwigMovePointer {
    T *ptr;
    SwigMovePointer(T *p) : ptr(p) { }
    ~SwigMovePointer() { delete ptr; }
    SwigMovePointer& operator=(SwigMovePointer& rhs) { T* oldptr = ptr; ptr = 0; delete oldptr; ptr = rhs.ptr; rhs.ptr = 0; return *this; }
  } pointer;
  SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
  SwigValueWrapper(const SwigValueWrapper<T>& rhs);
public:
  SwigValueWrapper() : pointer(0) { }
  SwigValueWrapper& operator=(const T& t) { SwigMovePointer tmp(new T(t)); pointer = tmp; return *this; }
  operator T&() const { return *pointer.ptr; }
  T *operator&() { return pointer.ptr; }
};

template <typename T> T SwigValueInit() {
  return T();
}
#endif

/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#  define SWIGTEMPLATEDISAMBIGUATOR template
# elif defined(__HP_aCC)
/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
#  define SWIGTEMPLATEDISAMBIGUATOR template
# else
#  define SWIGTEMPLATEDISAMBIGUATOR
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__))
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__))
# else
#   define SWIGUNUSED
# endif
#endif

#ifndef SWIG_MSC_UNSUPPRESS_4505
# if defined(_MSC_VER)
#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
# endif
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if defined(__GNUC__)
#  if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#    ifndef GCC_HASCLASSVISIBILITY
#      define GCC_HASCLASSVISIBILITY
#    endif
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
# define _SCL_SECURE_NO_DEPRECATE
#endif

/* Deal with Apple's deprecated 'AssertMacros.h' from Carbon-framework */
#if defined(__APPLE__) && !defined(__ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES)
# define __ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES 0
#endif

/* Intel's compiler complains if a variable which was never initialised is
 * cast to void, which is a common idiom which we use to indicate that we
 * are aware a variable isn't used.  So we just silence that warning.
 * See: https://github.com/swig/swig/issues/192 for more discussion.
 */
#ifdef __INTEL_COMPILER
# pragma warning disable 592
#endif


#if defined(__GNUC__) && defined(_WIN32) && !defined(SWIG_PYTHON_NO_HYPOT_WORKAROUND)
/* Workaround for '::hypot' has not been declared', see https://bugs.python.org/issue11566 */
# include <math.h>
#endif

#if defined(_DEBUG) && defined(SWIG_PYTHON_INTERPRETER_NO_DEBUG)
/* Use debug wrappers with the Python release dll */
# undef _DEBUG
# include <Python.h>
# define _DEBUG 1
#else
# include <Python.h>
#endif

/* -----------------------------------------------------------------------------
 * swigrun.swg
 *
 * This file contains generic C API SWIG runtime support for pointer
 * type checking.
 * ----------------------------------------------------------------------------- */

/* This should only be incremented when either the layout of swig_type_info changes,
   or for whatever reason, the runtime changes incompatibly */
#define SWIG_RUNTIME_VERSION "4"

/* define SWIG_TYPE_TABLE_NAME as "SWIG_TYPE_TABLE" */
#ifdef SWIG_TYPE_TABLE
# define SWIG_QUOTE_STRING(x) #x
# define SWIG_EXPAND_AND_QUOTE_STRING(x) SWIG_QUOTE_STRING(x)
# define SWIG_TYPE_TABLE_NAME SWIG_EXPAND_AND_QUOTE_STRING(SWIG_TYPE_TABLE)
#else
# define SWIG_TYPE_TABLE_NAME
#endif

/*
  You can use the SWIGRUNTIME and SWIGRUNTIMEINLINE macros for
  creating a static or dynamic library from the SWIG runtime code.
  In 99.9% of the cases, SWIG just needs to declare them as 'static'.

  But only do this if strictly necessary, ie, if you have problems
  with your compiler or suchlike.
*/

#ifndef SWIGRUNTIME
# define SWIGRUNTIME SWIGINTERN
#endif

#ifndef SWIGRUNTIMEINLINE
# define SWIGRUNTIMEINLINE SWIGRUNTIME SWIGINLINE
#endif

/*  Generic buffer size */
#ifndef SWIG_BUFFER_SIZE
# define SWIG_BUFFER_SIZE 1024
#endif

/* Flags for pointer conversions */
#define SWIG_POINTER_DISOWN        0x1
#define SWIG_CAST_NEW_MEMORY       0x2
#define SWIG_POINTER_NO_NULL       0x4

/* Flags for new pointer objects */
#define SWIG_POINTER_OWN           0x1


/*
   Flags/methods for returning states.

   The SWIG conversion methods, as ConvertPtr, return an integer
   that tells if the conversion was successful or not. And if not,
   an error code can be returned (see swigerrors.swg for the codes).

   Use the following macros/flags to set or process the returning
   states.

   In old versions of SWIG, code such as the following was usually written:

     if (SWIG_ConvertPtr(obj,vptr,ty.flags) != -1) {
       // success code
     } else {
       //fail code
     }

   Now you can be more explicit:

    int res = SWIG_ConvertPtr(obj,vptr,ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
    } else {
      // fail code
    }

   which is the same really, but now you can also do

    Type *ptr;
    int res = SWIG_ConvertPtr(obj,(void **)(&ptr),ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
      if (SWIG_IsNewObj(res) {
        ...
	delete *ptr;
      } else {
        ...
      }
    } else {
      // fail code
    }

   I.e., now SWIG_ConvertPtr can return new objects and you can
   identify the case and take care of the deallocation. Of course that
   also requires SWIG_ConvertPtr to return new result values, such as

      int SWIG_ConvertPtr(obj, ptr,...) {
        if (<obj is ok>) {
          if (<need new object>) {
            *ptr = <ptr to new allocated object>;
            return SWIG_NEWOBJ;
          } else {
            *ptr = <ptr to old object>;
            return SWIG_OLDOBJ;
          }
        } else {
          return SWIG_BADOBJ;
        }
      }

   Of course, returning the plain '0(success)/-1(fail)' still works, but you can be
   more explicit by returning SWIG_BADOBJ, SWIG_ERROR or any of the
   SWIG errors code.

   Finally, if the SWIG_CASTRANK_MODE is enabled, the result code
   allows to return the 'cast rank', for example, if you have this

       int food(double)
       int fooi(int);

   and you call

      food(1)   // cast rank '1'  (1 -> 1.0)
      fooi(1)   // cast rank '0'

   just use the SWIG_AddCast()/SWIG_CheckState()
*/

#define SWIG_OK                    (0)
#define SWIG_ERROR                 (-1)
#define SWIG_IsOK(r)               (r >= 0)
#define SWIG_ArgError(r)           ((r != SWIG_ERROR) ? r : SWIG_TypeError)

/* The CastRankLimit says how many bits are used for the cast rank */
#define SWIG_CASTRANKLIMIT         (1 << 8)
/* The NewMask denotes the object was created (using new/malloc) */
#define SWIG_NEWOBJMASK            (SWIG_CASTRANKLIMIT  << 1)
/* The TmpMask is for in/out typemaps that use temporal objects */
#define SWIG_TMPOBJMASK            (SWIG_NEWOBJMASK << 1)
/* Simple returning values */
#define SWIG_BADOBJ                (SWIG_ERROR)
#define SWIG_OLDOBJ                (SWIG_OK)
#define SWIG_NEWOBJ                (SWIG_OK | SWIG_NEWOBJMASK)
#define SWIG_TMPOBJ                (SWIG_OK | SWIG_TMPOBJMASK)
/* Check, add and del mask methods */
#define SWIG_AddNewMask(r)         (SWIG_IsOK(r) ? (r | SWIG_NEWOBJMASK) : r)
#define SWIG_DelNewMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_NEWOBJMASK) : r)
#define SWIG_IsNewObj(r)           (SWIG_IsOK(r) && (r & SWIG_NEWOBJMASK))
#define SWIG_AddTmpMask(r)         (SWIG_IsOK(r) ? (r | SWIG_TMPOBJMASK) : r)
#define SWIG_DelTmpMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_TMPOBJMASK) : r)
#define SWIG_IsTmpObj(r)           (SWIG_IsOK(r) && (r & SWIG_TMPOBJMASK))

/* Cast-Rank Mode */
#if defined(SWIG_CASTRANK_MODE)
#  ifndef SWIG_TypeRank
#    define SWIG_TypeRank             unsigned long
#  endif
#  ifndef SWIG_MAXCASTRANK            /* Default cast allowed */
#    define SWIG_MAXCASTRANK          (2)
#  endif
#  define SWIG_CASTRANKMASK          ((SWIG_CASTRANKLIMIT) -1)
#  define SWIG_CastRank(r)           (r & SWIG_CASTRANKMASK)
SWIGINTERNINLINE int SWIG_AddCast(int r) {
  return SWIG_IsOK(r) ? ((SWIG_CastRank(r) < SWIG_MAXCASTRANK) ? (r + 1) : SWIG_ERROR) : r;
}
SWIGINTERNINLINE int SWIG_CheckState(int r) {
  return SWIG_IsOK(r) ? SWIG_CastRank(r) + 1 : 0;
}
#else /* no cast-rank mode */
#  define SWIG_AddCast(r) (r)
#  define SWIG_CheckState(r) (SWIG_IsOK(r) ? 1 : 0)
#endif


#include <string.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef void *(*swig_converter_func)(void *, int *);
typedef struct swig_type_info *(*swig_dycast_func)(void **);

/* Structure to store information on one type */
typedef struct swig_type_info {
  const char             *name;			/* mangled name of this type */
  const char             *str;			/* human readable name of this type */
  swig_dycast_func        dcast;		/* dynamic cast function down a hierarchy */
  struct swig_cast_info  *cast;			/* linked list of types that can cast into this type */
  void                   *clientdata;		/* language specific type data */
  int                    owndata;		/* flag if the structure owns the clientdata */
} swig_type_info;

/* Structure to store a type and conversion function used for casting */
typedef struct swig_cast_info {
  swig_type_info         *type;			/* pointer to type that is equivalent to this type */
  swig_converter_func     converter;		/* function to cast the void pointers */
  struct swig_cast_info  *next;			/* pointer to next cast in linked list */
  struct swig_cast_info  *prev;			/* pointer to the previous cast */
} swig_cast_info;

/* Structure used to store module information
 * Each module generates one structure like this, and the runtime collects
 * all of these structures and stores them in a circularly linked list.*/
typedef struct swig_module_info {
  swig_type_info         **types;		/* Array of pointers to swig_type_info structures that are in this module */
  size_t                 size;		        /* Number of types in this module */
  struct swig_module_info *next;		/* Pointer to next element in circularly linked list */
  swig_type_info         **type_initial;	/* Array of initially generated type structures */
  swig_cast_info         **cast_initial;	/* Array of initially generated casting structures */
  void                    *clientdata;		/* Language specific module data */
} swig_module_info;

/*
  Compare two type names skipping the space characters, therefore
  "char*" == "char *" and "Class<int>" == "Class<int >", etc.

  Return 0 when the two name types are equivalent, as in
  strncmp, but skipping ' '.
*/
SWIGRUNTIME int
SWIG_TypeNameComp(const char *f1, const char *l1,
		  const char *f2, const char *l2) {
  for (;(f1 != l1) && (f2 != l2); ++f1, ++f2) {
    while ((*f1 == ' ') && (f1 != l1)) ++f1;
    while ((*f2 == ' ') && (f2 != l2)) ++f2;
    if (*f1 != *f2) return (*f1 > *f2) ? 1 : -1;
  }
  return (int)((l1 - f1) - (l2 - f2));
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if equal, -1 if nb < tb, 1 if nb > tb
*/
SWIGRUNTIME int
SWIG_TypeCmp(const char *nb, const char *tb) {
  int equiv = 1;
  const char* te = tb + strlen(tb);
  const char* ne = nb;
  while (equiv != 0 && *ne) {
    for (nb = ne; *ne; ++ne) {
      if (*ne == '|') break;
    }
    equiv = SWIG_TypeNameComp(nb, ne, tb, te);
    if (*ne) ++ne;
  }
  return equiv;
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if not equal, 1 if equal
*/
SWIGRUNTIME int
SWIG_TypeEquiv(const char *nb, const char *tb) {
  return SWIG_TypeCmp(nb, tb) == 0 ? 1 : 0;
}

/*
  Check the typename
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheck(const char *c, swig_type_info *ty) {
  if (ty) {
    swig_cast_info *iter = ty->cast;
    while (iter) {
      if (strcmp(iter->type->name, c) == 0) {
        if (iter == ty->cast)
          return iter;
        /* Move iter to the top of the linked list */
        iter->prev->next = iter->next;
        if (iter->next)
          iter->next->prev = iter->prev;
        iter->next = ty->cast;
        iter->prev = 0;
        if (ty->cast) ty->cast->prev = iter;
        ty->cast = iter;
        return iter;
      }
      iter = iter->next;
    }
  }
  return 0;
}

/*
  Identical to SWIG_TypeCheck, except strcmp is replaced with a pointer comparison
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheckStruct(swig_type_info *from, swig_type_info *ty) {
  if (ty) {
    swig_cast_info *iter = ty->cast;
    while (iter) {
      if (iter->type == from) {
        if (iter == ty->cast)
          return iter;
        /* Move iter to the top of the linked list */
        iter->prev->next = iter->next;
        if (iter->next)
          iter->next->prev = iter->prev;
        iter->next = ty->cast;
        iter->prev = 0;
        if (ty->cast) ty->cast->prev = iter;
        ty->cast = iter;
        return iter;
      }
      iter = iter->next;
    }
  }
  return 0;
}

/*
  Cast a pointer up an inheritance hierarchy
*/
SWIGRUNTIMEINLINE void *
SWIG_TypeCast(swig_cast_info *ty, void *ptr, int *newmemory) {
  return ((!ty) || (!ty->converter)) ? ptr : (*ty->converter)(ptr, newmemory);
}

/*
   Dynamic pointer casting. Down an inheritance hierarchy
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
  swig_type_info *lastty = ty;
  if (!ty || !ty->dcast) return ty;
  while (ty && (ty->dcast)) {
    ty = (*ty->dcast)(ptr);
    if (ty) lastty = ty;
  }
  return lastty;
}

/*
  Return the name associated with this type
*/
SWIGRUNTIMEINLINE const char *
SWIG_TypeName(const swig_type_info *ty) {
  return ty->name;
}

/*
  Return the pretty name associated with this type,
  that is an unmangled type name in a form presentable to the user.
*/
SWIGRUNTIME const char *
SWIG_TypePrettyName(const swig_type_info *type) {
  /* The "str" field contains the equivalent pretty names of the
     type, separated by vertical-bar characters.  We choose
     to print the last name, as it is often (?) the most
     specific. */
  if (!type) return NULL;
  if (type->str != NULL) {
    const char *last_name = type->str;
    const char *s;
    for (s = type->str; *s; s++)
      if (*s == '|') last_name = s+1;
    return last_name;
  }
  else
    return type->name;
}

/*
   Set the clientdata field for a type
*/
SWIGRUNTIME void
SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
  swig_cast_info *cast = ti->cast;
  /* if (ti->clientdata == clientdata) return; */
  ti->clientdata = clientdata;

  while (cast) {
    if (!cast->converter) {
      swig_type_info *tc = cast->type;
      if (!tc->clientdata) {
	SWIG_TypeClientData(tc, clientdata);
      }
    }
    cast = cast->next;
  }
}
SWIGRUNTIME void
SWIG_TypeNewClientData(swig_type_info *ti, void *clientdata) {
  SWIG_TypeClientData(ti, clientdata);
  ti->owndata = 1;
}

/*
  Search for a swig_type_info structure only by mangled name
  Search is a O(log #types)

  We start searching at module start, and finish searching when start == end.
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_MangledTypeQueryModule(swig_module_info *start,
                            swig_module_info *end,
		            const char *name) {
  swig_module_info *iter = start;
  do {
    if (iter->size) {
      size_t l = 0;
      size_t r = iter->size - 1;
      do {
	/* since l+r >= 0, we can (>> 1) instead (/ 2) */
	size_t i = (l + r) >> 1;
	const char *iname = iter->types[i]->name;
	if (iname) {
	  int compare = strcmp(name, iname);
	  if (compare == 0) {
	    return iter->types[i];
	  } else if (compare < 0) {
	    if (i) {
	      r = i - 1;
	    } else {
	      break;
	    }
	  } else if (compare > 0) {
	    l = i + 1;
	  }
	} else {
	  break; /* should never happen */
	}
      } while (l <= r);
    }
    iter = iter->next;
  } while (iter != end);
  return 0;
}

/*
  Search for a swig_type_info structure for either a mangled name or a human readable name.
  It first searches the mangled names of the types, which is a O(log #types)
  If a type is not found it then searches the human readable names, which is O(#types).

  We start searching at module start, and finish searching when start == end.
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeQueryModule(swig_module_info *start,
                     swig_module_info *end,
		     const char *name) {
  /* STEP 1: Search the name field using binary search */
  swig_type_info *ret = SWIG_MangledTypeQueryModule(start, end, name);
  if (ret) {
    return ret;
  } else {
    /* STEP 2: If the type hasn't been found, do a complete search
       of the str field (the human readable name) */
    swig_module_info *iter = start;
    do {
      size_t i = 0;
      for (; i < iter->size; ++i) {
	if (iter->types[i]->str && (SWIG_TypeEquiv(iter->types[i]->str, name)))
	  return iter->types[i];
      }
      iter = iter->next;
    } while (iter != end);
  }

  /* neither found a match */
  return 0;
}

/*
   Pack binary data into a string
*/
SWIGRUNTIME char *
SWIG_PackData(char *c, void *ptr, size_t sz) {
  static const char hex[17] = "0123456789abcdef";
  const unsigned char *u = (unsigned char *) ptr;
  const unsigned char *eu =  u + sz;
  for (; u != eu; ++u) {
    unsigned char uu = *u;
    *(c++) = hex[(uu & 0xf0) >> 4];
    *(c++) = hex[uu & 0xf];
  }
  return c;
}

/*
   Unpack binary data from a string
*/
SWIGRUNTIME const char *
SWIG_UnpackData(const char *c, void *ptr, size_t sz) {
  unsigned char *u = (unsigned char *) ptr;
  const unsigned char *eu = u + sz;
  for (; u != eu; ++u) {
    char d = *(c++);
    unsigned char uu;
    if ((d >= '0') && (d <= '9'))
      uu = (unsigned char)((d - '0') << 4);
    else if ((d >= 'a') && (d <= 'f'))
      uu = (unsigned char)((d - ('a'-10)) << 4);
    else
      return (char *) 0;
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu |= (unsigned char)(d - '0');
    else if ((d >= 'a') && (d <= 'f'))
      uu |= (unsigned char)(d - ('a'-10));
    else
      return (char *) 0;
    *u = uu;
  }
  return c;
}

/*
   Pack 'void *' into a string buffer.
*/
SWIGRUNTIME char *
SWIG_PackVoidPtr(char *buff, void *ptr, const char *name, size_t bsz) {
  char *r = buff;
  if ((2*sizeof(void *) + 2) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,&ptr,sizeof(void *));
  if (strlen(name) + 1 > (bsz - (r - buff))) return 0;
  strcpy(r,name);
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackVoidPtr(const char *c, void **ptr, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      *ptr = (void *) 0;
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sizeof(void *));
}

SWIGRUNTIME char *
SWIG_PackDataName(char *buff, void *ptr, size_t sz, const char *name, size_t bsz) {
  char *r = buff;
  size_t lname = (name ? strlen(name) : 0);
  if ((2*sz + 2 + lname) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,ptr,sz);
  if (lname) {
    strncpy(r,name,lname+1);
  } else {
    *r = 0;
  }
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackDataName(const char *c, void *ptr, size_t sz, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      memset(ptr,0,sz);
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sz);
}

#ifdef __cplusplus
}
#endif

/*  Errors in SWIG */
#define  SWIG_UnknownError    	   -1
#define  SWIG_IOError        	   -2
#define  SWIG_RuntimeError   	   -3
#define  SWIG_IndexError     	   -4
#define  SWIG_TypeError      	   -5
#define  SWIG_DivisionByZero 	   -6
#define  SWIG_OverflowError  	   -7
#define  SWIG_SyntaxError    	   -8
#define  SWIG_ValueError     	   -9
#define  SWIG_SystemError    	   -10
#define  SWIG_AttributeError 	   -11
#define  SWIG_MemoryError    	   -12
#define  SWIG_NullReferenceError   -13



/* Compatibility macros for Python 3 */
#if PY_VERSION_HEX >= 0x03000000

#define PyClass_Check(obj) PyObject_IsInstance(obj, (PyObject *)&PyType_Type)
#define PyInt_Check(x) PyLong_Check(x)
#define PyInt_AsLong(x) PyLong_AsLong(x)
#define PyInt_FromLong(x) PyLong_FromLong(x)
#define PyInt_FromSize_t(x) PyLong_FromSize_t(x)
#define PyString_Check(name) PyBytes_Check(name)
#define PyString_FromString(x) PyUnicode_FromString(x)
#define PyString_Format(fmt, args)  PyUnicode_Format(fmt, args)
#define PyString_AsString(str) PyBytes_AsString(str)
#define PyString_Size(str) PyBytes_Size(str)	
#define PyString_InternFromString(key) PyUnicode_InternFromString(key)
#define Py_TPFLAGS_HAVE_CLASS Py_TPFLAGS_BASETYPE
#define PyString_AS_STRING(x) PyUnicode_AS_STRING(x)
#define _PyLong_FromSsize_t(x) PyLong_FromSsize_t(x)

#endif

#ifndef Py_TYPE
#  define Py_TYPE(op) ((op)->ob_type)
#endif

/* SWIG APIs for compatibility of both Python 2 & 3 */

#if PY_VERSION_HEX >= 0x03000000
#  define SWIG_Python_str_FromFormat PyUnicode_FromFormat
#else
#  define SWIG_Python_str_FromFormat PyString_FromFormat
#endif


/* Warning: This function will allocate a new string in Python 3,
 * so please call SWIG_Python_str_DelForPy3(x) to free the space.
 */
SWIGINTERN char*
SWIG_Python_str_AsChar(PyObject *str)
{
#if PY_VERSION_HEX >= 0x03030000
  return (char *)PyUnicode_AsUTF8(str);
#elif PY_VERSION_HEX >= 0x03000000
  char *newstr = 0;
  str = PyUnicode_AsUTF8String(str);
  if (str) {
    char *cstr;
    Py_ssize_t len;
    if (PyBytes_AsStringAndSize(str, &cstr, &len) != -1) {
      newstr = (char *) malloc(len+1);
      if (newstr)
        memcpy(newstr, cstr, len+1);
    }
    Py_XDECREF(str);
  }
  return newstr;
#else
  return PyString_AsString(str);
#endif
}

#if PY_VERSION_HEX >= 0x03030000 || PY_VERSION_HEX < 0x03000000
#  define SWIG_Python_str_DelForPy3(x)
#else
#  define SWIG_Python_str_DelForPy3(x) free( (void*) (x) )
#endif


SWIGINTERN PyObject*
SWIG_Python_str_FromChar(const char *c)
{
#if PY_VERSION_HEX >= 0x03000000
  return PyUnicode_FromString(c); 
#else
  return PyString_FromString(c);
#endif
}

#ifndef PyObject_DEL
# define PyObject_DEL PyObject_Del
#endif

// SWIGPY_USE_CAPSULE is no longer used within SWIG itself, but some user
// interface files check for it.
# define SWIGPY_USE_CAPSULE
# define SWIGPY_CAPSULE_NAME ("swig_runtime_data" SWIG_RUNTIME_VERSION ".type_pointer_capsule" SWIG_TYPE_TABLE_NAME)

#if PY_VERSION_HEX < 0x03020000
#define PyDescr_TYPE(x) (((PyDescrObject *)(x))->d_type)
#define PyDescr_NAME(x) (((PyDescrObject *)(x))->d_name)
#define Py_hash_t long
#endif

/* -----------------------------------------------------------------------------
 * error manipulation
 * ----------------------------------------------------------------------------- */

SWIGRUNTIME PyObject*
SWIG_Python_ErrorType(int code) {
  PyObject* type = 0;
  switch(code) {
  case SWIG_MemoryError:
    type = PyExc_MemoryError;
    break;
  case SWIG_IOError:
    type = PyExc_IOError;
    break;
  case SWIG_RuntimeError:
    type = PyExc_RuntimeError;
    break;
  case SWIG_IndexError:
    type = PyExc_IndexError;
    break;
  case SWIG_TypeError:
    type = PyExc_TypeError;
    break;
  case SWIG_DivisionByZero:
    type = PyExc_ZeroDivisionError;
    break;
  case SWIG_OverflowError:
    type = PyExc_OverflowError;
    break;
  case SWIG_SyntaxError:
    type = PyExc_SyntaxError;
    break;
  case SWIG_ValueError:
    type = PyExc_ValueError;
    break;
  case SWIG_SystemError:
    type = PyExc_SystemError;
    break;
  case SWIG_AttributeError:
    type = PyExc_AttributeError;
    break;
  default:
    type = PyExc_RuntimeError;
  }
  return type;
}


SWIGRUNTIME void
SWIG_Python_AddErrorMsg(const char* mesg)
{
  PyObject *type = 0;
  PyObject *value = 0;
  PyObject *traceback = 0;

  if (PyErr_Occurred())
    PyErr_Fetch(&type, &value, &traceback);
  if (value) {
    PyObject *old_str = PyObject_Str(value);
    const char *tmp = SWIG_Python_str_AsChar(old_str);
    PyErr_Clear();
    Py_XINCREF(type);
    if (tmp)
      PyErr_Format(type, "%s %s", tmp, mesg);
    else
      PyErr_Format(type, "%s", mesg);
    SWIG_Python_str_DelForPy3(tmp);
    Py_DECREF(old_str);
    Py_DECREF(value);
  } else {
    PyErr_SetString(PyExc_RuntimeError, mesg);
  }
}

SWIGRUNTIME int
SWIG_Python_TypeErrorOccurred(PyObject *obj)
{
  PyObject *error;
  if (obj)
    return 0;
  error = PyErr_Occurred();
  return error && PyErr_GivenExceptionMatches(error, PyExc_TypeError);
}

SWIGRUNTIME void
SWIG_Python_RaiseOrModifyTypeError(const char *message)
{
  if (SWIG_Python_TypeErrorOccurred(NULL)) {
    /* Use existing TypeError to preserve stacktrace and enhance with given message */
    PyObject *newvalue;
    PyObject *type = NULL, *value = NULL, *traceback = NULL;
    PyErr_Fetch(&type, &value, &traceback);
#if PY_VERSION_HEX >= 0x03000000
    newvalue = PyUnicode_FromFormat("%S\nAdditional information:\n%s", value, message);
#else
    newvalue = PyString_FromFormat("%s\nAdditional information:\n%s", PyString_AsString(value), message);
#endif
    Py_XDECREF(value);
    PyErr_Restore(type, newvalue, traceback);
  } else {
    /* Raise TypeError using given message */
    PyErr_SetString(PyExc_TypeError, message);
  }
}

#if defined(SWIG_PYTHON_NO_THREADS)
#  if defined(SWIG_PYTHON_THREADS)
#    undef SWIG_PYTHON_THREADS
#  endif
#endif
#if defined(SWIG_PYTHON_THREADS) /* Threading support is enabled */
#  if !defined(SWIG_PYTHON_USE_GIL) && !defined(SWIG_PYTHON_NO_USE_GIL)
#    define SWIG_PYTHON_USE_GIL
#  endif
#  if defined(SWIG_PYTHON_USE_GIL) /* Use PyGILState threads calls */
#    ifndef SWIG_PYTHON_INITIALIZE_THREADS
#     define SWIG_PYTHON_INITIALIZE_THREADS  PyEval_InitThreads() 
#    endif
#    ifdef __cplusplus /* C++ code */
       class SWIG_Python_Thread_Block {
         bool status;
         PyGILState_STATE state;
       public:
         void end() { if (status) { PyGILState_Release(state); status = false;} }
         SWIG_Python_Thread_Block() : status(true), state(PyGILState_Ensure()) {}
         ~SWIG_Python_Thread_Block() { end(); }
       };
       class SWIG_Python_Thread_Allow {
         bool status;
         PyThreadState *save;
       public:
         void end() { if (status) { PyEval_RestoreThread(save); status = false; }}
         SWIG_Python_Thread_Allow() : status(true), save(PyEval_SaveThread()) {}
         ~SWIG_Python_Thread_Allow() { end(); }
       };
#      define SWIG_PYTHON_THREAD_BEGIN_BLOCK   SWIG_Python_Thread_Block _swig_thread_block
#      define SWIG_PYTHON_THREAD_END_BLOCK     _swig_thread_block.end()
#      define SWIG_PYTHON_THREAD_BEGIN_ALLOW   SWIG_Python_Thread_Allow _swig_thread_allow
#      define SWIG_PYTHON_THREAD_END_ALLOW     _swig_thread_allow.end()
#    else /* C code */
#      define SWIG_PYTHON_THREAD_BEGIN_BLOCK   PyGILState_STATE _swig_thread_block = PyGILState_Ensure()
#      define SWIG_PYTHON_THREAD_END_BLOCK     PyGILState_Release(_swig_thread_block)
#      define SWIG_PYTHON_THREAD_BEGIN_ALLOW   PyThreadState *_swig_thread_allow = PyEval_SaveThread()
#      define SWIG_PYTHON_THREAD_END_ALLOW     PyEval_RestoreThread(_swig_thread_allow)
#    endif
#  else /* Old thread way, not implemented, user must provide it */
#    if !defined(SWIG_PYTHON_INITIALIZE_THREADS)
#      define SWIG_PYTHON_INITIALIZE_THREADS
#    endif
#    if !defined(SWIG_PYTHON_THREAD_BEGIN_BLOCK)
#      define SWIG_PYTHON_THREAD_BEGIN_BLOCK
#    endif
#    if !defined(SWIG_PYTHON_THREAD_END_BLOCK)
#      define SWIG_PYTHON_THREAD_END_BLOCK
#    endif
#    if !defined(SWIG_PYTHON_THREAD_BEGIN_ALLOW)
#      define SWIG_PYTHON_THREAD_BEGIN_ALLOW
#    endif
#    if !defined(SWIG_PYTHON_THREAD_END_ALLOW)
#      define SWIG_PYTHON_THREAD_END_ALLOW
#    endif
#  endif
#else /* No thread support */
#  define SWIG_PYTHON_INITIALIZE_THREADS
#  define SWIG_PYTHON_THREAD_BEGIN_BLOCK
#  define SWIG_PYTHON_THREAD_END_BLOCK
#  define SWIG_PYTHON_THREAD_BEGIN_ALLOW
#  define SWIG_PYTHON_THREAD_END_ALLOW
#endif

/* -----------------------------------------------------------------------------
 * Python API portion that goes into the runtime
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#endif

/* -----------------------------------------------------------------------------
 * Constant declarations
 * ----------------------------------------------------------------------------- */

/* Constant Types */
#define SWIG_PY_POINTER 4
#define SWIG_PY_BINARY  5

/* Constant information structure */
typedef struct swig_const_info {
  int type;
  const char *name;
  long lvalue;
  double dvalue;
  void   *pvalue;
  swig_type_info **ptype;
} swig_const_info;

#ifdef __cplusplus
}
#endif


/* -----------------------------------------------------------------------------
 * pyrun.swg
 *
 * This file contains the runtime support for Python modules
 * and includes code for managing global variables and pointer
 * type checking.
 *
 * ----------------------------------------------------------------------------- */

#if PY_VERSION_HEX < 0x02070000 /* 2.7.0 */
# error "This version of SWIG only supports Python >= 2.7"
#endif

#if PY_VERSION_HEX >= 0x03000000 && PY_VERSION_HEX < 0x03020000
# error "This version of SWIG only supports Python 3 >= 3.2"
#endif

/* Common SWIG API */

/* for raw pointers */
#define SWIG_Python_ConvertPtr(obj, pptr, type, flags)  SWIG_Python_ConvertPtrAndOwn(obj, pptr, type, flags, 0)
#define SWIG_ConvertPtr(obj, pptr, type, flags)         SWIG_Python_ConvertPtr(obj, pptr, type, flags)
#define SWIG_ConvertPtrAndOwn(obj,pptr,type,flags,own)  SWIG_Python_ConvertPtrAndOwn(obj, pptr, type, flags, own)

#ifdef SWIGPYTHON_BUILTIN
#define SWIG_NewPointerObj(ptr, type, flags)            SWIG_Python_NewPointerObj(self, ptr, type, flags)
#else
#define SWIG_NewPointerObj(ptr, type, flags)            SWIG_Python_NewPointerObj(NULL, ptr, type, flags)
#endif

#define SWIG_InternalNewPointerObj(ptr, type, flags)	SWIG_Python_NewPointerObj(NULL, ptr, type, flags)

#define SWIG_CheckImplicit(ty)                          SWIG_Python_CheckImplicit(ty) 
#define SWIG_AcquirePtr(ptr, src)                       SWIG_Python_AcquirePtr(ptr, src)
#define swig_owntype                                    int

/* for raw packed data */
#define SWIG_ConvertPacked(obj, ptr, sz, ty)            SWIG_Python_ConvertPacked(obj, ptr, sz, ty)
#define SWIG_NewPackedObj(ptr, sz, type)                SWIG_Python_NewPackedObj(ptr, sz, type)

/* for class or struct pointers */
#define SWIG_ConvertInstance(obj, pptr, type, flags)    SWIG_ConvertPtr(obj, pptr, type, flags)
#define SWIG_NewInstanceObj(ptr, type, flags)           SWIG_NewPointerObj(ptr, type, flags)

/* for C or C++ function pointers */
#define SWIG_ConvertFunctionPtr(obj, pptr, type)        SWIG_Python_ConvertFunctionPtr(obj, pptr, type)
#define SWIG_NewFunctionPtrObj(ptr, type)               SWIG_Python_NewPointerObj(NULL, ptr, type, 0)

/* for C++ member pointers, ie, member methods */
#define SWIG_ConvertMember(obj, ptr, sz, ty)            SWIG_Python_ConvertPacked(obj, ptr, sz, ty)
#define SWIG_NewMemberObj(ptr, sz, type)                SWIG_Python_NewPackedObj(ptr, sz, type)


/* Runtime API */

#define SWIG_GetModule(clientdata)                      SWIG_Python_GetModule(clientdata)
#define SWIG_SetModule(clientdata, pointer)             SWIG_Python_SetModule(pointer)
#define SWIG_NewClientData(obj)                         SwigPyClientData_New(obj)

#define SWIG_SetErrorObj                                SWIG_Python_SetErrorObj                            
#define SWIG_SetErrorMsg                        	SWIG_Python_SetErrorMsg				   
#define SWIG_ErrorType(code)                    	SWIG_Python_ErrorType(code)                        
#define SWIG_Error(code, msg)            		SWIG_Python_SetErrorMsg(SWIG_ErrorType(code), msg) 
#define SWIG_fail                        		goto fail					   


/* Runtime API implementation */

/* Error manipulation */

SWIGINTERN void 
SWIG_Python_SetErrorObj(PyObject *errtype, PyObject *obj) {
  SWIG_PYTHON_THREAD_BEGIN_BLOCK; 
  PyErr_SetObject(errtype, obj);
  Py_DECREF(obj);
  SWIG_PYTHON_THREAD_END_BLOCK;
}

SWIGINTERN void 
SWIG_Python_SetErrorMsg(PyObject *errtype, const char *msg) {
  SWIG_PYTHON_THREAD_BEGIN_BLOCK;
  PyErr_SetString(errtype, msg);
  SWIG_PYTHON_THREAD_END_BLOCK;
}

#define SWIG_Python_Raise(obj, type, desc)  SWIG_Python_SetErrorObj(SWIG_Python_ExceptionType(desc), obj)

/* Set a constant value */

#if defined(SWIGPYTHON_BUILTIN)

SWIGINTERN void
SwigPyBuiltin_AddPublicSymbol(PyObject *seq, const char *key) {
  PyObject *s = PyString_InternFromString(key);
  PyList_Append(seq, s);
  Py_DECREF(s);
}

SWIGINTERN void
SWIG_Python_SetConstant(PyObject *d, PyObject *public_interface, const char *name, PyObject *obj) {   
  PyDict_SetItemString(d, name, obj);
  Py_DECREF(obj);
  if (public_interface)
    SwigPyBuiltin_AddPublicSymbol(public_interface, name);
}

#else

SWIGINTERN void
SWIG_Python_SetConstant(PyObject *d, const char *name, PyObject *obj) {   
  PyDict_SetItemString(d, name, obj);
  Py_DECREF(obj);                            
}

#endif

/* Append a value to the result obj */

SWIGINTERN PyObject*
SWIG_Python_AppendOutput(PyObject* result, PyObject* obj) {
  if (!result) {
    result = obj;
  } else if (result == Py_None) {
    Py_DECREF(result);
    result = obj;
  } else {
    if (!PyList_Check(result)) {
      PyObject *o2 = result;
      result = PyList_New(1);
      PyList_SetItem(result, 0, o2);
    }
    PyList_Append(result,obj);
    Py_DECREF(obj);
  }
  return result;
}

/* Unpack the argument tuple */

SWIGINTERN Py_ssize_t
SWIG_Python_UnpackTuple(PyObject *args, const char *name, Py_ssize_t min, Py_ssize_t max, PyObject **objs)
{
  if (!args) {
    if (!min && !max) {
      return 1;
    } else {
      PyErr_Format(PyExc_TypeError, "%s expected %s%d arguments, got none", 
		   name, (min == max ? "" : "at least "), (int)min);
      return 0;
    }
  }  
  if (!PyTuple_Check(args)) {
    if (min <= 1 && max >= 1) {
      Py_ssize_t i;
      objs[0] = args;
      for (i = 1; i < max; ++i) {
	objs[i] = 0;
      }
      return 2;
    }
    PyErr_SetString(PyExc_SystemError, "UnpackTuple() argument list is not a tuple");
    return 0;
  } else {
    Py_ssize_t l = PyTuple_GET_SIZE(args);
    if (l < min) {
      PyErr_Format(PyExc_TypeError, "%s expected %s%d arguments, got %d", 
		   name, (min == max ? "" : "at least "), (int)min, (int)l);
      return 0;
    } else if (l > max) {
      PyErr_Format(PyExc_TypeError, "%s expected %s%d arguments, got %d", 
		   name, (min == max ? "" : "at most "), (int)max, (int)l);
      return 0;
    } else {
      Py_ssize_t i;
      for (i = 0; i < l; ++i) {
	objs[i] = PyTuple_GET_ITEM(args, i);
      }
      for (; l < max; ++l) {
	objs[l] = 0;
      }
      return i + 1;
    }    
  }
}

SWIGINTERN int
SWIG_Python_CheckNoKeywords(PyObject *kwargs, const char *name) {
  int no_kwargs = 1;
  if (kwargs) {
    assert(PyDict_Check(kwargs));
    if (PyDict_Size(kwargs) > 0) {
      PyErr_Format(PyExc_TypeError, "%s() does not take keyword arguments", name);
      no_kwargs = 0;
    }
  }
  return no_kwargs;
}

/* A functor is a function object with one single object argument */
#define SWIG_Python_CallFunctor(functor, obj)	        PyObject_CallFunctionObjArgs(functor, obj, NULL);

/*
  Helper for static pointer initialization for both C and C++ code, for example
  static PyObject *SWIG_STATIC_POINTER(MyVar) = NewSomething(...);
*/
#ifdef __cplusplus
#define SWIG_STATIC_POINTER(var)  var
#else
#define SWIG_STATIC_POINTER(var)  var = 0; if (!var) var
#endif

/* -----------------------------------------------------------------------------
 * Pointer declarations
 * ----------------------------------------------------------------------------- */

/* Flags for new pointer objects */
#define SWIG_POINTER_NOSHADOW       (SWIG_POINTER_OWN      << 1)
#define SWIG_POINTER_NEW            (SWIG_POINTER_NOSHADOW | SWIG_POINTER_OWN)

#define SWIG_POINTER_IMPLICIT_CONV  (SWIG_POINTER_DISOWN   << 1)

#define SWIG_BUILTIN_TP_INIT	    (SWIG_POINTER_OWN << 2)
#define SWIG_BUILTIN_INIT	    (SWIG_BUILTIN_TP_INIT | SWIG_POINTER_OWN)

#ifdef __cplusplus
extern "C" {
#endif

/* The python void return value */

SWIGRUNTIMEINLINE PyObject * 
SWIG_Py_Void(void)
{
  PyObject *none = Py_None;
  Py_INCREF(none);
  return none;
}

/* SwigPyClientData */

typedef struct {
  PyObject *klass;
  PyObject *newraw;
  PyObject *newargs;
  PyObject *destroy;
  int delargs;
  int implicitconv;
  PyTypeObject *pytype;
} SwigPyClientData;

SWIGRUNTIMEINLINE int 
SWIG_Python_CheckImplicit(swig_type_info *ty)
{
  SwigPyClientData *data = (SwigPyClientData *)ty->clientdata;
  int fail = data ? data->implicitconv : 0;
  if (fail)
    PyErr_SetString(PyExc_TypeError, "Implicit conversion is prohibited for explicit constructors.");
  return fail;
}

SWIGRUNTIMEINLINE PyObject *
SWIG_Python_ExceptionType(swig_type_info *desc) {
  SwigPyClientData *data = desc ? (SwigPyClientData *) desc->clientdata : 0;
  PyObject *klass = data ? data->klass : 0;
  return (klass ? klass : PyExc_RuntimeError);
}


SWIGRUNTIME SwigPyClientData * 
SwigPyClientData_New(PyObject* obj)
{
  if (!obj) {
    return 0;
  } else {
    SwigPyClientData *data = (SwigPyClientData *)malloc(sizeof(SwigPyClientData));
    /* the klass element */
    data->klass = obj;
    Py_INCREF(data->klass);
    /* the newraw method and newargs arguments used to create a new raw instance */
    if (PyClass_Check(obj)) {
      data->newraw = 0;
      data->newargs = obj;
      Py_INCREF(obj);
    } else {
      data->newraw = PyObject_GetAttrString(data->klass, "__new__");
      if (data->newraw) {
	Py_INCREF(data->newraw);
	data->newargs = PyTuple_New(1);
	PyTuple_SetItem(data->newargs, 0, obj);
      } else {
	data->newargs = obj;
      }
      Py_INCREF(data->newargs);
    }
    /* the destroy method, aka as the C++ delete method */
    data->destroy = PyObject_GetAttrString(data->klass, "__swig_destroy__");
    if (PyErr_Occurred()) {
      PyErr_Clear();
      data->destroy = 0;
    }
    if (data->destroy) {
      int flags;
      Py_INCREF(data->destroy);
      flags = PyCFunction_GET_FLAGS(data->destroy);
      data->delargs = !(flags & (METH_O));
    } else {
      data->delargs = 0;
    }
    data->implicitconv = 0;
    data->pytype = 0;
    return data;
  }
}

SWIGRUNTIME void 
SwigPyClientData_Del(SwigPyClientData *data) {
  Py_XDECREF(data->newraw);
  Py_XDECREF(data->newargs);
  Py_XDECREF(data->destroy);
}

/* =============== SwigPyObject =====================*/

typedef struct {
  PyObject_HEAD
  void *ptr;
  swig_type_info *ty;
  int own;
  PyObject *next;
#ifdef SWIGPYTHON_BUILTIN
  PyObject *dict;
#endif
} SwigPyObject;


#ifdef SWIGPYTHON_BUILTIN

SWIGRUNTIME PyObject *
SwigPyObject_get___dict__(PyObject *v, PyObject *SWIGUNUSEDPARM(args))
{
  SwigPyObject *sobj = (SwigPyObject *)v;

  if (!sobj->dict)
    sobj->dict = PyDict_New();

  Py_INCREF(sobj->dict);
  return sobj->dict;
}

#endif

SWIGRUNTIME PyObject *
SwigPyObject_long(SwigPyObject *v)
{
  return PyLong_FromVoidPtr(v->ptr);
}

SWIGRUNTIME PyObject *
SwigPyObject_format(const char* fmt, SwigPyObject *v)
{
  PyObject *res = NULL;
  PyObject *args = PyTuple_New(1);
  if (args) {
    if (PyTuple_SetItem(args, 0, SwigPyObject_long(v)) == 0) {
      PyObject *ofmt = SWIG_Python_str_FromChar(fmt);
      if (ofmt) {
#if PY_VERSION_HEX >= 0x03000000
	res = PyUnicode_Format(ofmt,args);
#else
	res = PyString_Format(ofmt,args);
#endif
	Py_DECREF(ofmt);
      }
      Py_DECREF(args);
    }
  }
  return res;
}

SWIGRUNTIME PyObject *
SwigPyObject_oct(SwigPyObject *v)
{
  return SwigPyObject_format("%o",v);
}

SWIGRUNTIME PyObject *
SwigPyObject_hex(SwigPyObject *v)
{
  return SwigPyObject_format("%x",v);
}

SWIGRUNTIME PyObject *
SwigPyObject_repr(SwigPyObject *v)
{
  const char *name = SWIG_TypePrettyName(v->ty);
  PyObject *repr = SWIG_Python_str_FromFormat("<Swig Object of type '%s' at %p>", (name ? name : "unknown"), (void *)v);
  if (v->next) {
    PyObject *nrep = SwigPyObject_repr((SwigPyObject *)v->next);
# if PY_VERSION_HEX >= 0x03000000
    PyObject *joined = PyUnicode_Concat(repr, nrep);
    Py_DecRef(repr);
    Py_DecRef(nrep);
    repr = joined;
# else
    PyString_ConcatAndDel(&repr,nrep);
# endif
  }
  return repr;  
}

/* We need a version taking two PyObject* parameters so it's a valid
 * PyCFunction to use in swigobject_methods[]. */
SWIGRUNTIME PyObject *
SwigPyObject_repr2(PyObject *v, PyObject *SWIGUNUSEDPARM(args))
{
  return SwigPyObject_repr((SwigPyObject*)v);
}

SWIGRUNTIME int
SwigPyObject_compare(SwigPyObject *v, SwigPyObject *w)
{
  void *i = v->ptr;
  void *j = w->ptr;
  return (i < j) ? -1 : ((i > j) ? 1 : 0);
}

/* Added for Python 3.x, would it also be useful for Python 2.x? */
SWIGRUNTIME PyObject*
SwigPyObject_richcompare(SwigPyObject *v, SwigPyObject *w, int op)
{
  PyObject* res;
  if( op != Py_EQ && op != Py_NE ) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  res = PyBool_FromLong( (SwigPyObject_compare(v, w)==0) == (op == Py_EQ) ? 1 : 0);
  return res;  
}


SWIGRUNTIME PyTypeObject* SwigPyObject_TypeOnce(void);

#ifdef SWIGPYTHON_BUILTIN
static swig_type_info *SwigPyObject_stype = 0;
SWIGRUNTIME PyTypeObject*
SwigPyObject_type(void) {
    SwigPyClientData *cd;
    assert(SwigPyObject_stype);
    cd = (SwigPyClientData*) SwigPyObject_stype->clientdata;
    assert(cd);
    assert(cd->pytype);
    return cd->pytype;
}
#else
SWIGRUNTIME PyTypeObject*
SwigPyObject_type(void) {
  static PyTypeObject *SWIG_STATIC_POINTER(type) = SwigPyObject_TypeOnce();
  return type;
}
#endif

SWIGRUNTIMEINLINE int
SwigPyObject_Check(PyObject *op) {
#ifdef SWIGPYTHON_BUILTIN
  PyTypeObject *target_tp = SwigPyObject_type();
  if (PyType_IsSubtype(op->ob_type, target_tp))
    return 1;
  return (strcmp(op->ob_type->tp_name, "SwigPyObject") == 0);
#else
  return (Py_TYPE(op) == SwigPyObject_type())
    || (strcmp(Py_TYPE(op)->tp_name,"SwigPyObject") == 0);
#endif
}

SWIGRUNTIME PyObject *
SwigPyObject_New(void *ptr, swig_type_info *ty, int own);

SWIGRUNTIME void
SwigPyObject_dealloc(PyObject *v)
{
  SwigPyObject *sobj = (SwigPyObject *) v;
  PyObject *next = sobj->next;
  if (sobj->own == SWIG_POINTER_OWN) {
    swig_type_info *ty = sobj->ty;
    SwigPyClientData *data = ty ? (SwigPyClientData *) ty->clientdata : 0;
    PyObject *destroy = data ? data->destroy : 0;
    if (destroy) {
      /* destroy is always a VARARGS method */
      PyObject *res;

      /* PyObject_CallFunction() has the potential to silently drop
         the active exception.  In cases of unnamed temporary
         variable or where we just finished iterating over a generator
         StopIteration will be active right now, and this needs to
         remain true upon return from SwigPyObject_dealloc.  So save
         and restore. */
      
      PyObject *type = NULL, *value = NULL, *traceback = NULL;
      PyErr_Fetch(&type, &value, &traceback);

      if (data->delargs) {
        /* we need to create a temporary object to carry the destroy operation */
        PyObject *tmp = SwigPyObject_New(sobj->ptr, ty, 0);
        res = SWIG_Python_CallFunctor(destroy, tmp);
        Py_DECREF(tmp);
      } else {
        PyCFunction meth = PyCFunction_GET_FUNCTION(destroy);
        PyObject *mself = PyCFunction_GET_SELF(destroy);
        res = ((*meth)(mself, v));
      }
      if (!res)
        PyErr_WriteUnraisable(destroy);

      PyErr_Restore(type, value, traceback);

      Py_XDECREF(res);
    } 
#if !defined(SWIG_PYTHON_SILENT_MEMLEAK)
    else {
      const char *name = SWIG_TypePrettyName(ty);
      printf("swig/python detected a memory leak of type '%s', no destructor found.\n", (name ? name : "unknown"));
    }
#endif
  } 
  Py_XDECREF(next);
  PyObject_DEL(v);
}

SWIGRUNTIME PyObject* 
SwigPyObject_append(PyObject* v, PyObject* next)
{
  SwigPyObject *sobj = (SwigPyObject *) v;
  if (!SwigPyObject_Check(next)) {
    PyErr_SetString(PyExc_TypeError, "Attempt to append a non SwigPyObject");
    return NULL;
  }
  sobj->next = next;
  Py_INCREF(next);
  return SWIG_Py_Void();
}

SWIGRUNTIME PyObject* 
SwigPyObject_next(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
{
  SwigPyObject *sobj = (SwigPyObject *) v;
  if (sobj->next) {    
    Py_INCREF(sobj->next);
    return sobj->next;
  } else {
    return SWIG_Py_Void();
  }
}

SWIGINTERN PyObject*
SwigPyObject_disown(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
{
  SwigPyObject *sobj = (SwigPyObject *)v;
  sobj->own = 0;
  return SWIG_Py_Void();
}

SWIGINTERN PyObject*
SwigPyObject_acquire(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
{
  SwigPyObject *sobj = (SwigPyObject *)v;
  sobj->own = SWIG_POINTER_OWN;
  return SWIG_Py_Void();
}

SWIGINTERN PyObject*
SwigPyObject_own(PyObject *v, PyObject *args)
{
  PyObject *val = 0;
  if (!PyArg_UnpackTuple(args, "own", 0, 1, &val)) {
    return NULL;
  } else {
    SwigPyObject *sobj = (SwigPyObject *)v;
    PyObject *obj = PyBool_FromLong(sobj->own);
    if (val) {
      if (PyObject_IsTrue(val)) {
        SwigPyObject_acquire(v,args);
      } else {
        SwigPyObject_disown(v,args);
      }
    } 
    return obj;
  }
}

static PyMethodDef
swigobject_methods[] = {
  {"disown",  SwigPyObject_disown,  METH_NOARGS,  "releases ownership of the pointer"},
  {"acquire", SwigPyObject_acquire, METH_NOARGS,  "acquires ownership of the pointer"},
  {"own",     SwigPyObject_own,     METH_VARARGS, "returns/sets ownership of the pointer"},
  {"append",  SwigPyObject_append,  METH_O,       "appends another 'this' object"},
  {"next",    SwigPyObject_next,    METH_NOARGS,  "returns the next 'this' object"},
  {"__repr__",SwigPyObject_repr2,   METH_NOARGS,  "returns object representation"},
  {0, 0, 0, 0}  
};

SWIGRUNTIME PyTypeObject*
SwigPyObject_TypeOnce(void) {
  static char swigobject_doc[] = "Swig object carries a C/C++ instance pointer";

  static PyNumberMethods SwigPyObject_as_number = {
    (binaryfunc)0, /*nb_add*/
    (binaryfunc)0, /*nb_subtract*/
    (binaryfunc)0, /*nb_multiply*/
    /* nb_divide removed in Python 3 */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc)0, /*nb_divide*/
#endif
    (binaryfunc)0, /*nb_remainder*/
    (binaryfunc)0, /*nb_divmod*/
    (ternaryfunc)0,/*nb_power*/
    (unaryfunc)0,  /*nb_negative*/
    (unaryfunc)0,  /*nb_positive*/
    (unaryfunc)0,  /*nb_absolute*/
    (inquiry)0,    /*nb_nonzero*/
    0,		   /*nb_invert*/
    0,		   /*nb_lshift*/
    0,		   /*nb_rshift*/
    0,		   /*nb_and*/
    0,		   /*nb_xor*/
    0,		   /*nb_or*/
#if PY_VERSION_HEX < 0x03000000
    0,   /*nb_coerce*/
#endif
    (unaryfunc)SwigPyObject_long, /*nb_int*/
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc)SwigPyObject_long, /*nb_long*/
#else
    0, /*nb_reserved*/
#endif
    (unaryfunc)0,                 /*nb_float*/
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc)SwigPyObject_oct,  /*nb_oct*/
    (unaryfunc)SwigPyObject_hex,  /*nb_hex*/
#endif
#if PY_VERSION_HEX >= 0x03050000 /* 3.5 */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_inplace_matrix_multiply */
#elif PY_VERSION_HEX >= 0x03000000 /* 3.0 */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_index, nb_inplace_divide removed */
#else
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_index */
#endif
  };

  static PyTypeObject swigpyobject_type;
  static int type_init = 0;
  if (!type_init) {
    const PyTypeObject tmp = {
#if PY_VERSION_HEX >= 0x03000000
      PyVarObject_HEAD_INIT(NULL, 0)
#else
      PyObject_HEAD_INIT(NULL)
      0,                                    /* ob_size */
#endif
      "SwigPyObject",                       /* tp_name */
      sizeof(SwigPyObject),                 /* tp_basicsize */
      0,                                    /* tp_itemsize */
      (destructor)SwigPyObject_dealloc,     /* tp_dealloc */
      0,                                    /* tp_print */
      (getattrfunc)0,                       /* tp_getattr */
      (setattrfunc)0,                       /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
      0, /* tp_reserved in 3.0.1, tp_compare in 3.0.0 but not used */
#else
      (cmpfunc)SwigPyObject_compare,        /* tp_compare */
#endif
      (reprfunc)SwigPyObject_repr,          /* tp_repr */
      &SwigPyObject_as_number,              /* tp_as_number */
      0,                                    /* tp_as_sequence */
      0,                                    /* tp_as_mapping */
      (hashfunc)0,                          /* tp_hash */
      (ternaryfunc)0,                       /* tp_call */
      0,                                    /* tp_str */
      PyObject_GenericGetAttr,              /* tp_getattro */
      0,                                    /* tp_setattro */
      0,                                    /* tp_as_buffer */
      Py_TPFLAGS_DEFAULT,                   /* tp_flags */
      swigobject_doc,                       /* tp_doc */
      0,                                    /* tp_traverse */
      0,                                    /* tp_clear */
      (richcmpfunc)SwigPyObject_richcompare,/* tp_richcompare */
      0,                                    /* tp_weaklistoffset */
      0,                                    /* tp_iter */
      0,                                    /* tp_iternext */
      swigobject_methods,                   /* tp_methods */
      0,                                    /* tp_members */
      0,                                    /* tp_getset */
      0,                                    /* tp_base */
      0,                                    /* tp_dict */
      0,                                    /* tp_descr_get */
      0,                                    /* tp_descr_set */
      0,                                    /* tp_dictoffset */
      0,                                    /* tp_init */
      0,                                    /* tp_alloc */
      0,                                    /* tp_new */
      0,                                    /* tp_free */
      0,                                    /* tp_is_gc */
      0,                                    /* tp_bases */
      0,                                    /* tp_mro */
      0,                                    /* tp_cache */
      0,                                    /* tp_subclasses */
      0,                                    /* tp_weaklist */
      0,                                    /* tp_del */
      0,                                    /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
      0,                                    /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
      0,                                    /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
      0,                                    /* tp_print */
#endif
#ifdef COUNT_ALLOCS
      0,                                    /* tp_allocs */
      0,                                    /* tp_frees */
      0,                                    /* tp_maxalloc */
      0,                                    /* tp_prev */
      0                                     /* tp_next */
#endif
    };
    swigpyobject_type = tmp;
    type_init = 1;
    if (PyType_Ready(&swigpyobject_type) < 0)
      return NULL;
  }
  return &swigpyobject_type;
}

SWIGRUNTIME PyObject *
SwigPyObject_New(void *ptr, swig_type_info *ty, int own)
{
  SwigPyObject *sobj = PyObject_NEW(SwigPyObject, SwigPyObject_type());
  if (sobj) {
    sobj->ptr  = ptr;
    sobj->ty   = ty;
    sobj->own  = own;
    sobj->next = 0;
  }
  return (PyObject *)sobj;
}

/* -----------------------------------------------------------------------------
 * Implements a simple Swig Packed type, and use it instead of string
 * ----------------------------------------------------------------------------- */

typedef struct {
  PyObject_HEAD
  void *pack;
  swig_type_info *ty;
  size_t size;
} SwigPyPacked;

SWIGRUNTIME PyObject *
SwigPyPacked_repr(SwigPyPacked *v)
{
  char result[SWIG_BUFFER_SIZE];
  if (SWIG_PackDataName(result, v->pack, v->size, 0, sizeof(result))) {
    return SWIG_Python_str_FromFormat("<Swig Packed at %s%s>", result, v->ty->name);
  } else {
    return SWIG_Python_str_FromFormat("<Swig Packed %s>", v->ty->name);
  }  
}

SWIGRUNTIME PyObject *
SwigPyPacked_str(SwigPyPacked *v)
{
  char result[SWIG_BUFFER_SIZE];
  if (SWIG_PackDataName(result, v->pack, v->size, 0, sizeof(result))){
    return SWIG_Python_str_FromFormat("%s%s", result, v->ty->name);
  } else {
    return SWIG_Python_str_FromChar(v->ty->name);
  }  
}

SWIGRUNTIME int
SwigPyPacked_compare(SwigPyPacked *v, SwigPyPacked *w)
{
  size_t i = v->size;
  size_t j = w->size;
  int s = (i < j) ? -1 : ((i > j) ? 1 : 0);
  return s ? s : strncmp((const char *)v->pack, (const char *)w->pack, 2*v->size);
}

SWIGRUNTIME PyTypeObject* SwigPyPacked_TypeOnce(void);

SWIGRUNTIME PyTypeObject*
SwigPyPacked_type(void) {
  static PyTypeObject *SWIG_STATIC_POINTER(type) = SwigPyPacked_TypeOnce();
  return type;
}

SWIGRUNTIMEINLINE int
SwigPyPacked_Check(PyObject *op) {
  return ((op)->ob_type == SwigPyPacked_TypeOnce()) 
    || (strcmp((op)->ob_type->tp_name,"SwigPyPacked") == 0);
}

SWIGRUNTIME void
SwigPyPacked_dealloc(PyObject *v)
{
  if (SwigPyPacked_Check(v)) {
    SwigPyPacked *sobj = (SwigPyPacked *) v;
    free(sobj->pack);
  }
  PyObject_DEL(v);
}

SWIGRUNTIME PyTypeObject*
SwigPyPacked_TypeOnce(void) {
  static char swigpacked_doc[] = "Swig object carries a C/C++ instance pointer";
  static PyTypeObject swigpypacked_type;
  static int type_init = 0;
  if (!type_init) {
    const PyTypeObject tmp = {
#if PY_VERSION_HEX>=0x03000000
      PyVarObject_HEAD_INIT(NULL, 0)
#else
      PyObject_HEAD_INIT(NULL)
      0,                                    /* ob_size */
#endif
      "SwigPyPacked",                       /* tp_name */
      sizeof(SwigPyPacked),                 /* tp_basicsize */
      0,                                    /* tp_itemsize */
      (destructor)SwigPyPacked_dealloc,     /* tp_dealloc */
      0,                                    /* tp_print */
      (getattrfunc)0,                       /* tp_getattr */
      (setattrfunc)0,                       /* tp_setattr */
#if PY_VERSION_HEX>=0x03000000
      0, /* tp_reserved in 3.0.1 */
#else
      (cmpfunc)SwigPyPacked_compare,        /* tp_compare */
#endif
      (reprfunc)SwigPyPacked_repr,          /* tp_repr */
      0,                                    /* tp_as_number */
      0,                                    /* tp_as_sequence */
      0,                                    /* tp_as_mapping */
      (hashfunc)0,                          /* tp_hash */
      (ternaryfunc)0,                       /* tp_call */
      (reprfunc)SwigPyPacked_str,           /* tp_str */
      PyObject_GenericGetAttr,              /* tp_getattro */
      0,                                    /* tp_setattro */
      0,                                    /* tp_as_buffer */
      Py_TPFLAGS_DEFAULT,                   /* tp_flags */
      swigpacked_doc,                       /* tp_doc */
      0,                                    /* tp_traverse */
      0,                                    /* tp_clear */
      0,                                    /* tp_richcompare */
      0,                                    /* tp_weaklistoffset */
      0,                                    /* tp_iter */
      0,                                    /* tp_iternext */
      0,                                    /* tp_methods */
      0,                                    /* tp_members */
      0,                                    /* tp_getset */
      0,                                    /* tp_base */
      0,                                    /* tp_dict */
      0,                                    /* tp_descr_get */
      0,                                    /* tp_descr_set */
      0,                                    /* tp_dictoffset */
      0,                                    /* tp_init */
      0,                                    /* tp_alloc */
      0,                                    /* tp_new */
      0,                                    /* tp_free */
      0,                                    /* tp_is_gc */
      0,                                    /* tp_bases */
      0,                                    /* tp_mro */
      0,                                    /* tp_cache */
      0,                                    /* tp_subclasses */
      0,                                    /* tp_weaklist */
      0,                                    /* tp_del */
      0,                                    /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
      0,                                    /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
      0,                                    /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
      0,                                    /* tp_print */
#endif
#ifdef COUNT_ALLOCS
      0,                                    /* tp_allocs */
      0,                                    /* tp_frees */
      0,                                    /* tp_maxalloc */
      0,                                    /* tp_prev */
      0                                     /* tp_next */
#endif
    };
    swigpypacked_type = tmp;
    type_init = 1;
    if (PyType_Ready(&swigpypacked_type) < 0)
      return NULL;
  }
  return &swigpypacked_type;
}

SWIGRUNTIME PyObject *
SwigPyPacked_New(void *ptr, size_t size, swig_type_info *ty)
{
  SwigPyPacked *sobj = PyObject_NEW(SwigPyPacked, SwigPyPacked_type());
  if (sobj) {
    void *pack = malloc(size);
    if (pack) {
      memcpy(pack, ptr, size);
      sobj->pack = pack;
      sobj->ty   = ty;
      sobj->size = size;
    } else {
      PyObject_DEL((PyObject *) sobj);
      sobj = 0;
    }
  }
  return (PyObject *) sobj;
}

SWIGRUNTIME swig_type_info *
SwigPyPacked_UnpackData(PyObject *obj, void *ptr, size_t size)
{
  if (SwigPyPacked_Check(obj)) {
    SwigPyPacked *sobj = (SwigPyPacked *)obj;
    if (sobj->size != size) return 0;
    memcpy(ptr, sobj->pack, size);
    return sobj->ty;
  } else {
    return 0;
  }
}

/* -----------------------------------------------------------------------------
 * pointers/data manipulation
 * ----------------------------------------------------------------------------- */

static PyObject *Swig_This_global = NULL;

SWIGRUNTIME PyObject *
SWIG_This(void)
{
  if (Swig_This_global == NULL)
    Swig_This_global = SWIG_Python_str_FromChar("this");
  return Swig_This_global;
}

/* #define SWIG_PYTHON_SLOW_GETSET_THIS */

/* TODO: I don't know how to implement the fast getset in Python 3 right now */
#if PY_VERSION_HEX>=0x03000000
#define SWIG_PYTHON_SLOW_GETSET_THIS 
#endif

SWIGRUNTIME SwigPyObject *
SWIG_Python_GetSwigThis(PyObject *pyobj) 
{
  PyObject *obj;

  if (SwigPyObject_Check(pyobj))
    return (SwigPyObject *) pyobj;

#ifdef SWIGPYTHON_BUILTIN
  (void)obj;
# ifdef PyWeakref_CheckProxy
  if (PyWeakref_CheckProxy(pyobj)) {
    pyobj = PyWeakref_GET_OBJECT(pyobj);
    if (pyobj && SwigPyObject_Check(pyobj))
      return (SwigPyObject*) pyobj;
  }
# endif
  return NULL;
#else

  obj = 0;

#if !defined(SWIG_PYTHON_SLOW_GETSET_THIS)
  if (PyInstance_Check(pyobj)) {
    obj = _PyInstance_Lookup(pyobj, SWIG_This());      
  } else {
    PyObject **dictptr = _PyObject_GetDictPtr(pyobj);
    if (dictptr != NULL) {
      PyObject *dict = *dictptr;
      obj = dict ? PyDict_GetItem(dict, SWIG_This()) : 0;
    } else {
#ifdef PyWeakref_CheckProxy
      if (PyWeakref_CheckProxy(pyobj)) {
	PyObject *wobj = PyWeakref_GET_OBJECT(pyobj);
	return wobj ? SWIG_Python_GetSwigThis(wobj) : 0;
      }
#endif
      obj = PyObject_GetAttr(pyobj,SWIG_This());
      if (obj) {
	Py_DECREF(obj);
      } else {
	if (PyErr_Occurred()) PyErr_Clear();
	return 0;
      }
    }
  }
#else
  obj = PyObject_GetAttr(pyobj,SWIG_This());
  if (obj) {
    Py_DECREF(obj);
  } else {
    if (PyErr_Occurred()) PyErr_Clear();
    return 0;
  }
#endif
  if (obj && !SwigPyObject_Check(obj)) {
    /* a PyObject is called 'this', try to get the 'real this'
       SwigPyObject from it */ 
    return SWIG_Python_GetSwigThis(obj);
  }
  return (SwigPyObject *)obj;
#endif
}

/* Acquire a pointer value */

SWIGRUNTIME int
SWIG_Python_AcquirePtr(PyObject *obj, int own) {
  if (own == SWIG_POINTER_OWN) {
    SwigPyObject *sobj = SWIG_Python_GetSwigThis(obj);
    if (sobj) {
      int oldown = sobj->own;
      sobj->own = own;
      return oldown;
    }
  }
  return 0;
}

/* Convert a pointer value */

SWIGRUNTIME int
SWIG_Python_ConvertPtrAndOwn(PyObject *obj, void **ptr, swig_type_info *ty, int flags, int *own) {
  int res;
  SwigPyObject *sobj;
  int implicit_conv = (flags & SWIG_POINTER_IMPLICIT_CONV) != 0;

  if (!obj)
    return SWIG_ERROR;
  if (obj == Py_None && !implicit_conv) {
    if (ptr)
      *ptr = 0;
    return (flags & SWIG_POINTER_NO_NULL) ? SWIG_NullReferenceError : SWIG_OK;
  }

  res = SWIG_ERROR;

  sobj = SWIG_Python_GetSwigThis(obj);
  if (own)
    *own = 0;
  while (sobj) {
    void *vptr = sobj->ptr;
    if (ty) {
      swig_type_info *to = sobj->ty;
      if (to == ty) {
        /* no type cast needed */
        if (ptr) *ptr = vptr;
        break;
      } else {
        swig_cast_info *tc = SWIG_TypeCheck(to->name,ty);
        if (!tc) {
          sobj = (SwigPyObject *)sobj->next;
        } else {
          if (ptr) {
            int newmemory = 0;
            *ptr = SWIG_TypeCast(tc,vptr,&newmemory);
            if (newmemory == SWIG_CAST_NEW_MEMORY) {
              assert(own); /* badly formed typemap which will lead to a memory leak - it must set and use own to delete *ptr */
              if (own)
                *own = *own | SWIG_CAST_NEW_MEMORY;
            }
          }
          break;
        }
      }
    } else {
      if (ptr) *ptr = vptr;
      break;
    }
  }
  if (sobj) {
    if (own)
      *own = *own | sobj->own;
    if (flags & SWIG_POINTER_DISOWN) {
      sobj->own = 0;
    }
    res = SWIG_OK;
  } else {
    if (implicit_conv) {
      SwigPyClientData *data = ty ? (SwigPyClientData *) ty->clientdata : 0;
      if (data && !data->implicitconv) {
        PyObject *klass = data->klass;
        if (klass) {
          PyObject *impconv;
          data->implicitconv = 1; /* avoid recursion and call 'explicit' constructors*/
          impconv = SWIG_Python_CallFunctor(klass, obj);
          data->implicitconv = 0;
          if (PyErr_Occurred()) {
            PyErr_Clear();
            impconv = 0;
          }
          if (impconv) {
            SwigPyObject *iobj = SWIG_Python_GetSwigThis(impconv);
            if (iobj) {
              void *vptr;
              res = SWIG_Python_ConvertPtrAndOwn((PyObject*)iobj, &vptr, ty, 0, 0);
              if (SWIG_IsOK(res)) {
                if (ptr) {
                  *ptr = vptr;
                  /* transfer the ownership to 'ptr' */
                  iobj->own = 0;
                  res = SWIG_AddCast(res);
                  res = SWIG_AddNewMask(res);
                } else {
                  res = SWIG_AddCast(res);		    
                }
              }
            }
            Py_DECREF(impconv);
          }
        }
      }
      if (!SWIG_IsOK(res) && obj == Py_None) {
        if (ptr)
          *ptr = 0;
        if (PyErr_Occurred())
          PyErr_Clear();
        res = SWIG_OK;
      }
    }
  }
  return res;
}

/* Convert a function ptr value */

SWIGRUNTIME int
SWIG_Python_ConvertFunctionPtr(PyObject *obj, void **ptr, swig_type_info *ty) {
  if (!PyCFunction_Check(obj)) {
    return SWIG_ConvertPtr(obj, ptr, ty, 0);
  } else {
    void *vptr = 0;
    swig_cast_info *tc;

    /* here we get the method pointer for callbacks */
    const char *doc = (((PyCFunctionObject *)obj) -> m_ml -> ml_doc);
    const char *desc = doc ? strstr(doc, "swig_ptr: ") : 0;
    if (desc)
      desc = ty ? SWIG_UnpackVoidPtr(desc + 10, &vptr, ty->name) : 0;
    if (!desc)
      return SWIG_ERROR;
    tc = SWIG_TypeCheck(desc,ty);
    if (tc) {
      int newmemory = 0;
      *ptr = SWIG_TypeCast(tc,vptr,&newmemory);
      assert(!newmemory); /* newmemory handling not yet implemented */
    } else {
      return SWIG_ERROR;
    }
    return SWIG_OK;
  }
}

/* Convert a packed pointer value */

SWIGRUNTIME int
SWIG_Python_ConvertPacked(PyObject *obj, void *ptr, size_t sz, swig_type_info *ty) {
  swig_type_info *to = SwigPyPacked_UnpackData(obj, ptr, sz);
  if (!to) return SWIG_ERROR;
  if (ty) {
    if (to != ty) {
      /* check type cast? */
      swig_cast_info *tc = SWIG_TypeCheck(to->name,ty);
      if (!tc) return SWIG_ERROR;
    }
  }
  return SWIG_OK;
}  

/* -----------------------------------------------------------------------------
 * Create a new pointer object
 * ----------------------------------------------------------------------------- */

/*
  Create a new instance object, without calling __init__, and set the
  'this' attribute.
*/

SWIGRUNTIME PyObject* 
SWIG_Python_NewShadowInstance(SwigPyClientData *data, PyObject *swig_this)
{
  PyObject *inst = 0;
  PyObject *newraw = data->newraw;
  if (newraw) {
    inst = PyObject_Call(newraw, data->newargs, NULL);
    if (inst) {
#if !defined(SWIG_PYTHON_SLOW_GETSET_THIS)
      PyObject **dictptr = _PyObject_GetDictPtr(inst);
      if (dictptr != NULL) {
	PyObject *dict = *dictptr;
	if (dict == NULL) {
	  dict = PyDict_New();
	  *dictptr = dict;
	  PyDict_SetItem(dict, SWIG_This(), swig_this);
	}
      }
#else
      if (PyObject_SetAttr(inst, SWIG_This(), swig_this) == -1) {
        Py_DECREF(inst);
        inst = 0;
      }
#endif
    }
  } else {
#if PY_VERSION_HEX >= 0x03000000
    PyObject *empty_args = PyTuple_New(0);
    if (empty_args) {
      PyObject *empty_kwargs = PyDict_New();
      if (empty_kwargs) {
        inst = ((PyTypeObject *)data->newargs)->tp_new((PyTypeObject *)data->newargs, empty_args, empty_kwargs);
        Py_DECREF(empty_kwargs);
        if (inst) {
          if (PyObject_SetAttr(inst, SWIG_This(), swig_this) == -1) {
            Py_DECREF(inst);
            inst = 0;
          } else {
            Py_TYPE(inst)->tp_flags &= ~Py_TPFLAGS_VALID_VERSION_TAG;
          }
        }
      }
      Py_DECREF(empty_args);
    }
#else
    PyObject *dict = PyDict_New();
    if (dict) {
      PyDict_SetItem(dict, SWIG_This(), swig_this);
      inst = PyInstance_NewRaw(data->newargs, dict);
      Py_DECREF(dict);
    }
#endif
  }
  return inst;
}

SWIGRUNTIME int
SWIG_Python_SetSwigThis(PyObject *inst, PyObject *swig_this)
{
#if !defined(SWIG_PYTHON_SLOW_GETSET_THIS)
  PyObject **dictptr = _PyObject_GetDictPtr(inst);
  if (dictptr != NULL) {
    PyObject *dict = *dictptr;
    if (dict == NULL) {
      dict = PyDict_New();
      *dictptr = dict;
    }
    return PyDict_SetItem(dict, SWIG_This(), swig_this);
  }
#endif
  return PyObject_SetAttr(inst, SWIG_This(), swig_this);
} 


SWIGINTERN PyObject *
SWIG_Python_InitShadowInstance(PyObject *args) {
  PyObject *obj[2];
  if (!SWIG_Python_UnpackTuple(args, "swiginit", 2, 2, obj)) {
    return NULL;
  } else {
    SwigPyObject *sthis = SWIG_Python_GetSwigThis(obj[0]);
    if (sthis) {
      SwigPyObject_append((PyObject*) sthis, obj[1]);
    } else {
      if (SWIG_Python_SetSwigThis(obj[0], obj[1]) != 0)
        return NULL;
    }
    return SWIG_Py_Void();
  }
}

/* Create a new pointer object */

SWIGRUNTIME PyObject *
SWIG_Python_NewPointerObj(PyObject *self, void *ptr, swig_type_info *type, int flags) {
  SwigPyClientData *clientdata;
  PyObject * robj;
  int own;

  if (!ptr)
    return SWIG_Py_Void();

  clientdata = type ? (SwigPyClientData *)(type->clientdata) : 0;
  own = (flags & SWIG_POINTER_OWN) ? SWIG_POINTER_OWN : 0;
  if (clientdata && clientdata->pytype) {
    SwigPyObject *newobj;
    if (flags & SWIG_BUILTIN_TP_INIT) {
      newobj = (SwigPyObject*) self;
      if (newobj->ptr) {
        PyObject *next_self = clientdata->pytype->tp_alloc(clientdata->pytype, 0);
        while (newobj->next)
	  newobj = (SwigPyObject *) newobj->next;
        newobj->next = next_self;
        newobj = (SwigPyObject *)next_self;
#ifdef SWIGPYTHON_BUILTIN
        newobj->dict = 0;
#endif
      }
    } else {
      newobj = PyObject_New(SwigPyObject, clientdata->pytype);
#ifdef SWIGPYTHON_BUILTIN
      newobj->dict = 0;
#endif
    }
    if (newobj) {
      newobj->ptr = ptr;
      newobj->ty = type;
      newobj->own = own;
      newobj->next = 0;
      return (PyObject*) newobj;
    }
    return SWIG_Py_Void();
  }

  assert(!(flags & SWIG_BUILTIN_TP_INIT));

  robj = SwigPyObject_New(ptr, type, own);
  if (robj && clientdata && !(flags & SWIG_POINTER_NOSHADOW)) {
    PyObject *inst = SWIG_Python_NewShadowInstance(clientdata, robj);
    Py_DECREF(robj);
    robj = inst;
  }
  return robj;
}

/* Create a new packed object */

SWIGRUNTIMEINLINE PyObject *
SWIG_Python_NewPackedObj(void *ptr, size_t sz, swig_type_info *type) {
  return ptr ? SwigPyPacked_New((void *) ptr, sz, type) : SWIG_Py_Void();
}

/* -----------------------------------------------------------------------------*
 *  Get type list 
 * -----------------------------------------------------------------------------*/

#ifdef SWIG_LINK_RUNTIME
void *SWIG_ReturnGlobalTypeList(void *);
#endif

SWIGRUNTIME swig_module_info *
SWIG_Python_GetModule(void *SWIGUNUSEDPARM(clientdata)) {
  static void *type_pointer = (void *)0;
  /* first check if module already created */
  if (!type_pointer) {
#ifdef SWIG_LINK_RUNTIME
    type_pointer = SWIG_ReturnGlobalTypeList((void *)0);
#else
    type_pointer = PyCapsule_Import(SWIGPY_CAPSULE_NAME, 0);
    if (PyErr_Occurred()) {
      PyErr_Clear();
      type_pointer = (void *)0;
    }
#endif
  }
  return (swig_module_info *) type_pointer;
}

SWIGRUNTIME void
SWIG_Python_DestroyModule(PyObject *obj)
{
  swig_module_info *swig_module = (swig_module_info *) PyCapsule_GetPointer(obj, SWIGPY_CAPSULE_NAME);
  swig_type_info **types = swig_module->types;
  size_t i;
  for (i =0; i < swig_module->size; ++i) {
    swig_type_info *ty = types[i];
    if (ty->owndata) {
      SwigPyClientData *data = (SwigPyClientData *) ty->clientdata;
      if (data) SwigPyClientData_Del(data);
    }
  }
  Py_DECREF(SWIG_This());
  Swig_This_global = NULL;
}

SWIGRUNTIME void
SWIG_Python_SetModule(swig_module_info *swig_module) {
#if PY_VERSION_HEX >= 0x03000000
 /* Add a dummy module object into sys.modules */
  PyObject *module = PyImport_AddModule("swig_runtime_data" SWIG_RUNTIME_VERSION);
#else
  static PyMethodDef swig_empty_runtime_method_table[] = { {NULL, NULL, 0, NULL} }; /* Sentinel */
  PyObject *module = Py_InitModule("swig_runtime_data" SWIG_RUNTIME_VERSION, swig_empty_runtime_method_table);
#endif
  PyObject *pointer = PyCapsule_New((void *) swig_module, SWIGPY_CAPSULE_NAME, SWIG_Python_DestroyModule);
  if (pointer && module) {
    PyModule_AddObject(module, "type_pointer_capsule" SWIG_TYPE_TABLE_NAME, pointer);
  } else {
    Py_XDECREF(pointer);
  }
}

/* The python cached type query */
SWIGRUNTIME PyObject *
SWIG_Python_TypeCache(void) {
  static PyObject *SWIG_STATIC_POINTER(cache) = PyDict_New();
  return cache;
}

SWIGRUNTIME swig_type_info *
SWIG_Python_TypeQuery(const char *type)
{
  PyObject *cache = SWIG_Python_TypeCache();
  PyObject *key = SWIG_Python_str_FromChar(type); 
  PyObject *obj = PyDict_GetItem(cache, key);
  swig_type_info *descriptor;
  if (obj) {
    descriptor = (swig_type_info *) PyCapsule_GetPointer(obj, NULL);
  } else {
    swig_module_info *swig_module = SWIG_GetModule(0);
    descriptor = SWIG_TypeQueryModule(swig_module, swig_module, type);
    if (descriptor) {
      obj = PyCapsule_New((void*) descriptor, NULL, NULL);
      PyDict_SetItem(cache, key, obj);
      Py_DECREF(obj);
    }
  }
  Py_DECREF(key);
  return descriptor;
}

/* 
   For backward compatibility only
*/
#define SWIG_POINTER_EXCEPTION  0
#define SWIG_arg_fail(arg)      SWIG_Python_ArgFail(arg)
#define SWIG_MustGetPtr(p, type, argnum, flags)  SWIG_Python_MustGetPtr(p, type, argnum, flags)

SWIGRUNTIME int
SWIG_Python_AddErrMesg(const char* mesg, int infront)
{  
  if (PyErr_Occurred()) {
    PyObject *type = 0;
    PyObject *value = 0;
    PyObject *traceback = 0;
    PyErr_Fetch(&type, &value, &traceback);
    if (value) {
      PyObject *old_str = PyObject_Str(value);
      const char *tmp = SWIG_Python_str_AsChar(old_str);
      const char *errmesg = tmp ? tmp : "Invalid error message";
      Py_XINCREF(type);
      PyErr_Clear();
      if (infront) {
	PyErr_Format(type, "%s %s", mesg, errmesg);
      } else {
	PyErr_Format(type, "%s %s", errmesg, mesg);
      }
      SWIG_Python_str_DelForPy3(tmp);
      Py_DECREF(old_str);
    }
    return 1;
  } else {
    return 0;
  }
}
  
SWIGRUNTIME int
SWIG_Python_ArgFail(int argnum)
{
  if (PyErr_Occurred()) {
    /* add information about failing argument */
    char mesg[256];
    PyOS_snprintf(mesg, sizeof(mesg), "argument number %d:", argnum);
    return SWIG_Python_AddErrMesg(mesg, 1);
  } else {
    return 0;
  }
}

SWIGRUNTIMEINLINE const char *
SwigPyObject_GetDesc(PyObject *self)
{
  SwigPyObject *v = (SwigPyObject *)self;
  swig_type_info *ty = v ? v->ty : 0;
  return ty ? ty->str : "";
}

SWIGRUNTIME void
SWIG_Python_TypeError(const char *type, PyObject *obj)
{
  if (type) {
#if defined(SWIG_COBJECT_TYPES)
    if (obj && SwigPyObject_Check(obj)) {
      const char *otype = (const char *) SwigPyObject_GetDesc(obj);
      if (otype) {
	PyErr_Format(PyExc_TypeError, "a '%s' is expected, 'SwigPyObject(%s)' is received",
		     type, otype);
	return;
      }
    } else 
#endif      
    {
      const char *otype = (obj ? obj->ob_type->tp_name : 0); 
      if (otype) {
	PyObject *str = PyObject_Str(obj);
	const char *cstr = str ? SWIG_Python_str_AsChar(str) : 0;
	if (cstr) {
	  PyErr_Format(PyExc_TypeError, "a '%s' is expected, '%s(%s)' is received",
		       type, otype, cstr);
          SWIG_Python_str_DelForPy3(cstr);
	} else {
	  PyErr_Format(PyExc_TypeError, "a '%s' is expected, '%s' is received",
		       type, otype);
	}
	Py_XDECREF(str);
	return;
      }
    }   
    PyErr_Format(PyExc_TypeError, "a '%s' is expected", type);
  } else {
    PyErr_Format(PyExc_TypeError, "unexpected type is received");
  }
}


/* Convert a pointer value, signal an exception on a type mismatch */
SWIGRUNTIME void *
SWIG_Python_MustGetPtr(PyObject *obj, swig_type_info *ty, int SWIGUNUSEDPARM(argnum), int flags) {
  void *result;
  if (SWIG_Python_ConvertPtr(obj, &result, ty, flags) == -1) {
    PyErr_Clear();
#if SWIG_POINTER_EXCEPTION
    if (flags) {
      SWIG_Python_TypeError(SWIG_TypePrettyName(ty), obj);
      SWIG_Python_ArgFail(argnum);
    }
#endif
  }
  return result;
}

#ifdef SWIGPYTHON_BUILTIN
SWIGRUNTIME int
SWIG_Python_NonDynamicSetAttr(PyObject *obj, PyObject *name, PyObject *value) {
  PyTypeObject *tp = obj->ob_type;
  PyObject *descr;
  PyObject *encoded_name;
  descrsetfunc f;
  int res = -1;

# ifdef Py_USING_UNICODE
  if (PyString_Check(name)) {
    name = PyUnicode_Decode(PyString_AsString(name), PyString_Size(name), NULL, NULL);
    if (!name)
      return -1;
  } else if (!PyUnicode_Check(name))
# else
  if (!PyString_Check(name))
# endif
  {
    PyErr_Format(PyExc_TypeError, "attribute name must be string, not '%.200s'", name->ob_type->tp_name);
    return -1;
  } else {
    Py_INCREF(name);
  }

  if (!tp->tp_dict) {
    if (PyType_Ready(tp) < 0)
      goto done;
  }

  descr = _PyType_Lookup(tp, name);
  f = NULL;
  if (descr != NULL)
    f = descr->ob_type->tp_descr_set;
  if (!f) {
    if (PyString_Check(name)) {
      encoded_name = name;
      Py_INCREF(name);
    } else {
      encoded_name = PyUnicode_AsUTF8String(name);
      if (!encoded_name)
        return -1;
    }
    PyErr_Format(PyExc_AttributeError, "'%.100s' object has no attribute '%.200s'", tp->tp_name, PyString_AsString(encoded_name));
    Py_DECREF(encoded_name);
  } else {
    res = f(descr, obj, value);
  }
  
  done:
  Py_DECREF(name);
  return res;
}
#endif


#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif

SWIGINTERN Py_hash_t
SwigPyObject_hash(PyObject *obj) {
  SwigPyObject *sobj = (SwigPyObject *)obj;
  void *ptr = sobj->ptr;
  return (Py_hash_t)ptr;
}

SWIGINTERN Py_hash_t
SWIG_PyNumber_AsPyHash(PyObject *obj) {
  Py_hash_t result = -1;
#if PY_VERSION_HEX < 0x03020000
  if (PyInt_Check(obj))
    result = PyInt_AsLong(obj);
  else if (PyLong_Check(obj))
    result = PyLong_AsLong(obj);
#else
  if (PyNumber_Check(obj))
    result = PyNumber_AsSsize_t(obj, NULL);
#endif
  else
    PyErr_Format(PyExc_TypeError, "Wrong type for hash function");
  return PyErr_Occurred() ? -1 : result;
}

SWIGINTERN int
SwigPyBuiltin_BadInit(PyObject *self, PyObject *SWIGUNUSEDPARM(args), PyObject *SWIGUNUSEDPARM(kwds)) {
  PyErr_Format(PyExc_TypeError, "Cannot create new instances of type '%.300s'", self->ob_type->tp_name);
  return -1;
}

SWIGINTERN void
SwigPyBuiltin_BadDealloc(PyObject *obj) {
  SwigPyObject *sobj = (SwigPyObject *)obj;
  if (sobj->own) {
    PyErr_Format(PyExc_TypeError, "Swig detected a memory leak in type '%.300s': no callable destructor found.", obj->ob_type->tp_name);
  }
}

typedef struct {
  PyCFunction get;
  PyCFunction set;
} SwigPyGetSet;

SWIGINTERN PyObject *
SwigPyBuiltin_GetterClosure (PyObject *obj, void *closure) {
  SwigPyGetSet *getset;
  PyObject *tuple, *result;
  if (!closure)
    return SWIG_Py_Void();
  getset = (SwigPyGetSet *)closure;
  if (!getset->get)
    return SWIG_Py_Void();
  tuple = PyTuple_New(0);
  assert(tuple);
  result = (*getset->get)(obj, tuple);
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyObject *
SwigPyBuiltin_FunpackGetterClosure (PyObject *obj, void *closure) {
  SwigPyGetSet *getset;
  PyObject *result;
  if (!closure)
    return SWIG_Py_Void();
  getset = (SwigPyGetSet *)closure;
  if (!getset->get)
    return SWIG_Py_Void();
  result = (*getset->get)(obj, NULL);
  return result;
}

SWIGINTERN int
SwigPyBuiltin_SetterClosure (PyObject *obj, PyObject *val, void *closure) {
  SwigPyGetSet *getset;
  PyObject *tuple, *result;
  if (!closure) {
    PyErr_Format(PyExc_TypeError, "Missing getset closure");
    return -1;
  }
  getset = (SwigPyGetSet *)closure;
  if (!getset->set) {
    PyErr_Format(PyExc_TypeError, "Illegal member variable assignment in type '%.300s'", obj->ob_type->tp_name);
    return -1;
  }
  tuple = PyTuple_New(1);
  assert(tuple);
  Py_INCREF(val);
  PyTuple_SET_ITEM(tuple, 0, val);
  result = (*getset->set)(obj, tuple);
  Py_DECREF(tuple);
  Py_XDECREF(result);
  return result ? 0 : -1;
}

SWIGINTERN int
SwigPyBuiltin_FunpackSetterClosure (PyObject *obj, PyObject *val, void *closure) {
  SwigPyGetSet *getset;
  PyObject *result;
  if (!closure) {
    PyErr_Format(PyExc_TypeError, "Missing getset closure");
    return -1;
  }
  getset = (SwigPyGetSet *)closure;
  if (!getset->set) {
    PyErr_Format(PyExc_TypeError, "Illegal member variable assignment in type '%.300s'", obj->ob_type->tp_name);
    return -1;
  }
  result = (*getset->set)(obj, val);
  Py_XDECREF(result);
  return result ? 0 : -1;
}

SWIGINTERN void
SwigPyStaticVar_dealloc(PyDescrObject *descr) {
  PyObject_GC_UnTrack(descr);
  Py_XDECREF(PyDescr_TYPE(descr));
  Py_XDECREF(PyDescr_NAME(descr));
  PyObject_GC_Del(descr);
}

SWIGINTERN PyObject *
SwigPyStaticVar_repr(PyGetSetDescrObject *descr) {
#if PY_VERSION_HEX >= 0x03000000

  return PyUnicode_FromFormat("<class attribute '%S' of type '%s'>", PyDescr_NAME(descr), PyDescr_TYPE(descr)->tp_name);
#else
  return PyString_FromFormat("<class attribute '%s' of type '%s'>", PyString_AsString(PyDescr_NAME(descr)), PyDescr_TYPE(descr)->tp_name);
#endif
}

SWIGINTERN int
SwigPyStaticVar_traverse(PyObject *self, visitproc visit, void *arg) {
  PyDescrObject *descr;
  descr = (PyDescrObject *)self;
  Py_VISIT((PyObject*) PyDescr_TYPE(descr));
  return 0;
}

SWIGINTERN PyObject *
SwigPyStaticVar_get(PyGetSetDescrObject *descr, PyObject *obj, PyObject *SWIGUNUSEDPARM(type)) {
  if (descr->d_getset->get != NULL)
    return descr->d_getset->get(obj, descr->d_getset->closure);
#if PY_VERSION_HEX >= 0x03000000
  PyErr_Format(PyExc_AttributeError, "attribute '%.300S' of '%.100s' objects is not readable", PyDescr_NAME(descr), PyDescr_TYPE(descr)->tp_name);
#else
  PyErr_Format(PyExc_AttributeError, "attribute '%.300s' of '%.100s' objects is not readable", PyString_AsString(PyDescr_NAME(descr)), PyDescr_TYPE(descr)->tp_name);
#endif
  return NULL;
}

SWIGINTERN int
SwigPyStaticVar_set(PyGetSetDescrObject *descr, PyObject *obj, PyObject *value) {
  if (descr->d_getset->set != NULL)
    return descr->d_getset->set(obj, value, descr->d_getset->closure);
#if PY_VERSION_HEX >= 0x03000000
  PyErr_Format(PyExc_AttributeError, "attribute '%.300S' of '%.100s' objects is not writable", PyDescr_NAME(descr), PyDescr_TYPE(descr)->tp_name);
#else
  PyErr_Format(PyExc_AttributeError, "attribute '%.300s' of '%.100s' objects is not writable", PyString_AsString(PyDescr_NAME(descr)), PyDescr_TYPE(descr)->tp_name);
#endif
  return -1;
}

SWIGINTERN int
SwigPyObjectType_setattro(PyObject *typeobject, PyObject *name, PyObject *value) {
  PyObject *attribute;
  PyTypeObject *type;
  descrsetfunc local_set;

  assert(PyType_Check(typeobject));
  type = (PyTypeObject *)typeobject;
  attribute = _PyType_Lookup(type, name);
  if (attribute != NULL) {
    /* Implement descriptor functionality, if any */
    local_set = attribute->ob_type->tp_descr_set;
    if (local_set != NULL)
      return local_set(attribute, (PyObject *)type, value);
#if PY_VERSION_HEX >= 0x03000000
    PyErr_Format(PyExc_AttributeError, "cannot modify read-only attribute '%.50s.%.400S'", type->tp_name, name);
#else 
    PyErr_Format(PyExc_AttributeError, "cannot modify read-only attribute '%.50s.%.400s'", type->tp_name, PyString_AS_STRING(name));
#endif
  } else {
#if PY_VERSION_HEX >= 0x03000000
    PyErr_Format(PyExc_AttributeError, "type '%.50s' has no attribute '%.400S'", type->tp_name, name);
#else
    PyErr_Format(PyExc_AttributeError, "type '%.50s' has no attribute '%.400s'", type->tp_name, PyString_AS_STRING(name));
#endif
  }

  return -1;
}

SWIGINTERN PyTypeObject*
SwigPyStaticVar_Type(void) {
  static PyTypeObject staticvar_type;
  static int type_init = 0;
  if (!type_init) {
    const PyTypeObject tmp = {
#if PY_VERSION_HEX >= 0x03000000
      PyVarObject_HEAD_INIT(&PyType_Type, 0)
#else
      PyObject_HEAD_INIT(&PyType_Type)
      0,                                        /* ob_size */
#endif
      "swig_static_var_getset_descriptor",      /* tp_name */
      sizeof(PyGetSetDescrObject),              /* tp_basicsize */
      0,                                        /* tp_itemsize */
      (destructor)SwigPyStaticVar_dealloc,      /* tp_dealloc */
      0,                                        /* tp_print */
      0,                                        /* tp_getattr */
      0,                                        /* tp_setattr */
      0,                                        /* tp_compare */
      (reprfunc)SwigPyStaticVar_repr,           /* tp_repr */
      0,                                        /* tp_as_number */
      0,                                        /* tp_as_sequence */
      0,                                        /* tp_as_mapping */
      0,                                        /* tp_hash */
      0,                                        /* tp_call */
      0,                                        /* tp_str */
      PyObject_GenericGetAttr,                  /* tp_getattro */
      0,                                        /* tp_setattro */
      0,                                        /* tp_as_buffer */
      Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC|Py_TPFLAGS_HAVE_CLASS, /* tp_flags */
      0,                                        /* tp_doc */
      SwigPyStaticVar_traverse,                 /* tp_traverse */
      0,                                        /* tp_clear */
      0,                                        /* tp_richcompare */
      0,                                        /* tp_weaklistoffset */
      0,                                        /* tp_iter */
      0,                                        /* tp_iternext */
      0,                                        /* tp_methods */
      0,                                        /* tp_members */
      0,                                        /* tp_getset */
      0,                                        /* tp_base */
      0,                                        /* tp_dict */
      (descrgetfunc)SwigPyStaticVar_get,        /* tp_descr_get */
      (descrsetfunc)SwigPyStaticVar_set,        /* tp_descr_set */
      0,                                        /* tp_dictoffset */
      0,                                        /* tp_init */
      0,                                        /* tp_alloc */
      0,                                        /* tp_new */
      0,                                        /* tp_free */
      0,                                        /* tp_is_gc */
      0,                                        /* tp_bases */
      0,                                        /* tp_mro */
      0,                                        /* tp_cache */
      0,                                        /* tp_subclasses */
      0,                                        /* tp_weaklist */
      0,                                        /* tp_del */
      0,                                        /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
      0,                                        /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
      0,                                        /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
      0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
      0,                                        /* tp_allocs */
      0,                                        /* tp_frees */
      0,                                        /* tp_maxalloc */
      0,                                        /* tp_prev */
      0                                         /* tp_next */
#endif
    };
    staticvar_type = tmp;
    type_init = 1;
    if (PyType_Ready(&staticvar_type) < 0)
      return NULL;
  }
  return &staticvar_type;
}

SWIGINTERN PyTypeObject*
SwigPyObjectType(void) {
  static char swigpyobjecttype_doc[] = "Metaclass for SWIG wrapped types";
  static PyTypeObject swigpyobjecttype_type;
  static int type_init = 0;
  if (!type_init) {
    const PyTypeObject tmp = {
#if PY_VERSION_HEX >= 0x03000000
      PyVarObject_HEAD_INIT(&PyType_Type, 0)
#else
      PyObject_HEAD_INIT(&PyType_Type)
      0,                                        /* ob_size */
#endif
      "SwigPyObjectType",                       /* tp_name */
      PyType_Type.tp_basicsize,                 /* tp_basicsize */
      0,                                        /* tp_itemsize */
      0,                                        /* tp_dealloc */
      0,                                        /* tp_print */
      0,                                        /* tp_getattr */
      0,                                        /* tp_setattr */
      0,                                        /* tp_compare */
      0,                                        /* tp_repr */
      0,                                        /* tp_as_number */
      0,                                        /* tp_as_sequence */
      0,                                        /* tp_as_mapping */
      0,                                        /* tp_hash */
      0,                                        /* tp_call */
      0,                                        /* tp_str */
      0,                                        /* tp_getattro */
      SwigPyObjectType_setattro,                /* tp_setattro */
      0,                                        /* tp_as_buffer */
      Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_CLASS, /* tp_flags */
      swigpyobjecttype_doc,                     /* tp_doc */
      0,                                        /* tp_traverse */
      0,                                        /* tp_clear */
      0,                                        /* tp_richcompare */
      0,                                        /* tp_weaklistoffset */
      0,                                        /* tp_iter */
      0,                                        /* tp_iternext */
      0,                                        /* tp_methods */
      0,                                        /* tp_members */
      0,                                        /* tp_getset */
      0,                                        /* tp_base */
      0,                                        /* tp_dict */
      0,                                        /* tp_descr_get */
      0,                                        /* tp_descr_set */
      0,                                        /* tp_dictoffset */
      0,                                        /* tp_init */
      0,                                        /* tp_alloc */
      0,                                        /* tp_new */
      0,                                        /* tp_free */
      0,                                        /* tp_is_gc */
      0,                                        /* tp_bases */
      0,                                        /* tp_mro */
      0,                                        /* tp_cache */
      0,                                        /* tp_subclasses */
      0,                                        /* tp_weaklist */
      0,                                        /* tp_del */
      0,                                        /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
      0,                                        /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
      0,                                        /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
      0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
      0,                                        /* tp_allocs */
      0,                                        /* tp_frees */
      0,                                        /* tp_maxalloc */
      0,                                        /* tp_prev */
      0                                         /* tp_next */
#endif
    };
    swigpyobjecttype_type = tmp;
    type_init = 1;
    swigpyobjecttype_type.tp_base = &PyType_Type;
    if (PyType_Ready(&swigpyobjecttype_type) < 0)
      return NULL;
  }
  return &swigpyobjecttype_type;
}

SWIGINTERN PyGetSetDescrObject *
SwigPyStaticVar_new_getset(PyTypeObject *type, PyGetSetDef *getset) {

  PyGetSetDescrObject *descr;
  descr = (PyGetSetDescrObject *)PyType_GenericAlloc(SwigPyStaticVar_Type(), 0);
  assert(descr);
  Py_XINCREF(type);
  PyDescr_TYPE(descr) = type;
  PyDescr_NAME(descr) = PyString_InternFromString(getset->name);
  descr->d_getset = getset;
  if (PyDescr_NAME(descr) == NULL) {
    Py_DECREF(descr);
    descr = NULL;
  }
  return descr;
}

SWIGINTERN void
SwigPyBuiltin_InitBases (PyTypeObject *type, PyTypeObject **bases) {
  Py_ssize_t base_count = 0;
  PyTypeObject **b;
  PyObject *tuple;
  Py_ssize_t i;

  if (!bases[0]) {
    bases[0] = SwigPyObject_type();
    bases[1] = NULL;
  }
  type->tp_base = bases[0];
  Py_INCREF((PyObject *)bases[0]);
  for (b = bases; *b != NULL; ++b)
    ++base_count;
  tuple = PyTuple_New(base_count);
  for (i = 0; i < base_count; ++i) {
    Py_INCREF((PyObject *)bases[i]);
    PyTuple_SET_ITEM(tuple, i, (PyObject *)bases[i]);
  }
  type->tp_bases = tuple;
}

SWIGINTERN PyObject *
SwigPyBuiltin_ThisClosure (PyObject *self, void *SWIGUNUSEDPARM(closure)) {
  PyObject *result;
  result = (PyObject *)SWIG_Python_GetSwigThis(self);
  Py_XINCREF(result);
  return result;
}

SWIGINTERN void
SwigPyBuiltin_SetMetaType (PyTypeObject *type, PyTypeObject *metatype)
{
#if PY_VERSION_HEX >= 0x03000000
    type->ob_base.ob_base.ob_type = metatype;
#else
    type->ob_type = metatype;
#endif
}


/* Start of callback function macros for use in PyTypeObject */

typedef PyObject *(*SwigPyWrapperFunction)(PyObject *, PyObject *);

#define SWIGPY_UNARYFUNC_CLOSURE(wrapper)		\
SWIGINTERN PyObject *					\
wrapper##_unaryfunc_closure(PyObject *a) {		\
  return SwigPyBuiltin_unaryfunc_closure(wrapper, a);	\
}
SWIGINTERN PyObject *
SwigPyBuiltin_unaryfunc_closure(SwigPyWrapperFunction wrapper, PyObject *a) {
  return wrapper(a, NULL);
}

#define SWIGPY_DESTRUCTOR_CLOSURE(wrapper)			\
SWIGINTERN void							\
wrapper##_destructor_closure(PyObject *a) {			\
    SwigPyBuiltin_destructor_closure(wrapper, #wrapper, a);	\
}
SWIGINTERN void
SwigPyBuiltin_destructor_closure(SwigPyWrapperFunction wrapper, const char *wrappername, PyObject *a) {
  SwigPyObject *sobj;
  sobj = (SwigPyObject *)a;
  Py_XDECREF(sobj->dict);
  if (sobj->own) {
    PyObject *o;
    PyObject *type = 0, *value = 0, *traceback = 0;
    PyErr_Fetch(&type, &value, &traceback);
    o = wrapper(a, NULL);
    if (!o) {
      PyObject *deallocname = PyString_FromString(wrappername);
      PyErr_WriteUnraisable(deallocname);
      Py_DECREF(deallocname);
    }
    PyErr_Restore(type, value, traceback);
    Py_XDECREF(o);
  }
  if (PyType_IS_GC(a->ob_type)) {
    PyObject_GC_Del(a);
  } else {
    PyObject_Del(a);
  }
}

#define SWIGPY_INQUIRY_CLOSURE(wrapper)			\
SWIGINTERN int						\
wrapper##_inquiry_closure(PyObject *a) {		\
  return SwigPyBuiltin_inquiry_closure(wrapper, a);	\
}
SWIGINTERN int
SwigPyBuiltin_inquiry_closure(SwigPyWrapperFunction wrapper, PyObject *a) {
  PyObject *pyresult;
  int result;
  pyresult = wrapper(a, NULL);
  result = pyresult && PyObject_IsTrue(pyresult) ? 1 : 0;
  Py_XDECREF(pyresult);
  return result;
}

#define SWIGPY_GETITERFUNC_CLOSURE(wrapper)		\
SWIGINTERN PyObject *					\
wrapper##_getiterfunc_closure(PyObject *a) {		\
  return SwigPyBuiltin_getiterfunc_closure(wrapper, a);	\
}
SWIGINTERN PyObject *
SwigPyBuiltin_getiterfunc_closure(SwigPyWrapperFunction wrapper, PyObject *a) {
  return wrapper(a, NULL);
}

#define SWIGPY_BINARYFUNC_CLOSURE(wrapper)			\
SWIGINTERN PyObject *						\
wrapper##_binaryfunc_closure(PyObject *a, PyObject *b) {	\
  return SwigPyBuiltin_binaryfunc_closure(wrapper, a, b);	\
}
SWIGINTERN PyObject *
SwigPyBuiltin_binaryfunc_closure(SwigPyWrapperFunction wrapper, PyObject *a, PyObject *b) {
  PyObject *tuple, *result;
  tuple = PyTuple_New(1);
  assert(tuple);
  Py_INCREF(b);
  PyTuple_SET_ITEM(tuple, 0, b);
  result = wrapper(a, tuple);
  Py_DECREF(tuple);
  return result;
}

typedef ternaryfunc ternarycallfunc;

#define SWIGPY_TERNARYFUNC_CLOSURE(wrapper)				\
SWIGINTERN PyObject *							\
wrapper##_ternaryfunc_closure(PyObject *a, PyObject *b, PyObject *c) {	\
  return SwigPyBuiltin_ternaryfunc_closure(wrapper, a, b, c);		\
}
SWIGINTERN PyObject *
SwigPyBuiltin_ternaryfunc_closure(SwigPyWrapperFunction wrapper, PyObject *a, PyObject *b, PyObject *c) {
  PyObject *tuple, *result;
  tuple = PyTuple_New(2);
  assert(tuple);
  Py_INCREF(b);
  PyTuple_SET_ITEM(tuple, 0, b);
  Py_INCREF(c);
  PyTuple_SET_ITEM(tuple, 1, c);
  result = wrapper(a, tuple);
  Py_DECREF(tuple);
  return result;
}

#define SWIGPY_TERNARYCALLFUNC_CLOSURE(wrapper)					\
SWIGINTERN PyObject *								\
wrapper##_ternarycallfunc_closure(PyObject *a, PyObject *b, PyObject *c) {	\
  return SwigPyBuiltin_ternarycallfunc_closure(wrapper, a, b, c);		\
}
SWIGINTERN PyObject *
SwigPyBuiltin_ternarycallfunc_closure(SwigPyWrapperFunction wrapper, PyObject *a, PyObject *b, PyObject *c) {
  (void) c;
  return wrapper(a, b);
}

#define SWIGPY_LENFUNC_CLOSURE(wrapper)			\
SWIGINTERN Py_ssize_t					\
wrapper##_lenfunc_closure(PyObject *a) {		\
  return SwigPyBuiltin_lenfunc_closure(wrapper, a);	\
}
SWIGINTERN Py_ssize_t
SwigPyBuiltin_lenfunc_closure(SwigPyWrapperFunction wrapper, PyObject *a) {
  PyObject *resultobj;
  Py_ssize_t result;
  resultobj = wrapper(a, NULL);
  result = PyNumber_AsSsize_t(resultobj, NULL);
  Py_DECREF(resultobj);
  return result;
}

#define SWIGPY_SSIZESSIZEARGFUNC_CLOSURE(wrapper)				\
SWIGINTERN PyObject *								\
wrapper##_ssizessizeargfunc_closure(PyObject *a, Py_ssize_t b, Py_ssize_t c) {	\
  return SwigPyBuiltin_ssizessizeargfunc_closure(wrapper, a, b, c);		\
}
SWIGINTERN PyObject *
SwigPyBuiltin_ssizessizeargfunc_closure(SwigPyWrapperFunction wrapper, PyObject *a, Py_ssize_t b, Py_ssize_t c) {
  PyObject *tuple, *result;
  tuple = PyTuple_New(2);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, _PyLong_FromSsize_t(b));
  PyTuple_SET_ITEM(tuple, 1, _PyLong_FromSsize_t(c));
  result = wrapper(a, tuple);
  Py_DECREF(tuple);
  return result;
}

#define SWIGPY_SSIZESSIZEOBJARGPROC_CLOSURE(wrapper)						\
SWIGINTERN int											\
wrapper##_ssizessizeobjargproc_closure(PyObject *a, Py_ssize_t b, Py_ssize_t c, PyObject *d) {	\
  return SwigPyBuiltin_ssizessizeobjargproc_closure(wrapper, a, b, c, d);			\
}
SWIGINTERN int
SwigPyBuiltin_ssizessizeobjargproc_closure(SwigPyWrapperFunction wrapper, PyObject *a, Py_ssize_t b, Py_ssize_t c, PyObject *d) {
  PyObject *tuple, *resultobj;
  int result;
  tuple = PyTuple_New(d ? 3 : 2);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, _PyLong_FromSsize_t(b));
  PyTuple_SET_ITEM(tuple, 1, _PyLong_FromSsize_t(c));
  if (d) {
    Py_INCREF(d);
    PyTuple_SET_ITEM(tuple, 2, d);
  }
  resultobj = wrapper(a, tuple);
  result = resultobj ? 0 : -1;
  Py_DECREF(tuple);
  Py_XDECREF(resultobj);
  return result;
}

#define SWIGPY_SSIZEARGFUNC_CLOSURE(wrapper)				\
SWIGINTERN PyObject *							\
wrapper##_ssizeargfunc_closure(PyObject *a, Py_ssize_t b) {		\
  return SwigPyBuiltin_funpack_ssizeargfunc_closure(wrapper, a, b);	\
}
SWIGINTERN PyObject *
SwigPyBuiltin_funpack_ssizeargfunc_closure(SwigPyWrapperFunction wrapper, PyObject *a, Py_ssize_t b) {
  PyObject *tuple, *result;
  tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, _PyLong_FromSsize_t(b));
  result = wrapper(a, tuple);
  Py_DECREF(tuple);
  return result;
}

#define SWIGPY_FUNPACK_SSIZEARGFUNC_CLOSURE(wrapper)			\
SWIGINTERN PyObject *							\
wrapper##_ssizeargfunc_closure(PyObject *a, Py_ssize_t b) {		\
  return SwigPyBuiltin_ssizeargfunc_closure(wrapper, a, b);		\
}
SWIGINTERN PyObject *
SwigPyBuiltin_ssizeargfunc_closure(SwigPyWrapperFunction wrapper, PyObject *a, Py_ssize_t b) {
  PyObject *arg, *result;
  arg = _PyLong_FromSsize_t(b);
  result = wrapper(a, arg);
  Py_DECREF(arg);
  return result;
}

#define SWIGPY_SSIZEOBJARGPROC_CLOSURE(wrapper)					\
SWIGINTERN int									\
wrapper##_ssizeobjargproc_closure(PyObject *a, Py_ssize_t b, PyObject *c) {	\
  return SwigPyBuiltin_ssizeobjargproc_closure(wrapper, a, b, c);		\
}
SWIGINTERN int
SwigPyBuiltin_ssizeobjargproc_closure(SwigPyWrapperFunction wrapper, PyObject *a, Py_ssize_t b, PyObject *c) {
  PyObject *tuple, *resultobj;
  int result;
  tuple = PyTuple_New(2);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, _PyLong_FromSsize_t(b));
  Py_INCREF(c);
  PyTuple_SET_ITEM(tuple, 1, c);
  resultobj = wrapper(a, tuple);
  result = resultobj ? 0 : -1;
  Py_XDECREF(resultobj);
  Py_DECREF(tuple);
  return result;
}

#define SWIGPY_OBJOBJPROC_CLOSURE(wrapper)			\
SWIGINTERN int							\
wrapper##_objobjproc_closure(PyObject *a, PyObject *b) {	\
  return SwigPyBuiltin_objobjproc_closure(wrapper, a, b);	\
}
SWIGINTERN int
SwigPyBuiltin_objobjproc_closure(SwigPyWrapperFunction wrapper, PyObject *a, PyObject *b) {
  int result;
  PyObject *pyresult;
  PyObject *tuple;
  tuple = PyTuple_New(1);
  assert(tuple);
  Py_INCREF(b);
  PyTuple_SET_ITEM(tuple, 0, b);
  pyresult = wrapper(a, tuple);
  result = pyresult ? (PyObject_IsTrue(pyresult) ? 1 : 0) : -1;
  Py_XDECREF(pyresult);
  Py_DECREF(tuple);
  return result;
}

#define SWIGPY_FUNPACK_OBJOBJPROC_CLOSURE(wrapper)			\
SWIGINTERN int								\
wrapper##_objobjproc_closure(PyObject *a, PyObject *b) {		\
  return SwigPyBuiltin_funpack_objobjproc_closure(wrapper, a, b);	\
}
SWIGINTERN int
SwigPyBuiltin_funpack_objobjproc_closure(SwigPyWrapperFunction wrapper, PyObject *a, PyObject *b) {
  int result;
  PyObject *pyresult;
  pyresult = wrapper(a, b);
  result = pyresult ? (PyObject_IsTrue(pyresult) ? 1 : 0) : -1;
  Py_XDECREF(pyresult);
  return result;
}

#define SWIGPY_OBJOBJARGPROC_CLOSURE(wrapper)					\
SWIGINTERN int									\
wrapper##_objobjargproc_closure(PyObject *a, PyObject *b, PyObject *c) {	\
  return SwigPyBuiltin_objobjargproc_closure(wrapper, a, b, c);			\
}
SWIGINTERN int
SwigPyBuiltin_objobjargproc_closure(SwigPyWrapperFunction wrapper, PyObject *a, PyObject *b, PyObject *c) {
  PyObject *tuple, *resultobj;
  int result;
  tuple = PyTuple_New(c ? 2 : 1);
  assert(tuple);
  Py_INCREF(b);
  PyTuple_SET_ITEM(tuple, 0, b);
  if (c) {
    Py_INCREF(c);
    PyTuple_SET_ITEM(tuple, 1, c);
  }
  resultobj = wrapper(a, tuple);
  result = resultobj ? 0 : -1;
  Py_XDECREF(resultobj);
  Py_DECREF(tuple);
  return result;
}

#define SWIGPY_REPRFUNC_CLOSURE(wrapper)		\
SWIGINTERN PyObject *					\
wrapper##_reprfunc_closure(PyObject *a) {		\
  return SwigPyBuiltin_reprfunc_closure(wrapper, a);	\
}
SWIGINTERN PyObject *
SwigPyBuiltin_reprfunc_closure(SwigPyWrapperFunction wrapper, PyObject *a) {
  return wrapper(a, NULL);
}

#define SWIGPY_HASHFUNC_CLOSURE(wrapper)		\
SWIGINTERN Py_hash_t					\
wrapper##_hashfunc_closure(PyObject *a) {		\
  return SwigPyBuiltin_hashfunc_closure(wrapper, a);	\
}
SWIGINTERN Py_hash_t
SwigPyBuiltin_hashfunc_closure(SwigPyWrapperFunction wrapper, PyObject *a) {
  PyObject *pyresult;
  Py_hash_t result;
  pyresult = wrapper(a, NULL);
  if (!pyresult)
    return -1;
  result = SWIG_PyNumber_AsPyHash(pyresult);
  Py_DECREF(pyresult);
  return result;
}

#define SWIGPY_ITERNEXTFUNC_CLOSURE(wrapper)		\
SWIGINTERN PyObject *					\
wrapper##_iternextfunc_closure(PyObject *a) {		\
  return SwigPyBuiltin_iternextfunc_closure(wrapper, a);\
}
SWIGINTERN PyObject *
SwigPyBuiltin_iternextfunc_closure(SwigPyWrapperFunction wrapper, PyObject *a) {
  return wrapper(a, NULL);
}

/* End of callback function macros for use in PyTypeObject */

#ifdef __cplusplus
}
#endif




#define SWIG_exception_fail(code, msg) do { SWIG_Error(code, msg); SWIG_fail; } while(0) 

#define SWIG_contract_assert(expr, msg) if (!(expr)) { SWIG_Error(SWIG_RuntimeError, msg); SWIG_fail; } else 



#ifdef __cplusplus
extern "C" {
#endif

/* Method creation and docstring support functions */

SWIGINTERN PyMethodDef *SWIG_PythonGetProxyDoc(const char *name);
SWIGINTERN PyObject *SWIG_PyInstanceMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *func);
SWIGINTERN PyObject *SWIG_PyStaticMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *func);

#ifdef __cplusplus
}
#endif


  #define SWIG_exception(code, msg) do { SWIG_Error(code, msg); SWIG_fail;; } while(0) 

/* -----------------------------------------------------------------------------
 * director_common.swg
 *
 * This file contains support for director classes which is common between
 * languages.
 * ----------------------------------------------------------------------------- */

/*
  Use -DSWIG_DIRECTOR_STATIC if you prefer to avoid the use of the
  'Swig' namespace. This could be useful for multi-modules projects.
*/
#ifdef SWIG_DIRECTOR_STATIC
/* Force anonymous (static) namespace */
#define Swig
#endif
/* -----------------------------------------------------------------------------
 * director.swg
 *
 * This file contains support for director classes so that Python proxy
 * methods can be called from C++.
 * ----------------------------------------------------------------------------- */

#ifndef SWIG_DIRECTOR_PYTHON_HEADER_
#define SWIG_DIRECTOR_PYTHON_HEADER_

#include <string>
#include <iostream>
#include <exception>
#include <vector>
#include <map>


/*
  Use -DSWIG_PYTHON_DIRECTOR_NO_VTABLE if you don't want to generate a 'virtual
  table', and avoid multiple GetAttr calls to retrieve the python
  methods.
*/

#ifndef SWIG_PYTHON_DIRECTOR_NO_VTABLE
#ifndef SWIG_PYTHON_DIRECTOR_VTABLE
#define SWIG_PYTHON_DIRECTOR_VTABLE
#endif
#endif



/*
  Use -DSWIG_DIRECTOR_NO_UEH if you prefer to avoid the use of the
  Undefined Exception Handler provided by swig.
*/
#ifndef SWIG_DIRECTOR_NO_UEH
#ifndef SWIG_DIRECTOR_UEH
#define SWIG_DIRECTOR_UEH
#endif
#endif


/*
  Use -DSWIG_DIRECTOR_NORTTI if you prefer to avoid the use of the
  native C++ RTTI and dynamic_cast<>. But be aware that directors
  could stop working when using this option.
*/
#ifdef SWIG_DIRECTOR_NORTTI
/*
   When we don't use the native C++ RTTI, we implement a minimal one
   only for Directors.
*/
# ifndef SWIG_DIRECTOR_RTDIR
# define SWIG_DIRECTOR_RTDIR

namespace Swig {
  class Director;
  SWIGINTERN std::map<void *, Director *>& get_rtdir_map() {
    static std::map<void *, Director *> rtdir_map;
    return rtdir_map;
  }

  SWIGINTERNINLINE void set_rtdir(void *vptr, Director *rtdir) {
    get_rtdir_map()[vptr] = rtdir;
  }

  SWIGINTERNINLINE Director *get_rtdir(void *vptr) {
    std::map<void *, Director *>::const_iterator pos = get_rtdir_map().find(vptr);
    Director *rtdir = (pos != get_rtdir_map().end()) ? pos->second : 0;
    return rtdir;
  }
}
# endif /* SWIG_DIRECTOR_RTDIR */

# define SWIG_DIRECTOR_CAST(ARG) Swig::get_rtdir(static_cast<void *>(ARG))
# define SWIG_DIRECTOR_RGTR(ARG1, ARG2) Swig::set_rtdir(static_cast<void *>(ARG1), ARG2)

#else

# define SWIG_DIRECTOR_CAST(ARG) dynamic_cast<Swig::Director *>(ARG)
# define SWIG_DIRECTOR_RGTR(ARG1, ARG2)

#endif /* SWIG_DIRECTOR_NORTTI */

extern "C" {
  struct swig_type_info;
}

namespace Swig {

  /* memory handler */
  struct GCItem {
    virtual ~GCItem() {}

    virtual int get_own() const {
      return 0;
    }
  };

  struct GCItem_var {
    GCItem_var(GCItem *item = 0) : _item(item) {
    }

    GCItem_var& operator=(GCItem *item) {
      GCItem *tmp = _item;
      _item = item;
      delete tmp;
      return *this;
    }

    ~GCItem_var() {
      delete _item;
    }

    GCItem * operator->() const {
      return _item;
    }

  private:
    GCItem *_item;
  };

  struct GCItem_Object : GCItem {
    GCItem_Object(int own) : _own(own) {
    }

    virtual ~GCItem_Object() {
    }

    int get_own() const {
      return _own;
    }

  private:
    int _own;
  };

  template <typename Type>
  struct GCItem_T : GCItem {
    GCItem_T(Type *ptr) : _ptr(ptr) {
    }

    virtual ~GCItem_T() {
      delete _ptr;
    }

  private:
    Type *_ptr;
  };

  template <typename Type>
  struct GCArray_T : GCItem {
    GCArray_T(Type *ptr) : _ptr(ptr) {
    }

    virtual ~GCArray_T() {
      delete[] _ptr;
    }

  private:
    Type *_ptr;
  };

  /* base class for director exceptions */
  class DirectorException : public std::exception {
  protected:
    std::string swig_msg;
  public:
    DirectorException(PyObject *error, const char *hdr ="", const char *msg ="") : swig_msg(hdr) {
      SWIG_PYTHON_THREAD_BEGIN_BLOCK;
      if (msg[0]) {
        swig_msg += " ";
        swig_msg += msg;
      }
      if (!PyErr_Occurred()) {
        PyErr_SetString(error, what());
      }
      SWIG_PYTHON_THREAD_END_BLOCK;
    }

    virtual ~DirectorException() throw() {
    }

    /* Deprecated, use what() instead */
    const char *getMessage() const {
      return what();
    }

    const char *what() const throw() {
      return swig_msg.c_str();
    }

    static void raise(PyObject *error, const char *msg) {
      throw DirectorException(error, msg);
    }

    static void raise(const char *msg) {
      raise(PyExc_RuntimeError, msg);
    }
  };

  /* type mismatch in the return value from a python method call */
  class DirectorTypeMismatchException : public DirectorException {
  public:
    DirectorTypeMismatchException(PyObject *error, const char *msg="")
      : DirectorException(error, "SWIG director type mismatch", msg) {
    }

    DirectorTypeMismatchException(const char *msg="")
      : DirectorException(PyExc_TypeError, "SWIG director type mismatch", msg) {
    }

    static void raise(PyObject *error, const char *msg) {
      throw DirectorTypeMismatchException(error, msg);
    }

    static void raise(const char *msg) {
      throw DirectorTypeMismatchException(msg);
    }
  };

  /* any python exception that occurs during a director method call */
  class DirectorMethodException : public DirectorException {
  public:
    DirectorMethodException(const char *msg = "")
      : DirectorException(PyExc_RuntimeError, "SWIG director method error.", msg) {
    }

    static void raise(const char *msg) {
      throw DirectorMethodException(msg);
    }
  };

  /* attempt to call a pure virtual method via a director method */
  class DirectorPureVirtualException : public DirectorException {
  public:
    DirectorPureVirtualException(const char *msg = "")
      : DirectorException(PyExc_RuntimeError, "SWIG director pure virtual method called", msg) {
    }

    static void raise(const char *msg) {
      throw DirectorPureVirtualException(msg);
    }
  };


#if defined(SWIG_PYTHON_THREADS)
/*  __THREAD__ is the old macro to activate some thread support */
# if !defined(__THREAD__)
#   define __THREAD__ 1
# endif
#endif

#ifdef __THREAD__
# include "pythread.h"
  class Guard {
    PyThread_type_lock &mutex_;

  public:
    Guard(PyThread_type_lock & mutex) : mutex_(mutex) {
      PyThread_acquire_lock(mutex_, WAIT_LOCK);
    }

    ~Guard() {
      PyThread_release_lock(mutex_);
    }
  };
# define SWIG_GUARD(mutex) Guard _guard(mutex)
#else
# define SWIG_GUARD(mutex)
#endif

  /* director base class */
  class Director {
  private:
    /* pointer to the wrapped python object */
    PyObject *swig_self;
    /* flag indicating whether the object is owned by python or c++ */
    mutable bool swig_disown_flag;

    /* decrement the reference count of the wrapped python object */
    void swig_decref() const {
      if (swig_disown_flag) {
        SWIG_PYTHON_THREAD_BEGIN_BLOCK;
        Py_DECREF(swig_self);
        SWIG_PYTHON_THREAD_END_BLOCK;
      }
    }

  public:
    /* wrap a python object. */
    Director(PyObject *self) : swig_self(self), swig_disown_flag(false) {
    }

    /* discard our reference at destruction */
    virtual ~Director() {
      swig_decref();
    }

    /* return a pointer to the wrapped python object */
    PyObject *swig_get_self() const {
      return swig_self;
    }

    /* acquire ownership of the wrapped python object (the sense of "disown" is from python) */
    void swig_disown() const {
      if (!swig_disown_flag) {
        swig_disown_flag=true;
        swig_incref();
      }
    }

    /* increase the reference count of the wrapped python object */
    void swig_incref() const {
      if (swig_disown_flag) {
        Py_INCREF(swig_self);
      }
    }

    /* methods to implement pseudo protected director members */
    virtual bool swig_get_inner(const char * /* swig_protected_method_name */) const {
      return true;
    }

    virtual void swig_set_inner(const char * /* swig_protected_method_name */, bool /* swig_val */) const {
    }

  /* ownership management */
  private:
    typedef std::map<void *, GCItem_var> swig_ownership_map;
    mutable swig_ownership_map swig_owner;
#ifdef __THREAD__
    static PyThread_type_lock swig_mutex_own;
#endif

  public:
    template <typename Type>
    void swig_acquire_ownership_array(Type *vptr) const {
      if (vptr) {
        SWIG_GUARD(swig_mutex_own);
        swig_owner[vptr] = new GCArray_T<Type>(vptr);
      }
    }

    template <typename Type>
    void swig_acquire_ownership(Type *vptr) const {
      if (vptr) {
        SWIG_GUARD(swig_mutex_own);
        swig_owner[vptr] = new GCItem_T<Type>(vptr);
      }
    }

    void swig_acquire_ownership_obj(void *vptr, int own) const {
      if (vptr && own) {
        SWIG_GUARD(swig_mutex_own);
        swig_owner[vptr] = new GCItem_Object(own);
      }
    }

    int swig_release_ownership(void *vptr) const {
      int own = 0;
      if (vptr) {
        SWIG_GUARD(swig_mutex_own);
        swig_ownership_map::iterator iter = swig_owner.find(vptr);
        if (iter != swig_owner.end()) {
          own = iter->second->get_own();
          swig_owner.erase(iter);
        }
      }
      return own;
    }

    template <typename Type>
    static PyObject *swig_pyobj_disown(PyObject *pyobj, PyObject *SWIGUNUSEDPARM(args)) {
      SwigPyObject *sobj = (SwigPyObject *)pyobj;
      sobj->own = 0;
      Director *d = SWIG_DIRECTOR_CAST(reinterpret_cast<Type *>(sobj->ptr));
      if (d)
        d->swig_disown();
      return PyWeakref_NewProxy(pyobj, NULL);
    }
  };

#ifdef __THREAD__
  PyThread_type_lock Director::swig_mutex_own = PyThread_allocate_lock();
#endif
}

#endif

/* -------- TYPES TABLE (BEGIN) -------- */

#define SWIGTYPE_p_Column swig_types[0]
#define SWIGTYPE_p_EntityArray swig_types[1]
#define SWIGTYPE_p_InstanceType swig_types[2]
#define SWIGTYPE_p_KeyType swig_types[3]
#define SWIGTYPE_p_Row swig_types[4]
#define SWIGTYPE_p_SwigPyObject swig_types[5]
#define SWIGTYPE_p_TupleArray swig_types[6]
#define SWIGTYPE_p_ValueType swig_types[7]
#define SWIGTYPE_p_VariantArray swig_types[8]
#define SWIGTYPE_p_ampl__AMPL swig_types[9]
#define SWIGTYPE_p_ampl__AMPLException swig_types[10]
#define SWIGTYPE_p_ampl__BasicEntityT_ampl__ConstraintInstance_t swig_types[11]
#define SWIGTYPE_p_ampl__BasicEntityT_ampl__ObjectiveInstance_t swig_types[12]
#define SWIGTYPE_p_ampl__BasicEntityT_ampl__SetInstance_t swig_types[13]
#define SWIGTYPE_p_ampl__BasicEntityT_ampl__TableInstance_t swig_types[14]
#define SWIGTYPE_p_ampl__BasicEntityT_ampl__VariableInstance_t swig_types[15]
#define SWIGTYPE_p_ampl__BasicEntityT_ampl__VariantRef_t swig_types[16]
#define SWIGTYPE_p_ampl__Constraint swig_types[17]
#define SWIGTYPE_p_ampl__ConstraintInstance swig_types[18]
#define SWIGTYPE_p_ampl__DataFrame swig_types[19]
#define SWIGTYPE_p_ampl__Entity swig_types[20]
#define SWIGTYPE_p_ampl__EntityArgs swig_types[21]
#define SWIGTYPE_p_ampl__EntityMapT_ampl__Constraint_t swig_types[22]
#define SWIGTYPE_p_ampl__EntityMapT_ampl__Constraint_t__iterator swig_types[23]
#define SWIGTYPE_p_ampl__EntityMapT_ampl__Objective_t swig_types[24]
#define SWIGTYPE_p_ampl__EntityMapT_ampl__Objective_t__iterator swig_types[25]
#define SWIGTYPE_p_ampl__EntityMapT_ampl__Parameter_t swig_types[26]
#define SWIGTYPE_p_ampl__EntityMapT_ampl__Parameter_t__iterator swig_types[27]
#define SWIGTYPE_p_ampl__EntityMapT_ampl__Set_t swig_types[28]
#define SWIGTYPE_p_ampl__EntityMapT_ampl__Set_t__iterator swig_types[29]
#define SWIGTYPE_p_ampl__EntityMapT_ampl__Table_t swig_types[30]
#define SWIGTYPE_p_ampl__EntityMapT_ampl__Table_t__iterator swig_types[31]
#define SWIGTYPE_p_ampl__EntityMapT_ampl__Variable_t swig_types[32]
#define SWIGTYPE_p_ampl__EntityMapT_ampl__Variable_t__iterator swig_types[33]
#define SWIGTYPE_p_ampl__Environment swig_types[34]
#define SWIGTYPE_p_ampl__ErrorHandler swig_types[35]
#define SWIGTYPE_p_ampl__FileIOException swig_types[36]
#define SWIGTYPE_p_ampl__Instance swig_types[37]
#define SWIGTYPE_p_ampl__InvalidSubscriptException swig_types[38]
#define SWIGTYPE_p_ampl__LicenseException swig_types[39]
#define SWIGTYPE_p_ampl__NoDataException swig_types[40]
#define SWIGTYPE_p_ampl__Objective swig_types[41]
#define SWIGTYPE_p_ampl__ObjectiveInstance swig_types[42]
#define SWIGTYPE_p_ampl__OptionalT_bool_t swig_types[43]
#define SWIGTYPE_p_ampl__OptionalT_double_t swig_types[44]
#define SWIGTYPE_p_ampl__OptionalT_int_t swig_types[45]
#define SWIGTYPE_p_ampl__OptionalT_std__string_t swig_types[46]
#define SWIGTYPE_p_ampl__OutputHandler swig_types[47]
#define SWIGTYPE_p_ampl__Parameter swig_types[48]
#define SWIGTYPE_p_ampl__Runnable swig_types[49]
#define SWIGTYPE_p_ampl__Set swig_types[50]
#define SWIGTYPE_p_ampl__SetInstance swig_types[51]
#define SWIGTYPE_p_ampl__SetInstance__MemberRange swig_types[52]
#define SWIGTYPE_p_ampl__SetInstance__MemberRange__iterator swig_types[53]
#define SWIGTYPE_p_ampl__StringArray swig_types[54]
#define SWIGTYPE_p_ampl__StringRefArray swig_types[55]
#define SWIGTYPE_p_ampl__SyntaxErrorException swig_types[56]
#define SWIGTYPE_p_ampl__Table swig_types[57]
#define SWIGTYPE_p_ampl__TableInstance swig_types[58]
#define SWIGTYPE_p_ampl__Tuple swig_types[59]
#define SWIGTYPE_p_ampl__TupleRef swig_types[60]
#define SWIGTYPE_p_ampl__UnsupportedOperationException swig_types[61]
#define SWIGTYPE_p_ampl__Variable swig_types[62]
#define SWIGTYPE_p_ampl__VariableInstance swig_types[63]
#define SWIGTYPE_p_ampl__Variant swig_types[64]
#define SWIGTYPE_p_ampl__VariantRef swig_types[65]
#define SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t swig_types[66]
#define SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t swig_types[67]
#define SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t swig_types[68]
#define SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__TableInstance_t_t swig_types[69]
#define SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t swig_types[70]
#define SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t swig_types[71]
#define SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t swig_types[72]
#define SWIGTYPE_p_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t swig_types[73]
#define SWIGTYPE_p_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t swig_types[74]
#define SWIGTYPE_p_ampl__internal__EntityWrapperT_ampl__SetInstance_t swig_types[75]
#define SWIGTYPE_p_ampl__internal__EntityWrapperT_ampl__TableInstance_t swig_types[76]
#define SWIGTYPE_p_ampl__internal__EntityWrapperT_ampl__VariableInstance_t swig_types[77]
#define SWIGTYPE_p_ampl__internal__EntityWrapperT_ampl__VariantRef_t swig_types[78]
#define SWIGTYPE_p_ampl__internal__EnvironmentIterator swig_types[79]
#define SWIGTYPE_p_ampl__internal__SliceT_false_t swig_types[80]
#define SWIGTYPE_p_ampl__internal__SliceT_false_t__iterator swig_types[81]
#define SWIGTYPE_p_ampl__internal__SliceT_true_t swig_types[82]
#define SWIGTYPE_p_ampl__internal__SliceT_true_t__iterator swig_types[83]
#define SWIGTYPE_p_char swig_types[84]
#define SWIGTYPE_p_double swig_types[85]
#define SWIGTYPE_p_iterator swig_types[86]
#define SWIGTYPE_p_p_char swig_types[87]
#define SWIGTYPE_p_std__runtime_error swig_types[88]
static swig_type_info *swig_types[90];
static swig_module_info swig_module = {swig_types, 89, 0, 0, 0, 0};
#define SWIG_TypeQuery(name) SWIG_TypeQueryModule(&swig_module, &swig_module, name)
#define SWIG_MangledTypeQuery(name) SWIG_MangledTypeQueryModule(&swig_module, &swig_module, name)

/* -------- TYPES TABLE (END) -------- */

#ifdef SWIG_TypeQuery
# undef SWIG_TypeQuery
#endif
#define SWIG_TypeQuery SWIG_Python_TypeQuery

/*-----------------------------------------------
              @(target):= _amplpython.so
  ------------------------------------------------*/
#if PY_VERSION_HEX >= 0x03000000
#  define SWIG_init    PyInit__amplpython

#else
#  define SWIG_init    init_amplpython

#endif
#define SWIG_name    "_amplpython"

#define SWIGVERSION 0x040002 
#define SWIG_VERSION SWIGVERSION


#define SWIG_as_voidptr(a) const_cast< void * >(static_cast< const void * >(a)) 
#define SWIG_as_voidptrptr(a) ((void)SWIG_as_voidptr(*a),reinterpret_cast< void** >(a)) 


#include <stdexcept>


namespace swig {
  class SwigPtr_PyObject {
  protected:
    PyObject *_obj;

  public:
    SwigPtr_PyObject() :_obj(0)
    {
    }

    SwigPtr_PyObject(const SwigPtr_PyObject& item) : _obj(item._obj)
    {
      SWIG_PYTHON_THREAD_BEGIN_BLOCK;
      Py_XINCREF(_obj);      
      SWIG_PYTHON_THREAD_END_BLOCK;
    }
    
    SwigPtr_PyObject(PyObject *obj, bool initial_ref = true) :_obj(obj)
    {
      if (initial_ref) {
        SWIG_PYTHON_THREAD_BEGIN_BLOCK;
        Py_XINCREF(_obj);
        SWIG_PYTHON_THREAD_END_BLOCK;
      }
    }
    
    SwigPtr_PyObject & operator=(const SwigPtr_PyObject& item) 
    {
      SWIG_PYTHON_THREAD_BEGIN_BLOCK;
      Py_XINCREF(item._obj);
      Py_XDECREF(_obj);
      _obj = item._obj;
      SWIG_PYTHON_THREAD_END_BLOCK;
      return *this;      
    }
    
    ~SwigPtr_PyObject() 
    {
      SWIG_PYTHON_THREAD_BEGIN_BLOCK;
      Py_XDECREF(_obj);
      SWIG_PYTHON_THREAD_END_BLOCK;
    }
    
    operator PyObject *() const
    {
      return _obj;
    }

    PyObject *operator->() const
    {
      return _obj;
    }
  };
}


namespace swig {
  struct SwigVar_PyObject : SwigPtr_PyObject {
    SwigVar_PyObject(PyObject* obj = 0) : SwigPtr_PyObject(obj, false) { }
    
    SwigVar_PyObject & operator = (PyObject* obj)
    {
      Py_XDECREF(_obj);
      _obj = obj;
      return *this;      
    }
  };
}


#include <stddef.h>


#if PY_VERSION_HEX>=0x03000000
  #define _PyString_AsString(str) PyUnicode_AsUTF8(str)
  #define _PyString_Check(obj) PyUnicode_Check(obj)
#else
  #define _PyString_AsString(str) PyString_AsString(str)
  #define _PyString_Check(obj) PyString_Check(obj)
#endif


  #include "ampl/ampl.h"


#include <string>


  #define SWIG_From_long   PyInt_FromLong 


SWIGINTERNINLINE PyObject* 
SWIG_From_unsigned_SS_long  (unsigned long value)
{
  return (value > LONG_MAX) ?
    PyLong_FromUnsignedLong(value) : PyInt_FromLong(static_cast< long >(value));
}


#include <limits.h>
#if !defined(SWIG_NO_LLONG_MAX)
# if !defined(LLONG_MAX) && defined(__GNUC__) && defined (__LONG_LONG_MAX__)
#   define LLONG_MAX __LONG_LONG_MAX__
#   define LLONG_MIN (-LLONG_MAX - 1LL)
#   define ULLONG_MAX (LLONG_MAX * 2ULL + 1ULL)
# endif
#endif


#if defined(LLONG_MAX) && !defined(SWIG_LONG_LONG_AVAILABLE)
#  define SWIG_LONG_LONG_AVAILABLE
#endif


#ifdef SWIG_LONG_LONG_AVAILABLE
SWIGINTERNINLINE PyObject* 
SWIG_From_unsigned_SS_long_SS_long  (unsigned long long value)
{
  return (value > LONG_MAX) ?
    PyLong_FromUnsignedLongLong(value) : PyInt_FromLong(static_cast< long >(value));
}
#endif


SWIGINTERNINLINE PyObject *
SWIG_From_size_t  (size_t value)
{    
#ifdef SWIG_LONG_LONG_AVAILABLE
  if (sizeof(size_t) <= sizeof(unsigned long)) {
#endif
    return SWIG_From_unsigned_SS_long  (static_cast< unsigned long >(value));
#ifdef SWIG_LONG_LONG_AVAILABLE
  } else {
    /* assume sizeof(size_t) <= sizeof(unsigned long long) */
    return SWIG_From_unsigned_SS_long_SS_long  (static_cast< unsigned long long >(value));
  }
#endif
}


SWIGINTERN int
SWIG_AsVal_double (PyObject *obj, double *val)
{
  int res = SWIG_TypeError;
  if (PyFloat_Check(obj)) {
    if (val) *val = PyFloat_AsDouble(obj);
    return SWIG_OK;
#if PY_VERSION_HEX < 0x03000000
  } else if (PyInt_Check(obj)) {
    if (val) *val = (double) PyInt_AsLong(obj);
    return SWIG_OK;
#endif
  } else if (PyLong_Check(obj)) {
    double v = PyLong_AsDouble(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      PyErr_Clear();
    }
  }
#ifdef SWIG_PYTHON_CAST_MODE
  {
    int dispatch = 0;
    double d = PyFloat_AsDouble(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = d;
      return SWIG_AddCast(SWIG_OK);
    } else {
      PyErr_Clear();
    }
    if (!dispatch) {
      long v = PyLong_AsLong(obj);
      if (!PyErr_Occurred()) {
	if (val) *val = v;
	return SWIG_AddCast(SWIG_AddCast(SWIG_OK));
      } else {
	PyErr_Clear();
      }
    }
  }
#endif
  return res;
}


#include <float.h>


#include <math.h>


SWIGINTERNINLINE int
SWIG_CanCastAsInteger(double *d, double min, double max) {
  double x = *d;
  if ((min <= x && x <= max)) {
   double fx = floor(x);
   double cx = ceil(x);
   double rd =  ((x - fx) < 0.5) ? fx : cx; /* simple rint */
   if ((errno == EDOM) || (errno == ERANGE)) {
     errno = 0;
   } else {
     double summ, reps, diff;
     if (rd < x) {
       diff = x - rd;
     } else if (rd > x) {
       diff = rd - x;
     } else {
       return 1;
     }
     summ = rd + x;
     reps = diff/summ;
     if (reps < 8*DBL_EPSILON) {
       *d = rd;
       return 1;
     }
   }
  }
  return 0;
}


SWIGINTERN int
SWIG_AsVal_unsigned_SS_long (PyObject *obj, unsigned long *val) 
{
#if PY_VERSION_HEX < 0x03000000
  if (PyInt_Check(obj)) {
    long v = PyInt_AsLong(obj);
    if (v >= 0) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      return SWIG_OverflowError;
    }
  } else
#endif
  if (PyLong_Check(obj)) {
    unsigned long v = PyLong_AsUnsignedLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      PyErr_Clear();
      return SWIG_OverflowError;
    }
  }
#ifdef SWIG_PYTHON_CAST_MODE
  {
    int dispatch = 0;
    unsigned long v = PyLong_AsUnsignedLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_AddCast(SWIG_OK);
    } else {
      PyErr_Clear();
    }
    if (!dispatch) {
      double d;
      int res = SWIG_AddCast(SWIG_AsVal_double (obj,&d));
      if (SWIG_IsOK(res) && SWIG_CanCastAsInteger(&d, 0, ULONG_MAX)) {
	if (val) *val = (unsigned long)(d);
	return res;
      }
    }
  }
#endif
  return SWIG_TypeError;
}


#ifdef SWIG_LONG_LONG_AVAILABLE
SWIGINTERN int
SWIG_AsVal_unsigned_SS_long_SS_long (PyObject *obj, unsigned long long *val)
{
  int res = SWIG_TypeError;
  if (PyLong_Check(obj)) {
    unsigned long long v = PyLong_AsUnsignedLongLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      PyErr_Clear();
      res = SWIG_OverflowError;
    }
  } else {
    unsigned long v;
    res = SWIG_AsVal_unsigned_SS_long (obj,&v);
    if (SWIG_IsOK(res)) {
      if (val) *val = v;
      return res;
    }
  }
#ifdef SWIG_PYTHON_CAST_MODE
  {
    const double mant_max = 1LL << DBL_MANT_DIG;
    double d;
    res = SWIG_AsVal_double (obj,&d);
    if (SWIG_IsOK(res) && !SWIG_CanCastAsInteger(&d, 0, mant_max))
      return SWIG_OverflowError;
    if (SWIG_IsOK(res) && SWIG_CanCastAsInteger(&d, 0, mant_max)) {
      if (val) *val = (unsigned long long)(d);
      return SWIG_AddCast(res);
    }
    res = SWIG_TypeError;
  }
#endif
  return res;
}
#endif


SWIGINTERNINLINE int
SWIG_AsVal_size_t (PyObject * obj, size_t *val)
{
  int res = SWIG_TypeError;
#ifdef SWIG_LONG_LONG_AVAILABLE
  if (sizeof(size_t) <= sizeof(unsigned long)) {
#endif
    unsigned long v;
    res = SWIG_AsVal_unsigned_SS_long (obj, val ? &v : 0);
    if (SWIG_IsOK(res) && val) *val = static_cast< size_t >(v);
#ifdef SWIG_LONG_LONG_AVAILABLE
  } else if (sizeof(size_t) <= sizeof(unsigned long long)) {
    unsigned long long v;
    res = SWIG_AsVal_unsigned_SS_long_SS_long (obj, val ? &v : 0);
    if (SWIG_IsOK(res) && val) *val = static_cast< size_t >(v);
  }
#endif
  return res;
}


SWIGINTERN swig_type_info*
SWIG_pchar_descriptor(void)
{
  static int init = 0;
  static swig_type_info* info = 0;
  if (!init) {
    info = SWIG_TypeQuery("_p_char");
    init = 1;
  }
  return info;
}


SWIGINTERNINLINE PyObject *
SWIG_FromCharPtrAndSize(const char* carray, size_t size)
{
  if (carray) {
    if (size > INT_MAX) {
      swig_type_info* pchar_descriptor = SWIG_pchar_descriptor();
      return pchar_descriptor ? 
	SWIG_InternalNewPointerObj(const_cast< char * >(carray), pchar_descriptor, 0) : SWIG_Py_Void();
    } else {
#if PY_VERSION_HEX >= 0x03000000
#if defined(SWIG_PYTHON_STRICT_BYTE_CHAR)
      return PyBytes_FromStringAndSize(carray, static_cast< Py_ssize_t >(size));
#else
      return PyUnicode_DecodeUTF8(carray, static_cast< Py_ssize_t >(size), "surrogateescape");
#endif
#else
      return PyString_FromStringAndSize(carray, static_cast< Py_ssize_t >(size));
#endif
    }
  } else {
    return SWIG_Py_Void();
  }
}


SWIGINTERNINLINE PyObject * 
SWIG_FromCharPtr(const char *cptr)
{ 
  return SWIG_FromCharPtrAndSize(cptr, (cptr ? strlen(cptr) : 0));
}


ampl::Variant VariantFromPyObject(PyObject *obj) {
    if (obj == Py_None) {
        return ampl::Variant();
    } else if (PyInt_Check(obj)) {
        return ampl::Variant(PyInt_AsLong(obj));
    } else if (PyLong_Check(obj)) {
        return ampl::Variant(PyLong_AsLong(obj));
    } else if (PyFloat_Check(obj)) {
        return ampl::Variant(PyFloat_AsDouble(obj));
    } else if (PyUnicode_Check(obj) || PyString_Check(obj)) {
        return ampl::Variant(std::string(_PyString_AsString(obj)));
    } else {
        PyErr_Clear();
        double value = PyFloat_AsDouble(obj);
        if (PyErr_Occurred() != NULL) {
            throw std::logic_error("Failed to cast value to int/float/double/string");
        }
        return ampl::Variant(value);
    }
}

void SetTupleFromPyObject(PyObject *obj, ampl::Tuple *t) {
    bool is_tuple = PyTuple_Check(obj);
    bool is_list = !is_tuple && PyList_Check(obj);
    std::size_t size = 1;
    if (is_tuple || is_list) {
        size = Py_SIZE(obj);
    }
    std::vector<ampl::Variant> args(size);
    for (std::size_t i = 0; i < size; i++) {
        PyObject *item;
        if (is_tuple) {
            item = PyTuple_GetItem(obj, i);
        } else if (is_list) {
            item = PyList_GetItem(obj, i);
        } else {
            item = obj;
        }
        args[i] = VariantFromPyObject(item);
    }
    *t = ampl::Tuple(args.data(), args.size());
}


#include <typeinfo>
#include <stdexcept>


typedef ampl::Variant VariantArray;

SWIGINTERN VariantArray *new_VariantArray(size_t nelements){
    return (new ampl::Variant[nelements]());
  }
SWIGINTERN void delete_VariantArray(VariantArray *self){
    delete[] self;
  }
SWIGINTERN ampl::Variant VariantArray___getitem__(VariantArray *self,size_t index){
    return self[index];
  }
SWIGINTERN void VariantArray___setitem__(VariantArray *self,size_t index,ampl::Variant value){
    self[index] = value;
  }
SWIGINTERN ampl::Variant *VariantArray_cast(VariantArray *self){
    return self;
  }
SWIGINTERN VariantArray *VariantArray_frompointer(ampl::Variant *t){
    return static_cast< VariantArray * >(t);
  }

typedef ampl::Tuple TupleArray;

SWIGINTERN TupleArray *new_TupleArray(size_t nelements){
    return (new ampl::Tuple[nelements]());
  }
SWIGINTERN void delete_TupleArray(TupleArray *self){
    delete[] self;
  }
SWIGINTERN ampl::Tuple TupleArray___getitem__(TupleArray *self,size_t index){
    return self[index];
  }
SWIGINTERN void TupleArray___setitem__(TupleArray *self,size_t index,ampl::Tuple value){
    self[index] = value;
  }
SWIGINTERN ampl::Tuple *TupleArray_cast(TupleArray *self){
    return self;
  }
SWIGINTERN TupleArray *TupleArray_frompointer(ampl::Tuple *t){
    return static_cast< TupleArray * >(t);
  }

SWIGINTERN int
SWIG_AsVal_long (PyObject *obj, long* val)
{
#if PY_VERSION_HEX < 0x03000000
  if (PyInt_Check(obj)) {
    if (val) *val = PyInt_AsLong(obj);
    return SWIG_OK;
  } else
#endif
  if (PyLong_Check(obj)) {
    long v = PyLong_AsLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      PyErr_Clear();
      return SWIG_OverflowError;
    }
  }
#ifdef SWIG_PYTHON_CAST_MODE
  {
    int dispatch = 0;
    long v = PyInt_AsLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_AddCast(SWIG_OK);
    } else {
      PyErr_Clear();
    }
    if (!dispatch) {
      double d;
      int res = SWIG_AddCast(SWIG_AsVal_double (obj,&d));
      if (SWIG_IsOK(res) && SWIG_CanCastAsInteger(&d, LONG_MIN, LONG_MAX)) {
	if (val) *val = (long)(d);
	return res;
      }
    }
  }
#endif
  return SWIG_TypeError;
}


SWIGINTERN int
SWIG_AsVal_int (PyObject * obj, int *val)
{
  long v;
  int res = SWIG_AsVal_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v < INT_MIN || v > INT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = static_cast< int >(v);
    }
  }  
  return res;
}


SWIGINTERNINLINE PyObject*
  SWIG_From_bool  (bool value)
{
  return PyBool_FromLong(value ? 1 : 0);
}


SWIGINTERNINLINE PyObject*
  SWIG_From_int  (int value)
{
  return PyInt_FromLong((long) value);
}


SWIGINTERN int
SWIG_AsCharPtrAndSize(PyObject *obj, char** cptr, size_t* psize, int *alloc)
{
#if PY_VERSION_HEX>=0x03000000
#if defined(SWIG_PYTHON_STRICT_BYTE_CHAR)
  if (PyBytes_Check(obj))
#else
  if (PyUnicode_Check(obj))
#endif
#else  
  if (PyString_Check(obj))
#endif
  {
    char *cstr; Py_ssize_t len;
    int ret = SWIG_OK;
#if PY_VERSION_HEX>=0x03000000
#if !defined(SWIG_PYTHON_STRICT_BYTE_CHAR)
    if (!alloc && cptr) {
        /* We can't allow converting without allocation, since the internal
           representation of string in Python 3 is UCS-2/UCS-4 but we require
           a UTF-8 representation.
           TODO(bhy) More detailed explanation */
        return SWIG_RuntimeError;
    }
    obj = PyUnicode_AsUTF8String(obj);
    if (!obj)
      return SWIG_TypeError;
    if (alloc)
      *alloc = SWIG_NEWOBJ;
#endif
    if (PyBytes_AsStringAndSize(obj, &cstr, &len) == -1)
      return SWIG_TypeError;
#else
    if (PyString_AsStringAndSize(obj, &cstr, &len) == -1)
      return SWIG_TypeError;
#endif
    if (cptr) {
      if (alloc) {
	if (*alloc == SWIG_NEWOBJ) {
	  *cptr = reinterpret_cast< char* >(memcpy(new char[len + 1], cstr, sizeof(char)*(len + 1)));
	  *alloc = SWIG_NEWOBJ;
	} else {
	  *cptr = cstr;
	  *alloc = SWIG_OLDOBJ;
	}
      } else {
#if PY_VERSION_HEX>=0x03000000
#if defined(SWIG_PYTHON_STRICT_BYTE_CHAR)
	*cptr = PyBytes_AsString(obj);
#else
	assert(0); /* Should never reach here with Unicode strings in Python 3 */
#endif
#else
	*cptr = SWIG_Python_str_AsChar(obj);
        if (!*cptr)
          ret = SWIG_TypeError;
#endif
      }
    }
    if (psize) *psize = len + 1;
#if PY_VERSION_HEX>=0x03000000 && !defined(SWIG_PYTHON_STRICT_BYTE_CHAR)
    Py_XDECREF(obj);
#endif
    return ret;
  } else {
#if defined(SWIG_PYTHON_2_UNICODE)
#if defined(SWIG_PYTHON_STRICT_BYTE_CHAR)
#error "Cannot use both SWIG_PYTHON_2_UNICODE and SWIG_PYTHON_STRICT_BYTE_CHAR at once"
#endif
#if PY_VERSION_HEX<0x03000000
    if (PyUnicode_Check(obj)) {
      char *cstr; Py_ssize_t len;
      if (!alloc && cptr) {
        return SWIG_RuntimeError;
      }
      obj = PyUnicode_AsUTF8String(obj);
      if (!obj)
        return SWIG_TypeError;
      if (PyString_AsStringAndSize(obj, &cstr, &len) != -1) {
        if (cptr) {
          if (alloc) *alloc = SWIG_NEWOBJ;
          *cptr = reinterpret_cast< char* >(memcpy(new char[len + 1], cstr, sizeof(char)*(len + 1)));
        }
        if (psize) *psize = len + 1;

        Py_XDECREF(obj);
        return SWIG_OK;
      } else {
        Py_XDECREF(obj);
      }
    }
#endif
#endif

    swig_type_info* pchar_descriptor = SWIG_pchar_descriptor();
    if (pchar_descriptor) {
      void* vptr = 0;
      if (SWIG_ConvertPtr(obj, &vptr, pchar_descriptor, 0) == SWIG_OK) {
	if (cptr) *cptr = (char *) vptr;
	if (psize) *psize = vptr ? (strlen((char *)vptr) + 1) : 0;
	if (alloc) *alloc = SWIG_OLDOBJ;
	return SWIG_OK;
      }
    }
  }
  return SWIG_TypeError;
}


SWIGINTERN int
SWIG_AsPtr_std_string (PyObject * obj, std::string **val) 
{
  char* buf = 0 ; size_t size = 0; int alloc = SWIG_OLDOBJ;
  if (SWIG_IsOK((SWIG_AsCharPtrAndSize(obj, &buf, &size, &alloc)))) {
    if (buf) {
      if (val) *val = new std::string(buf, size - 1);
      if (alloc == SWIG_NEWOBJ) delete[] buf;
      return SWIG_NEWOBJ;
    } else {
      if (val) *val = 0;
      return SWIG_OLDOBJ;
    }
  } else {
    static int init = 0;
    static swig_type_info* descriptor = 0;
    if (!init) {
      descriptor = SWIG_TypeQuery("std::string" " *");
      init = 1;
    }
    if (descriptor) {
      std::string *vptr;
      int res = SWIG_ConvertPtr(obj, (void**)&vptr, descriptor, 0);
      if (SWIG_IsOK(res) && val) *val = vptr;
      return res;
    }
  }
  return SWIG_ERROR;
}


SWIGINTERNINLINE PyObject *
SWIG_From_std_string  (const std::string& s)
{
  return SWIG_FromCharPtrAndSize(s.data(), s.size());
}


SWIGINTERN int
SWIG_AsVal_bool (PyObject *obj, bool *val)
{
  int r;
  if (!PyBool_Check(obj))
    return SWIG_ERROR;
  r = PyObject_IsTrue(obj);
  if (r == -1)
    return SWIG_ERROR;
  if (val) *val = r ? true : false;
  return SWIG_OK;
}


  #define SWIG_From_double   PyFloat_FromDouble 

SWIGINTERN bool ampl_Variant_equals(ampl::Variant *self,ampl::Variant &b){
      return ampl::internal::compare(*self, b)==0;
    }
SWIGINTERN int ampl_Variant_compare(ampl::Variant *self,ampl::Variant &b){
      return ampl::internal::compare(*self, b);
    }
SWIGINTERN bool ampl_VariantRef_equals(ampl::VariantRef *self,ampl::VariantRef &b){
      return ampl::internal::compare(*self, b) == 0;
    }
SWIGINTERN int ampl_VariantRef_compare(ampl::VariantRef *self,ampl::VariantRef &b){
      return ampl::internal::compare(*self, b);
    }



SWIGINTERN bool ampl_Tuple_operator_Se__Se_(ampl::Tuple *self,ampl::Tuple &other){
  return (other == *self);
  }
SWIGINTERN ampl::Tuple ampl_Tuple_Factory__SWIG_0(VariantArray &args,std::size_t count){
    return ampl::Tuple(VariantArray_cast(&args), count);
  }
SWIGINTERN ampl::Tuple ampl_Tuple_Factory__SWIG_1(ampl::TupleRef t){
    return ampl::Tuple(t);
  }
SWIGINTERN void ampl_DataFrame_setValueSWIG__SWIG_0(ampl::DataFrame *self,ampl::Tuple rowIndex,fmt::CStringRef colHeader,ampl::Variant value){
	self->setValue(ampl::TupleRef(rowIndex), colHeader, value);
}
SWIGINTERN void ampl_DataFrame_setValueSWIG__SWIG_1(ampl::DataFrame *self,std::size_t rowIndex,std::size_t colIndex,ampl::Variant value){
	self->setValue(rowIndex, colIndex, value);
}
SWIGINTERN void ampl_DataFrame_addColumnSWIG(ampl::DataFrame *self,fmt::CStringRef header){
  return self->addColumn(header);
}
SWIGINTERN void ampl_DataFrame_addColumnSWIG(ampl::DataFrame *self,fmt::CStringRef header,char const *args[]){
  return self->addColumn(header, ampl::internal::Args(args));
}
SWIGINTERN void ampl_DataFrame_addColumnSWIG(ampl::DataFrame *self,fmt::CStringRef header,double *args){
  return self->addColumn(header, ampl::internal::Args(args));
}
SWIGINTERN void ampl_DataFrame_addRow__SWIG_5(ampl::DataFrame *self,ampl::Tuple tuple){
  return self->addRow(ampl::TupleRef(tuple));
  }
SWIGINTERN ampl::internal::Slice< true > ampl_DataFrame_getRow(ampl::DataFrame *self,ampl::Tuple tuple){
  return self->getRow(ampl::TupleRef(tuple));
  }
SWIGINTERN void ampl_DataFrame_setColumnSWIG(ampl::DataFrame *self,fmt::CStringRef header,char const *args[],std::size_t n){
    self->setColumn(header, ampl::internal::Args(args), n);
  }
SWIGINTERN void ampl_DataFrame_setColumnSWIG(ampl::DataFrame *self,fmt::CStringRef header,double *values,std::size_t n){
    self->setColumn(header, ampl::internal::Args(values), n);
  }
SWIGINTERN void ampl_DataFrame_setArraySWIG(ampl::DataFrame *self,double *args,double *values,std::size_t n){
    self->setArray(n, ampl::internal::Args(args), values);
  }
SWIGINTERN void ampl_DataFrame_setArraySWIG(ampl::DataFrame *self,char const *args[],double *values,std::size_t n){
    self->setArray(n, ampl::internal::Args(args), values);
  }
SWIGINTERN void ampl_DataFrame_setArraySWIG(ampl::DataFrame *self,double *args,char const *const *values,std::size_t n){
    self->setArray(n, ampl::internal::Args(args), values);
  }
SWIGINTERN void ampl_DataFrame_setArraySWIG(ampl::DataFrame *self,char const *args[],char const *const *values,std::size_t n){
    self->setArray(n, ampl::internal::Args(args), values);
  }
SWIGINTERN void ampl_DataFrame_setMatrixSWIG(ampl::DataFrame *self,double *row_indices,std::size_t rown,double *col_indices,std::size_t coln,double const *values){
    self->setMatrix(rown, ampl::internal::Args(row_indices), coln,
      ampl::internal::Args(col_indices), values);
  }
SWIGINTERN void ampl_DataFrame_setMatrixSWIG(ampl::DataFrame *self,char const *row_indices[],std::size_t rown,char const *col_indices[],std::size_t coln,double const *values){
    self->setMatrix(rown, ampl::internal::Args(row_indices), coln,
      ampl::internal::Args(col_indices), values);
  }
SWIGINTERN void ampl_DataFrame_setMatrixSWIG(ampl::DataFrame *self,double *row_indices,std::size_t rown,char const *col_indices[],std::size_t coln,double const *values){
    self->setMatrix(rown, ampl::internal::Args(row_indices), coln,
      ampl::internal::Args(col_indices), values);
  }
SWIGINTERN void ampl_DataFrame_setMatrixSWIG(ampl::DataFrame *self,char const *row_indices[],std::size_t rown,double *col_indices,std::size_t coln,double const *values){
    self->setMatrix(rown, ampl::internal::Args(row_indices), coln,
      ampl::internal::Args(col_indices), values);
  }
SWIGINTERN void ampl_DataFrame_setMatrixSWIG(ampl::DataFrame *self,double *row_indices,std::size_t rown,double *col_indices,std::size_t coln,char const *args[]){
    self->setMatrix(rown, ampl::internal::Args(row_indices), coln,
      ampl::internal::Args(col_indices), args);
  }
SWIGINTERN void ampl_DataFrame_setMatrixSWIG(ampl::DataFrame *self,double *row_indices,std::size_t rown,char const *col_indices[],std::size_t coln,char const *args[]){
    self->setMatrix(rown, ampl::internal::Args(row_indices), coln,
      ampl::internal::Args(col_indices), args);
  }
SWIGINTERN void ampl_DataFrame_setMatrixSWIG(ampl::DataFrame *self,char const *row_indices[],std::size_t rown,double *col_indices,std::size_t coln,char const *args[]){
    self->setMatrix(rown, ampl::internal::Args(row_indices), coln,
      ampl::internal::Args(col_indices), args);
  }
SWIGINTERN void ampl_DataFrame_setMatrixSWIG(ampl::DataFrame *self,char const *row_indices[],std::size_t rown,char const *col_indices[],std::size_t coln,char const *args[]){
    self->setMatrix(rown, ampl::internal::Args(row_indices), coln,
      ampl::internal::Args(col_indices), args);
  }
SWIGINTERN ampl::DataFrame ampl_DataFrame_factory(int numberOfIndexColumns,char const *args[],int count){
    ampl::StringArgs s(args, count);
    return ampl::DataFrame(numberOfIndexColumns, s);
  }
SWIGINTERN void ampl_DataFrame_setColumnPyList(ampl::DataFrame *self,fmt::CStringRef header,PyObject *list){
        if (!PyList_Check(list)) {
            throw std::logic_error("Expected a list");
        }
        std::size_t size = Py_SIZE(list);
        bool has_numbers = false, has_strings = false;
        for (std::size_t i = 0; i < size; i++) {
            PyObject *item = PyList_GetItem(list, i);
            if (item == NULL) {
                throw std::logic_error("Failed to access value");
            }
            if (PyUnicode_Check(item) || PyString_Check(item)) {
                has_strings = true;
            } else {
                has_numbers = true;
            }
            if (has_numbers && has_strings) {
                throw std::logic_error("All values must be either numbers or strings");
            }
        }
        if (has_strings) {
            std::vector<const char *> values(size);
            for (std::size_t i = 0; i < size; i++) {
                PyObject *item = PyList_GetItem(list, i);
                values[i] = _PyString_AsString(item);
            }
            self->setColumn(header, ampl::internal::Args(values.data()), size);
        } else if (has_numbers) {
            std::vector<double> values(size);
            for (std::size_t i = 0; i < size; i++) {
                PyObject *item = PyList_GetItem(list, i);
                if (PyInt_Check(item)) {
                    values[i] = PyInt_AsLong(item);
                } else if (PyLong_Check(item)) {
                    values[i] = PyLong_AsLong(item);
                } else {
                    PyErr_Clear();
                    values[i] = PyFloat_AsDouble(item);
                    if (PyErr_Occurred() != NULL) {
                        throw std::logic_error("Failed to cast value to int/float/double");
                    }
                }
            }
            self->setColumn(header, ampl::internal::Args(values.data()), size);
        }
    }
SWIGINTERN PyObject *ampl_internal_Slice_Sl_false_Sg__toPyList(ampl::internal::Slice< false > *self){
        std::size_t size = self->size();
        PyObject* res = PyList_New(size);
        for (std::size_t i = 0; i < size; i++) {
            const ampl::VariantRef &v = (*self)[i];
            PyObject *item = NULL;
            switch (v.type()) {
            case ampl::STRING:
                item = PyString_FromString(v.c_str());
                break;
            case ampl::NUMERIC:
                item = PyFloat_FromDouble(v.dbl());
                break;
            case ampl::EMPTY:
                item = Py_None;
                break;
            }
            PyList_SetItem(res, i, item);
        }
        return res;
    }
SWIGINTERN bool ampl_SetInstance_Contains(ampl::SetInstance const *self,ampl::Tuple t){
    return self->contains(ampl::TupleRef(t));
  }
SWIGINTERN void ampl_SetInstance_setValues(ampl::SetInstance *self,ampl::Tuple const *t,std::size_t n){
    return self->setValues(t, n);
  }
SWIGINTERN void ampl_SetInstance_setValues(ampl::SetInstance *self,TupleArray &t,std::size_t n){
    return self->setValues(TupleArray_cast(&t), n);
  }
SWIGINTERN void ampl_SetInstance_setValues(ampl::SetInstance *self,double *values,std::size_t n){
    return self->setValues(ampl::internal::Args(values), n);
  }
SWIGINTERN void ampl_SetInstance_setValues(ampl::SetInstance *self,char const *args[],std::size_t n){
    return self->setValues(ampl::internal::Args(args), n);
  }

typedef ampl::Entity EntityArray;

SWIGINTERN EntityArray *new_EntityArray(size_t nelements){
    return (new ampl::Entity[nelements]());
  }
SWIGINTERN void delete_EntityArray(EntityArray *self){
    delete[] self;
  }
SWIGINTERN ampl::Entity EntityArray___getitem__(EntityArray *self,size_t index){
    return self[index];
  }
SWIGINTERN void EntityArray___setitem__(EntityArray *self,size_t index,ampl::Entity value){
    self[index] = value;
  }
SWIGINTERN ampl::Entity *EntityArray_cast(EntityArray *self){
    return self;
  }
SWIGINTERN EntityArray *EntityArray_frompointer(ampl::Entity *t){
    return static_cast< EntityArray * >(t);
  }
SWIGINTERN ampl::DataFrame ampl_Entity_getValues(ampl::Entity *self,char const *args[],int count){
      ampl::StringArgs s(args, count);
      return self->getValues(s);
    }
SWIGINTERN ampl::EntityArgs ampl_EntityArgs_Factory(EntityArray &args,std::size_t count){
    return ampl::EntityArgs(EntityArray_cast(&args), count);
  }
SWIGINTERN bool ampl_Set_contains(ampl::Set const *self,ampl::Tuple t){
        return self->contains(ampl::TupleRef(t));
      }
SWIGINTERN void ampl_Set_setValuesTuples(ampl::Set *self,ampl::Tuple const *t,std::size_t n){
        return self->setValues(t, n);
      }
SWIGINTERN void ampl_Set_setValues(ampl::Set *self,TupleArray &t,std::size_t n){
        return self->setValues(TupleArray_cast(&t), n);
      }
SWIGINTERN void ampl_Set_setValuesDbl(ampl::Set *self,double *values,std::size_t n){
        return self->setValues(ampl::internal::Args(values), n);
      }
SWIGINTERN void ampl_Set_setValuesStr(ampl::Set *self,char const *args[],std::size_t n){
        return self->setValues(ampl::internal::Args(args), n);
      }
SWIGINTERN void ampl_Parameter_set__SWIG_0(ampl::Parameter *self,ampl::Variant value){
      self->set(ampl::VariantRef(value));
    }
SWIGINTERN void ampl_Parameter_set__SWIG_1(ampl::Parameter *self,double value){
        self->set(ampl::VariantRef(value));
      }
SWIGINTERN void ampl_Parameter_set__SWIG_2(ampl::Parameter *self,char const *value){
      self->set(ampl::VariantRef(value));
    }
SWIGINTERN void ampl_Parameter_set__SWIG_3(ampl::Parameter *self,ampl::Tuple index,ampl::Variant value){
      self->set(ampl::TupleRef(index), ampl::VariantRef(value));
    }
SWIGINTERN void ampl_Parameter_set(ampl::Parameter *self,ampl::Tuple index,double value){
        self->set(ampl::TupleRef(index), ampl::VariantRef(value));
      }
SWIGINTERN void ampl_Parameter_set(ampl::Parameter *self,ampl::Tuple index,char const *value){
      self->set(ampl::TupleRef(index), ampl::VariantRef(value));
    }
SWIGINTERN void ampl_Parameter_setValues(ampl::Parameter *self,ampl::Tuple const *indices,double const *values,std::size_t nvalues){
        self->setValues(indices, ampl::internal::Args(values), nvalues);
      }
SWIGINTERN void ampl_Parameter_setValues(ampl::Parameter *self,TupleArray &indices,double *values,std::size_t nvalues){
        self->setValues(TupleArray_cast(&indices), ampl::internal::Args(values), nvalues);
      }
SWIGINTERN void ampl_Parameter_setValues(ampl::Parameter *self,ampl::Tuple const *indices,char const *args[],std::size_t nvalues){
        self->setValues(indices, ampl::internal::Args(args), nvalues);
      }
SWIGINTERN void ampl_Parameter_setValues(ampl::Parameter *self,TupleArray &indices,char const *args[],std::size_t nvalues){
        self->setValues(TupleArray_cast(&indices), ampl::internal::Args(args), nvalues);
      }
SWIGINTERN void ampl_Parameter_setValues(ampl::Parameter *self,double *values,std::size_t n){
        self->setValues(ampl::internal::Args(values), n);
      }
SWIGINTERN void ampl_Parameter_setValues(ampl::Parameter *self,char const *args[],std::size_t n){
        self->setValues(ampl::internal::Args(args), n);
      }
SWIGINTERN void ampl_Parameter_setValues__SWIG_0(ampl::Parameter *self,std::size_t num_rows,char const *row_indices[],std::size_t num_cols,char const *col_indices[],double const *values,bool transpose){
        self->setValues(num_rows, ampl::internal::Args(row_indices),
          num_cols,ampl::internal::Args(col_indices), values, transpose);
      }
SWIGINTERN void ampl_Parameter_setValues__SWIG_1(ampl::Parameter *self,std::size_t num_rows,double *row_indices,std::size_t num_cols,double *col_indices,double const *values,bool transpose){
        self->setValues(num_rows, ampl::internal::Args(row_indices),
          num_cols,ampl::internal::Args(col_indices), values, transpose);
      }
SWIGINTERN void ampl_Parameter_setValuesPyDict(ampl::Parameter *self,PyObject *dict){
        if (!PyDict_Check(dict)) {
            throw std::logic_error("Expected a dictionary");
        }
        PyObject *d_keys = PyDict_Keys(dict);
        PyObject *d_values = PyDict_Values(dict);
        std::size_t size = Py_SIZE(dict);
        bool has_numbers = false, has_strings = false;
        for (std::size_t i = 0; i < size; i++) {
            PyObject *item = PyList_GetItem(d_values, i);
            if (item == NULL) {
                throw std::logic_error("Failed to access value");
            }
            if (PyUnicode_Check(item) || PyString_Check(item)) {
                has_strings = true;
            } else {
                has_numbers = true;
            }
            if (has_numbers && has_strings) {
                throw std::logic_error("All values must be either numbers or strings");
            }
        }
        if (has_strings && !has_numbers) {
            std::vector<ampl::Tuple> keys(size);
            std::vector<const char *> values(size);
            for (std::size_t i = 0; i < size; i++) {
                PyObject *item = PyList_GetItem(d_values, i);
                values[i] = _PyString_AsString(item);
                SetTupleFromPyObject(PyList_GetItem(d_keys, i), &keys[i]);
            }
            self->setValues(keys.data(), values.data(), size);
        } else if (has_numbers && !has_strings) {
            std::vector<ampl::Tuple> keys(size);
            std::vector<double> values(size);
            for (std::size_t i = 0; i < size; i++) {
                PyObject *item = PyList_GetItem(d_values, i);
                if (PyInt_Check(item)) {
                    values[i] = PyInt_AsLong(item);
                } else if (PyLong_Check(item)) {
                    values[i] = PyLong_AsLong(item);
                } else {
                    values[i] = PyFloat_AsDouble(item);
                }
                SetTupleFromPyObject(PyList_GetItem(d_keys, i), &keys[i]);
            }
            self->setValues(keys.data(), values.data(), size);
        }
    }
SWIGINTERN ampl::internal::EntityWrapper< ampl::VariableInstance >::KeyType ampl_internal_CountedIterator_Sl_ampl_internal_EntityWrapper_Sl_ampl_VariableInstance_Sg__Sg__first(ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > *self){
        return self->operator*().first;
        }
SWIGINTERN ampl::internal::EntityWrapper< ampl::VariableInstance >::InstanceType ampl_internal_CountedIterator_Sl_ampl_internal_EntityWrapper_Sl_ampl_VariableInstance_Sg__Sg__second(ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > *self){
        return self->operator*().second;
      }
SWIGINTERN ampl::internal::EntityWrapper< ampl::ConstraintInstance >::KeyType ampl_internal_CountedIterator_Sl_ampl_internal_EntityWrapper_Sl_ampl_ConstraintInstance_Sg__Sg__first(ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > *self){
        return self->operator*().first;
        }
SWIGINTERN ampl::internal::EntityWrapper< ampl::ConstraintInstance >::InstanceType ampl_internal_CountedIterator_Sl_ampl_internal_EntityWrapper_Sl_ampl_ConstraintInstance_Sg__Sg__second(ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > *self){
        return self->operator*().second;
      }
SWIGINTERN ampl::internal::EntityWrapper< ampl::ObjectiveInstance >::KeyType ampl_internal_CountedIterator_Sl_ampl_internal_EntityWrapper_Sl_ampl_ObjectiveInstance_Sg__Sg__first(ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > *self){
        return self->operator*().first;
        }
SWIGINTERN ampl::internal::EntityWrapper< ampl::ObjectiveInstance >::InstanceType ampl_internal_CountedIterator_Sl_ampl_internal_EntityWrapper_Sl_ampl_ObjectiveInstance_Sg__Sg__second(ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > *self){
        return self->operator*().second;
      }
SWIGINTERN ampl::internal::EntityWrapper< ampl::SetInstance >::KeyType ampl_internal_CountedIterator_Sl_ampl_internal_EntityWrapper_Sl_ampl_SetInstance_Sg__Sg__first(ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > *self){
        return self->operator*().first;
        }
SWIGINTERN ampl::internal::EntityWrapper< ampl::SetInstance >::InstanceType ampl_internal_CountedIterator_Sl_ampl_internal_EntityWrapper_Sl_ampl_SetInstance_Sg__Sg__second(ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > *self){
        return self->operator*().second;
      }
SWIGINTERN ampl::internal::EntityWrapper< ampl::TableInstance >::KeyType ampl_internal_CountedIterator_Sl_ampl_internal_EntityWrapper_Sl_ampl_TableInstance_Sg__Sg__first(ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::TableInstance > > *self){
        return self->operator*().first;
        }
SWIGINTERN ampl::internal::EntityWrapper< ampl::TableInstance >::InstanceType ampl_internal_CountedIterator_Sl_ampl_internal_EntityWrapper_Sl_ampl_TableInstance_Sg__Sg__second(ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::TableInstance > > *self){
        return self->operator*().second;
      }
SWIGINTERN ampl::internal::EntityWrapper< ampl::VariantRef >::KeyType ampl_internal_CountedIterator_Sl_ampl_internal_EntityWrapper_Sl_ampl_VariantRef_Sg__Sg__first(ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > *self){
        return self->operator*().first;
        }
SWIGINTERN ampl::internal::EntityWrapper< ampl::VariantRef >::InstanceType ampl_internal_CountedIterator_Sl_ampl_internal_EntityWrapper_Sl_ampl_VariantRef_Sg__Sg__second(ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > *self){
        return self->operator*().second;
      }

#if defined(__GNUC__)
#  if __GNUC__ == 2 && __GNUC_MINOR <= 96
#     define SWIG_STD_NOMODERN_STL
#  endif
#endif


#include <utility>


	#include "ampl/environment.h"

SWIGINTERN ampl::internal::EnvironmentIterator::KeyType ampl_internal_CountedIterator_Sl_ampl_internal_EnvironmentIterator_Sg__first(ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > *self){
        return self->operator*().first;
        }
SWIGINTERN ampl::internal::EnvironmentIterator::InstanceType ampl_internal_CountedIterator_Sl_ampl_internal_EnvironmentIterator_Sg__second(ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > *self){
        return self->operator*().second;
      }
SWIGINTERN void ampl_AMPL_display(ampl::AMPL *self,char const *args[],int count){
  ampl::StringArgs s(args, count);
  self->display(s);
}
SWIGINTERN ampl::DataFrame ampl_AMPL_getData(ampl::AMPL *self,char const *args[],int count){
  ampl::StringArgs s(args, count);
  return self->getData(s);
}


/* ---------------------------------------------------
 * C++ director class methods
 * --------------------------------------------------- */

#include "amplpythonPYTHON_wrap.h"

SwigDirector_ErrorHandler::SwigDirector_ErrorHandler(PyObject *self): ampl::ErrorHandler(), Swig::Director(self) {
  SWIG_DIRECTOR_RGTR((ampl::ErrorHandler *)this, this); 
}




SwigDirector_ErrorHandler::~SwigDirector_ErrorHandler() {
}

void SwigDirector_ErrorHandler::error(ampl::AMPLException const &arg0) {
  PyObject *self = NULL;
  (void)self;
  swig::SwigVar_PyObject obj0;
  obj0 = SWIG_NewPointerObj(SWIG_as_voidptr(&arg0), SWIGTYPE_p_ampl__AMPLException,  0 );
  if (!swig_get_self()) {
    Swig::DirectorException::raise("'self' uninitialized, maybe you forgot to call ErrorHandler.__init__.");
  }
#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
  const size_t swig_method_index = 0;
  const char *const swig_method_name = "error";
  PyObject *method = swig_get_method(swig_method_index, swig_method_name);
  swig::SwigVar_PyObject result = PyObject_CallFunctionObjArgs(method ,(PyObject *)obj0, NULL);
#else
  swig::SwigVar_PyObject swig_method_name = SWIG_Python_str_FromChar("error");
  swig::SwigVar_PyObject result = PyObject_CallMethodObjArgs(swig_get_self(), (PyObject *) swig_method_name ,(PyObject *)obj0, NULL);
#endif
  if (!result) {
    PyObject *error = PyErr_Occurred();
    if (error) {
      Swig::DirectorMethodException::raise("Error detected when calling 'ErrorHandler.error'");
    }
  }
}


void SwigDirector_ErrorHandler::warning(ampl::AMPLException const &arg0) {
  PyObject *self = NULL;
  (void)self;
  swig::SwigVar_PyObject obj0;
  obj0 = SWIG_NewPointerObj(SWIG_as_voidptr(&arg0), SWIGTYPE_p_ampl__AMPLException,  0 );
  if (!swig_get_self()) {
    Swig::DirectorException::raise("'self' uninitialized, maybe you forgot to call ErrorHandler.__init__.");
  }
#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
  const size_t swig_method_index = 1;
  const char *const swig_method_name = "warning";
  PyObject *method = swig_get_method(swig_method_index, swig_method_name);
  swig::SwigVar_PyObject result = PyObject_CallFunctionObjArgs(method ,(PyObject *)obj0, NULL);
#else
  swig::SwigVar_PyObject swig_method_name = SWIG_Python_str_FromChar("warning");
  swig::SwigVar_PyObject result = PyObject_CallMethodObjArgs(swig_get_self(), (PyObject *) swig_method_name ,(PyObject *)obj0, NULL);
#endif
  if (!result) {
    PyObject *error = PyErr_Occurred();
    if (error) {
      Swig::DirectorMethodException::raise("Error detected when calling 'ErrorHandler.warning'");
    }
  }
}


SwigDirector_Runnable::SwigDirector_Runnable(PyObject *self): ampl::Runnable(), Swig::Director(self) {
  SWIG_DIRECTOR_RGTR((ampl::Runnable *)this, this); 
}




SwigDirector_Runnable::~SwigDirector_Runnable() {
}

void SwigDirector_Runnable::run() {
  PyObject *self = NULL;
  (void)self;
  if (!swig_get_self()) {
    Swig::DirectorException::raise("'self' uninitialized, maybe you forgot to call Runnable.__init__.");
  }
#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
  const size_t swig_method_index = 0;
  const char *const swig_method_name = "run";
  PyObject *method = swig_get_method(swig_method_index, swig_method_name);
  swig::SwigVar_PyObject args = PyTuple_New(0);
  swig::SwigVar_PyObject result = PyObject_Call(method, (PyObject *) args, NULL);
#else
  swig::SwigVar_PyObject swig_method_name = SWIG_Python_str_FromChar("run");
  swig::SwigVar_PyObject result = PyObject_CallMethodObjArgs(swig_get_self(), (PyObject *) swig_method_name, NULL);
#endif
  if (!result) {
    PyObject *error = PyErr_Occurred();
    if (error) {
      Swig::DirectorMethodException::raise("Error detected when calling 'Runnable.run'");
    }
  }
}


SwigDirector_OutputHandler::SwigDirector_OutputHandler(PyObject *self): ampl::OutputHandler(), Swig::Director(self) {
  SWIG_DIRECTOR_RGTR((ampl::OutputHandler *)this, this); 
}




SwigDirector_OutputHandler::~SwigDirector_OutputHandler() {
}

void SwigDirector_OutputHandler::output(ampl::output::Kind kind, char const *msg) {
  PyObject *self = NULL;
  (void)self;
  swig::SwigVar_PyObject obj0;
  obj0 = SWIG_From_int(static_cast< int >(kind));
  swig::SwigVar_PyObject obj1;
  obj1 = SWIG_FromCharPtr((const char *)msg);
  if (!swig_get_self()) {
    Swig::DirectorException::raise("'self' uninitialized, maybe you forgot to call OutputHandler.__init__.");
  }
#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
  const size_t swig_method_index = 0;
  const char *const swig_method_name = "output";
  PyObject *method = swig_get_method(swig_method_index, swig_method_name);
  swig::SwigVar_PyObject result = PyObject_CallFunctionObjArgs(method ,(PyObject *)obj0,(PyObject *)obj1, NULL);
#else
  swig::SwigVar_PyObject swig_method_name = SWIG_Python_str_FromChar("output");
  swig::SwigVar_PyObject result = PyObject_CallMethodObjArgs(swig_get_self(), (PyObject *) swig_method_name ,(PyObject *)obj0,(PyObject *)obj1, NULL);
#endif
  if (!result) {
    PyObject *error = PyErr_Occurred();
    if (error) {
      Swig::DirectorMethodException::raise("Error detected when calling 'OutputHandler.output'");
    }
  }
}


#ifdef __cplusplus
extern "C" {
#endif
SWIGINTERN PyObject *_wrap_StringArray_size(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::StringArray *arg1 = (ampl::StringArray *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::size_t result;
  
  if (!SWIG_Python_UnpackTuple(args, "StringArray_size", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__StringArray, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StringArray_size" "', argument " "1"" of type '" "ampl::StringArray const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::StringArray * >(argp1);
  result = ((ampl::StringArray const *)arg1)->size();
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_StringArray_getIndex(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::StringArray *arg1 = (ampl::StringArray *) 0 ;
  std::size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  char *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__StringArray, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StringArray_getIndex" "', argument " "1"" of type '" "ampl::StringArray const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::StringArray * >(argp1);
  ecode2 = SWIG_AsVal_size_t(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "StringArray_getIndex" "', argument " "2"" of type '" "std::size_t""'");
  } 
  arg2 = static_cast< std::size_t >(val2);
  result = (char *)((ampl::StringArray const *)arg1)->operator [](arg2);
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_StringArray(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::StringArray *arg1 = (ampl::StringArray *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_StringArray", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__StringArray, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_StringArray" "', argument " "1"" of type '" "ampl::StringArray *""'"); 
  }
  arg1 = reinterpret_cast< ampl::StringArray * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_StringArray) /* defines _wrap_delete_StringArray_destructor_closure */

SWIGINTERN PyObject *_wrap_StringRefArray_size(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::StringRefArray *arg1 = (ampl::StringRefArray *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::size_t result;
  
  if (!SWIG_Python_UnpackTuple(args, "StringRefArray_size", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__StringRefArray, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StringRefArray_size" "', argument " "1"" of type '" "ampl::StringRefArray const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::StringRefArray * >(argp1);
  result = ((ampl::StringRefArray const *)arg1)->size();
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_StringRefArray_getIndex(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::StringRefArray *arg1 = (ampl::StringRefArray *) 0 ;
  std::size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  char *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__StringRefArray, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StringRefArray_getIndex" "', argument " "1"" of type '" "ampl::StringRefArray const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::StringRefArray * >(argp1);
  ecode2 = SWIG_AsVal_size_t(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "StringRefArray_getIndex" "', argument " "2"" of type '" "std::size_t""'");
  } 
  arg2 = static_cast< std::size_t >(val2);
  result = (char *)((ampl::StringRefArray const *)arg1)->operator [](arg2);
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_StringRefArray(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::StringRefArray *arg1 = (ampl::StringRefArray *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_StringRefArray", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__StringRefArray, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_StringRefArray" "', argument " "1"" of type '" "ampl::StringRefArray *""'"); 
  }
  arg1 = reinterpret_cast< ampl::StringRefArray * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_StringRefArray) /* defines _wrap_delete_StringRefArray_destructor_closure */

SWIGINTERN PyObject *_wrap_runtime_error_what(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  std::runtime_error *arg1 = (std::runtime_error *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  char *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "runtime_error_what", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__runtime_error, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "runtime_error_what" "', argument " "1"" of type '" "std::runtime_error const *""'"); 
  }
  arg1 = reinterpret_cast< std::runtime_error * >(argp1);
  result = (char *)((std::runtime_error const *)arg1)->what();
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_runtime_error(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  std::runtime_error *arg1 = (std::runtime_error *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_runtime_error", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__runtime_error, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_runtime_error" "', argument " "1"" of type '" "std::runtime_error *""'"); 
  }
  arg1 = reinterpret_cast< std::runtime_error * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_runtime_error) /* defines _wrap_delete_runtime_error_destructor_closure */

SWIGINTERN PyObject *_wrap_VariantFromPyObject(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) 0 ;
  PyObject *swig_obj[1] ;
  SwigValueWrapper< ampl::Variant > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  arg1 = swig_obj[0];
  result = VariantFromPyObject(arg1);
  resultobj = SWIG_NewPointerObj((new ampl::Variant(static_cast< const ampl::Variant& >(result))), SWIGTYPE_p_ampl__Variant, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SetTupleFromPyObject(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) 0 ;
  ampl::Tuple *arg2 = (ampl::Tuple *) 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "SetTupleFromPyObject", 2, 2, swig_obj)) SWIG_fail;
  arg1 = swig_obj[0];
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2,SWIGTYPE_p_ampl__Tuple, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetTupleFromPyObject" "', argument " "2"" of type '" "ampl::Tuple *""'"); 
  }
  arg2 = reinterpret_cast< ampl::Tuple * >(argp2);
  SetTupleFromPyObject(arg1,arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN int _wrap_new_VariantArray(PyObject *self, PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  size_t arg1 ;
  size_t val1 ;
  int ecode1 = 0 ;
  PyObject *swig_obj[1] ;
  VariantArray *result = 0 ;
  
  if (!SWIG_Python_CheckNoKeywords(kwargs, "new_VariantArray")) SWIG_fail;
  if (!SWIG_Python_UnpackTuple(args, "new_VariantArray", 1, 1, swig_obj)) SWIG_fail;
  ecode1 = SWIG_AsVal_size_t(swig_obj[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_VariantArray" "', argument " "1"" of type '" "size_t""'");
  } 
  arg1 = static_cast< size_t >(val1);
  {
    try {
      result = (VariantArray *)new_VariantArray(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_VariantArray, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN PyObject *_wrap_delete_VariantArray(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  VariantArray *arg1 = (VariantArray *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_VariantArray", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_VariantArray, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_VariantArray" "', argument " "1"" of type '" "VariantArray *""'"); 
  }
  arg1 = reinterpret_cast< VariantArray * >(argp1);
  {
    try {
      delete_VariantArray(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariantArray___getitem__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  VariantArray *arg1 = (VariantArray *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  SwigValueWrapper< ampl::Variant > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_VariantArray, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariantArray___getitem__" "', argument " "1"" of type '" "VariantArray *""'"); 
  }
  arg1 = reinterpret_cast< VariantArray * >(argp1);
  ecode2 = SWIG_AsVal_size_t(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VariantArray___getitem__" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    try {
      result = VariantArray___getitem__(arg1,arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::Variant(static_cast< const ampl::Variant& >(result))), SWIGTYPE_p_ampl__Variant, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariantArray___setitem__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  VariantArray *arg1 = (VariantArray *) 0 ;
  size_t arg2 ;
  SwigValueWrapper< ampl::Variant > arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args, "VariantArray___setitem__", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_VariantArray, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariantArray___setitem__" "', argument " "1"" of type '" "VariantArray *""'"); 
  }
  arg1 = reinterpret_cast< VariantArray * >(argp1);
  ecode2 = SWIG_AsVal_size_t(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VariantArray___setitem__" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    res3 = SWIG_ConvertPtr(swig_obj[1], &argp3, SWIGTYPE_p_ampl__Variant,  0  | 0);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "VariantArray___setitem__" "', argument " "3"" of type '" "ampl::Variant""'"); 
    }  
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VariantArray___setitem__" "', argument " "3"" of type '" "ampl::Variant""'");
    } else {
      ampl::Variant * temp = reinterpret_cast< ampl::Variant * >(argp3);
      arg3 = *temp;
      if (SWIG_IsNewObj(res3)) delete temp;
    }
  }
  {
    try {
      VariantArray___setitem__(arg1,arg2,arg3);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariantArray_cast(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  VariantArray *arg1 = (VariantArray *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ampl::Variant *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "VariantArray_cast", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_VariantArray, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariantArray_cast" "', argument " "1"" of type '" "VariantArray *""'"); 
  }
  arg1 = reinterpret_cast< VariantArray * >(argp1);
  {
    try {
      result = (ampl::Variant *)VariantArray_cast(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__Variant, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariantArray_frompointer(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Variant *arg1 = (ampl::Variant *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  VariantArray *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_ampl__Variant, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariantArray_frompointer" "', argument " "1"" of type '" "ampl::Variant *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Variant * >(argp1);
  {
    try {
      result = (VariantArray *)VariantArray_frompointer(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_VariantArray, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_VariantArray) /* defines _wrap_delete_VariantArray_destructor_closure */

SWIGPY_FUNPACK_SSIZEARGFUNC_CLOSURE(_wrap_VariantArray___getitem__) /* defines _wrap_VariantArray___getitem___ssizeargfunc_closure */

SWIGPY_SSIZEOBJARGPROC_CLOSURE(_wrap_VariantArray___setitem__) /* defines _wrap_VariantArray___setitem___ssizeobjargproc_closure */

SWIGINTERN int _wrap_new_TupleArray(PyObject *self, PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  size_t arg1 ;
  size_t val1 ;
  int ecode1 = 0 ;
  PyObject *swig_obj[1] ;
  TupleArray *result = 0 ;
  
  if (!SWIG_Python_CheckNoKeywords(kwargs, "new_TupleArray")) SWIG_fail;
  if (!SWIG_Python_UnpackTuple(args, "new_TupleArray", 1, 1, swig_obj)) SWIG_fail;
  ecode1 = SWIG_AsVal_size_t(swig_obj[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_TupleArray" "', argument " "1"" of type '" "size_t""'");
  } 
  arg1 = static_cast< size_t >(val1);
  {
    try {
      result = (TupleArray *)new_TupleArray(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_TupleArray, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN PyObject *_wrap_delete_TupleArray(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  TupleArray *arg1 = (TupleArray *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_TupleArray", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_TupleArray, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_TupleArray" "', argument " "1"" of type '" "TupleArray *""'"); 
  }
  arg1 = reinterpret_cast< TupleArray * >(argp1);
  {
    try {
      delete_TupleArray(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_TupleArray___getitem__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  TupleArray *arg1 = (TupleArray *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  ampl::Tuple result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_TupleArray, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TupleArray___getitem__" "', argument " "1"" of type '" "TupleArray *""'"); 
  }
  arg1 = reinterpret_cast< TupleArray * >(argp1);
  ecode2 = SWIG_AsVal_size_t(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "TupleArray___getitem__" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    try {
      result = TupleArray___getitem__(arg1,arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::Tuple(static_cast< const ampl::Tuple& >(result))), SWIGTYPE_p_ampl__Tuple, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_TupleArray___setitem__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  TupleArray *arg1 = (TupleArray *) 0 ;
  size_t arg2 ;
  ampl::Tuple arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args, "TupleArray___setitem__", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_TupleArray, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TupleArray___setitem__" "', argument " "1"" of type '" "TupleArray *""'"); 
  }
  arg1 = reinterpret_cast< TupleArray * >(argp1);
  ecode2 = SWIG_AsVal_size_t(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "TupleArray___setitem__" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    res3 = SWIG_ConvertPtr(swig_obj[1], &argp3, SWIGTYPE_p_ampl__Tuple,  0  | 0);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "TupleArray___setitem__" "', argument " "3"" of type '" "ampl::Tuple""'"); 
    }  
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "TupleArray___setitem__" "', argument " "3"" of type '" "ampl::Tuple""'");
    } else {
      ampl::Tuple * temp = reinterpret_cast< ampl::Tuple * >(argp3);
      arg3 = *temp;
      if (SWIG_IsNewObj(res3)) delete temp;
    }
  }
  {
    try {
      TupleArray___setitem__(arg1,arg2,arg3);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_TupleArray_cast(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  TupleArray *arg1 = (TupleArray *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ampl::Tuple *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "TupleArray_cast", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_TupleArray, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TupleArray_cast" "', argument " "1"" of type '" "TupleArray *""'"); 
  }
  arg1 = reinterpret_cast< TupleArray * >(argp1);
  {
    try {
      result = (ampl::Tuple *)TupleArray_cast(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__Tuple, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_TupleArray_frompointer(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Tuple *arg1 = (ampl::Tuple *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  TupleArray *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_ampl__Tuple, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TupleArray_frompointer" "', argument " "1"" of type '" "ampl::Tuple *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Tuple * >(argp1);
  {
    try {
      result = (TupleArray *)TupleArray_frompointer(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_TupleArray, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_TupleArray) /* defines _wrap_delete_TupleArray_destructor_closure */

SWIGPY_FUNPACK_SSIZEARGFUNC_CLOSURE(_wrap_TupleArray___getitem__) /* defines _wrap_TupleArray___getitem___ssizeargfunc_closure */

SWIGPY_SSIZEOBJARGPROC_CLOSURE(_wrap_TupleArray___setitem__) /* defines _wrap_TupleArray___setitem___ssizeobjargproc_closure */

SWIGINTERN int _wrap_new_OptionalInt__SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **SWIGUNUSEDPARM(swig_obj)) {
  PyObject *resultobj = 0;
  ampl::Optional< int > *result = 0 ;
  
  if ((nobjs < 0) || (nobjs > 0)) SWIG_fail;
  {
    try {
      result = (ampl::Optional< int > *)new ampl::Optional< int >();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__OptionalT_int_t, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN int _wrap_new_OptionalInt__SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  int *arg1 = 0 ;
  int temp1 ;
  int val1 ;
  int ecode1 = 0 ;
  ampl::Optional< int > *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  ecode1 = SWIG_AsVal_int(swig_obj[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_OptionalInt" "', argument " "1"" of type '" "int""'");
  } 
  temp1 = static_cast< int >(val1);
  arg1 = &temp1;
  {
    try {
      result = (ampl::Optional< int > *)new ampl::Optional< int >((int const &)*arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__OptionalT_int_t, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN int _wrap_new_OptionalInt(PyObject *self, PyObject *args, PyObject *kwargs) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!SWIG_Python_CheckNoKeywords(kwargs, "new_OptionalInt")) SWIG_fail;
  if (!(argc = SWIG_Python_UnpackTuple(args, "new_OptionalInt", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 0) {
    return _wrap_new_OptionalInt__SWIG_0(self, argc, argv);
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_OptionalInt__SWIG_1(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'new_OptionalInt'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    ampl::Optional< int >::Optional()\n"
    "    ampl::Optional< int >::Optional(int const &)\n");
  return -1;
}


SWIGINTERN PyObject *_wrap_OptionalInt_hasValue(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Optional< int > *arg1 = (ampl::Optional< int > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args, "OptionalInt_hasValue", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__OptionalT_int_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OptionalInt_hasValue" "', argument " "1"" of type '" "ampl::Optional< int > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Optional< int > * >(argp1);
  {
    try {
      result = (bool)((ampl::Optional< int > const *)arg1)->operator bool();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_OptionalInt_value(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Optional< int > *arg1 = (ampl::Optional< int > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  int *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "OptionalInt_value", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__OptionalT_int_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OptionalInt_value" "', argument " "1"" of type '" "ampl::Optional< int > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Optional< int > * >(argp1);
  {
    try {
      result = (int *) &((ampl::Optional< int > const *)arg1)->value();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_int(static_cast< int >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_OptionalInt(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Optional< int > *arg1 = (ampl::Optional< int > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_OptionalInt", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__OptionalT_int_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_OptionalInt" "', argument " "1"" of type '" "ampl::Optional< int > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Optional< int > * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_INQUIRY_CLOSURE(_wrap_OptionalInt_hasValue) /* defines _wrap_OptionalInt_hasValue_inquiry_closure */

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_OptionalInt) /* defines _wrap_delete_OptionalInt_destructor_closure */

SWIGINTERN int _wrap_new_OptionalString__SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **SWIGUNUSEDPARM(swig_obj)) {
  PyObject *resultobj = 0;
  ampl::Optional< std::string > *result = 0 ;
  
  if ((nobjs < 0) || (nobjs > 0)) SWIG_fail;
  {
    try {
      result = (ampl::Optional< std::string > *)new ampl::Optional< std::string >();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__OptionalT_std__string_t, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN int _wrap_new_OptionalString__SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  ampl::Optional< std::string > *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(swig_obj[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_OptionalString" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_OptionalString" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (ampl::Optional< std::string > *)new ampl::Optional< std::string >((std::string const &)*arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__OptionalT_std__string_t, SWIG_BUILTIN_INIT |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  return resultobj == Py_None ? -1 : 0;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return -1;
}


SWIGINTERN int _wrap_new_OptionalString(PyObject *self, PyObject *args, PyObject *kwargs) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!SWIG_Python_CheckNoKeywords(kwargs, "new_OptionalString")) SWIG_fail;
  if (!(argc = SWIG_Python_UnpackTuple(args, "new_OptionalString", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 0) {
    return _wrap_new_OptionalString__SWIG_0(self, argc, argv);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OptionalString__SWIG_1(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'new_OptionalString'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    ampl::Optional< std::string >::Optional()\n"
    "    ampl::Optional< std::string >::Optional(std::string const &)\n");
  return -1;
}


SWIGINTERN PyObject *_wrap_OptionalString_hasValue(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Optional< std::string > *arg1 = (ampl::Optional< std::string > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args, "OptionalString_hasValue", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__OptionalT_std__string_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OptionalString_hasValue" "', argument " "1"" of type '" "ampl::Optional< std::string > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Optional< std::string > * >(argp1);
  {
    try {
      result = (bool)((ampl::Optional< std::string > const *)arg1)->operator bool();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_OptionalString_value(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Optional< std::string > *arg1 = (ampl::Optional< std::string > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "OptionalString_value", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__OptionalT_std__string_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OptionalString_value" "', argument " "1"" of type '" "ampl::Optional< std::string > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Optional< std::string > * >(argp1);
  {
    try {
      result = (std::string *) &((ampl::Optional< std::string > const *)arg1)->value();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_OptionalString(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Optional< std::string > *arg1 = (ampl::Optional< std::string > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_OptionalString", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__OptionalT_std__string_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_OptionalString" "', argument " "1"" of type '" "ampl::Optional< std::string > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Optional< std::string > * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_INQUIRY_CLOSURE(_wrap_OptionalString_hasValue) /* defines _wrap_OptionalString_hasValue_inquiry_closure */

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_OptionalString) /* defines _wrap_delete_OptionalString_destructor_closure */

SWIGINTERN int _wrap_new_OptionalBool__SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **SWIGUNUSEDPARM(swig_obj)) {
  PyObject *resultobj = 0;
  ampl::Optional< bool > *result = 0 ;
  
  if ((nobjs < 0) || (nobjs > 0)) SWIG_fail;
  {
    try {
      result = (ampl::Optional< bool > *)new ampl::Optional< bool >();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__OptionalT_bool_t, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN int _wrap_new_OptionalBool__SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  bool *arg1 = 0 ;
  bool temp1 ;
  bool val1 ;
  int ecode1 = 0 ;
  ampl::Optional< bool > *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  ecode1 = SWIG_AsVal_bool(swig_obj[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_OptionalBool" "', argument " "1"" of type '" "bool""'");
  } 
  temp1 = static_cast< bool >(val1);
  arg1 = &temp1;
  {
    try {
      result = (ampl::Optional< bool > *)new ampl::Optional< bool >((bool const &)*arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__OptionalT_bool_t, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN int _wrap_new_OptionalBool(PyObject *self, PyObject *args, PyObject *kwargs) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!SWIG_Python_CheckNoKeywords(kwargs, "new_OptionalBool")) SWIG_fail;
  if (!(argc = SWIG_Python_UnpackTuple(args, "new_OptionalBool", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 0) {
    return _wrap_new_OptionalBool__SWIG_0(self, argc, argv);
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_bool(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_OptionalBool__SWIG_1(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'new_OptionalBool'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    ampl::Optional< bool >::Optional()\n"
    "    ampl::Optional< bool >::Optional(bool const &)\n");
  return -1;
}


SWIGINTERN PyObject *_wrap_OptionalBool_hasValue(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Optional< bool > *arg1 = (ampl::Optional< bool > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args, "OptionalBool_hasValue", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__OptionalT_bool_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OptionalBool_hasValue" "', argument " "1"" of type '" "ampl::Optional< bool > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Optional< bool > * >(argp1);
  {
    try {
      result = (bool)((ampl::Optional< bool > const *)arg1)->operator bool();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_OptionalBool_value(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Optional< bool > *arg1 = (ampl::Optional< bool > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "OptionalBool_value", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__OptionalT_bool_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OptionalBool_value" "', argument " "1"" of type '" "ampl::Optional< bool > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Optional< bool > * >(argp1);
  {
    try {
      result = (bool *) &((ampl::Optional< bool > const *)arg1)->value();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_OptionalBool(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Optional< bool > *arg1 = (ampl::Optional< bool > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_OptionalBool", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__OptionalT_bool_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_OptionalBool" "', argument " "1"" of type '" "ampl::Optional< bool > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Optional< bool > * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_INQUIRY_CLOSURE(_wrap_OptionalBool_hasValue) /* defines _wrap_OptionalBool_hasValue_inquiry_closure */

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_OptionalBool) /* defines _wrap_delete_OptionalBool_destructor_closure */

SWIGINTERN int _wrap_new_OptionalDouble__SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **SWIGUNUSEDPARM(swig_obj)) {
  PyObject *resultobj = 0;
  ampl::Optional< double > *result = 0 ;
  
  if ((nobjs < 0) || (nobjs > 0)) SWIG_fail;
  {
    try {
      result = (ampl::Optional< double > *)new ampl::Optional< double >();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__OptionalT_double_t, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN int _wrap_new_OptionalDouble__SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  double *arg1 = 0 ;
  double temp1 ;
  double val1 ;
  int ecode1 = 0 ;
  ampl::Optional< double > *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  ecode1 = SWIG_AsVal_double(swig_obj[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_OptionalDouble" "', argument " "1"" of type '" "double""'");
  } 
  temp1 = static_cast< double >(val1);
  arg1 = &temp1;
  {
    try {
      result = (ampl::Optional< double > *)new ampl::Optional< double >((double const &)*arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__OptionalT_double_t, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN int _wrap_new_OptionalDouble(PyObject *self, PyObject *args, PyObject *kwargs) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!SWIG_Python_CheckNoKeywords(kwargs, "new_OptionalDouble")) SWIG_fail;
  if (!(argc = SWIG_Python_UnpackTuple(args, "new_OptionalDouble", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 0) {
    return _wrap_new_OptionalDouble__SWIG_0(self, argc, argv);
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_double(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_OptionalDouble__SWIG_1(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'new_OptionalDouble'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    ampl::Optional< double >::Optional()\n"
    "    ampl::Optional< double >::Optional(double const &)\n");
  return -1;
}


SWIGINTERN PyObject *_wrap_OptionalDouble_hasValue(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Optional< double > *arg1 = (ampl::Optional< double > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args, "OptionalDouble_hasValue", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__OptionalT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OptionalDouble_hasValue" "', argument " "1"" of type '" "ampl::Optional< double > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Optional< double > * >(argp1);
  {
    try {
      result = (bool)((ampl::Optional< double > const *)arg1)->operator bool();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_OptionalDouble_value(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Optional< double > *arg1 = (ampl::Optional< double > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "OptionalDouble_value", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__OptionalT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OptionalDouble_value" "', argument " "1"" of type '" "ampl::Optional< double > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Optional< double > * >(argp1);
  {
    try {
      result = (double *) &((ampl::Optional< double > const *)arg1)->value();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_OptionalDouble(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Optional< double > *arg1 = (ampl::Optional< double > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_OptionalDouble", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__OptionalT_double_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_OptionalDouble" "', argument " "1"" of type '" "ampl::Optional< double > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Optional< double > * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_INQUIRY_CLOSURE(_wrap_OptionalDouble_hasValue) /* defines _wrap_OptionalDouble_hasValue_inquiry_closure */

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_OptionalDouble) /* defines _wrap_delete_OptionalDouble_destructor_closure */

SWIGINTERN int _wrap_new_Variant__SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::string arg1 ;
  ampl::Variant *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(swig_obj[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "new_Variant" "', argument " "1"" of type '" "std::string""'"); 
    }
    arg1 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    try {
      result = (ampl::Variant *)new ampl::Variant(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__Variant, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN int _wrap_new_Variant__SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  ampl::Variant *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  ecode1 = SWIG_AsVal_double(swig_obj[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_Variant" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  {
    try {
      result = (ampl::Variant *)new ampl::Variant(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__Variant, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN int _wrap_new_Variant__SWIG_2(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  ampl::VariantRef *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ampl::Variant *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_ampl__VariantRef,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Variant" "', argument " "1"" of type '" "ampl::VariantRef const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Variant" "', argument " "1"" of type '" "ampl::VariantRef const &""'"); 
  }
  arg1 = reinterpret_cast< ampl::VariantRef * >(argp1);
  {
    try {
      result = (ampl::Variant *)new ampl::Variant((ampl::VariantRef const &)*arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__Variant, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN int _wrap_new_Variant(PyObject *self, PyObject *args, PyObject *kwargs) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!SWIG_Python_CheckNoKeywords(kwargs, "new_Variant")) SWIG_fail;
  if (!(argc = SWIG_Python_UnpackTuple(args, "new_Variant", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_ampl__VariantRef, SWIG_POINTER_NO_NULL | 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Variant__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_double(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_Variant__SWIG_1(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Variant__SWIG_0(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'new_Variant'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    ampl::Variant::Variant(std::string)\n"
    "    ampl::Variant::Variant(double)\n"
    "    ampl::Variant::Variant(ampl::VariantRef const &)\n");
  return -1;
}


SWIGINTERN PyObject *_wrap_Variant_str(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Variant *arg1 = (ampl::Variant *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "Variant_str", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Variant, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variant_str" "', argument " "1"" of type '" "ampl::Variant const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Variant * >(argp1);
  {
    try {
      result = ((ampl::Variant const *)arg1)->str();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variant_dbl(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Variant *arg1 = (ampl::Variant *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "Variant_dbl", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Variant, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variant_dbl" "', argument " "1"" of type '" "ampl::Variant const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Variant * >(argp1);
  {
    try {
      result = (double)((ampl::Variant const *)arg1)->dbl();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variant_type(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Variant *arg1 = (ampl::Variant *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ampl::Type result;
  
  if (!SWIG_Python_UnpackTuple(args, "Variant_type", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Variant, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variant_type" "', argument " "1"" of type '" "ampl::Variant const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Variant * >(argp1);
  {
    try {
      result = (ampl::Type)((ampl::Variant const *)arg1)->type();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variant_toString(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Variant *arg1 = (ampl::Variant *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "Variant_toString", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Variant, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variant_toString" "', argument " "1"" of type '" "ampl::Variant *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Variant * >(argp1);
  {
    try {
      result = (arg1)->toString();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variant_equals(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Variant *arg1 = (ampl::Variant *) 0 ;
  ampl::Variant *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Variant, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variant_equals" "', argument " "1"" of type '" "ampl::Variant *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Variant * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ampl__Variant,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Variant_equals" "', argument " "2"" of type '" "ampl::Variant &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Variant_equals" "', argument " "2"" of type '" "ampl::Variant &""'"); 
  }
  arg2 = reinterpret_cast< ampl::Variant * >(argp2);
  {
    try {
      result = (bool)ampl_Variant_equals(arg1,*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variant_compare(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Variant *arg1 = (ampl::Variant *) 0 ;
  ampl::Variant *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Variant, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variant_compare" "', argument " "1"" of type '" "ampl::Variant *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Variant * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ampl__Variant,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Variant_compare" "', argument " "2"" of type '" "ampl::Variant &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Variant_compare" "', argument " "2"" of type '" "ampl::Variant &""'"); 
  }
  arg2 = reinterpret_cast< ampl::Variant * >(argp2);
  {
    try {
      result = (int)ampl_Variant_compare(arg1,*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_Variant(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Variant *arg1 = (ampl::Variant *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_Variant", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Variant, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Variant" "', argument " "1"" of type '" "ampl::Variant *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Variant * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_Variant) /* defines _wrap_delete_Variant_destructor_closure */

SWIGINTERN int _wrap_new_VariantRef__SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::string arg1 ;
  ampl::VariantRef *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(swig_obj[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "new_VariantRef" "', argument " "1"" of type '" "std::string""'"); 
    }
    arg1 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    try {
      result = (ampl::VariantRef *)new ampl::VariantRef(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__VariantRef, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN int _wrap_new_VariantRef__SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  ampl::VariantRef *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  ecode1 = SWIG_AsVal_double(swig_obj[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_VariantRef" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  {
    try {
      result = (ampl::VariantRef *)new ampl::VariantRef(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__VariantRef, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN int _wrap_new_VariantRef__SWIG_2(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  ampl::Variant *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ampl::VariantRef *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_ampl__Variant,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_VariantRef" "', argument " "1"" of type '" "ampl::Variant const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_VariantRef" "', argument " "1"" of type '" "ampl::Variant const &""'"); 
  }
  arg1 = reinterpret_cast< ampl::Variant * >(argp1);
  {
    try {
      result = (ampl::VariantRef *)new ampl::VariantRef((ampl::Variant const &)*arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__VariantRef, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN int _wrap_new_VariantRef(PyObject *self, PyObject *args, PyObject *kwargs) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!SWIG_Python_CheckNoKeywords(kwargs, "new_VariantRef")) SWIG_fail;
  if (!(argc = SWIG_Python_UnpackTuple(args, "new_VariantRef", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_ampl__Variant, SWIG_POINTER_NO_NULL | 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_VariantRef__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_double(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_VariantRef__SWIG_1(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_VariantRef__SWIG_0(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'new_VariantRef'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    ampl::VariantRef::VariantRef(std::string)\n"
    "    ampl::VariantRef::VariantRef(double)\n"
    "    ampl::VariantRef::VariantRef(ampl::Variant const &)\n");
  return -1;
}


SWIGINTERN PyObject *_wrap_VariantRef_str(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::VariantRef *arg1 = (ampl::VariantRef *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "VariantRef_str", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__VariantRef, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariantRef_str" "', argument " "1"" of type '" "ampl::VariantRef const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::VariantRef * >(argp1);
  {
    try {
      result = ((ampl::VariantRef const *)arg1)->str();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariantRef_dbl(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::VariantRef *arg1 = (ampl::VariantRef *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "VariantRef_dbl", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__VariantRef, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariantRef_dbl" "', argument " "1"" of type '" "ampl::VariantRef const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::VariantRef * >(argp1);
  {
    try {
      result = (double)((ampl::VariantRef const *)arg1)->dbl();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariantRef_type(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::VariantRef *arg1 = (ampl::VariantRef *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ampl::Type result;
  
  if (!SWIG_Python_UnpackTuple(args, "VariantRef_type", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__VariantRef, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariantRef_type" "', argument " "1"" of type '" "ampl::VariantRef const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::VariantRef * >(argp1);
  {
    try {
      result = (ampl::Type)((ampl::VariantRef const *)arg1)->type();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariantRef_toString(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::VariantRef *arg1 = (ampl::VariantRef *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "VariantRef_toString", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__VariantRef, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariantRef_toString" "', argument " "1"" of type '" "ampl::VariantRef *""'"); 
  }
  arg1 = reinterpret_cast< ampl::VariantRef * >(argp1);
  {
    try {
      result = (arg1)->toString();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariantRef_equals(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::VariantRef *arg1 = (ampl::VariantRef *) 0 ;
  ampl::VariantRef *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__VariantRef, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariantRef_equals" "', argument " "1"" of type '" "ampl::VariantRef *""'"); 
  }
  arg1 = reinterpret_cast< ampl::VariantRef * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ampl__VariantRef,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VariantRef_equals" "', argument " "2"" of type '" "ampl::VariantRef &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VariantRef_equals" "', argument " "2"" of type '" "ampl::VariantRef &""'"); 
  }
  arg2 = reinterpret_cast< ampl::VariantRef * >(argp2);
  {
    try {
      result = (bool)ampl_VariantRef_equals(arg1,*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariantRef_compare(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::VariantRef *arg1 = (ampl::VariantRef *) 0 ;
  ampl::VariantRef *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__VariantRef, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariantRef_compare" "', argument " "1"" of type '" "ampl::VariantRef *""'"); 
  }
  arg1 = reinterpret_cast< ampl::VariantRef * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ampl__VariantRef,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VariantRef_compare" "', argument " "2"" of type '" "ampl::VariantRef &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VariantRef_compare" "', argument " "2"" of type '" "ampl::VariantRef &""'"); 
  }
  arg2 = reinterpret_cast< ampl::VariantRef * >(argp2);
  {
    try {
      result = (int)ampl_VariantRef_compare(arg1,*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_VariantRef(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::VariantRef *arg1 = (ampl::VariantRef *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_VariantRef", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__VariantRef, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_VariantRef" "', argument " "1"" of type '" "ampl::VariantRef *""'"); 
  }
  arg1 = reinterpret_cast< ampl::VariantRef * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_VariantRef) /* defines _wrap_delete_VariantRef_destructor_closure */

SWIGINTERN int _wrap_new_TupleRef(PyObject *self, PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  ampl::Tuple arg1 ;
  void *argp1 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ampl::TupleRef *result = 0 ;
  
  if (!SWIG_Python_CheckNoKeywords(kwargs, "new_TupleRef")) SWIG_fail;
  if (!SWIG_Python_UnpackTuple(args, "new_TupleRef", 1, 1, swig_obj)) SWIG_fail;
  {
    res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_ampl__Tuple,  0  | 0);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_TupleRef" "', argument " "1"" of type '" "ampl::Tuple""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_TupleRef" "', argument " "1"" of type '" "ampl::Tuple""'");
    } else {
      ampl::Tuple * temp = reinterpret_cast< ampl::Tuple * >(argp1);
      arg1 = *temp;
      if (SWIG_IsNewObj(res1)) delete temp;
    }
  }
  {
    try {
      result = (ampl::TupleRef *)new ampl::TupleRef(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__TupleRef, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN PyObject *_wrap_TupleRef_size(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::TupleRef *arg1 = (ampl::TupleRef *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::size_t result;
  
  if (!SWIG_Python_UnpackTuple(args, "TupleRef_size", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__TupleRef, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TupleRef_size" "', argument " "1"" of type '" "ampl::TupleRef *""'"); 
  }
  arg1 = reinterpret_cast< ampl::TupleRef * >(argp1);
  {
    try {
      result = (arg1)->size();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_TupleRef_toString(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::TupleRef *arg1 = (ampl::TupleRef *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "TupleRef_toString", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__TupleRef, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TupleRef_toString" "', argument " "1"" of type '" "ampl::TupleRef *""'"); 
  }
  arg1 = reinterpret_cast< ampl::TupleRef * >(argp1);
  {
    try {
      result = (arg1)->toString();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_TupleRef_getIndex(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::TupleRef *arg1 = (ampl::TupleRef *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  SwigValueWrapper< ampl::Variant > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__TupleRef, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TupleRef_getIndex" "', argument " "1"" of type '" "ampl::TupleRef *""'"); 
  }
  arg1 = reinterpret_cast< ampl::TupleRef * >(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "TupleRef_getIndex" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  {
    try {
      result = (arg1)->operator [](arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  {
    switch ((&result)->type()) {
    case ampl::STRING:
      resultobj = PyString_FromString((&result)->c_str());
      break;
    case ampl::NUMERIC:
      resultobj = PyFloat_FromDouble((&result)->dbl());
      break;
    default:
      resultobj = Py_None;
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_TupleRef(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::TupleRef *arg1 = (ampl::TupleRef *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_TupleRef", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__TupleRef, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_TupleRef" "', argument " "1"" of type '" "ampl::TupleRef *""'"); 
  }
  arg1 = reinterpret_cast< ampl::TupleRef * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_TupleRef) /* defines _wrap_delete_TupleRef_destructor_closure */

SWIGINTERN int _wrap_new_Tuple__SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **SWIGUNUSEDPARM(swig_obj)) {
  PyObject *resultobj = 0;
  ampl::Tuple *result = 0 ;
  
  if ((nobjs < 0) || (nobjs > 0)) SWIG_fail;
  {
    try {
      result = (ampl::Tuple *)new ampl::Tuple();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__Tuple, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN int _wrap_new_Tuple__SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  ampl::Tuple *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  ecode1 = SWIG_AsVal_double(swig_obj[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_Tuple" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  {
    try {
      result = (ampl::Tuple *)new ampl::Tuple(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__Tuple, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN int _wrap_new_Tuple__SWIG_2(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  ampl::Tuple *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(swig_obj[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Tuple" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  {
    try {
      result = (ampl::Tuple *)new ampl::Tuple((char const *)arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__Tuple, SWIG_BUILTIN_INIT |  0 );
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return resultobj == Py_None ? -1 : 0;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return -1;
}


SWIGINTERN int _wrap_new_Tuple(PyObject *self, PyObject *args, PyObject *kwargs) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!SWIG_Python_CheckNoKeywords(kwargs, "new_Tuple")) SWIG_fail;
  if (!(argc = SWIG_Python_UnpackTuple(args, "new_Tuple", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 0) {
    return _wrap_new_Tuple__SWIG_0(self, argc, argv);
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_double(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_Tuple__SWIG_1(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Tuple__SWIG_2(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'new_Tuple'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    ampl::Tuple::Tuple()\n"
    "    ampl::Tuple::Tuple(double)\n"
    "    ampl::Tuple::Tuple(char const *)\n");
  return -1;
}


SWIGINTERN PyObject *_wrap_Tuple_size(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Tuple *arg1 = (ampl::Tuple *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::size_t result;
  
  if (!SWIG_Python_UnpackTuple(args, "Tuple_size", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Tuple, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tuple_size" "', argument " "1"" of type '" "ampl::Tuple *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Tuple * >(argp1);
  {
    try {
      result = (arg1)->size();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tuple_toString(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Tuple *arg1 = (ampl::Tuple *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "Tuple_toString", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Tuple, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tuple_toString" "', argument " "1"" of type '" "ampl::Tuple *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Tuple * >(argp1);
  {
    try {
      result = (arg1)->toString();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tuple_getIndex(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Tuple *arg1 = (ampl::Tuple *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  SwigValueWrapper< ampl::Variant > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Tuple, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tuple_getIndex" "', argument " "1"" of type '" "ampl::Tuple *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Tuple * >(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Tuple_getIndex" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  {
    try {
      result = (arg1)->operator [](arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  {
    switch ((&result)->type()) {
    case ampl::STRING:
      resultobj = PyString_FromString((&result)->c_str());
      break;
    case ampl::NUMERIC:
      resultobj = PyFloat_FromDouble((&result)->dbl());
      break;
    default:
      resultobj = Py_None;
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tuple_equals(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Tuple *arg1 = (ampl::Tuple *) 0 ;
  ampl::Tuple *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Tuple, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tuple_equals" "', argument " "1"" of type '" "ampl::Tuple *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Tuple * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ampl__Tuple,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Tuple_equals" "', argument " "2"" of type '" "ampl::Tuple &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Tuple_equals" "', argument " "2"" of type '" "ampl::Tuple &""'"); 
  }
  arg2 = reinterpret_cast< ampl::Tuple * >(argp2);
  {
    try {
      result = (bool)ampl_Tuple_operator_Se__Se_(arg1,*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_Tuple_Factory__SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  VariantArray *arg1 = 0 ;
  std::size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  ampl::Tuple result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_VariantArray,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tuple_Factory" "', argument " "1"" of type '" "VariantArray &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Tuple_Factory" "', argument " "1"" of type '" "VariantArray &""'"); 
  }
  arg1 = reinterpret_cast< VariantArray * >(argp1);
  ecode2 = SWIG_AsVal_size_t(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Tuple_Factory" "', argument " "2"" of type '" "std::size_t""'");
  } 
  arg2 = static_cast< std::size_t >(val2);
  {
    try {
      result = ampl_Tuple_Factory__SWIG_0(*arg1,arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::Tuple(static_cast< const ampl::Tuple& >(result))), SWIGTYPE_p_ampl__Tuple, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tuple_Factory__SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  SwigValueWrapper< ampl::TupleRef > arg1 ;
  void *argp1 ;
  int res1 = 0 ;
  ampl::Tuple result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  {
    res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_ampl__TupleRef,  0  | 0);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tuple_Factory" "', argument " "1"" of type '" "ampl::TupleRef""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Tuple_Factory" "', argument " "1"" of type '" "ampl::TupleRef""'");
    } else {
      ampl::TupleRef * temp = reinterpret_cast< ampl::TupleRef * >(argp1);
      arg1 = *temp;
      if (SWIG_IsNewObj(res1)) delete temp;
    }
  }
  {
    try {
      result = ampl_Tuple_Factory__SWIG_1(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::Tuple(static_cast< const ampl::Tuple& >(result))), SWIGTYPE_p_ampl__Tuple, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tuple_Factory(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "Tuple_Factory", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_ampl__TupleRef, SWIG_POINTER_NO_NULL | 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Tuple_Factory__SWIG_1(self, argc, argv);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_VariantArray, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Tuple_Factory__SWIG_0(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'Tuple_Factory'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    ampl::Tuple::Factory(VariantArray &,std::size_t)\n"
    "    ampl::Tuple::ampl_Tuple_Factory__SWIG_1(ampl::TupleRef)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_delete_Tuple(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Tuple *arg1 = (ampl::Tuple *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_Tuple", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Tuple, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Tuple" "', argument " "1"" of type '" "ampl::Tuple *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Tuple * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_Tuple) /* defines _wrap_delete_Tuple_destructor_closure */

SWIGINTERN int _wrap_new_DataFrame__SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::size_t arg1 ;
  size_t val1 ;
  int ecode1 = 0 ;
  ampl::DataFrame *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  ecode1 = SWIG_AsVal_size_t(swig_obj[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_DataFrame" "', argument " "1"" of type '" "std::size_t""'");
  } 
  arg1 = static_cast< std::size_t >(val1);
  {
    try {
      result = (ampl::DataFrame *)new ampl::DataFrame(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__DataFrame, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN PyObject *_wrap_delete_DataFrame(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_DataFrame", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_DataFrame" "', argument " "1"" of type '" "ampl::DataFrame *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN int _wrap_new_DataFrame__SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  ampl::EntityArgs *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ampl::DataFrame *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_ampl__EntityArgs,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_DataFrame" "', argument " "1"" of type '" "ampl::EntityArgs const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_DataFrame" "', argument " "1"" of type '" "ampl::EntityArgs const &""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityArgs * >(argp1);
  {
    try {
      result = (ampl::DataFrame *)new ampl::DataFrame((ampl::EntityArgs const &)*arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__DataFrame, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN int _wrap_new_DataFrame__SWIG_2(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ampl::DataFrame *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_ampl__DataFrame,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_DataFrame" "', argument " "1"" of type '" "ampl::DataFrame const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_DataFrame" "', argument " "1"" of type '" "ampl::DataFrame const &""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  {
    try {
      result = (ampl::DataFrame *)new ampl::DataFrame((ampl::DataFrame const &)*arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__DataFrame, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN int _wrap_new_DataFrame(PyObject *self, PyObject *args, PyObject *kwargs) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!SWIG_Python_CheckNoKeywords(kwargs, "new_DataFrame")) SWIG_fail;
  if (!(argc = SWIG_Python_UnpackTuple(args, "new_DataFrame", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_ampl__EntityArgs, SWIG_POINTER_NO_NULL | 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_DataFrame__SWIG_1(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_ampl__DataFrame, SWIG_POINTER_NO_NULL | 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_DataFrame__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_size_t(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_DataFrame__SWIG_0(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'new_DataFrame'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    ampl::DataFrame::DataFrame(std::size_t)\n"
    "    ampl::DataFrame::DataFrame(ampl::EntityArgs const &)\n"
    "    ampl::DataFrame::DataFrame(ampl::DataFrame const &)\n");
  return -1;
}


SWIGINTERN PyObject *_wrap_DataFrame_clone(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  ampl::DataFrame *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  ampl::DataFrame *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_clone" "', argument " "1"" of type '" "ampl::DataFrame *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ampl__DataFrame,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DataFrame_clone" "', argument " "2"" of type '" "ampl::DataFrame const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DataFrame_clone" "', argument " "2"" of type '" "ampl::DataFrame const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::DataFrame * >(argp2);
  {
    try {
      result = (ampl::DataFrame *) &(arg1)->operator =((ampl::DataFrame const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_equals(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  ampl::DataFrame *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_equals" "', argument " "1"" of type '" "ampl::DataFrame const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ampl__DataFrame,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DataFrame_equals" "', argument " "2"" of type '" "ampl::DataFrame const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DataFrame_equals" "', argument " "2"" of type '" "ampl::DataFrame const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::DataFrame * >(argp2);
  {
    try {
      result = (bool)((ampl::DataFrame const *)arg1)->operator ==((ampl::DataFrame const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_DataFrame_differs(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  ampl::DataFrame *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_differs" "', argument " "1"" of type '" "ampl::DataFrame const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ampl__DataFrame,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DataFrame_differs" "', argument " "2"" of type '" "ampl::DataFrame const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DataFrame_differs" "', argument " "2"" of type '" "ampl::DataFrame const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::DataFrame * >(argp2);
  {
    try {
      result = (bool)((ampl::DataFrame const *)arg1)->operator !=((ampl::DataFrame const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_DataFrame_getNumCols(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::size_t result;
  
  if (!SWIG_Python_UnpackTuple(args, "DataFrame_getNumCols", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_getNumCols" "', argument " "1"" of type '" "ampl::DataFrame const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  {
    try {
      result = ((ampl::DataFrame const *)arg1)->getNumCols();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_getNumRows(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::size_t result;
  
  if (!SWIG_Python_UnpackTuple(args, "DataFrame_getNumRows", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_getNumRows" "', argument " "1"" of type '" "ampl::DataFrame const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  {
    try {
      result = ((ampl::DataFrame const *)arg1)->getNumRows();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_getNumIndices(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::size_t result;
  
  if (!SWIG_Python_UnpackTuple(args, "DataFrame_getNumIndices", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_getNumIndices" "', argument " "1"" of type '" "ampl::DataFrame const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  {
    try {
      result = ((ampl::DataFrame const *)arg1)->getNumIndices();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_addRow__SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  SwigValueWrapper< ampl::TupleRef > arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_addRow" "', argument " "1"" of type '" "ampl::DataFrame *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_ampl__TupleRef,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DataFrame_addRow" "', argument " "2"" of type '" "ampl::TupleRef""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DataFrame_addRow" "', argument " "2"" of type '" "ampl::TupleRef""'");
    } else {
      ampl::TupleRef * temp = reinterpret_cast< ampl::TupleRef * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      (arg1)->addRow(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_addRow__SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  SwigValueWrapper< ampl::VariantRef > arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_addRow" "', argument " "1"" of type '" "ampl::DataFrame *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_ampl__VariantRef,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DataFrame_addRow" "', argument " "2"" of type '" "ampl::VariantRef""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DataFrame_addRow" "', argument " "2"" of type '" "ampl::VariantRef""'");
    } else {
      ampl::VariantRef * temp = reinterpret_cast< ampl::VariantRef * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      (arg1)->addRow(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_addRow__SWIG_2(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  SwigValueWrapper< ampl::VariantRef > arg2 ;
  SwigValueWrapper< ampl::VariantRef > arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_addRow" "', argument " "1"" of type '" "ampl::DataFrame *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_ampl__VariantRef,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DataFrame_addRow" "', argument " "2"" of type '" "ampl::VariantRef""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DataFrame_addRow" "', argument " "2"" of type '" "ampl::VariantRef""'");
    } else {
      ampl::VariantRef * temp = reinterpret_cast< ampl::VariantRef * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    res3 = SWIG_ConvertPtr(swig_obj[2], &argp3, SWIGTYPE_p_ampl__VariantRef,  0  | 0);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "DataFrame_addRow" "', argument " "3"" of type '" "ampl::VariantRef""'"); 
    }  
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DataFrame_addRow" "', argument " "3"" of type '" "ampl::VariantRef""'");
    } else {
      ampl::VariantRef * temp = reinterpret_cast< ampl::VariantRef * >(argp3);
      arg3 = *temp;
      if (SWIG_IsNewObj(res3)) delete temp;
    }
  }
  {
    try {
      (arg1)->addRow(arg2,arg3);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_addRow__SWIG_3(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  SwigValueWrapper< ampl::VariantRef > arg2 ;
  SwigValueWrapper< ampl::VariantRef > arg3 ;
  SwigValueWrapper< ampl::VariantRef > arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  void *argp4 ;
  int res4 = 0 ;
  
  if ((nobjs < 4) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_addRow" "', argument " "1"" of type '" "ampl::DataFrame *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_ampl__VariantRef,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DataFrame_addRow" "', argument " "2"" of type '" "ampl::VariantRef""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DataFrame_addRow" "', argument " "2"" of type '" "ampl::VariantRef""'");
    } else {
      ampl::VariantRef * temp = reinterpret_cast< ampl::VariantRef * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    res3 = SWIG_ConvertPtr(swig_obj[2], &argp3, SWIGTYPE_p_ampl__VariantRef,  0  | 0);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "DataFrame_addRow" "', argument " "3"" of type '" "ampl::VariantRef""'"); 
    }  
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DataFrame_addRow" "', argument " "3"" of type '" "ampl::VariantRef""'");
    } else {
      ampl::VariantRef * temp = reinterpret_cast< ampl::VariantRef * >(argp3);
      arg3 = *temp;
      if (SWIG_IsNewObj(res3)) delete temp;
    }
  }
  {
    res4 = SWIG_ConvertPtr(swig_obj[3], &argp4, SWIGTYPE_p_ampl__VariantRef,  0  | 0);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "DataFrame_addRow" "', argument " "4"" of type '" "ampl::VariantRef""'"); 
    }  
    if (!argp4) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DataFrame_addRow" "', argument " "4"" of type '" "ampl::VariantRef""'");
    } else {
      ampl::VariantRef * temp = reinterpret_cast< ampl::VariantRef * >(argp4);
      arg4 = *temp;
      if (SWIG_IsNewObj(res4)) delete temp;
    }
  }
  {
    try {
      (arg1)->addRow(arg2,arg3,arg4);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_addRow__SWIG_4(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  SwigValueWrapper< ampl::VariantRef > arg2 ;
  SwigValueWrapper< ampl::VariantRef > arg3 ;
  SwigValueWrapper< ampl::VariantRef > arg4 ;
  SwigValueWrapper< ampl::VariantRef > arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  void *argp4 ;
  int res4 = 0 ;
  void *argp5 ;
  int res5 = 0 ;
  
  if ((nobjs < 5) || (nobjs > 5)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_addRow" "', argument " "1"" of type '" "ampl::DataFrame *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_ampl__VariantRef,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DataFrame_addRow" "', argument " "2"" of type '" "ampl::VariantRef""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DataFrame_addRow" "', argument " "2"" of type '" "ampl::VariantRef""'");
    } else {
      ampl::VariantRef * temp = reinterpret_cast< ampl::VariantRef * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    res3 = SWIG_ConvertPtr(swig_obj[2], &argp3, SWIGTYPE_p_ampl__VariantRef,  0  | 0);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "DataFrame_addRow" "', argument " "3"" of type '" "ampl::VariantRef""'"); 
    }  
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DataFrame_addRow" "', argument " "3"" of type '" "ampl::VariantRef""'");
    } else {
      ampl::VariantRef * temp = reinterpret_cast< ampl::VariantRef * >(argp3);
      arg3 = *temp;
      if (SWIG_IsNewObj(res3)) delete temp;
    }
  }
  {
    res4 = SWIG_ConvertPtr(swig_obj[3], &argp4, SWIGTYPE_p_ampl__VariantRef,  0  | 0);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "DataFrame_addRow" "', argument " "4"" of type '" "ampl::VariantRef""'"); 
    }  
    if (!argp4) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DataFrame_addRow" "', argument " "4"" of type '" "ampl::VariantRef""'");
    } else {
      ampl::VariantRef * temp = reinterpret_cast< ampl::VariantRef * >(argp4);
      arg4 = *temp;
      if (SWIG_IsNewObj(res4)) delete temp;
    }
  }
  {
    res5 = SWIG_ConvertPtr(swig_obj[4], &argp5, SWIGTYPE_p_ampl__VariantRef,  0  | 0);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "DataFrame_addRow" "', argument " "5"" of type '" "ampl::VariantRef""'"); 
    }  
    if (!argp5) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DataFrame_addRow" "', argument " "5"" of type '" "ampl::VariantRef""'");
    } else {
      ampl::VariantRef * temp = reinterpret_cast< ampl::VariantRef * >(argp5);
      arg5 = *temp;
      if (SWIG_IsNewObj(res5)) delete temp;
    }
  }
  {
    try {
      (arg1)->addRow(arg2,arg3,arg4,arg5);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_reserve(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  std::size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_reserve" "', argument " "1"" of type '" "ampl::DataFrame *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  ecode2 = SWIG_AsVal_size_t(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DataFrame_reserve" "', argument " "2"" of type '" "std::size_t""'");
  } 
  arg2 = static_cast< std::size_t >(val2);
  {
    try {
      (arg1)->reserve(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_toString(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "DataFrame_toString", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_toString" "', argument " "1"" of type '" "ampl::DataFrame const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  {
    try {
      result = ((ampl::DataFrame const *)arg1)->toString();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_getColumn(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  fmt::CStringRef arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  SwigValueWrapper< ampl::internal::Slice< false > > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_getColumn" "', argument " "1"" of type '" "ampl::DataFrame const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  
  arg2 = _PyString_AsString(swig_obj[0]);
  
  {
    try {
      result = ((ampl::DataFrame const *)arg1)->getColumn(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::DataFrame::Column(static_cast< const ampl::DataFrame::Column& >(result))), SWIGTYPE_p_ampl__internal__SliceT_false_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_getRowByIndex(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  std::size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  SwigValueWrapper< ampl::internal::Slice< true > > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_getRowByIndex" "', argument " "1"" of type '" "ampl::DataFrame const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  ecode2 = SWIG_AsVal_size_t(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DataFrame_getRowByIndex" "', argument " "2"" of type '" "std::size_t""'");
  } 
  arg2 = static_cast< std::size_t >(val2);
  {
    try {
      result = ((ampl::DataFrame const *)arg1)->getRowByIndex(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::DataFrame::Row(static_cast< const ampl::DataFrame::Row& >(result))), SWIGTYPE_p_ampl__internal__SliceT_true_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_getRow__SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  SwigValueWrapper< ampl::VariantRef > arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  SwigValueWrapper< ampl::internal::Slice< true > > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_getRow" "', argument " "1"" of type '" "ampl::DataFrame *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_ampl__VariantRef,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DataFrame_getRow" "', argument " "2"" of type '" "ampl::VariantRef""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DataFrame_getRow" "', argument " "2"" of type '" "ampl::VariantRef""'");
    } else {
      ampl::VariantRef * temp = reinterpret_cast< ampl::VariantRef * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (arg1)->getRow(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::DataFrame::Row(static_cast< const ampl::DataFrame::Row& >(result))), SWIGTYPE_p_ampl__internal__SliceT_true_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_getRow__SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  SwigValueWrapper< ampl::TupleRef > arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  SwigValueWrapper< ampl::internal::Slice< true > > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_getRow" "', argument " "1"" of type '" "ampl::DataFrame const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_ampl__TupleRef,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DataFrame_getRow" "', argument " "2"" of type '" "ampl::TupleRef""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DataFrame_getRow" "', argument " "2"" of type '" "ampl::TupleRef""'");
    } else {
      ampl::TupleRef * temp = reinterpret_cast< ampl::TupleRef * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = ((ampl::DataFrame const *)arg1)->getRow(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::DataFrame::Row(static_cast< const ampl::DataFrame::Row& >(result))), SWIGTYPE_p_ampl__internal__SliceT_true_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_getRow__SWIG_2(PyObject *self, Py_ssize_t nobjs, PyObject **SWIGUNUSEDPARM(swig_obj)) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< ampl::internal::Slice< true > > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_getRow" "', argument " "1"" of type '" "ampl::DataFrame const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  {
    try {
      result = ((ampl::DataFrame const *)arg1)->getRow();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::DataFrame::Row(static_cast< const ampl::DataFrame::Row& >(result))), SWIGTYPE_p_ampl__internal__SliceT_true_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_getRow(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "DataFrame_getRow", 0, 2, argv+1))) SWIG_fail;
  argv[0] = self;
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__DataFrame, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_DataFrame_getRow__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__DataFrame, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_ampl__TupleRef, SWIG_POINTER_NO_NULL | 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_DataFrame_getRow__SWIG_1(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__DataFrame, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_ampl__VariantRef, SWIG_POINTER_NO_NULL | 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_DataFrame_getRow__SWIG_0(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'DataFrame_getRow'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    ampl::DataFrame::getRow(ampl::VariantRef)\n"
    "    ampl::DataFrame::getRow(ampl::TupleRef) const\n"
    "    ampl::DataFrame::getRow() const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_DataFrame_getHeaders(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ampl::StringRefArray result;
  
  if (!SWIG_Python_UnpackTuple(args, "DataFrame_getHeaders", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_getHeaders" "', argument " "1"" of type '" "ampl::DataFrame const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  {
    try {
      result = ((ampl::DataFrame const *)arg1)->getHeaders();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  {
    const ampl::StringRefArray &sa = result; // to avoid issues with result[i];
    std::size_t size = sa.size();
    resultobj = PyList_New(size);
    for (std::size_t i = 0; i < size; i++) {
      PyList_SetItem(resultobj, i, PyString_FromString(sa[i]));
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_impl(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ampl::internal::DataFrame *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "DataFrame_impl", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_impl" "', argument " "1"" of type '" "ampl::DataFrame const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  {
    try {
      result = (ampl::internal::DataFrame *)((ampl::DataFrame const *)arg1)->impl();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_setValueSWIG__SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  ampl::Tuple arg2 ;
  fmt::CStringRef arg3 ;
  SwigValueWrapper< ampl::Variant > arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp4 ;
  int res4 = 0 ;
  
  if ((nobjs < 4) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_setValueSWIG" "', argument " "1"" of type '" "ampl::DataFrame *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  {
    SetTupleFromPyObject(swig_obj[1], &arg2);
  }
  
  arg3 = _PyString_AsString(swig_obj[2]);
  
  {
    res4 = SWIG_ConvertPtr(swig_obj[3], &argp4, SWIGTYPE_p_ampl__Variant,  0  | 0);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "DataFrame_setValueSWIG" "', argument " "4"" of type '" "ampl::Variant""'"); 
    }  
    if (!argp4) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DataFrame_setValueSWIG" "', argument " "4"" of type '" "ampl::Variant""'");
    } else {
      ampl::Variant * temp = reinterpret_cast< ampl::Variant * >(argp4);
      arg4 = *temp;
      if (SWIG_IsNewObj(res4)) delete temp;
    }
  }
  {
    try {
      ampl_DataFrame_setValueSWIG__SWIG_0(arg1,arg2,arg3,arg4);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_setValueSWIG__SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  std::size_t arg2 ;
  std::size_t arg3 ;
  SwigValueWrapper< ampl::Variant > arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  void *argp4 ;
  int res4 = 0 ;
  
  if ((nobjs < 4) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_setValueSWIG" "', argument " "1"" of type '" "ampl::DataFrame *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  ecode2 = SWIG_AsVal_size_t(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DataFrame_setValueSWIG" "', argument " "2"" of type '" "std::size_t""'");
  } 
  arg2 = static_cast< std::size_t >(val2);
  ecode3 = SWIG_AsVal_size_t(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "DataFrame_setValueSWIG" "', argument " "3"" of type '" "std::size_t""'");
  } 
  arg3 = static_cast< std::size_t >(val3);
  {
    res4 = SWIG_ConvertPtr(swig_obj[3], &argp4, SWIGTYPE_p_ampl__Variant,  0  | 0);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "DataFrame_setValueSWIG" "', argument " "4"" of type '" "ampl::Variant""'"); 
    }  
    if (!argp4) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DataFrame_setValueSWIG" "', argument " "4"" of type '" "ampl::Variant""'");
    } else {
      ampl::Variant * temp = reinterpret_cast< ampl::Variant * >(argp4);
      arg4 = *temp;
      if (SWIG_IsNewObj(res4)) delete temp;
    }
  }
  {
    try {
      ampl_DataFrame_setValueSWIG__SWIG_1(arg1,arg2,arg3,arg4);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_setValueSWIG(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[5] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "DataFrame_setValueSWIG", 0, 4, argv+1))) SWIG_fail;
  argv[0] = self;
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__DataFrame, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        _v = PyTuple_Check(argv[1]) ? 1 : 0;
      }
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          int res = SWIG_ConvertPtr(argv[3], 0, SWIGTYPE_p_ampl__Variant, SWIG_POINTER_NO_NULL | 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_DataFrame_setValueSWIG__SWIG_0(self, argc, argv);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__DataFrame, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          int res = SWIG_ConvertPtr(argv[3], 0, SWIGTYPE_p_ampl__Variant, SWIG_POINTER_NO_NULL | 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_DataFrame_setValueSWIG__SWIG_1(self, argc, argv);
          }
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'DataFrame_setValueSWIG'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    ampl::DataFrame::setValueSWIG(ampl::Tuple,fmt::CStringRef,ampl::Variant)\n"
    "    ampl::DataFrame::setValueSWIG(std::size_t,std::size_t,ampl::Variant)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_DataFrame_addColumn(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  fmt::CStringRef arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_addColumn" "', argument " "1"" of type '" "ampl::DataFrame *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  
  arg2 = _PyString_AsString(swig_obj[0]);
  
  {
    try {
      ampl_DataFrame_addColumnSWIG(arg1,arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_addColumnStr(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  fmt::CStringRef arg2 ;
  char **arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[3] ;
  
  {
    arg3 = NULL;
  }
  if (!SWIG_Python_UnpackTuple(args, "DataFrame_addColumnStr", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_addColumnStr" "', argument " "1"" of type '" "ampl::DataFrame *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  
  arg2 = _PyString_AsString(swig_obj[0]);
  
  {
    /* Check if is a list */
    if (PyList_Check(swig_obj[1])) {
      std::size_t size = PyList_Size(swig_obj[1]);
      std::size_t i = 0;
      arg3 = (char **)malloc((size + 1) * sizeof(char *));
      for (i = 0; i < size; i++) {
        PyObject *obj = PyList_GetItem(swig_obj[1],i);
        if (_PyString_Check(obj)) {
          arg3[i] = (char *)_PyString_AsString(PyList_GetItem(swig_obj[1],i));
        } else {
          PyErr_SetString(PyExc_TypeError, "list must contain strings");
          free(arg3);
          return NULL;
        }
      }
      arg3[i] = 0;
    } else {
      PyErr_SetString(PyExc_TypeError, "not a list");
      return NULL;
    }
  }
  {
    try {
      ampl_DataFrame_addColumnSWIG(arg1,arg2,(char const *(*))arg3);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  {
    free((char *)arg3);
  }
  return resultobj;
fail:
  {
    free((char *)arg3);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_addColumnDbl(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  fmt::CStringRef arg2 ;
  double *arg3 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args, "DataFrame_addColumnDbl", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_addColumnDbl" "', argument " "1"" of type '" "ampl::DataFrame *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  
  arg2 = _PyString_AsString(swig_obj[0]);
  
  {
    /* Check if is a list */
    if (PyList_Check(swig_obj[1])) {
      int size = PyList_Size(swig_obj[1]);
      int i = 0;
      arg3 = (double *)malloc(size * sizeof(double));
      for (i = 0; i < size; i++) {
        PyObject *o = PyList_GetItem(swig_obj[1],i);
        if (PyFloat_Check(o))
        arg3[i] = PyFloat_AsDouble(PyList_GetItem(swig_obj[1],i));
        else {
          PyErr_SetString(PyExc_TypeError, "The input list must contain floating point numbers");
          free(arg3);
          return NULL;
        }
      }
    }
    else {
      PyErr_SetString(PyExc_TypeError,"The input is not a list");
      return NULL;
    }
  }
  {
    try {
      ampl_DataFrame_addColumnSWIG(arg1,arg2,arg3);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  {
    free((double *)arg3);
  }
  return resultobj;
fail:
  {
    free((double *)arg3);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_addRow__SWIG_5(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  ampl::Tuple arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_addRow" "', argument " "1"" of type '" "ampl::DataFrame *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  {
    SetTupleFromPyObject(swig_obj[1], &arg2);
  }
  {
    try {
      ampl_DataFrame_addRow__SWIG_5(arg1,arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_addRow(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[6] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "DataFrame_addRow", 0, 5, argv+1))) SWIG_fail;
  argv[0] = self;
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__DataFrame, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_ampl__TupleRef, SWIG_POINTER_NO_NULL | 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_DataFrame_addRow__SWIG_0(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__DataFrame, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_ampl__VariantRef, SWIG_POINTER_NO_NULL | 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_DataFrame_addRow__SWIG_1(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__DataFrame, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        _v = PyTuple_Check(argv[1]) ? 1 : 0;
      }
      if (_v) {
        return _wrap_DataFrame_addRow__SWIG_5(self, argc, argv);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__DataFrame, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_ampl__VariantRef, SWIG_POINTER_NO_NULL | 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_ConvertPtr(argv[2], 0, SWIGTYPE_p_ampl__VariantRef, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_DataFrame_addRow__SWIG_2(self, argc, argv);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__DataFrame, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_ampl__VariantRef, SWIG_POINTER_NO_NULL | 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_ConvertPtr(argv[2], 0, SWIGTYPE_p_ampl__VariantRef, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          int res = SWIG_ConvertPtr(argv[3], 0, SWIGTYPE_p_ampl__VariantRef, SWIG_POINTER_NO_NULL | 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_DataFrame_addRow__SWIG_3(self, argc, argv);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__DataFrame, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_ampl__VariantRef, SWIG_POINTER_NO_NULL | 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_ConvertPtr(argv[2], 0, SWIGTYPE_p_ampl__VariantRef, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          int res = SWIG_ConvertPtr(argv[3], 0, SWIGTYPE_p_ampl__VariantRef, SWIG_POINTER_NO_NULL | 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            int res = SWIG_ConvertPtr(argv[4], 0, SWIGTYPE_p_ampl__VariantRef, SWIG_POINTER_NO_NULL | 0);
            _v = SWIG_CheckState(res);
            if (_v) {
              return _wrap_DataFrame_addRow__SWIG_4(self, argc, argv);
            }
          }
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'DataFrame_addRow'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    ampl::DataFrame::addRow(ampl::TupleRef)\n"
    "    ampl::DataFrame::addRow(ampl::VariantRef)\n"
    "    ampl::DataFrame::addRow(ampl::VariantRef,ampl::VariantRef)\n"
    "    ampl::DataFrame::addRow(ampl::VariantRef,ampl::VariantRef,ampl::VariantRef)\n"
    "    ampl::DataFrame::addRow(ampl::VariantRef,ampl::VariantRef,ampl::VariantRef,ampl::VariantRef)\n"
    "    ampl::DataFrame::addRow(ampl::Tuple)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_DataFrame_getRowTpl(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  ampl::Tuple arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  SwigValueWrapper< ampl::internal::Slice< true > > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_getRowTpl" "', argument " "1"" of type '" "ampl::DataFrame *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  {
    SetTupleFromPyObject(swig_obj[0], &arg2);
  }
  {
    try {
      result = ampl_DataFrame_getRow(arg1,arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::internal::Slice< true >(static_cast< const ampl::internal::Slice< true >& >(result))), SWIGTYPE_p_ampl__internal__SliceT_true_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_setColumnStr(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  fmt::CStringRef arg2 ;
  char **arg3 ;
  std::size_t arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val4 ;
  int ecode4 = 0 ;
  PyObject *swig_obj[4] ;
  
  {
    arg3 = NULL;
  }
  if (!SWIG_Python_UnpackTuple(args, "DataFrame_setColumnStr", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_setColumnStr" "', argument " "1"" of type '" "ampl::DataFrame *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  
  arg2 = _PyString_AsString(swig_obj[0]);
  
  {
    /* Check if is a list */
    if (PyList_Check(swig_obj[1])) {
      std::size_t size = PyList_Size(swig_obj[1]);
      std::size_t i = 0;
      arg3 = (char **)malloc((size + 1) * sizeof(char *));
      for (i = 0; i < size; i++) {
        PyObject *obj = PyList_GetItem(swig_obj[1],i);
        if (_PyString_Check(obj)) {
          arg3[i] = (char *)_PyString_AsString(PyList_GetItem(swig_obj[1],i));
        } else {
          PyErr_SetString(PyExc_TypeError, "list must contain strings");
          free(arg3);
          return NULL;
        }
      }
      arg3[i] = 0;
    } else {
      PyErr_SetString(PyExc_TypeError, "not a list");
      return NULL;
    }
  }
  ecode4 = SWIG_AsVal_size_t(swig_obj[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "DataFrame_setColumnStr" "', argument " "4"" of type '" "std::size_t""'");
  } 
  arg4 = static_cast< std::size_t >(val4);
  {
    try {
      ampl_DataFrame_setColumnSWIG(arg1,arg2,(char const *(*))arg3,arg4);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  {
    free((char *)arg3);
  }
  return resultobj;
fail:
  {
    free((char *)arg3);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_setColumnDbl(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  fmt::CStringRef arg2 ;
  double *arg3 = (double *) 0 ;
  std::size_t arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val4 ;
  int ecode4 = 0 ;
  PyObject *swig_obj[4] ;
  
  if (!SWIG_Python_UnpackTuple(args, "DataFrame_setColumnDbl", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_setColumnDbl" "', argument " "1"" of type '" "ampl::DataFrame *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  
  arg2 = _PyString_AsString(swig_obj[0]);
  
  {
    /* Check if is a list */
    if (PyList_Check(swig_obj[1])) {
      int size = PyList_Size(swig_obj[1]);
      int i = 0;
      arg3 = (double *)malloc(size * sizeof(double));
      for (i = 0; i < size; i++) {
        PyObject *o = PyList_GetItem(swig_obj[1],i);
        if (PyFloat_Check(o))
        arg3[i] = PyFloat_AsDouble(PyList_GetItem(swig_obj[1],i));
        else {
          PyErr_SetString(PyExc_TypeError, "The input list must contain floating point numbers");
          free(arg3);
          return NULL;
        }
      }
    }
    else {
      PyErr_SetString(PyExc_TypeError,"The input is not a list");
      return NULL;
    }
  }
  ecode4 = SWIG_AsVal_size_t(swig_obj[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "DataFrame_setColumnDbl" "', argument " "4"" of type '" "std::size_t""'");
  } 
  arg4 = static_cast< std::size_t >(val4);
  {
    try {
      ampl_DataFrame_setColumnSWIG(arg1,arg2,arg3,arg4);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  {
    free((double *)arg3);
  }
  return resultobj;
fail:
  {
    free((double *)arg3);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_setArrayDblDbl(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  std::size_t arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val4 ;
  int ecode4 = 0 ;
  PyObject *swig_obj[4] ;
  
  if (!SWIG_Python_UnpackTuple(args, "DataFrame_setArrayDblDbl", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_setArrayDblDbl" "', argument " "1"" of type '" "ampl::DataFrame *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  {
    /* Check if is a list */
    if (PyList_Check(swig_obj[0])) {
      int size = PyList_Size(swig_obj[0]);
      int i = 0;
      arg2 = (double *)malloc(size * sizeof(double));
      for (i = 0; i < size; i++) {
        PyObject *o = PyList_GetItem(swig_obj[0],i);
        if (PyFloat_Check(o))
        arg2[i] = PyFloat_AsDouble(PyList_GetItem(swig_obj[0],i));
        else {
          PyErr_SetString(PyExc_TypeError, "The input list must contain floating point numbers");
          free(arg2);
          return NULL;
        }
      }
    }
    else {
      PyErr_SetString(PyExc_TypeError,"The input is not a list");
      return NULL;
    }
  }
  {
    /* Check if is a list */
    if (PyList_Check(swig_obj[1])) {
      int size = PyList_Size(swig_obj[1]);
      int i = 0;
      arg3 = (double *)malloc(size * sizeof(double));
      for (i = 0; i < size; i++) {
        PyObject *o = PyList_GetItem(swig_obj[1],i);
        if (PyFloat_Check(o))
        arg3[i] = PyFloat_AsDouble(PyList_GetItem(swig_obj[1],i));
        else {
          PyErr_SetString(PyExc_TypeError, "The input list must contain floating point numbers");
          free(arg3);
          return NULL;
        }
      }
    }
    else {
      PyErr_SetString(PyExc_TypeError,"The input is not a list");
      return NULL;
    }
  }
  ecode4 = SWIG_AsVal_size_t(swig_obj[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "DataFrame_setArrayDblDbl" "', argument " "4"" of type '" "std::size_t""'");
  } 
  arg4 = static_cast< std::size_t >(val4);
  {
    try {
      ampl_DataFrame_setArraySWIG(arg1,arg2,arg3,arg4);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  {
    free((double *)arg2);
  }
  {
    free((double *)arg3);
  }
  return resultobj;
fail:
  {
    free((double *)arg2);
  }
  {
    free((double *)arg3);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_setArrayStrDbl(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  char **arg2 ;
  double *arg3 = (double *) 0 ;
  std::size_t arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val4 ;
  int ecode4 = 0 ;
  PyObject *swig_obj[4] ;
  
  {
    arg2 = NULL;
  }
  if (!SWIG_Python_UnpackTuple(args, "DataFrame_setArrayStrDbl", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_setArrayStrDbl" "', argument " "1"" of type '" "ampl::DataFrame *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  {
    /* Check if is a list */
    if (PyList_Check(swig_obj[0])) {
      std::size_t size = PyList_Size(swig_obj[0]);
      std::size_t i = 0;
      arg2 = (char **)malloc((size + 1) * sizeof(char *));
      for (i = 0; i < size; i++) {
        PyObject *obj = PyList_GetItem(swig_obj[0],i);
        if (_PyString_Check(obj)) {
          arg2[i] = (char *)_PyString_AsString(PyList_GetItem(swig_obj[0],i));
        } else {
          PyErr_SetString(PyExc_TypeError, "list must contain strings");
          free(arg2);
          return NULL;
        }
      }
      arg2[i] = 0;
    } else {
      PyErr_SetString(PyExc_TypeError, "not a list");
      return NULL;
    }
  }
  {
    /* Check if is a list */
    if (PyList_Check(swig_obj[1])) {
      int size = PyList_Size(swig_obj[1]);
      int i = 0;
      arg3 = (double *)malloc(size * sizeof(double));
      for (i = 0; i < size; i++) {
        PyObject *o = PyList_GetItem(swig_obj[1],i);
        if (PyFloat_Check(o))
        arg3[i] = PyFloat_AsDouble(PyList_GetItem(swig_obj[1],i));
        else {
          PyErr_SetString(PyExc_TypeError, "The input list must contain floating point numbers");
          free(arg3);
          return NULL;
        }
      }
    }
    else {
      PyErr_SetString(PyExc_TypeError,"The input is not a list");
      return NULL;
    }
  }
  ecode4 = SWIG_AsVal_size_t(swig_obj[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "DataFrame_setArrayStrDbl" "', argument " "4"" of type '" "std::size_t""'");
  } 
  arg4 = static_cast< std::size_t >(val4);
  {
    try {
      ampl_DataFrame_setArraySWIG(arg1,(char const *(*))arg2,arg3,arg4);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  {
    free((char *)arg2);
  }
  {
    free((double *)arg3);
  }
  return resultobj;
fail:
  {
    free((char *)arg2);
  }
  {
    free((double *)arg3);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_setArrayDblStr(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  double *arg2 = (double *) 0 ;
  char **arg3 = (char **) 0 ;
  std::size_t arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val4 ;
  int ecode4 = 0 ;
  PyObject *swig_obj[4] ;
  
  {
    arg3 = NULL;
  }
  if (!SWIG_Python_UnpackTuple(args, "DataFrame_setArrayDblStr", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_setArrayDblStr" "', argument " "1"" of type '" "ampl::DataFrame *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  {
    /* Check if is a list */
    if (PyList_Check(swig_obj[0])) {
      int size = PyList_Size(swig_obj[0]);
      int i = 0;
      arg2 = (double *)malloc(size * sizeof(double));
      for (i = 0; i < size; i++) {
        PyObject *o = PyList_GetItem(swig_obj[0],i);
        if (PyFloat_Check(o))
        arg2[i] = PyFloat_AsDouble(PyList_GetItem(swig_obj[0],i));
        else {
          PyErr_SetString(PyExc_TypeError, "The input list must contain floating point numbers");
          free(arg2);
          return NULL;
        }
      }
    }
    else {
      PyErr_SetString(PyExc_TypeError,"The input is not a list");
      return NULL;
    }
  }
  {
    /* Check if is a list */
    if (PyList_Check(swig_obj[1])) {
      std::size_t size = PyList_Size(swig_obj[1]);
      std::size_t i = 0;
      arg3 = (char **)malloc((size + 1) * sizeof(char *));
      for (i = 0; i < size; i++) {
        PyObject *obj = PyList_GetItem(swig_obj[1],i);
        if (_PyString_Check(obj)) {
          arg3[i] = (char *)_PyString_AsString(PyList_GetItem(swig_obj[1],i));
        } else {
          PyErr_SetString(PyExc_TypeError, "list must contain strings");
          free(arg3);
          return NULL;
        }
      }
      arg3[i] = 0;
    } else {
      PyErr_SetString(PyExc_TypeError, "not a list");
      return NULL;
    }
  }
  ecode4 = SWIG_AsVal_size_t(swig_obj[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "DataFrame_setArrayDblStr" "', argument " "4"" of type '" "std::size_t""'");
  } 
  arg4 = static_cast< std::size_t >(val4);
  {
    try {
      ampl_DataFrame_setArraySWIG(arg1,arg2,(char const *const *)arg3,arg4);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  {
    free((double *)arg2);
  }
  {
    free((char *)arg3);
  }
  return resultobj;
fail:
  {
    free((double *)arg2);
  }
  {
    free((char *)arg3);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_setArrayStrStr(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  char **arg2 ;
  char **arg3 = (char **) 0 ;
  std::size_t arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val4 ;
  int ecode4 = 0 ;
  PyObject *swig_obj[4] ;
  
  {
    arg2 = NULL;
  }
  {
    arg3 = NULL;
  }
  if (!SWIG_Python_UnpackTuple(args, "DataFrame_setArrayStrStr", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_setArrayStrStr" "', argument " "1"" of type '" "ampl::DataFrame *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  {
    /* Check if is a list */
    if (PyList_Check(swig_obj[0])) {
      std::size_t size = PyList_Size(swig_obj[0]);
      std::size_t i = 0;
      arg2 = (char **)malloc((size + 1) * sizeof(char *));
      for (i = 0; i < size; i++) {
        PyObject *obj = PyList_GetItem(swig_obj[0],i);
        if (_PyString_Check(obj)) {
          arg2[i] = (char *)_PyString_AsString(PyList_GetItem(swig_obj[0],i));
        } else {
          PyErr_SetString(PyExc_TypeError, "list must contain strings");
          free(arg2);
          return NULL;
        }
      }
      arg2[i] = 0;
    } else {
      PyErr_SetString(PyExc_TypeError, "not a list");
      return NULL;
    }
  }
  {
    /* Check if is a list */
    if (PyList_Check(swig_obj[1])) {
      std::size_t size = PyList_Size(swig_obj[1]);
      std::size_t i = 0;
      arg3 = (char **)malloc((size + 1) * sizeof(char *));
      for (i = 0; i < size; i++) {
        PyObject *obj = PyList_GetItem(swig_obj[1],i);
        if (_PyString_Check(obj)) {
          arg3[i] = (char *)_PyString_AsString(PyList_GetItem(swig_obj[1],i));
        } else {
          PyErr_SetString(PyExc_TypeError, "list must contain strings");
          free(arg3);
          return NULL;
        }
      }
      arg3[i] = 0;
    } else {
      PyErr_SetString(PyExc_TypeError, "not a list");
      return NULL;
    }
  }
  ecode4 = SWIG_AsVal_size_t(swig_obj[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "DataFrame_setArrayStrStr" "', argument " "4"" of type '" "std::size_t""'");
  } 
  arg4 = static_cast< std::size_t >(val4);
  {
    try {
      ampl_DataFrame_setArraySWIG(arg1,(char const *(*))arg2,(char const *const *)arg3,arg4);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  {
    free((char *)arg2);
  }
  {
    free((char *)arg3);
  }
  return resultobj;
fail:
  {
    free((char *)arg2);
  }
  {
    free((char *)arg3);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_setMatrixDblDblDbl(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  double *arg2 = (double *) 0 ;
  std::size_t arg3 ;
  double *arg4 = (double *) 0 ;
  std::size_t arg5 ;
  double *arg6 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  size_t val5 ;
  int ecode5 = 0 ;
  PyObject *swig_obj[6] ;
  
  if (!SWIG_Python_UnpackTuple(args, "DataFrame_setMatrixDblDblDbl", 5, 5, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_setMatrixDblDblDbl" "', argument " "1"" of type '" "ampl::DataFrame *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  {
    /* Check if is a list */
    if (PyList_Check(swig_obj[0])) {
      int size = PyList_Size(swig_obj[0]);
      int i = 0;
      arg2 = (double *)malloc(size * sizeof(double));
      for (i = 0; i < size; i++) {
        PyObject *o = PyList_GetItem(swig_obj[0],i);
        if (PyFloat_Check(o))
        arg2[i] = PyFloat_AsDouble(PyList_GetItem(swig_obj[0],i));
        else {
          PyErr_SetString(PyExc_TypeError, "The input list must contain floating point numbers");
          free(arg2);
          return NULL;
        }
      }
    }
    else {
      PyErr_SetString(PyExc_TypeError,"The input is not a list");
      return NULL;
    }
  }
  ecode3 = SWIG_AsVal_size_t(swig_obj[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "DataFrame_setMatrixDblDblDbl" "', argument " "3"" of type '" "std::size_t""'");
  } 
  arg3 = static_cast< std::size_t >(val3);
  {
    /* Check if is a list */
    if (PyList_Check(swig_obj[2])) {
      int size = PyList_Size(swig_obj[2]);
      int i = 0;
      arg4 = (double *)malloc(size * sizeof(double));
      for (i = 0; i < size; i++) {
        PyObject *o = PyList_GetItem(swig_obj[2],i);
        if (PyFloat_Check(o))
        arg4[i] = PyFloat_AsDouble(PyList_GetItem(swig_obj[2],i));
        else {
          PyErr_SetString(PyExc_TypeError, "The input list must contain floating point numbers");
          free(arg4);
          return NULL;
        }
      }
    }
    else {
      PyErr_SetString(PyExc_TypeError,"The input is not a list");
      return NULL;
    }
  }
  ecode5 = SWIG_AsVal_size_t(swig_obj[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "DataFrame_setMatrixDblDblDbl" "', argument " "5"" of type '" "std::size_t""'");
  } 
  arg5 = static_cast< std::size_t >(val5);
  {
    /* Check if is a list */
    if (PyList_Check(swig_obj[4])) {
      int size = PyList_Size(swig_obj[4]);
      int i = 0;
      arg6 = (double *)malloc(size * sizeof(double));
      for (i = 0; i < size; i++) {
        PyObject *o = PyList_GetItem(swig_obj[4],i);
        if (PyFloat_Check(o))
        arg6[i] = PyFloat_AsDouble(PyList_GetItem(swig_obj[4],i));
        else {
          PyErr_SetString(PyExc_TypeError, "The input list must contain floating point numbers");
          free(arg6);
          return NULL;
        }
      }
    }
    else {
      PyErr_SetString(PyExc_TypeError,"The input is not a list");
      return NULL;
    }
  }
  {
    try {
      ampl_DataFrame_setMatrixSWIG(arg1,arg2,arg3,arg4,arg5,(double const *)arg6);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  {
    free((double *)arg2);
  }
  {
    free((double *)arg4);
  }
  {
    free((double *)arg6);
  }
  return resultobj;
fail:
  {
    free((double *)arg2);
  }
  {
    free((double *)arg4);
  }
  {
    free((double *)arg6);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_setMatrixStrStrDbl(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  char **arg2 ;
  std::size_t arg3 ;
  char **arg4 ;
  std::size_t arg5 ;
  double *arg6 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  size_t val5 ;
  int ecode5 = 0 ;
  PyObject *swig_obj[6] ;
  
  if (!SWIG_Python_UnpackTuple(args, "DataFrame_setMatrixStrStrDbl", 5, 5, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_setMatrixStrStrDbl" "', argument " "1"" of type '" "ampl::DataFrame *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2,SWIGTYPE_p_p_char, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DataFrame_setMatrixStrStrDbl" "', argument " "2"" of type '" "char const *[]""'"); 
  } 
  arg2 = reinterpret_cast< char ** >(argp2);
  ecode3 = SWIG_AsVal_size_t(swig_obj[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "DataFrame_setMatrixStrStrDbl" "', argument " "3"" of type '" "std::size_t""'");
  } 
  arg3 = static_cast< std::size_t >(val3);
  res4 = SWIG_ConvertPtr(swig_obj[2], &argp4,SWIGTYPE_p_p_char, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "DataFrame_setMatrixStrStrDbl" "', argument " "4"" of type '" "char const *[]""'"); 
  } 
  arg4 = reinterpret_cast< char ** >(argp4);
  ecode5 = SWIG_AsVal_size_t(swig_obj[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "DataFrame_setMatrixStrStrDbl" "', argument " "5"" of type '" "std::size_t""'");
  } 
  arg5 = static_cast< std::size_t >(val5);
  {
    /* Check if is a list */
    if (PyList_Check(swig_obj[4])) {
      int size = PyList_Size(swig_obj[4]);
      int i = 0;
      arg6 = (double *)malloc(size * sizeof(double));
      for (i = 0; i < size; i++) {
        PyObject *o = PyList_GetItem(swig_obj[4],i);
        if (PyFloat_Check(o))
        arg6[i] = PyFloat_AsDouble(PyList_GetItem(swig_obj[4],i));
        else {
          PyErr_SetString(PyExc_TypeError, "The input list must contain floating point numbers");
          free(arg6);
          return NULL;
        }
      }
    }
    else {
      PyErr_SetString(PyExc_TypeError,"The input is not a list");
      return NULL;
    }
  }
  {
    try {
      ampl_DataFrame_setMatrixSWIG(arg1,(char const *(*))arg2,arg3,(char const *(*))arg4,arg5,(double const *)arg6);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  {
    free((double *)arg6);
  }
  return resultobj;
fail:
  {
    free((double *)arg6);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_setMatrixDblStrDbl(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  double *arg2 = (double *) 0 ;
  std::size_t arg3 ;
  char **arg4 ;
  std::size_t arg5 ;
  double *arg6 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  size_t val5 ;
  int ecode5 = 0 ;
  PyObject *swig_obj[6] ;
  
  if (!SWIG_Python_UnpackTuple(args, "DataFrame_setMatrixDblStrDbl", 5, 5, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_setMatrixDblStrDbl" "', argument " "1"" of type '" "ampl::DataFrame *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  {
    /* Check if is a list */
    if (PyList_Check(swig_obj[0])) {
      int size = PyList_Size(swig_obj[0]);
      int i = 0;
      arg2 = (double *)malloc(size * sizeof(double));
      for (i = 0; i < size; i++) {
        PyObject *o = PyList_GetItem(swig_obj[0],i);
        if (PyFloat_Check(o))
        arg2[i] = PyFloat_AsDouble(PyList_GetItem(swig_obj[0],i));
        else {
          PyErr_SetString(PyExc_TypeError, "The input list must contain floating point numbers");
          free(arg2);
          return NULL;
        }
      }
    }
    else {
      PyErr_SetString(PyExc_TypeError,"The input is not a list");
      return NULL;
    }
  }
  ecode3 = SWIG_AsVal_size_t(swig_obj[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "DataFrame_setMatrixDblStrDbl" "', argument " "3"" of type '" "std::size_t""'");
  } 
  arg3 = static_cast< std::size_t >(val3);
  res4 = SWIG_ConvertPtr(swig_obj[2], &argp4,SWIGTYPE_p_p_char, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "DataFrame_setMatrixDblStrDbl" "', argument " "4"" of type '" "char const *[]""'"); 
  } 
  arg4 = reinterpret_cast< char ** >(argp4);
  ecode5 = SWIG_AsVal_size_t(swig_obj[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "DataFrame_setMatrixDblStrDbl" "', argument " "5"" of type '" "std::size_t""'");
  } 
  arg5 = static_cast< std::size_t >(val5);
  {
    /* Check if is a list */
    if (PyList_Check(swig_obj[4])) {
      int size = PyList_Size(swig_obj[4]);
      int i = 0;
      arg6 = (double *)malloc(size * sizeof(double));
      for (i = 0; i < size; i++) {
        PyObject *o = PyList_GetItem(swig_obj[4],i);
        if (PyFloat_Check(o))
        arg6[i] = PyFloat_AsDouble(PyList_GetItem(swig_obj[4],i));
        else {
          PyErr_SetString(PyExc_TypeError, "The input list must contain floating point numbers");
          free(arg6);
          return NULL;
        }
      }
    }
    else {
      PyErr_SetString(PyExc_TypeError,"The input is not a list");
      return NULL;
    }
  }
  {
    try {
      ampl_DataFrame_setMatrixSWIG(arg1,arg2,arg3,(char const *(*))arg4,arg5,(double const *)arg6);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  {
    free((double *)arg2);
  }
  {
    free((double *)arg6);
  }
  return resultobj;
fail:
  {
    free((double *)arg2);
  }
  {
    free((double *)arg6);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_setMatrixStrDblDbl(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  char **arg2 ;
  std::size_t arg3 ;
  double *arg4 = (double *) 0 ;
  std::size_t arg5 ;
  double *arg6 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  size_t val5 ;
  int ecode5 = 0 ;
  PyObject *swig_obj[6] ;
  
  if (!SWIG_Python_UnpackTuple(args, "DataFrame_setMatrixStrDblDbl", 5, 5, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_setMatrixStrDblDbl" "', argument " "1"" of type '" "ampl::DataFrame *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2,SWIGTYPE_p_p_char, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DataFrame_setMatrixStrDblDbl" "', argument " "2"" of type '" "char const *[]""'"); 
  } 
  arg2 = reinterpret_cast< char ** >(argp2);
  ecode3 = SWIG_AsVal_size_t(swig_obj[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "DataFrame_setMatrixStrDblDbl" "', argument " "3"" of type '" "std::size_t""'");
  } 
  arg3 = static_cast< std::size_t >(val3);
  {
    /* Check if is a list */
    if (PyList_Check(swig_obj[2])) {
      int size = PyList_Size(swig_obj[2]);
      int i = 0;
      arg4 = (double *)malloc(size * sizeof(double));
      for (i = 0; i < size; i++) {
        PyObject *o = PyList_GetItem(swig_obj[2],i);
        if (PyFloat_Check(o))
        arg4[i] = PyFloat_AsDouble(PyList_GetItem(swig_obj[2],i));
        else {
          PyErr_SetString(PyExc_TypeError, "The input list must contain floating point numbers");
          free(arg4);
          return NULL;
        }
      }
    }
    else {
      PyErr_SetString(PyExc_TypeError,"The input is not a list");
      return NULL;
    }
  }
  ecode5 = SWIG_AsVal_size_t(swig_obj[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "DataFrame_setMatrixStrDblDbl" "', argument " "5"" of type '" "std::size_t""'");
  } 
  arg5 = static_cast< std::size_t >(val5);
  {
    /* Check if is a list */
    if (PyList_Check(swig_obj[4])) {
      int size = PyList_Size(swig_obj[4]);
      int i = 0;
      arg6 = (double *)malloc(size * sizeof(double));
      for (i = 0; i < size; i++) {
        PyObject *o = PyList_GetItem(swig_obj[4],i);
        if (PyFloat_Check(o))
        arg6[i] = PyFloat_AsDouble(PyList_GetItem(swig_obj[4],i));
        else {
          PyErr_SetString(PyExc_TypeError, "The input list must contain floating point numbers");
          free(arg6);
          return NULL;
        }
      }
    }
    else {
      PyErr_SetString(PyExc_TypeError,"The input is not a list");
      return NULL;
    }
  }
  {
    try {
      ampl_DataFrame_setMatrixSWIG(arg1,(char const *(*))arg2,arg3,arg4,arg5,(double const *)arg6);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  {
    free((double *)arg4);
  }
  {
    free((double *)arg6);
  }
  return resultobj;
fail:
  {
    free((double *)arg4);
  }
  {
    free((double *)arg6);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_setMatrixDblDblStr(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  double *arg2 = (double *) 0 ;
  std::size_t arg3 ;
  double *arg4 = (double *) 0 ;
  std::size_t arg5 ;
  char **arg6 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  size_t val5 ;
  int ecode5 = 0 ;
  PyObject *swig_obj[6] ;
  
  {
    arg6 = NULL;
  }
  if (!SWIG_Python_UnpackTuple(args, "DataFrame_setMatrixDblDblStr", 5, 5, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_setMatrixDblDblStr" "', argument " "1"" of type '" "ampl::DataFrame *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  {
    /* Check if is a list */
    if (PyList_Check(swig_obj[0])) {
      int size = PyList_Size(swig_obj[0]);
      int i = 0;
      arg2 = (double *)malloc(size * sizeof(double));
      for (i = 0; i < size; i++) {
        PyObject *o = PyList_GetItem(swig_obj[0],i);
        if (PyFloat_Check(o))
        arg2[i] = PyFloat_AsDouble(PyList_GetItem(swig_obj[0],i));
        else {
          PyErr_SetString(PyExc_TypeError, "The input list must contain floating point numbers");
          free(arg2);
          return NULL;
        }
      }
    }
    else {
      PyErr_SetString(PyExc_TypeError,"The input is not a list");
      return NULL;
    }
  }
  ecode3 = SWIG_AsVal_size_t(swig_obj[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "DataFrame_setMatrixDblDblStr" "', argument " "3"" of type '" "std::size_t""'");
  } 
  arg3 = static_cast< std::size_t >(val3);
  {
    /* Check if is a list */
    if (PyList_Check(swig_obj[2])) {
      int size = PyList_Size(swig_obj[2]);
      int i = 0;
      arg4 = (double *)malloc(size * sizeof(double));
      for (i = 0; i < size; i++) {
        PyObject *o = PyList_GetItem(swig_obj[2],i);
        if (PyFloat_Check(o))
        arg4[i] = PyFloat_AsDouble(PyList_GetItem(swig_obj[2],i));
        else {
          PyErr_SetString(PyExc_TypeError, "The input list must contain floating point numbers");
          free(arg4);
          return NULL;
        }
      }
    }
    else {
      PyErr_SetString(PyExc_TypeError,"The input is not a list");
      return NULL;
    }
  }
  ecode5 = SWIG_AsVal_size_t(swig_obj[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "DataFrame_setMatrixDblDblStr" "', argument " "5"" of type '" "std::size_t""'");
  } 
  arg5 = static_cast< std::size_t >(val5);
  {
    /* Check if is a list */
    if (PyList_Check(swig_obj[4])) {
      std::size_t size = PyList_Size(swig_obj[4]);
      std::size_t i = 0;
      arg6 = (char **)malloc((size + 1) * sizeof(char *));
      for (i = 0; i < size; i++) {
        PyObject *obj = PyList_GetItem(swig_obj[4],i);
        if (_PyString_Check(obj)) {
          arg6[i] = (char *)_PyString_AsString(PyList_GetItem(swig_obj[4],i));
        } else {
          PyErr_SetString(PyExc_TypeError, "list must contain strings");
          free(arg6);
          return NULL;
        }
      }
      arg6[i] = 0;
    } else {
      PyErr_SetString(PyExc_TypeError, "not a list");
      return NULL;
    }
  }
  {
    try {
      ampl_DataFrame_setMatrixSWIG(arg1,arg2,arg3,arg4,arg5,(char const *(*))arg6);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  {
    free((double *)arg2);
  }
  {
    free((double *)arg4);
  }
  {
    free((char *)arg6);
  }
  return resultobj;
fail:
  {
    free((double *)arg2);
  }
  {
    free((double *)arg4);
  }
  {
    free((char *)arg6);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_setMatrixDblStrStr(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  double *arg2 = (double *) 0 ;
  std::size_t arg3 ;
  char **arg4 ;
  std::size_t arg5 ;
  char **arg6 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  size_t val5 ;
  int ecode5 = 0 ;
  PyObject *swig_obj[6] ;
  
  {
    arg6 = NULL;
  }
  if (!SWIG_Python_UnpackTuple(args, "DataFrame_setMatrixDblStrStr", 5, 5, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_setMatrixDblStrStr" "', argument " "1"" of type '" "ampl::DataFrame *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  {
    /* Check if is a list */
    if (PyList_Check(swig_obj[0])) {
      int size = PyList_Size(swig_obj[0]);
      int i = 0;
      arg2 = (double *)malloc(size * sizeof(double));
      for (i = 0; i < size; i++) {
        PyObject *o = PyList_GetItem(swig_obj[0],i);
        if (PyFloat_Check(o))
        arg2[i] = PyFloat_AsDouble(PyList_GetItem(swig_obj[0],i));
        else {
          PyErr_SetString(PyExc_TypeError, "The input list must contain floating point numbers");
          free(arg2);
          return NULL;
        }
      }
    }
    else {
      PyErr_SetString(PyExc_TypeError,"The input is not a list");
      return NULL;
    }
  }
  ecode3 = SWIG_AsVal_size_t(swig_obj[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "DataFrame_setMatrixDblStrStr" "', argument " "3"" of type '" "std::size_t""'");
  } 
  arg3 = static_cast< std::size_t >(val3);
  res4 = SWIG_ConvertPtr(swig_obj[2], &argp4,SWIGTYPE_p_p_char, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "DataFrame_setMatrixDblStrStr" "', argument " "4"" of type '" "char const *[]""'"); 
  } 
  arg4 = reinterpret_cast< char ** >(argp4);
  ecode5 = SWIG_AsVal_size_t(swig_obj[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "DataFrame_setMatrixDblStrStr" "', argument " "5"" of type '" "std::size_t""'");
  } 
  arg5 = static_cast< std::size_t >(val5);
  {
    /* Check if is a list */
    if (PyList_Check(swig_obj[4])) {
      std::size_t size = PyList_Size(swig_obj[4]);
      std::size_t i = 0;
      arg6 = (char **)malloc((size + 1) * sizeof(char *));
      for (i = 0; i < size; i++) {
        PyObject *obj = PyList_GetItem(swig_obj[4],i);
        if (_PyString_Check(obj)) {
          arg6[i] = (char *)_PyString_AsString(PyList_GetItem(swig_obj[4],i));
        } else {
          PyErr_SetString(PyExc_TypeError, "list must contain strings");
          free(arg6);
          return NULL;
        }
      }
      arg6[i] = 0;
    } else {
      PyErr_SetString(PyExc_TypeError, "not a list");
      return NULL;
    }
  }
  {
    try {
      ampl_DataFrame_setMatrixSWIG(arg1,arg2,arg3,(char const *(*))arg4,arg5,(char const *(*))arg6);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  {
    free((double *)arg2);
  }
  {
    free((char *)arg6);
  }
  return resultobj;
fail:
  {
    free((double *)arg2);
  }
  {
    free((char *)arg6);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_setMatrixStrDblStr(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  char **arg2 ;
  std::size_t arg3 ;
  double *arg4 = (double *) 0 ;
  std::size_t arg5 ;
  char **arg6 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  size_t val5 ;
  int ecode5 = 0 ;
  PyObject *swig_obj[6] ;
  
  {
    arg6 = NULL;
  }
  if (!SWIG_Python_UnpackTuple(args, "DataFrame_setMatrixStrDblStr", 5, 5, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_setMatrixStrDblStr" "', argument " "1"" of type '" "ampl::DataFrame *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2,SWIGTYPE_p_p_char, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DataFrame_setMatrixStrDblStr" "', argument " "2"" of type '" "char const *[]""'"); 
  } 
  arg2 = reinterpret_cast< char ** >(argp2);
  ecode3 = SWIG_AsVal_size_t(swig_obj[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "DataFrame_setMatrixStrDblStr" "', argument " "3"" of type '" "std::size_t""'");
  } 
  arg3 = static_cast< std::size_t >(val3);
  {
    /* Check if is a list */
    if (PyList_Check(swig_obj[2])) {
      int size = PyList_Size(swig_obj[2]);
      int i = 0;
      arg4 = (double *)malloc(size * sizeof(double));
      for (i = 0; i < size; i++) {
        PyObject *o = PyList_GetItem(swig_obj[2],i);
        if (PyFloat_Check(o))
        arg4[i] = PyFloat_AsDouble(PyList_GetItem(swig_obj[2],i));
        else {
          PyErr_SetString(PyExc_TypeError, "The input list must contain floating point numbers");
          free(arg4);
          return NULL;
        }
      }
    }
    else {
      PyErr_SetString(PyExc_TypeError,"The input is not a list");
      return NULL;
    }
  }
  ecode5 = SWIG_AsVal_size_t(swig_obj[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "DataFrame_setMatrixStrDblStr" "', argument " "5"" of type '" "std::size_t""'");
  } 
  arg5 = static_cast< std::size_t >(val5);
  {
    /* Check if is a list */
    if (PyList_Check(swig_obj[4])) {
      std::size_t size = PyList_Size(swig_obj[4]);
      std::size_t i = 0;
      arg6 = (char **)malloc((size + 1) * sizeof(char *));
      for (i = 0; i < size; i++) {
        PyObject *obj = PyList_GetItem(swig_obj[4],i);
        if (_PyString_Check(obj)) {
          arg6[i] = (char *)_PyString_AsString(PyList_GetItem(swig_obj[4],i));
        } else {
          PyErr_SetString(PyExc_TypeError, "list must contain strings");
          free(arg6);
          return NULL;
        }
      }
      arg6[i] = 0;
    } else {
      PyErr_SetString(PyExc_TypeError, "not a list");
      return NULL;
    }
  }
  {
    try {
      ampl_DataFrame_setMatrixSWIG(arg1,(char const *(*))arg2,arg3,arg4,arg5,(char const *(*))arg6);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  {
    free((double *)arg4);
  }
  {
    free((char *)arg6);
  }
  return resultobj;
fail:
  {
    free((double *)arg4);
  }
  {
    free((char *)arg6);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_setMatrixStrStrStr(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  char **arg2 ;
  std::size_t arg3 ;
  char **arg4 ;
  std::size_t arg5 ;
  char **arg6 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  size_t val5 ;
  int ecode5 = 0 ;
  PyObject *swig_obj[6] ;
  
  {
    arg6 = NULL;
  }
  if (!SWIG_Python_UnpackTuple(args, "DataFrame_setMatrixStrStrStr", 5, 5, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_setMatrixStrStrStr" "', argument " "1"" of type '" "ampl::DataFrame *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2,SWIGTYPE_p_p_char, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DataFrame_setMatrixStrStrStr" "', argument " "2"" of type '" "char const *[]""'"); 
  } 
  arg2 = reinterpret_cast< char ** >(argp2);
  ecode3 = SWIG_AsVal_size_t(swig_obj[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "DataFrame_setMatrixStrStrStr" "', argument " "3"" of type '" "std::size_t""'");
  } 
  arg3 = static_cast< std::size_t >(val3);
  res4 = SWIG_ConvertPtr(swig_obj[2], &argp4,SWIGTYPE_p_p_char, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "DataFrame_setMatrixStrStrStr" "', argument " "4"" of type '" "char const *[]""'"); 
  } 
  arg4 = reinterpret_cast< char ** >(argp4);
  ecode5 = SWIG_AsVal_size_t(swig_obj[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "DataFrame_setMatrixStrStrStr" "', argument " "5"" of type '" "std::size_t""'");
  } 
  arg5 = static_cast< std::size_t >(val5);
  {
    /* Check if is a list */
    if (PyList_Check(swig_obj[4])) {
      std::size_t size = PyList_Size(swig_obj[4]);
      std::size_t i = 0;
      arg6 = (char **)malloc((size + 1) * sizeof(char *));
      for (i = 0; i < size; i++) {
        PyObject *obj = PyList_GetItem(swig_obj[4],i);
        if (_PyString_Check(obj)) {
          arg6[i] = (char *)_PyString_AsString(PyList_GetItem(swig_obj[4],i));
        } else {
          PyErr_SetString(PyExc_TypeError, "list must contain strings");
          free(arg6);
          return NULL;
        }
      }
      arg6[i] = 0;
    } else {
      PyErr_SetString(PyExc_TypeError, "not a list");
      return NULL;
    }
  }
  {
    try {
      ampl_DataFrame_setMatrixSWIG(arg1,(char const *(*))arg2,arg3,(char const *(*))arg4,arg5,(char const *(*))arg6);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  {
    free((char *)arg6);
  }
  return resultobj;
fail:
  {
    free((char *)arg6);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_factory(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  int arg1 ;
  char **arg2 ;
  int arg3 ;
  int val1 ;
  int ecode1 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  SwigValueWrapper< ampl::DataFrame > result;
  
  {
    arg2 = NULL;
  }
  if (!SWIG_Python_UnpackTuple(args, "DataFrame_factory", 3, 3, swig_obj)) SWIG_fail;
  ecode1 = SWIG_AsVal_int(swig_obj[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "DataFrame_factory" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = static_cast< int >(val1);
  {
    /* Check if is a list */
    if (PyList_Check(swig_obj[1])) {
      std::size_t size = PyList_Size(swig_obj[1]);
      std::size_t i = 0;
      arg2 = (char **)malloc((size + 1) * sizeof(char *));
      for (i = 0; i < size; i++) {
        PyObject *obj = PyList_GetItem(swig_obj[1],i);
        if (_PyString_Check(obj)) {
          arg2[i] = (char *)_PyString_AsString(PyList_GetItem(swig_obj[1],i));
        } else {
          PyErr_SetString(PyExc_TypeError, "list must contain strings");
          free(arg2);
          return NULL;
        }
      }
      arg2[i] = 0;
    } else {
      PyErr_SetString(PyExc_TypeError, "not a list");
      return NULL;
    }
  }
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "DataFrame_factory" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  {
    try {
      result = ampl_DataFrame_factory(arg1,(char const *(*))arg2,arg3);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::DataFrame(static_cast< const ampl::DataFrame& >(result))), SWIGTYPE_p_ampl__DataFrame, SWIG_POINTER_OWN |  0 );
  {
    free((char *)arg2);
  }
  return resultobj;
fail:
  {
    free((char *)arg2);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_setColumnPyList(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  fmt::CStringRef arg2 ;
  PyObject *arg3 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args, "DataFrame_setColumnPyList", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_setColumnPyList" "', argument " "1"" of type '" "ampl::DataFrame *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  
  arg2 = _PyString_AsString(swig_obj[0]);
  
  arg3 = swig_obj[1];
  {
    try {
      ampl_DataFrame_setColumnPyList(arg1,arg2,arg3);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_DataFrame) /* defines _wrap_delete_DataFrame_destructor_closure */

SWIGINTERN PyObject *_wrap_DataFrameColumn_size(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::Slice< false > *arg1 = (ampl::internal::Slice< false > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::size_t result;
  
  if (!SWIG_Python_UnpackTuple(args, "DataFrameColumn_size", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__SliceT_false_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrameColumn_size" "', argument " "1"" of type '" "ampl::internal::Slice< false > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::Slice< false > * >(argp1);
  {
    try {
      result = ((ampl::internal::Slice< false > const *)arg1)->size();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrameColumn_begin(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::Slice< false > *arg1 = (ampl::internal::Slice< false > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  SwigValueWrapper< ampl::internal::Slice< false >::iterator > result;
  
  if (!SWIG_Python_UnpackTuple(args, "DataFrameColumn_begin", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__SliceT_false_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrameColumn_begin" "', argument " "1"" of type '" "ampl::internal::Slice< false > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::Slice< false > * >(argp1);
  {
    try {
      result = ((ampl::internal::Slice< false > const *)arg1)->begin();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::internal::Slice< false >::iterator(static_cast< const ampl::internal::Slice< false >::iterator& >(result))), SWIGTYPE_p_ampl__internal__SliceT_false_t__iterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrameColumn_end(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::Slice< false > *arg1 = (ampl::internal::Slice< false > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  SwigValueWrapper< ampl::internal::Slice< false >::iterator > result;
  
  if (!SWIG_Python_UnpackTuple(args, "DataFrameColumn_end", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__SliceT_false_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrameColumn_end" "', argument " "1"" of type '" "ampl::internal::Slice< false > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::Slice< false > * >(argp1);
  {
    try {
      result = ((ampl::internal::Slice< false > const *)arg1)->end();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::internal::Slice< false >::iterator(static_cast< const ampl::internal::Slice< false >::iterator& >(result))), SWIGTYPE_p_ampl__internal__SliceT_false_t__iterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrameColumn_getIndex(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::Slice< false > *arg1 = (ampl::internal::Slice< false > *) 0 ;
  std::size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  SwigValueWrapper< ampl::VariantRef > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__SliceT_false_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrameColumn_getIndex" "', argument " "1"" of type '" "ampl::internal::Slice< false > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::Slice< false > * >(argp1);
  ecode2 = SWIG_AsVal_size_t(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DataFrameColumn_getIndex" "', argument " "2"" of type '" "std::size_t""'");
  } 
  arg2 = static_cast< std::size_t >(val2);
  {
    try {
      result = ((ampl::internal::Slice< false > const *)arg1)->operator [](arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  {
    switch ((&result)->type()) {
    case ampl::STRING:
      resultobj = PyString_FromString((&result)->c_str());
      break;
    case ampl::NUMERIC:
      resultobj = PyFloat_FromDouble((&result)->dbl());
      break;
    default:
      resultobj = Py_None;
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrameColumn_toPyList(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::Slice< false > *arg1 = (ampl::internal::Slice< false > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "DataFrameColumn_toPyList", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__SliceT_false_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrameColumn_toPyList" "', argument " "1"" of type '" "ampl::internal::Slice< false > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::Slice< false > * >(argp1);
  {
    try {
      result = (PyObject *)ampl_internal_Slice_Sl_false_Sg__toPyList(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_DataFrameColumn(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::Slice< false > *arg1 = (ampl::internal::Slice< false > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_DataFrameColumn", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__SliceT_false_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_DataFrameColumn" "', argument " "1"" of type '" "ampl::internal::Slice< false > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::Slice< false > * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_DataFrameColumn) /* defines _wrap_delete_DataFrameColumn_destructor_closure */

SWIGINTERN PyObject *_wrap_ColIterator_equals(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::Slice< false >::iterator *arg1 = (ampl::internal::Slice< false >::iterator *) 0 ;
  ampl::internal::Slice< false >::iterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__SliceT_false_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ColIterator_equals" "', argument " "1"" of type '" "ampl::internal::Slice< false >::iterator const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::Slice< false >::iterator * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ampl__internal__SliceT_false_t__iterator,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ColIterator_equals" "', argument " "2"" of type '" "ampl::internal::Slice< false >::iterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ColIterator_equals" "', argument " "2"" of type '" "ampl::internal::Slice< false >::iterator const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::internal::Slice< false >::iterator * >(argp2);
  {
    try {
      result = (bool)((ampl::internal::Slice< false >::iterator const *)arg1)->operator ==((ampl::internal::Slice< false >::iterator const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_ColIterator_differs(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::Slice< false >::iterator *arg1 = (ampl::internal::Slice< false >::iterator *) 0 ;
  ampl::internal::Slice< false >::iterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__SliceT_false_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ColIterator_differs" "', argument " "1"" of type '" "ampl::internal::Slice< false >::iterator const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::Slice< false >::iterator * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ampl__internal__SliceT_false_t__iterator,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ColIterator_differs" "', argument " "2"" of type '" "ampl::internal::Slice< false >::iterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ColIterator_differs" "', argument " "2"" of type '" "ampl::internal::Slice< false >::iterator const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::internal::Slice< false >::iterator * >(argp2);
  {
    try {
      result = (bool)((ampl::internal::Slice< false >::iterator const *)arg1)->operator !=((ampl::internal::Slice< false >::iterator const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_ColIterator___ref__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::Slice< false >::iterator *arg1 = (ampl::internal::Slice< false >::iterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  SwigValueWrapper< ampl::VariantRef > result;
  
  if (!SWIG_Python_UnpackTuple(args, "ColIterator___ref__", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__SliceT_false_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ColIterator___ref__" "', argument " "1"" of type '" "ampl::internal::Slice< false >::iterator const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::Slice< false >::iterator * >(argp1);
  {
    try {
      result = ((ampl::internal::Slice< false >::iterator const *)arg1)->operator *();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  {
    switch ((&result)->type()) {
    case ampl::STRING:
      resultobj = PyString_FromString((&result)->c_str());
      break;
    case ampl::NUMERIC:
      resultobj = PyFloat_FromDouble((&result)->dbl());
      break;
    default:
      resultobj = Py_None;
    }
  }
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_ColIterator_clone(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::Slice< false >::iterator *arg1 = (ampl::internal::Slice< false >::iterator *) 0 ;
  ampl::internal::Slice< false >::iterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  ampl::internal::Slice< false >::iterator *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__SliceT_false_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ColIterator_clone" "', argument " "1"" of type '" "ampl::internal::Slice< false >::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::Slice< false >::iterator * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ampl__internal__SliceT_false_t__iterator,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ColIterator_clone" "', argument " "2"" of type '" "ampl::internal::Slice< false >::iterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ColIterator_clone" "', argument " "2"" of type '" "ampl::internal::Slice< false >::iterator const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::internal::Slice< false >::iterator * >(argp2);
  {
    try {
      result = (ampl::internal::Slice< false >::iterator *) &(arg1)->operator =((ampl::internal::Slice< false >::iterator const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__internal__SliceT_false_t__iterator, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ColIterator_postIncrement(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::Slice< false >::iterator *arg1 = (ampl::internal::Slice< false >::iterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ampl::internal::Slice< false >::iterator *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "ColIterator_postIncrement", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__SliceT_false_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ColIterator_postIncrement" "', argument " "1"" of type '" "ampl::internal::Slice< false >::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::Slice< false >::iterator * >(argp1);
  {
    try {
      result = (ampl::internal::Slice< false >::iterator *) &(arg1)->operator ++();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__internal__SliceT_false_t__iterator, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ColIterator_postIncrementBy(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::Slice< false >::iterator *arg1 = (ampl::internal::Slice< false >::iterator *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  SwigValueWrapper< ampl::internal::Slice< false >::iterator > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__SliceT_false_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ColIterator_postIncrementBy" "', argument " "1"" of type '" "ampl::internal::Slice< false >::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::Slice< false >::iterator * >(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ColIterator_postIncrementBy" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  {
    try {
      result = (arg1)->operator ++(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::internal::Slice< false >::iterator(static_cast< const ampl::internal::Slice< false >::iterator& >(result))), SWIGTYPE_p_ampl__internal__SliceT_false_t__iterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ColIterator(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::Slice< false >::iterator *arg1 = (ampl::internal::Slice< false >::iterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_ColIterator", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__SliceT_false_t__iterator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ColIterator" "', argument " "1"" of type '" "ampl::internal::Slice< false >::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::Slice< false >::iterator * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_ColIterator) /* defines _wrap_delete_ColIterator_destructor_closure */

SWIGINTERN PyObject *_wrap_DataFrameRow_size(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::Slice< true > *arg1 = (ampl::internal::Slice< true > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::size_t result;
  
  if (!SWIG_Python_UnpackTuple(args, "DataFrameRow_size", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__SliceT_true_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrameRow_size" "', argument " "1"" of type '" "ampl::internal::Slice< true > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::Slice< true > * >(argp1);
  {
    try {
      result = ((ampl::internal::Slice< true > const *)arg1)->size();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrameRow_begin(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::Slice< true > *arg1 = (ampl::internal::Slice< true > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  SwigValueWrapper< ampl::internal::Slice< true >::iterator > result;
  
  if (!SWIG_Python_UnpackTuple(args, "DataFrameRow_begin", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__SliceT_true_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrameRow_begin" "', argument " "1"" of type '" "ampl::internal::Slice< true > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::Slice< true > * >(argp1);
  {
    try {
      result = ((ampl::internal::Slice< true > const *)arg1)->begin();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::internal::Slice< true >::iterator(static_cast< const ampl::internal::Slice< true >::iterator& >(result))), SWIGTYPE_p_ampl__internal__SliceT_true_t__iterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrameRow_end(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::Slice< true > *arg1 = (ampl::internal::Slice< true > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  SwigValueWrapper< ampl::internal::Slice< true >::iterator > result;
  
  if (!SWIG_Python_UnpackTuple(args, "DataFrameRow_end", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__SliceT_true_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrameRow_end" "', argument " "1"" of type '" "ampl::internal::Slice< true > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::Slice< true > * >(argp1);
  {
    try {
      result = ((ampl::internal::Slice< true > const *)arg1)->end();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::internal::Slice< true >::iterator(static_cast< const ampl::internal::Slice< true >::iterator& >(result))), SWIGTYPE_p_ampl__internal__SliceT_true_t__iterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrameRow_getIndex(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::Slice< true > *arg1 = (ampl::internal::Slice< true > *) 0 ;
  std::size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  SwigValueWrapper< ampl::VariantRef > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__SliceT_true_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrameRow_getIndex" "', argument " "1"" of type '" "ampl::internal::Slice< true > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::Slice< true > * >(argp1);
  ecode2 = SWIG_AsVal_size_t(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DataFrameRow_getIndex" "', argument " "2"" of type '" "std::size_t""'");
  } 
  arg2 = static_cast< std::size_t >(val2);
  {
    try {
      result = ((ampl::internal::Slice< true > const *)arg1)->operator [](arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  {
    switch ((&result)->type()) {
    case ampl::STRING:
      resultobj = PyString_FromString((&result)->c_str());
      break;
    case ampl::NUMERIC:
      resultobj = PyFloat_FromDouble((&result)->dbl());
      break;
    default:
      resultobj = Py_None;
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_DataFrameRow(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::Slice< true > *arg1 = (ampl::internal::Slice< true > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_DataFrameRow", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__SliceT_true_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_DataFrameRow" "', argument " "1"" of type '" "ampl::internal::Slice< true > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::Slice< true > * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_DataFrameRow) /* defines _wrap_delete_DataFrameRow_destructor_closure */

SWIGINTERN PyObject *_wrap_RowIterator_equals(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::Slice< true >::iterator *arg1 = (ampl::internal::Slice< true >::iterator *) 0 ;
  ampl::internal::Slice< true >::iterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__SliceT_true_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RowIterator_equals" "', argument " "1"" of type '" "ampl::internal::Slice< true >::iterator const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::Slice< true >::iterator * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ampl__internal__SliceT_true_t__iterator,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "RowIterator_equals" "', argument " "2"" of type '" "ampl::internal::Slice< true >::iterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "RowIterator_equals" "', argument " "2"" of type '" "ampl::internal::Slice< true >::iterator const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::internal::Slice< true >::iterator * >(argp2);
  {
    try {
      result = (bool)((ampl::internal::Slice< true >::iterator const *)arg1)->operator ==((ampl::internal::Slice< true >::iterator const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_RowIterator_differs(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::Slice< true >::iterator *arg1 = (ampl::internal::Slice< true >::iterator *) 0 ;
  ampl::internal::Slice< true >::iterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__SliceT_true_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RowIterator_differs" "', argument " "1"" of type '" "ampl::internal::Slice< true >::iterator const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::Slice< true >::iterator * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ampl__internal__SliceT_true_t__iterator,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "RowIterator_differs" "', argument " "2"" of type '" "ampl::internal::Slice< true >::iterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "RowIterator_differs" "', argument " "2"" of type '" "ampl::internal::Slice< true >::iterator const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::internal::Slice< true >::iterator * >(argp2);
  {
    try {
      result = (bool)((ampl::internal::Slice< true >::iterator const *)arg1)->operator !=((ampl::internal::Slice< true >::iterator const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_RowIterator___ref__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::Slice< true >::iterator *arg1 = (ampl::internal::Slice< true >::iterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  SwigValueWrapper< ampl::VariantRef > result;
  
  if (!SWIG_Python_UnpackTuple(args, "RowIterator___ref__", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__SliceT_true_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RowIterator___ref__" "', argument " "1"" of type '" "ampl::internal::Slice< true >::iterator const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::Slice< true >::iterator * >(argp1);
  {
    try {
      result = ((ampl::internal::Slice< true >::iterator const *)arg1)->operator *();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  {
    switch ((&result)->type()) {
    case ampl::STRING:
      resultobj = PyString_FromString((&result)->c_str());
      break;
    case ampl::NUMERIC:
      resultobj = PyFloat_FromDouble((&result)->dbl());
      break;
    default:
      resultobj = Py_None;
    }
  }
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_RowIterator_clone(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::Slice< true >::iterator *arg1 = (ampl::internal::Slice< true >::iterator *) 0 ;
  ampl::internal::Slice< true >::iterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  ampl::internal::Slice< true >::iterator *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__SliceT_true_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RowIterator_clone" "', argument " "1"" of type '" "ampl::internal::Slice< true >::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::Slice< true >::iterator * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ampl__internal__SliceT_true_t__iterator,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "RowIterator_clone" "', argument " "2"" of type '" "ampl::internal::Slice< true >::iterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "RowIterator_clone" "', argument " "2"" of type '" "ampl::internal::Slice< true >::iterator const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::internal::Slice< true >::iterator * >(argp2);
  {
    try {
      result = (ampl::internal::Slice< true >::iterator *) &(arg1)->operator =((ampl::internal::Slice< true >::iterator const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__internal__SliceT_true_t__iterator, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RowIterator_postIncrement(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::Slice< true >::iterator *arg1 = (ampl::internal::Slice< true >::iterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ampl::internal::Slice< true >::iterator *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "RowIterator_postIncrement", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__SliceT_true_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RowIterator_postIncrement" "', argument " "1"" of type '" "ampl::internal::Slice< true >::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::Slice< true >::iterator * >(argp1);
  {
    try {
      result = (ampl::internal::Slice< true >::iterator *) &(arg1)->operator ++();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__internal__SliceT_true_t__iterator, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RowIterator_postIncrementBy(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::Slice< true >::iterator *arg1 = (ampl::internal::Slice< true >::iterator *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  SwigValueWrapper< ampl::internal::Slice< true >::iterator > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__SliceT_true_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RowIterator_postIncrementBy" "', argument " "1"" of type '" "ampl::internal::Slice< true >::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::Slice< true >::iterator * >(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "RowIterator_postIncrementBy" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  {
    try {
      result = (arg1)->operator ++(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::internal::Slice< true >::iterator(static_cast< const ampl::internal::Slice< true >::iterator& >(result))), SWIGTYPE_p_ampl__internal__SliceT_true_t__iterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_RowIterator(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::Slice< true >::iterator *arg1 = (ampl::internal::Slice< true >::iterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_RowIterator", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__SliceT_true_t__iterator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_RowIterator" "', argument " "1"" of type '" "ampl::internal::Slice< true >::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::Slice< true >::iterator * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_RowIterator) /* defines _wrap_delete_RowIterator_destructor_closure */

SWIGINTERN PyObject *_wrap_Instance_toString(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Instance *arg1 = (ampl::Instance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "Instance_toString", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Instance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Instance_toString" "', argument " "1"" of type '" "ampl::Instance const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Instance * >(argp1);
  {
    try {
      result = ((ampl::Instance const *)arg1)->toString();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Instance_name(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Instance *arg1 = (ampl::Instance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "Instance_name", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Instance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Instance_name" "', argument " "1"" of type '" "ampl::Instance const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Instance * >(argp1);
  {
    try {
      result = ((ampl::Instance const *)arg1)->name();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Instance_entity(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Instance *arg1 = (ampl::Instance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  SwigValueWrapper< ampl::Entity > result;
  
  if (!SWIG_Python_UnpackTuple(args, "Instance_entity", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Instance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Instance_entity" "', argument " "1"" of type '" "ampl::Instance const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Instance * >(argp1);
  {
    try {
      result = ((ampl::Instance const *)arg1)->entity();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::Entity(static_cast< const ampl::Entity& >(result))), SWIGTYPE_p_ampl__Entity, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Instance_key(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Instance *arg1 = (ampl::Instance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ampl::Tuple result;
  
  if (!SWIG_Python_UnpackTuple(args, "Instance_key", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Instance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Instance_key" "', argument " "1"" of type '" "ampl::Instance const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Instance * >(argp1);
  {
    try {
      result = ((ampl::Instance const *)arg1)->key();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  {
    const ampl::TupleRef &tuple = result; // to avoid issues with result[i];
    std::size_t size = tuple.size();
    if (size != 1) {
      resultobj = PyTuple_New(size);
    }
    for (std::size_t i = 0; i < size; i++) {
      const ampl::VariantRef &v = tuple[i];
      PyObject *item = NULL;
      switch (v.type()) {
      case ampl::STRING:
        item = PyString_FromString(v.c_str());
        break;
      case ampl::NUMERIC:
        item = PyFloat_FromDouble(v.dbl());
        break;
      case ampl::EMPTY:
        item = Py_None;
        break;
      }
      if (size != 1) {
        PyTuple_SetItem(resultobj, i, item);
      } else {
        resultobj = item;
      }
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_Instance(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Instance *arg1 = (ampl::Instance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_Instance", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Instance, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Instance" "', argument " "1"" of type '" "ampl::Instance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Instance * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_Instance) /* defines _wrap_delete_Instance_destructor_closure */

SWIGINTERN PyObject *_wrap_SetInstance_size(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::SetInstance *arg1 = (ampl::SetInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::size_t result;
  
  if (!SWIG_Python_UnpackTuple(args, "SetInstance_size", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__SetInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetInstance_size" "', argument " "1"" of type '" "ampl::SetInstance const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::SetInstance * >(argp1);
  {
    try {
      result = ((ampl::SetInstance const *)arg1)->size();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SetInstance_contains(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::SetInstance *arg1 = (ampl::SetInstance *) 0 ;
  SwigValueWrapper< ampl::TupleRef > arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__SetInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetInstance_contains" "', argument " "1"" of type '" "ampl::SetInstance const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::SetInstance * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ampl__TupleRef,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetInstance_contains" "', argument " "2"" of type '" "ampl::TupleRef""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetInstance_contains" "', argument " "2"" of type '" "ampl::TupleRef""'");
    } else {
      ampl::TupleRef * temp = reinterpret_cast< ampl::TupleRef * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)((ampl::SetInstance const *)arg1)->contains(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SetInstance_getValues(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::SetInstance *arg1 = (ampl::SetInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  SwigValueWrapper< ampl::DataFrame > result;
  
  if (!SWIG_Python_UnpackTuple(args, "SetInstance_getValues", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__SetInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetInstance_getValues" "', argument " "1"" of type '" "ampl::SetInstance const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::SetInstance * >(argp1);
  {
    try {
      result = ((ampl::SetInstance const *)arg1)->getValues();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::DataFrame(static_cast< const ampl::DataFrame& >(result))), SWIGTYPE_p_ampl__DataFrame, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SetInstance_setValuesDf(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::SetInstance *arg1 = (ampl::SetInstance *) 0 ;
  SwigValueWrapper< ampl::DataFrame > arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__SetInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetInstance_setValuesDf" "', argument " "1"" of type '" "ampl::SetInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::SetInstance * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ampl__DataFrame,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetInstance_setValuesDf" "', argument " "2"" of type '" "ampl::DataFrame""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetInstance_setValuesDf" "', argument " "2"" of type '" "ampl::DataFrame""'");
    } else {
      ampl::DataFrame * temp = reinterpret_cast< ampl::DataFrame * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      (arg1)->setValues(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SetInstance_members(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::SetInstance *arg1 = (ampl::SetInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  SwigValueWrapper< ampl::SetInstance::MemberRange > result;
  
  if (!SWIG_Python_UnpackTuple(args, "SetInstance_members", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__SetInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetInstance_members" "', argument " "1"" of type '" "ampl::SetInstance const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::SetInstance * >(argp1);
  {
    try {
      result = ((ampl::SetInstance const *)arg1)->members();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::SetInstance::MemberRange(static_cast< const ampl::SetInstance::MemberRange& >(result))), SWIGTYPE_p_ampl__SetInstance__MemberRange, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SetInstance_Contains(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::SetInstance *arg1 = (ampl::SetInstance *) 0 ;
  ampl::Tuple arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__SetInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetInstance_Contains" "', argument " "1"" of type '" "ampl::SetInstance const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::SetInstance * >(argp1);
  {
    SetTupleFromPyObject(swig_obj[0], &arg2);
  }
  {
    try {
      result = (bool)ampl_SetInstance_Contains((ampl::SetInstance const *)arg1,arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SetInstance_setValuesTuples(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::SetInstance *arg1 = (ampl::SetInstance *) 0 ;
  ampl::Tuple *arg2 = (ampl::Tuple *) 0 ;
  std::size_t arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  
  {
    arg2 = NULL;
  }
  if (!SWIG_Python_UnpackTuple(args, "SetInstance_setValuesTuples", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__SetInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetInstance_setValuesTuples" "', argument " "1"" of type '" "ampl::SetInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::SetInstance * >(argp1);
  {
    /* Check if is a list */
    ampl::Tuple t;
    if (PyList_Check(swig_obj[0])) {
      int size = PyList_Size(swig_obj[0]);
      int i = 0;
      arg2 = (ampl::Tuple *)malloc(size * sizeof(ampl::Tuple));
      memset(arg2, 0, size * sizeof(ampl::Tuple));
      for (i = 0; i < size; i++) {
        PyObject *obj = PyList_GetItem(swig_obj[0], i);
        SetTupleFromPyObject(obj, &t);
        arg2[i] = t;
      }
    } else {
      SetTupleFromPyObject(swig_obj[0], &t);
      arg2 = (ampl::Tuple *)malloc(1 * sizeof(ampl::Tuple));
      memset(arg2, 0, 1 * sizeof(ampl::Tuple));
      arg2[0] = t;
    }
  }
  ecode3 = SWIG_AsVal_size_t(swig_obj[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SetInstance_setValuesTuples" "', argument " "3"" of type '" "std::size_t""'");
  } 
  arg3 = static_cast< std::size_t >(val3);
  {
    try {
      ampl_SetInstance_setValues(arg1,(ampl::Tuple const *)arg2,arg3);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  {
    free((ampl::Tuple *)arg2);
  }
  return resultobj;
fail:
  {
    free((ampl::Tuple *)arg2);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_SetInstance_setValues(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::SetInstance *arg1 = (ampl::SetInstance *) 0 ;
  TupleArray *arg2 = 0 ;
  std::size_t arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args, "SetInstance_setValues", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__SetInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetInstance_setValues" "', argument " "1"" of type '" "ampl::SetInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::SetInstance * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_TupleArray,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetInstance_setValues" "', argument " "2"" of type '" "TupleArray &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetInstance_setValues" "', argument " "2"" of type '" "TupleArray &""'"); 
  }
  arg2 = reinterpret_cast< TupleArray * >(argp2);
  ecode3 = SWIG_AsVal_size_t(swig_obj[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SetInstance_setValues" "', argument " "3"" of type '" "std::size_t""'");
  } 
  arg3 = static_cast< std::size_t >(val3);
  {
    try {
      ampl_SetInstance_setValues(arg1,*arg2,arg3);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SetInstance_setValuesDbl(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::SetInstance *arg1 = (ampl::SetInstance *) 0 ;
  double *arg2 = (double *) 0 ;
  std::size_t arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args, "SetInstance_setValuesDbl", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__SetInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetInstance_setValuesDbl" "', argument " "1"" of type '" "ampl::SetInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::SetInstance * >(argp1);
  {
    /* Check if is a list */
    if (PyList_Check(swig_obj[0])) {
      int size = PyList_Size(swig_obj[0]);
      int i = 0;
      arg2 = (double *)malloc(size * sizeof(double));
      for (i = 0; i < size; i++) {
        PyObject *o = PyList_GetItem(swig_obj[0],i);
        if (PyFloat_Check(o))
        arg2[i] = PyFloat_AsDouble(PyList_GetItem(swig_obj[0],i));
        else {
          PyErr_SetString(PyExc_TypeError, "The input list must contain floating point numbers");
          free(arg2);
          return NULL;
        }
      }
    }
    else {
      PyErr_SetString(PyExc_TypeError,"The input is not a list");
      return NULL;
    }
  }
  ecode3 = SWIG_AsVal_size_t(swig_obj[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SetInstance_setValuesDbl" "', argument " "3"" of type '" "std::size_t""'");
  } 
  arg3 = static_cast< std::size_t >(val3);
  {
    try {
      ampl_SetInstance_setValues(arg1,arg2,arg3);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  {
    free((double *)arg2);
  }
  return resultobj;
fail:
  {
    free((double *)arg2);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_SetInstance_setValuesStr(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::SetInstance *arg1 = (ampl::SetInstance *) 0 ;
  char **arg2 ;
  std::size_t arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  
  {
    arg2 = NULL;
  }
  if (!SWIG_Python_UnpackTuple(args, "SetInstance_setValuesStr", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__SetInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetInstance_setValuesStr" "', argument " "1"" of type '" "ampl::SetInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::SetInstance * >(argp1);
  {
    /* Check if is a list */
    if (PyList_Check(swig_obj[0])) {
      std::size_t size = PyList_Size(swig_obj[0]);
      std::size_t i = 0;
      arg2 = (char **)malloc((size + 1) * sizeof(char *));
      for (i = 0; i < size; i++) {
        PyObject *obj = PyList_GetItem(swig_obj[0],i);
        if (_PyString_Check(obj)) {
          arg2[i] = (char *)_PyString_AsString(PyList_GetItem(swig_obj[0],i));
        } else {
          PyErr_SetString(PyExc_TypeError, "list must contain strings");
          free(arg2);
          return NULL;
        }
      }
      arg2[i] = 0;
    } else {
      PyErr_SetString(PyExc_TypeError, "not a list");
      return NULL;
    }
  }
  ecode3 = SWIG_AsVal_size_t(swig_obj[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SetInstance_setValuesStr" "', argument " "3"" of type '" "std::size_t""'");
  } 
  arg3 = static_cast< std::size_t >(val3);
  {
    try {
      ampl_SetInstance_setValues(arg1,(char const *(*))arg2,arg3);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  {
    free((char *)arg2);
  }
  return resultobj;
fail:
  {
    free((char *)arg2);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_SetInstance(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::SetInstance *arg1 = (ampl::SetInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_SetInstance", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__SetInstance, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SetInstance" "', argument " "1"" of type '" "ampl::SetInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::SetInstance * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_SetInstance) /* defines _wrap_delete_SetInstance_destructor_closure */

SWIGINTERN int _wrap_new_MemberRange(PyObject *self, PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  ampl::internal::SetInstance *arg1 = (ampl::internal::SetInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ampl::SetInstance::MemberRange *result = 0 ;
  
  if (!SWIG_Python_CheckNoKeywords(kwargs, "new_MemberRange")) SWIG_fail;
  if (!SWIG_Python_UnpackTuple(args, "new_MemberRange", 1, 1, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_ampl__SetInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_MemberRange" "', argument " "1"" of type '" "ampl::internal::SetInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::SetInstance * >(argp1);
  {
    try {
      result = (ampl::SetInstance::MemberRange *)new ampl::SetInstance::MemberRange(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__SetInstance__MemberRange, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN PyObject *_wrap_MemberRange_begin(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::SetInstance::MemberRange *arg1 = (ampl::SetInstance::MemberRange *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  SwigValueWrapper< ampl::SetInstance::MemberRange::iterator > result;
  
  if (!SWIG_Python_UnpackTuple(args, "MemberRange_begin", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__SetInstance__MemberRange, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MemberRange_begin" "', argument " "1"" of type '" "ampl::SetInstance::MemberRange const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::SetInstance::MemberRange * >(argp1);
  {
    try {
      result = ((ampl::SetInstance::MemberRange const *)arg1)->begin();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::SetInstance::MemberRange::iterator(static_cast< const ampl::SetInstance::MemberRange::iterator& >(result))), SWIGTYPE_p_ampl__SetInstance__MemberRange__iterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MemberRange_end(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::SetInstance::MemberRange *arg1 = (ampl::SetInstance::MemberRange *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  SwigValueWrapper< ampl::SetInstance::MemberRange::iterator > result;
  
  if (!SWIG_Python_UnpackTuple(args, "MemberRange_end", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__SetInstance__MemberRange, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MemberRange_end" "', argument " "1"" of type '" "ampl::SetInstance::MemberRange const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::SetInstance::MemberRange * >(argp1);
  {
    try {
      result = ((ampl::SetInstance::MemberRange const *)arg1)->end();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::SetInstance::MemberRange::iterator(static_cast< const ampl::SetInstance::MemberRange::iterator& >(result))), SWIGTYPE_p_ampl__SetInstance__MemberRange__iterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MemberRange_size(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::SetInstance::MemberRange *arg1 = (ampl::SetInstance::MemberRange *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  size_t result;
  
  if (!SWIG_Python_UnpackTuple(args, "MemberRange_size", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__SetInstance__MemberRange, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MemberRange_size" "', argument " "1"" of type '" "ampl::SetInstance::MemberRange const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::SetInstance::MemberRange * >(argp1);
  {
    try {
      result = ((ampl::SetInstance::MemberRange const *)arg1)->size();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_MemberRange(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::SetInstance::MemberRange *arg1 = (ampl::SetInstance::MemberRange *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_MemberRange", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__SetInstance__MemberRange, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_MemberRange" "', argument " "1"" of type '" "ampl::SetInstance::MemberRange *""'"); 
  }
  arg1 = reinterpret_cast< ampl::SetInstance::MemberRange * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_MemberRange) /* defines _wrap_delete_MemberRange_destructor_closure */

SWIGINTERN PyObject *_wrap_iterator___ref__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::SetInstance::MemberRange::iterator *arg1 = (ampl::SetInstance::MemberRange::iterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  SwigValueWrapper< ampl::TupleRef > result;
  
  if (!SWIG_Python_UnpackTuple(args, "iterator___ref__", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__SetInstance__MemberRange__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "iterator___ref__" "', argument " "1"" of type '" "ampl::SetInstance::MemberRange::iterator const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::SetInstance::MemberRange::iterator * >(argp1);
  {
    try {
      result = ((ampl::SetInstance::MemberRange::iterator const *)arg1)->operator *();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  {
    const ampl::TupleRef &tuple = result; // to avoid issues with result[i];
    std::size_t size = tuple.size();
    if (size != 1) {
      resultobj = PyTuple_New(size);
    }
    for (std::size_t i = 0; i < size; i++) {
      const ampl::VariantRef &v = tuple[i];
      PyObject *item = NULL;
      switch (v.type()) {
      case ampl::STRING:
        item = PyString_FromString(v.c_str());
        break;
      case ampl::NUMERIC:
        item = PyFloat_FromDouble(v.dbl());
        break;
      case ampl::EMPTY:
        item = Py_None;
        break;
      }
      if (size != 1) {
        PyTuple_SetItem(resultobj, i, item);
      } else {
        resultobj = item;
      }
    }
  }
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_iterator_postIncrement(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::SetInstance::MemberRange::iterator *arg1 = (ampl::SetInstance::MemberRange::iterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ampl::SetInstance::MemberRange::iterator *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "iterator_postIncrement", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__SetInstance__MemberRange__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "iterator_postIncrement" "', argument " "1"" of type '" "ampl::SetInstance::MemberRange::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::SetInstance::MemberRange::iterator * >(argp1);
  {
    try {
      result = (ampl::SetInstance::MemberRange::iterator *) &(arg1)->operator ++();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__SetInstance__MemberRange__iterator, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_iterator_postIncrementBy(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::SetInstance::MemberRange::iterator *arg1 = (ampl::SetInstance::MemberRange::iterator *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  SwigValueWrapper< ampl::SetInstance::MemberRange::iterator > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__SetInstance__MemberRange__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "iterator_postIncrementBy" "', argument " "1"" of type '" "ampl::SetInstance::MemberRange::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::SetInstance::MemberRange::iterator * >(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "iterator_postIncrementBy" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  {
    try {
      result = (arg1)->operator ++(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::SetInstance::MemberRange::iterator(static_cast< const ampl::SetInstance::MemberRange::iterator& >(result))), SWIGTYPE_p_ampl__SetInstance__MemberRange__iterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_iterator_equals(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::SetInstance::MemberRange::iterator *arg1 = (ampl::SetInstance::MemberRange::iterator *) 0 ;
  ampl::SetInstance::MemberRange::iterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__SetInstance__MemberRange__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "iterator_equals" "', argument " "1"" of type '" "ampl::SetInstance::MemberRange::iterator const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::SetInstance::MemberRange::iterator * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ampl__SetInstance__MemberRange__iterator,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "iterator_equals" "', argument " "2"" of type '" "ampl::SetInstance::MemberRange::iterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "iterator_equals" "', argument " "2"" of type '" "ampl::SetInstance::MemberRange::iterator const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::SetInstance::MemberRange::iterator * >(argp2);
  {
    try {
      result = (bool)((ampl::SetInstance::MemberRange::iterator const *)arg1)->operator ==((ampl::SetInstance::MemberRange::iterator const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_iterator_differs(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::SetInstance::MemberRange::iterator *arg1 = (ampl::SetInstance::MemberRange::iterator *) 0 ;
  ampl::SetInstance::MemberRange::iterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__SetInstance__MemberRange__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "iterator_differs" "', argument " "1"" of type '" "ampl::SetInstance::MemberRange::iterator const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::SetInstance::MemberRange::iterator * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ampl__SetInstance__MemberRange__iterator,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "iterator_differs" "', argument " "2"" of type '" "ampl::SetInstance::MemberRange::iterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "iterator_differs" "', argument " "2"" of type '" "ampl::SetInstance::MemberRange::iterator const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::SetInstance::MemberRange::iterator * >(argp2);
  {
    try {
      result = (bool)((ampl::SetInstance::MemberRange::iterator const *)arg1)->operator !=((ampl::SetInstance::MemberRange::iterator const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_delete_iterator(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::SetInstance::MemberRange::iterator *arg1 = (ampl::SetInstance::MemberRange::iterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_iterator", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__SetInstance__MemberRange__iterator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_iterator" "', argument " "1"" of type '" "ampl::SetInstance::MemberRange::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::SetInstance::MemberRange::iterator * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_iterator) /* defines _wrap_delete_iterator_destructor_closure */

SWIGINTERN PyObject *_wrap_ObjectiveInstance_value(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::ObjectiveInstance *arg1 = (ampl::ObjectiveInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "ObjectiveInstance_value", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__ObjectiveInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ObjectiveInstance_value" "', argument " "1"" of type '" "ampl::ObjectiveInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::ObjectiveInstance * >(argp1);
  {
    try {
      result = (double)(arg1)->value();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ObjectiveInstance_astatus(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::ObjectiveInstance *arg1 = (ampl::ObjectiveInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "ObjectiveInstance_astatus", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__ObjectiveInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ObjectiveInstance_astatus" "', argument " "1"" of type '" "ampl::ObjectiveInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::ObjectiveInstance * >(argp1);
  {
    try {
      result = (arg1)->astatus();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ObjectiveInstance_sstatus(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::ObjectiveInstance *arg1 = (ampl::ObjectiveInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "ObjectiveInstance_sstatus", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__ObjectiveInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ObjectiveInstance_sstatus" "', argument " "1"" of type '" "ampl::ObjectiveInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::ObjectiveInstance * >(argp1);
  {
    try {
      result = (arg1)->sstatus();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ObjectiveInstance_exitcode(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::ObjectiveInstance *arg1 = (ampl::ObjectiveInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  int result;
  
  if (!SWIG_Python_UnpackTuple(args, "ObjectiveInstance_exitcode", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__ObjectiveInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ObjectiveInstance_exitcode" "', argument " "1"" of type '" "ampl::ObjectiveInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::ObjectiveInstance * >(argp1);
  {
    try {
      result = (int)(arg1)->exitcode();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ObjectiveInstance_message(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::ObjectiveInstance *arg1 = (ampl::ObjectiveInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "ObjectiveInstance_message", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__ObjectiveInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ObjectiveInstance_message" "', argument " "1"" of type '" "ampl::ObjectiveInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::ObjectiveInstance * >(argp1);
  {
    try {
      result = (arg1)->message();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ObjectiveInstance_result(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::ObjectiveInstance *arg1 = (ampl::ObjectiveInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "ObjectiveInstance_result", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__ObjectiveInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ObjectiveInstance_result" "', argument " "1"" of type '" "ampl::ObjectiveInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::ObjectiveInstance * >(argp1);
  {
    try {
      result = (arg1)->result();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ObjectiveInstance_drop(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::ObjectiveInstance *arg1 = (ampl::ObjectiveInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "ObjectiveInstance_drop", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__ObjectiveInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ObjectiveInstance_drop" "', argument " "1"" of type '" "ampl::ObjectiveInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::ObjectiveInstance * >(argp1);
  {
    try {
      (arg1)->drop();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ObjectiveInstance_restore(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::ObjectiveInstance *arg1 = (ampl::ObjectiveInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "ObjectiveInstance_restore", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__ObjectiveInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ObjectiveInstance_restore" "', argument " "1"" of type '" "ampl::ObjectiveInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::ObjectiveInstance * >(argp1);
  {
    try {
      (arg1)->restore();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ObjectiveInstance_minimization(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::ObjectiveInstance *arg1 = (ampl::ObjectiveInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args, "ObjectiveInstance_minimization", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__ObjectiveInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ObjectiveInstance_minimization" "', argument " "1"" of type '" "ampl::ObjectiveInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::ObjectiveInstance * >(argp1);
  {
    try {
      result = (bool)(arg1)->minimization();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ObjectiveInstance(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::ObjectiveInstance *arg1 = (ampl::ObjectiveInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_ObjectiveInstance", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__ObjectiveInstance, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ObjectiveInstance" "', argument " "1"" of type '" "ampl::ObjectiveInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::ObjectiveInstance * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_ObjectiveInstance) /* defines _wrap_delete_ObjectiveInstance_destructor_closure */

SWIGINTERN PyObject *_wrap_VariableInstance_fix__SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **SWIGUNUSEDPARM(swig_obj)) {
  PyObject *resultobj = 0;
  ampl::VariableInstance *arg1 = (ampl::VariableInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__VariableInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariableInstance_fix" "', argument " "1"" of type '" "ampl::VariableInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::VariableInstance * >(argp1);
  {
    try {
      (arg1)->fix();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariableInstance_fix__SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  ampl::VariableInstance *arg1 = (ampl::VariableInstance *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__VariableInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariableInstance_fix" "', argument " "1"" of type '" "ampl::VariableInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::VariableInstance * >(argp1);
  ecode2 = SWIG_AsVal_double(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VariableInstance_fix" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->fix(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariableInstance_fix(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "VariableInstance_fix", 0, 2, argv+1))) SWIG_fail;
  argv[0] = self;
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__VariableInstance, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_VariableInstance_fix__SWIG_0(self, argc, argv);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__VariableInstance, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_VariableInstance_fix__SWIG_1(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'VariableInstance_fix'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    ampl::VariableInstance::fix()\n"
    "    ampl::VariableInstance::fix(double)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_VariableInstance_unfix(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::VariableInstance *arg1 = (ampl::VariableInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "VariableInstance_unfix", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__VariableInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariableInstance_unfix" "', argument " "1"" of type '" "ampl::VariableInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::VariableInstance * >(argp1);
  {
    try {
      (arg1)->unfix();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariableInstance_setValue(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::VariableInstance *arg1 = (ampl::VariableInstance *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__VariableInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariableInstance_setValue" "', argument " "1"" of type '" "ampl::VariableInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::VariableInstance * >(argp1);
  ecode2 = SWIG_AsVal_double(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VariableInstance_setValue" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->setValue(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariableInstance_value(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::VariableInstance *arg1 = (ampl::VariableInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "VariableInstance_value", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__VariableInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariableInstance_value" "', argument " "1"" of type '" "ampl::VariableInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::VariableInstance * >(argp1);
  {
    try {
      result = (double)(arg1)->value();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariableInstance_defeqn(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::VariableInstance *arg1 = (ampl::VariableInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  int result;
  
  if (!SWIG_Python_UnpackTuple(args, "VariableInstance_defeqn", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__VariableInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariableInstance_defeqn" "', argument " "1"" of type '" "ampl::VariableInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::VariableInstance * >(argp1);
  {
    try {
      result = (int)(arg1)->defeqn();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariableInstance_dual(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::VariableInstance *arg1 = (ampl::VariableInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "VariableInstance_dual", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__VariableInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariableInstance_dual" "', argument " "1"" of type '" "ampl::VariableInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::VariableInstance * >(argp1);
  {
    try {
      result = (double)(arg1)->dual();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariableInstance_init(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::VariableInstance *arg1 = (ampl::VariableInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "VariableInstance_init", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__VariableInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariableInstance_init" "', argument " "1"" of type '" "ampl::VariableInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::VariableInstance * >(argp1);
  {
    try {
      result = (double)(arg1)->init();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariableInstance_init0(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::VariableInstance *arg1 = (ampl::VariableInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "VariableInstance_init0", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__VariableInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariableInstance_init0" "', argument " "1"" of type '" "ampl::VariableInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::VariableInstance * >(argp1);
  {
    try {
      result = (double)(arg1)->init0();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariableInstance_lb(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::VariableInstance *arg1 = (ampl::VariableInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "VariableInstance_lb", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__VariableInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariableInstance_lb" "', argument " "1"" of type '" "ampl::VariableInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::VariableInstance * >(argp1);
  {
    try {
      result = (double)(arg1)->lb();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariableInstance_ub(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::VariableInstance *arg1 = (ampl::VariableInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "VariableInstance_ub", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__VariableInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariableInstance_ub" "', argument " "1"" of type '" "ampl::VariableInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::VariableInstance * >(argp1);
  {
    try {
      result = (double)(arg1)->ub();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariableInstance_lb0(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::VariableInstance *arg1 = (ampl::VariableInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "VariableInstance_lb0", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__VariableInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariableInstance_lb0" "', argument " "1"" of type '" "ampl::VariableInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::VariableInstance * >(argp1);
  {
    try {
      result = (double)(arg1)->lb0();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariableInstance_ub0(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::VariableInstance *arg1 = (ampl::VariableInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "VariableInstance_ub0", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__VariableInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariableInstance_ub0" "', argument " "1"" of type '" "ampl::VariableInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::VariableInstance * >(argp1);
  {
    try {
      result = (double)(arg1)->ub0();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariableInstance_lb1(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::VariableInstance *arg1 = (ampl::VariableInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "VariableInstance_lb1", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__VariableInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariableInstance_lb1" "', argument " "1"" of type '" "ampl::VariableInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::VariableInstance * >(argp1);
  {
    try {
      result = (double)(arg1)->lb1();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariableInstance_ub1(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::VariableInstance *arg1 = (ampl::VariableInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "VariableInstance_ub1", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__VariableInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariableInstance_ub1" "', argument " "1"" of type '" "ampl::VariableInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::VariableInstance * >(argp1);
  {
    try {
      result = (double)(arg1)->ub1();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariableInstance_lb2(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::VariableInstance *arg1 = (ampl::VariableInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "VariableInstance_lb2", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__VariableInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariableInstance_lb2" "', argument " "1"" of type '" "ampl::VariableInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::VariableInstance * >(argp1);
  {
    try {
      result = (double)(arg1)->lb2();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariableInstance_ub2(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::VariableInstance *arg1 = (ampl::VariableInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "VariableInstance_ub2", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__VariableInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariableInstance_ub2" "', argument " "1"" of type '" "ampl::VariableInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::VariableInstance * >(argp1);
  {
    try {
      result = (double)(arg1)->ub2();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariableInstance_lrc(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::VariableInstance *arg1 = (ampl::VariableInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "VariableInstance_lrc", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__VariableInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariableInstance_lrc" "', argument " "1"" of type '" "ampl::VariableInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::VariableInstance * >(argp1);
  {
    try {
      result = (double)(arg1)->lrc();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariableInstance_urc(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::VariableInstance *arg1 = (ampl::VariableInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "VariableInstance_urc", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__VariableInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariableInstance_urc" "', argument " "1"" of type '" "ampl::VariableInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::VariableInstance * >(argp1);
  {
    try {
      result = (double)(arg1)->urc();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariableInstance_lslack(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::VariableInstance *arg1 = (ampl::VariableInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "VariableInstance_lslack", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__VariableInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariableInstance_lslack" "', argument " "1"" of type '" "ampl::VariableInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::VariableInstance * >(argp1);
  {
    try {
      result = (double)(arg1)->lslack();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariableInstance_uslack(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::VariableInstance *arg1 = (ampl::VariableInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "VariableInstance_uslack", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__VariableInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariableInstance_uslack" "', argument " "1"" of type '" "ampl::VariableInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::VariableInstance * >(argp1);
  {
    try {
      result = (double)(arg1)->uslack();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariableInstance_rc(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::VariableInstance *arg1 = (ampl::VariableInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "VariableInstance_rc", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__VariableInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariableInstance_rc" "', argument " "1"" of type '" "ampl::VariableInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::VariableInstance * >(argp1);
  {
    try {
      result = (double)(arg1)->rc();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariableInstance_slack(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::VariableInstance *arg1 = (ampl::VariableInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "VariableInstance_slack", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__VariableInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariableInstance_slack" "', argument " "1"" of type '" "ampl::VariableInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::VariableInstance * >(argp1);
  {
    try {
      result = (double)(arg1)->slack();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariableInstance_astatus(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::VariableInstance *arg1 = (ampl::VariableInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "VariableInstance_astatus", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__VariableInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariableInstance_astatus" "', argument " "1"" of type '" "ampl::VariableInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::VariableInstance * >(argp1);
  {
    try {
      result = (arg1)->astatus();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariableInstance_sstatus(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::VariableInstance *arg1 = (ampl::VariableInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "VariableInstance_sstatus", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__VariableInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariableInstance_sstatus" "', argument " "1"" of type '" "ampl::VariableInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::VariableInstance * >(argp1);
  {
    try {
      result = (arg1)->sstatus();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariableInstance_status(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::VariableInstance *arg1 = (ampl::VariableInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "VariableInstance_status", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__VariableInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariableInstance_status" "', argument " "1"" of type '" "ampl::VariableInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::VariableInstance * >(argp1);
  {
    try {
      result = (arg1)->status();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_VariableInstance(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::VariableInstance *arg1 = (ampl::VariableInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_VariableInstance", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__VariableInstance, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_VariableInstance" "', argument " "1"" of type '" "ampl::VariableInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::VariableInstance * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_VariableInstance) /* defines _wrap_delete_VariableInstance_destructor_closure */

SWIGINTERN PyObject *_wrap_ConstraintInstance_drop(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::ConstraintInstance *arg1 = (ampl::ConstraintInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "ConstraintInstance_drop", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__ConstraintInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConstraintInstance_drop" "', argument " "1"" of type '" "ampl::ConstraintInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::ConstraintInstance * >(argp1);
  {
    try {
      (arg1)->drop();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ConstraintInstance_restore(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::ConstraintInstance *arg1 = (ampl::ConstraintInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "ConstraintInstance_restore", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__ConstraintInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConstraintInstance_restore" "', argument " "1"" of type '" "ampl::ConstraintInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::ConstraintInstance * >(argp1);
  {
    try {
      (arg1)->restore();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ConstraintInstance_body(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::ConstraintInstance *arg1 = (ampl::ConstraintInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "ConstraintInstance_body", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__ConstraintInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConstraintInstance_body" "', argument " "1"" of type '" "ampl::ConstraintInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::ConstraintInstance * >(argp1);
  {
    try {
      result = (double)(arg1)->body();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ConstraintInstance_astatus(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::ConstraintInstance *arg1 = (ampl::ConstraintInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "ConstraintInstance_astatus", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__ConstraintInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConstraintInstance_astatus" "', argument " "1"" of type '" "ampl::ConstraintInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::ConstraintInstance * >(argp1);
  {
    try {
      result = (arg1)->astatus();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ConstraintInstance_defvar(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::ConstraintInstance *arg1 = (ampl::ConstraintInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  int result;
  
  if (!SWIG_Python_UnpackTuple(args, "ConstraintInstance_defvar", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__ConstraintInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConstraintInstance_defvar" "', argument " "1"" of type '" "ampl::ConstraintInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::ConstraintInstance * >(argp1);
  {
    try {
      result = (int)(arg1)->defvar();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ConstraintInstance_dinit(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::ConstraintInstance *arg1 = (ampl::ConstraintInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "ConstraintInstance_dinit", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__ConstraintInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConstraintInstance_dinit" "', argument " "1"" of type '" "ampl::ConstraintInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::ConstraintInstance * >(argp1);
  {
    try {
      result = (double)(arg1)->dinit();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ConstraintInstance_dinit0(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::ConstraintInstance *arg1 = (ampl::ConstraintInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "ConstraintInstance_dinit0", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__ConstraintInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConstraintInstance_dinit0" "', argument " "1"" of type '" "ampl::ConstraintInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::ConstraintInstance * >(argp1);
  {
    try {
      result = (double)(arg1)->dinit0();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ConstraintInstance_dual(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::ConstraintInstance *arg1 = (ampl::ConstraintInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "ConstraintInstance_dual", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__ConstraintInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConstraintInstance_dual" "', argument " "1"" of type '" "ampl::ConstraintInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::ConstraintInstance * >(argp1);
  {
    try {
      result = (double)(arg1)->dual();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ConstraintInstance_lb(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::ConstraintInstance *arg1 = (ampl::ConstraintInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "ConstraintInstance_lb", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__ConstraintInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConstraintInstance_lb" "', argument " "1"" of type '" "ampl::ConstraintInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::ConstraintInstance * >(argp1);
  {
    try {
      result = (double)(arg1)->lb();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ConstraintInstance_ub(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::ConstraintInstance *arg1 = (ampl::ConstraintInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "ConstraintInstance_ub", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__ConstraintInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConstraintInstance_ub" "', argument " "1"" of type '" "ampl::ConstraintInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::ConstraintInstance * >(argp1);
  {
    try {
      result = (double)(arg1)->ub();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ConstraintInstance_lbs(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::ConstraintInstance *arg1 = (ampl::ConstraintInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "ConstraintInstance_lbs", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__ConstraintInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConstraintInstance_lbs" "', argument " "1"" of type '" "ampl::ConstraintInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::ConstraintInstance * >(argp1);
  {
    try {
      result = (double)(arg1)->lbs();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ConstraintInstance_ubs(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::ConstraintInstance *arg1 = (ampl::ConstraintInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "ConstraintInstance_ubs", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__ConstraintInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConstraintInstance_ubs" "', argument " "1"" of type '" "ampl::ConstraintInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::ConstraintInstance * >(argp1);
  {
    try {
      result = (double)(arg1)->ubs();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ConstraintInstance_ldual(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::ConstraintInstance *arg1 = (ampl::ConstraintInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "ConstraintInstance_ldual", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__ConstraintInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConstraintInstance_ldual" "', argument " "1"" of type '" "ampl::ConstraintInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::ConstraintInstance * >(argp1);
  {
    try {
      result = (double)(arg1)->ldual();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ConstraintInstance_udual(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::ConstraintInstance *arg1 = (ampl::ConstraintInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "ConstraintInstance_udual", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__ConstraintInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConstraintInstance_udual" "', argument " "1"" of type '" "ampl::ConstraintInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::ConstraintInstance * >(argp1);
  {
    try {
      result = (double)(arg1)->udual();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ConstraintInstance_lslack(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::ConstraintInstance *arg1 = (ampl::ConstraintInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "ConstraintInstance_lslack", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__ConstraintInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConstraintInstance_lslack" "', argument " "1"" of type '" "ampl::ConstraintInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::ConstraintInstance * >(argp1);
  {
    try {
      result = (double)(arg1)->lslack();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ConstraintInstance_uslack(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::ConstraintInstance *arg1 = (ampl::ConstraintInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "ConstraintInstance_uslack", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__ConstraintInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConstraintInstance_uslack" "', argument " "1"" of type '" "ampl::ConstraintInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::ConstraintInstance * >(argp1);
  {
    try {
      result = (double)(arg1)->uslack();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ConstraintInstance_slack(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::ConstraintInstance *arg1 = (ampl::ConstraintInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "ConstraintInstance_slack", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__ConstraintInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConstraintInstance_slack" "', argument " "1"" of type '" "ampl::ConstraintInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::ConstraintInstance * >(argp1);
  {
    try {
      result = (double)(arg1)->slack();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ConstraintInstance_sstatus(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::ConstraintInstance *arg1 = (ampl::ConstraintInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "ConstraintInstance_sstatus", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__ConstraintInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConstraintInstance_sstatus" "', argument " "1"" of type '" "ampl::ConstraintInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::ConstraintInstance * >(argp1);
  {
    try {
      result = (arg1)->sstatus();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ConstraintInstance_status(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::ConstraintInstance *arg1 = (ampl::ConstraintInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "ConstraintInstance_status", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__ConstraintInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConstraintInstance_status" "', argument " "1"" of type '" "ampl::ConstraintInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::ConstraintInstance * >(argp1);
  {
    try {
      result = (arg1)->status();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ConstraintInstance_setDual(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::ConstraintInstance *arg1 = (ampl::ConstraintInstance *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__ConstraintInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConstraintInstance_setDual" "', argument " "1"" of type '" "ampl::ConstraintInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::ConstraintInstance * >(argp1);
  ecode2 = SWIG_AsVal_double(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ConstraintInstance_setDual" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->setDual(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ConstraintInstance_val(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::ConstraintInstance *arg1 = (ampl::ConstraintInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "ConstraintInstance_val", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__ConstraintInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConstraintInstance_val" "', argument " "1"" of type '" "ampl::ConstraintInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::ConstraintInstance * >(argp1);
  {
    try {
      result = (double)(arg1)->val();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ConstraintInstance(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::ConstraintInstance *arg1 = (ampl::ConstraintInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_ConstraintInstance", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__ConstraintInstance, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ConstraintInstance" "', argument " "1"" of type '" "ampl::ConstraintInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::ConstraintInstance * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_ConstraintInstance) /* defines _wrap_delete_ConstraintInstance_destructor_closure */

SWIGINTERN PyObject *_wrap_delete_TableInstance(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::TableInstance *arg1 = (ampl::TableInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_TableInstance", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__TableInstance, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_TableInstance" "', argument " "1"" of type '" "ampl::TableInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::TableInstance * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_TableInstance) /* defines _wrap_delete_TableInstance_destructor_closure */

SWIGINTERN int _wrap_new_EntityArray(PyObject *self, PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  size_t arg1 ;
  size_t val1 ;
  int ecode1 = 0 ;
  PyObject *swig_obj[1] ;
  EntityArray *result = 0 ;
  
  if (!SWIG_Python_CheckNoKeywords(kwargs, "new_EntityArray")) SWIG_fail;
  if (!SWIG_Python_UnpackTuple(args, "new_EntityArray", 1, 1, swig_obj)) SWIG_fail;
  ecode1 = SWIG_AsVal_size_t(swig_obj[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_EntityArray" "', argument " "1"" of type '" "size_t""'");
  } 
  arg1 = static_cast< size_t >(val1);
  {
    try {
      result = (EntityArray *)new_EntityArray(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_EntityArray, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN PyObject *_wrap_delete_EntityArray(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  EntityArray *arg1 = (EntityArray *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_EntityArray", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_EntityArray, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_EntityArray" "', argument " "1"" of type '" "EntityArray *""'"); 
  }
  arg1 = reinterpret_cast< EntityArray * >(argp1);
  {
    try {
      delete_EntityArray(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityArray___getitem__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  EntityArray *arg1 = (EntityArray *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  SwigValueWrapper< ampl::Entity > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_EntityArray, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityArray___getitem__" "', argument " "1"" of type '" "EntityArray *""'"); 
  }
  arg1 = reinterpret_cast< EntityArray * >(argp1);
  ecode2 = SWIG_AsVal_size_t(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "EntityArray___getitem__" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    try {
      result = EntityArray___getitem__(arg1,arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::Entity(static_cast< const ampl::Entity& >(result))), SWIGTYPE_p_ampl__Entity, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityArray___setitem__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  EntityArray *arg1 = (EntityArray *) 0 ;
  size_t arg2 ;
  SwigValueWrapper< ampl::Entity > arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args, "EntityArray___setitem__", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_EntityArray, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityArray___setitem__" "', argument " "1"" of type '" "EntityArray *""'"); 
  }
  arg1 = reinterpret_cast< EntityArray * >(argp1);
  ecode2 = SWIG_AsVal_size_t(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "EntityArray___setitem__" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    res3 = SWIG_ConvertPtr(swig_obj[1], &argp3, SWIGTYPE_p_ampl__Entity,  0  | 0);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "EntityArray___setitem__" "', argument " "3"" of type '" "ampl::Entity""'"); 
    }  
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "EntityArray___setitem__" "', argument " "3"" of type '" "ampl::Entity""'");
    } else {
      ampl::Entity * temp = reinterpret_cast< ampl::Entity * >(argp3);
      arg3 = *temp;
      if (SWIG_IsNewObj(res3)) delete temp;
    }
  }
  {
    try {
      EntityArray___setitem__(arg1,arg2,arg3);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityArray_cast(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  EntityArray *arg1 = (EntityArray *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ampl::Entity *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "EntityArray_cast", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_EntityArray, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityArray_cast" "', argument " "1"" of type '" "EntityArray *""'"); 
  }
  arg1 = reinterpret_cast< EntityArray * >(argp1);
  {
    try {
      result = (ampl::Entity *)EntityArray_cast(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__Entity, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityArray_frompointer(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Entity *arg1 = (ampl::Entity *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  EntityArray *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_ampl__Entity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityArray_frompointer" "', argument " "1"" of type '" "ampl::Entity *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Entity * >(argp1);
  {
    try {
      result = (EntityArray *)EntityArray_frompointer(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_EntityArray, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_EntityArray) /* defines _wrap_delete_EntityArray_destructor_closure */

SWIGPY_FUNPACK_SSIZEARGFUNC_CLOSURE(_wrap_EntityArray___getitem__) /* defines _wrap_EntityArray___getitem___ssizeargfunc_closure */

SWIGPY_SSIZEOBJARGPROC_CLOSURE(_wrap_EntityArray___setitem__) /* defines _wrap_EntityArray___setitem___ssizeobjargproc_closure */

SWIGINTERN PyObject *_wrap_Entity_toString(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Entity *arg1 = (ampl::Entity *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "Entity_toString", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Entity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Entity_toString" "', argument " "1"" of type '" "ampl::Entity *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Entity * >(argp1);
  {
    try {
      result = (arg1)->toString();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Entity_name(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Entity *arg1 = (ampl::Entity *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "Entity_name", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Entity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Entity_name" "', argument " "1"" of type '" "ampl::Entity *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Entity * >(argp1);
  {
    try {
      result = (arg1)->name();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Entity_type(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Entity *arg1 = (ampl::Entity *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "Entity_type", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Entity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Entity_type" "', argument " "1"" of type '" "ampl::Entity *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Entity * >(argp1);
  {
    try {
      result = (arg1)->type();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Entity_indexarity(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Entity *arg1 = (ampl::Entity *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  int result;
  
  if (!SWIG_Python_UnpackTuple(args, "Entity_indexarity", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Entity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Entity_indexarity" "', argument " "1"" of type '" "ampl::Entity *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Entity * >(argp1);
  {
    try {
      result = (int)(arg1)->indexarity();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Entity_isScalar(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Entity *arg1 = (ampl::Entity *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args, "Entity_isScalar", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Entity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Entity_isScalar" "', argument " "1"" of type '" "ampl::Entity *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Entity * >(argp1);
  {
    try {
      result = (bool)(arg1)->isScalar();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Entity_numInstances(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Entity *arg1 = (ampl::Entity *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  int result;
  
  if (!SWIG_Python_UnpackTuple(args, "Entity_numInstances", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Entity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Entity_numInstances" "', argument " "1"" of type '" "ampl::Entity *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Entity * >(argp1);
  {
    try {
      result = (int)(arg1)->numInstances();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Entity_getIndexingSets(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Entity *arg1 = (ampl::Entity *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ampl::StringArray result;
  
  if (!SWIG_Python_UnpackTuple(args, "Entity_getIndexingSets", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Entity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Entity_getIndexingSets" "', argument " "1"" of type '" "ampl::Entity const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Entity * >(argp1);
  {
    try {
      result = ((ampl::Entity const *)arg1)->getIndexingSets();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  {
    const ampl::StringArray &sa = result; // to avoid issues with result[i];
    std::size_t size = sa.size();
    resultobj = PyList_New(size);
    for (std::size_t i = 0; i < size; i++) {
      PyList_SetItem(resultobj, i, PyString_FromString(sa[i]));
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Entity_xref(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Entity *arg1 = (ampl::Entity *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ampl::StringArray result;
  
  if (!SWIG_Python_UnpackTuple(args, "Entity_xref", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Entity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Entity_xref" "', argument " "1"" of type '" "ampl::Entity const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Entity * >(argp1);
  {
    try {
      result = ((ampl::Entity const *)arg1)->xref();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  {
    const ampl::StringArray &sa = result; // to avoid issues with result[i];
    std::size_t size = sa.size();
    resultobj = PyList_New(size);
    for (std::size_t i = 0; i < size; i++) {
      PyList_SetItem(resultobj, i, PyString_FromString(sa[i]));
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Entity_getValues(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Entity *arg1 = (ampl::Entity *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  SwigValueWrapper< ampl::DataFrame > result;
  
  if (!SWIG_Python_UnpackTuple(args, "Entity_getValues", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Entity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Entity_getValues" "', argument " "1"" of type '" "ampl::Entity *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Entity * >(argp1);
  {
    try {
      result = (arg1)->getValues();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::DataFrame(static_cast< const ampl::DataFrame& >(result))), SWIGTYPE_p_ampl__DataFrame, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Entity_setValuesDf(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Entity *arg1 = (ampl::Entity *) 0 ;
  SwigValueWrapper< ampl::DataFrame > arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Entity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Entity_setValuesDf" "', argument " "1"" of type '" "ampl::Entity *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Entity * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ampl__DataFrame,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Entity_setValuesDf" "', argument " "2"" of type '" "ampl::DataFrame""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Entity_setValuesDf" "', argument " "2"" of type '" "ampl::DataFrame""'");
    } else {
      ampl::DataFrame * temp = reinterpret_cast< ampl::DataFrame * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      (arg1)->setValues(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Entity_getValuesLst(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Entity *arg1 = (ampl::Entity *) 0 ;
  char **arg2 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  SwigValueWrapper< ampl::DataFrame > result;
  
  {
    arg2 = NULL;
  }
  if (!SWIG_Python_UnpackTuple(args, "Entity_getValuesLst", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Entity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Entity_getValuesLst" "', argument " "1"" of type '" "ampl::Entity *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Entity * >(argp1);
  {
    /* Check if is a list */
    if (PyList_Check(swig_obj[0])) {
      std::size_t size = PyList_Size(swig_obj[0]);
      std::size_t i = 0;
      arg2 = (char **)malloc((size + 1) * sizeof(char *));
      for (i = 0; i < size; i++) {
        PyObject *obj = PyList_GetItem(swig_obj[0],i);
        if (_PyString_Check(obj)) {
          arg2[i] = (char *)_PyString_AsString(PyList_GetItem(swig_obj[0],i));
        } else {
          PyErr_SetString(PyExc_TypeError, "list must contain strings");
          free(arg2);
          return NULL;
        }
      }
      arg2[i] = 0;
    } else {
      PyErr_SetString(PyExc_TypeError, "not a list");
      return NULL;
    }
  }
  ecode3 = SWIG_AsVal_int(swig_obj[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Entity_getValuesLst" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  {
    try {
      result = ampl_Entity_getValues(arg1,(char const *(*))arg2,arg3);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::DataFrame(static_cast< const ampl::DataFrame& >(result))), SWIGTYPE_p_ampl__DataFrame, SWIG_POINTER_OWN |  0 );
  {
    free((char *)arg2);
  }
  return resultobj;
fail:
  {
    free((char *)arg2);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_Entity(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Entity *arg1 = (ampl::Entity *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_Entity", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Entity, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Entity" "', argument " "1"" of type '" "ampl::Entity *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Entity * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_Entity) /* defines _wrap_delete_Entity_destructor_closure */

SWIGINTERN PyObject *_wrap_EntityArgs_Factory(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  EntityArray *arg1 = 0 ;
  std::size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  SwigValueWrapper< ampl::EntityArgs > result;
  
  if (!SWIG_Python_UnpackTuple(args, "EntityArgs_Factory", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_EntityArray,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityArgs_Factory" "', argument " "1"" of type '" "EntityArray &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "EntityArgs_Factory" "', argument " "1"" of type '" "EntityArray &""'"); 
  }
  arg1 = reinterpret_cast< EntityArray * >(argp1);
  ecode2 = SWIG_AsVal_size_t(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "EntityArgs_Factory" "', argument " "2"" of type '" "std::size_t""'");
  } 
  arg2 = static_cast< std::size_t >(val2);
  {
    try {
      result = ampl_EntityArgs_Factory(*arg1,arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::EntityArgs(static_cast< const ampl::EntityArgs& >(result))), SWIGTYPE_p_ampl__EntityArgs, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_EntityArgs(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityArgs *arg1 = (ampl::EntityArgs *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_EntityArgs", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityArgs, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_EntityArgs" "', argument " "1"" of type '" "ampl::EntityArgs *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityArgs * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_EntityArgs) /* defines _wrap_delete_EntityArgs_destructor_closure */

SWIGINTERN PyObject *_wrap_BasicEntityVariable_begin(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::BasicEntity< ampl::VariableInstance > *arg1 = (ampl::BasicEntity< ampl::VariableInstance > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ampl::BasicEntity< ampl::VariableInstance >::iterator result;
  
  if (!SWIG_Python_UnpackTuple(args, "BasicEntityVariable_begin", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__BasicEntityT_ampl__VariableInstance_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BasicEntityVariable_begin" "', argument " "1"" of type '" "ampl::BasicEntity< ampl::VariableInstance > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::BasicEntity< ampl::VariableInstance > * >(argp1);
  {
    try {
      result = (arg1)->begin();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::BasicEntity< ampl::VariableInstance >::iterator(static_cast< const ampl::BasicEntity< ampl::VariableInstance >::iterator& >(result))), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BasicEntityVariable_end(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::BasicEntity< ampl::VariableInstance > *arg1 = (ampl::BasicEntity< ampl::VariableInstance > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ampl::BasicEntity< ampl::VariableInstance >::iterator result;
  
  if (!SWIG_Python_UnpackTuple(args, "BasicEntityVariable_end", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__BasicEntityT_ampl__VariableInstance_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BasicEntityVariable_end" "', argument " "1"" of type '" "ampl::BasicEntity< ampl::VariableInstance > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::BasicEntity< ampl::VariableInstance > * >(argp1);
  {
    try {
      result = (arg1)->end();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::BasicEntity< ampl::VariableInstance >::iterator(static_cast< const ampl::BasicEntity< ampl::VariableInstance >::iterator& >(result))), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BasicEntityVariable_find(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::BasicEntity< ampl::VariableInstance > *arg1 = (ampl::BasicEntity< ampl::VariableInstance > *) 0 ;
  ampl::Tuple arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  ampl::BasicEntity< ampl::VariableInstance >::iterator result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__BasicEntityT_ampl__VariableInstance_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BasicEntityVariable_find" "', argument " "1"" of type '" "ampl::BasicEntity< ampl::VariableInstance > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::BasicEntity< ampl::VariableInstance > * >(argp1);
  {
    SetTupleFromPyObject(swig_obj[0], &arg2);
  }
  {
    try {
      result = (arg1)->find(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::BasicEntity< ampl::VariableInstance >::iterator(static_cast< const ampl::BasicEntity< ampl::VariableInstance >::iterator& >(result))), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BasicEntityVariable_get__SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **SWIGUNUSEDPARM(swig_obj)) {
  PyObject *resultobj = 0;
  ampl::BasicEntity< ampl::VariableInstance > *arg1 = (ampl::BasicEntity< ampl::VariableInstance > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< ampl::VariableInstance > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__BasicEntityT_ampl__VariableInstance_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BasicEntityVariable_get" "', argument " "1"" of type '" "ampl::BasicEntity< ampl::VariableInstance > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::BasicEntity< ampl::VariableInstance > * >(argp1);
  {
    try {
      result = (arg1)->get();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::VariableInstance(static_cast< const ampl::VariableInstance& >(result))), SWIGTYPE_p_ampl__VariableInstance, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BasicEntityVariable_get__SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  ampl::BasicEntity< ampl::VariableInstance > *arg1 = (ampl::BasicEntity< ampl::VariableInstance > *) 0 ;
  ampl::Tuple arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< ampl::VariableInstance > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__BasicEntityT_ampl__VariableInstance_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BasicEntityVariable_get" "', argument " "1"" of type '" "ampl::BasicEntity< ampl::VariableInstance > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::BasicEntity< ampl::VariableInstance > * >(argp1);
  {
    SetTupleFromPyObject(swig_obj[1], &arg2);
  }
  {
    try {
      result = (arg1)->get(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::VariableInstance(static_cast< const ampl::VariableInstance& >(result))), SWIGTYPE_p_ampl__VariableInstance, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BasicEntityVariable_get(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "BasicEntityVariable_get", 0, 2, argv+1))) SWIG_fail;
  argv[0] = self;
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__BasicEntityT_ampl__VariableInstance_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_BasicEntityVariable_get__SWIG_0(self, argc, argv);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__BasicEntityT_ampl__VariableInstance_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        _v = PyTuple_Check(argv[1]) ? 1 : 0;
      }
      if (_v) {
        return _wrap_BasicEntityVariable_get__SWIG_1(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'BasicEntityVariable_get'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    ampl::BasicEntity< ampl::VariableInstance >::get()\n"
    "    ampl::BasicEntity< ampl::VariableInstance >::get(ampl::Tuple)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_delete_BasicEntityVariable(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::BasicEntity< ampl::VariableInstance > *arg1 = (ampl::BasicEntity< ampl::VariableInstance > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_BasicEntityVariable", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__BasicEntityT_ampl__VariableInstance_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_BasicEntityVariable" "', argument " "1"" of type '" "ampl::BasicEntity< ampl::VariableInstance > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::BasicEntity< ampl::VariableInstance > * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_BasicEntityVariable) /* defines _wrap_delete_BasicEntityVariable_destructor_closure */

SWIGINTERN PyObject *_wrap_BasicEntityConstraint_begin(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::BasicEntity< ampl::ConstraintInstance > *arg1 = (ampl::BasicEntity< ampl::ConstraintInstance > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ampl::BasicEntity< ampl::ConstraintInstance >::iterator result;
  
  if (!SWIG_Python_UnpackTuple(args, "BasicEntityConstraint_begin", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__BasicEntityT_ampl__ConstraintInstance_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BasicEntityConstraint_begin" "', argument " "1"" of type '" "ampl::BasicEntity< ampl::ConstraintInstance > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::BasicEntity< ampl::ConstraintInstance > * >(argp1);
  {
    try {
      result = (arg1)->begin();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::BasicEntity< ampl::ConstraintInstance >::iterator(static_cast< const ampl::BasicEntity< ampl::ConstraintInstance >::iterator& >(result))), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BasicEntityConstraint_end(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::BasicEntity< ampl::ConstraintInstance > *arg1 = (ampl::BasicEntity< ampl::ConstraintInstance > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ampl::BasicEntity< ampl::ConstraintInstance >::iterator result;
  
  if (!SWIG_Python_UnpackTuple(args, "BasicEntityConstraint_end", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__BasicEntityT_ampl__ConstraintInstance_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BasicEntityConstraint_end" "', argument " "1"" of type '" "ampl::BasicEntity< ampl::ConstraintInstance > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::BasicEntity< ampl::ConstraintInstance > * >(argp1);
  {
    try {
      result = (arg1)->end();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::BasicEntity< ampl::ConstraintInstance >::iterator(static_cast< const ampl::BasicEntity< ampl::ConstraintInstance >::iterator& >(result))), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BasicEntityConstraint_find(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::BasicEntity< ampl::ConstraintInstance > *arg1 = (ampl::BasicEntity< ampl::ConstraintInstance > *) 0 ;
  ampl::Tuple arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  ampl::BasicEntity< ampl::ConstraintInstance >::iterator result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__BasicEntityT_ampl__ConstraintInstance_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BasicEntityConstraint_find" "', argument " "1"" of type '" "ampl::BasicEntity< ampl::ConstraintInstance > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::BasicEntity< ampl::ConstraintInstance > * >(argp1);
  {
    SetTupleFromPyObject(swig_obj[0], &arg2);
  }
  {
    try {
      result = (arg1)->find(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::BasicEntity< ampl::ConstraintInstance >::iterator(static_cast< const ampl::BasicEntity< ampl::ConstraintInstance >::iterator& >(result))), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BasicEntityConstraint_get__SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **SWIGUNUSEDPARM(swig_obj)) {
  PyObject *resultobj = 0;
  ampl::BasicEntity< ampl::ConstraintInstance > *arg1 = (ampl::BasicEntity< ampl::ConstraintInstance > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< ampl::ConstraintInstance > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__BasicEntityT_ampl__ConstraintInstance_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BasicEntityConstraint_get" "', argument " "1"" of type '" "ampl::BasicEntity< ampl::ConstraintInstance > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::BasicEntity< ampl::ConstraintInstance > * >(argp1);
  {
    try {
      result = (arg1)->get();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::ConstraintInstance(static_cast< const ampl::ConstraintInstance& >(result))), SWIGTYPE_p_ampl__ConstraintInstance, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BasicEntityConstraint_get__SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  ampl::BasicEntity< ampl::ConstraintInstance > *arg1 = (ampl::BasicEntity< ampl::ConstraintInstance > *) 0 ;
  ampl::Tuple arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< ampl::ConstraintInstance > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__BasicEntityT_ampl__ConstraintInstance_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BasicEntityConstraint_get" "', argument " "1"" of type '" "ampl::BasicEntity< ampl::ConstraintInstance > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::BasicEntity< ampl::ConstraintInstance > * >(argp1);
  {
    SetTupleFromPyObject(swig_obj[1], &arg2);
  }
  {
    try {
      result = (arg1)->get(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::ConstraintInstance(static_cast< const ampl::ConstraintInstance& >(result))), SWIGTYPE_p_ampl__ConstraintInstance, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BasicEntityConstraint_get(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "BasicEntityConstraint_get", 0, 2, argv+1))) SWIG_fail;
  argv[0] = self;
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__BasicEntityT_ampl__ConstraintInstance_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_BasicEntityConstraint_get__SWIG_0(self, argc, argv);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__BasicEntityT_ampl__ConstraintInstance_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        _v = PyTuple_Check(argv[1]) ? 1 : 0;
      }
      if (_v) {
        return _wrap_BasicEntityConstraint_get__SWIG_1(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'BasicEntityConstraint_get'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    ampl::BasicEntity< ampl::ConstraintInstance >::get()\n"
    "    ampl::BasicEntity< ampl::ConstraintInstance >::get(ampl::Tuple)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_delete_BasicEntityConstraint(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::BasicEntity< ampl::ConstraintInstance > *arg1 = (ampl::BasicEntity< ampl::ConstraintInstance > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_BasicEntityConstraint", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__BasicEntityT_ampl__ConstraintInstance_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_BasicEntityConstraint" "', argument " "1"" of type '" "ampl::BasicEntity< ampl::ConstraintInstance > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::BasicEntity< ampl::ConstraintInstance > * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_BasicEntityConstraint) /* defines _wrap_delete_BasicEntityConstraint_destructor_closure */

SWIGINTERN PyObject *_wrap_BasicEntitySet_begin(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::BasicEntity< ampl::SetInstance > *arg1 = (ampl::BasicEntity< ampl::SetInstance > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ampl::BasicEntity< ampl::SetInstance >::iterator result;
  
  if (!SWIG_Python_UnpackTuple(args, "BasicEntitySet_begin", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__BasicEntityT_ampl__SetInstance_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BasicEntitySet_begin" "', argument " "1"" of type '" "ampl::BasicEntity< ampl::SetInstance > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::BasicEntity< ampl::SetInstance > * >(argp1);
  {
    try {
      result = (arg1)->begin();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::BasicEntity< ampl::SetInstance >::iterator(static_cast< const ampl::BasicEntity< ampl::SetInstance >::iterator& >(result))), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BasicEntitySet_end(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::BasicEntity< ampl::SetInstance > *arg1 = (ampl::BasicEntity< ampl::SetInstance > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ampl::BasicEntity< ampl::SetInstance >::iterator result;
  
  if (!SWIG_Python_UnpackTuple(args, "BasicEntitySet_end", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__BasicEntityT_ampl__SetInstance_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BasicEntitySet_end" "', argument " "1"" of type '" "ampl::BasicEntity< ampl::SetInstance > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::BasicEntity< ampl::SetInstance > * >(argp1);
  {
    try {
      result = (arg1)->end();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::BasicEntity< ampl::SetInstance >::iterator(static_cast< const ampl::BasicEntity< ampl::SetInstance >::iterator& >(result))), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BasicEntitySet_find(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::BasicEntity< ampl::SetInstance > *arg1 = (ampl::BasicEntity< ampl::SetInstance > *) 0 ;
  ampl::Tuple arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  ampl::BasicEntity< ampl::SetInstance >::iterator result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__BasicEntityT_ampl__SetInstance_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BasicEntitySet_find" "', argument " "1"" of type '" "ampl::BasicEntity< ampl::SetInstance > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::BasicEntity< ampl::SetInstance > * >(argp1);
  {
    SetTupleFromPyObject(swig_obj[0], &arg2);
  }
  {
    try {
      result = (arg1)->find(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::BasicEntity< ampl::SetInstance >::iterator(static_cast< const ampl::BasicEntity< ampl::SetInstance >::iterator& >(result))), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BasicEntitySet_get__SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **SWIGUNUSEDPARM(swig_obj)) {
  PyObject *resultobj = 0;
  ampl::BasicEntity< ampl::SetInstance > *arg1 = (ampl::BasicEntity< ampl::SetInstance > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< ampl::SetInstance > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__BasicEntityT_ampl__SetInstance_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BasicEntitySet_get" "', argument " "1"" of type '" "ampl::BasicEntity< ampl::SetInstance > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::BasicEntity< ampl::SetInstance > * >(argp1);
  {
    try {
      result = (arg1)->get();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::SetInstance(static_cast< const ampl::SetInstance& >(result))), SWIGTYPE_p_ampl__SetInstance, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BasicEntitySet_get__SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  ampl::BasicEntity< ampl::SetInstance > *arg1 = (ampl::BasicEntity< ampl::SetInstance > *) 0 ;
  ampl::Tuple arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< ampl::SetInstance > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__BasicEntityT_ampl__SetInstance_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BasicEntitySet_get" "', argument " "1"" of type '" "ampl::BasicEntity< ampl::SetInstance > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::BasicEntity< ampl::SetInstance > * >(argp1);
  {
    SetTupleFromPyObject(swig_obj[1], &arg2);
  }
  {
    try {
      result = (arg1)->get(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::SetInstance(static_cast< const ampl::SetInstance& >(result))), SWIGTYPE_p_ampl__SetInstance, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BasicEntitySet_get(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "BasicEntitySet_get", 0, 2, argv+1))) SWIG_fail;
  argv[0] = self;
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__BasicEntityT_ampl__SetInstance_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_BasicEntitySet_get__SWIG_0(self, argc, argv);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__BasicEntityT_ampl__SetInstance_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        _v = PyTuple_Check(argv[1]) ? 1 : 0;
      }
      if (_v) {
        return _wrap_BasicEntitySet_get__SWIG_1(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'BasicEntitySet_get'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    ampl::BasicEntity< ampl::SetInstance >::get()\n"
    "    ampl::BasicEntity< ampl::SetInstance >::get(ampl::Tuple)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_delete_BasicEntitySet(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::BasicEntity< ampl::SetInstance > *arg1 = (ampl::BasicEntity< ampl::SetInstance > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_BasicEntitySet", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__BasicEntityT_ampl__SetInstance_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_BasicEntitySet" "', argument " "1"" of type '" "ampl::BasicEntity< ampl::SetInstance > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::BasicEntity< ampl::SetInstance > * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_BasicEntitySet) /* defines _wrap_delete_BasicEntitySet_destructor_closure */

SWIGINTERN PyObject *_wrap_BasicEntityObjective_begin(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::BasicEntity< ampl::ObjectiveInstance > *arg1 = (ampl::BasicEntity< ampl::ObjectiveInstance > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ampl::BasicEntity< ampl::ObjectiveInstance >::iterator result;
  
  if (!SWIG_Python_UnpackTuple(args, "BasicEntityObjective_begin", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__BasicEntityT_ampl__ObjectiveInstance_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BasicEntityObjective_begin" "', argument " "1"" of type '" "ampl::BasicEntity< ampl::ObjectiveInstance > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::BasicEntity< ampl::ObjectiveInstance > * >(argp1);
  {
    try {
      result = (arg1)->begin();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::BasicEntity< ampl::ObjectiveInstance >::iterator(static_cast< const ampl::BasicEntity< ampl::ObjectiveInstance >::iterator& >(result))), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BasicEntityObjective_end(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::BasicEntity< ampl::ObjectiveInstance > *arg1 = (ampl::BasicEntity< ampl::ObjectiveInstance > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ampl::BasicEntity< ampl::ObjectiveInstance >::iterator result;
  
  if (!SWIG_Python_UnpackTuple(args, "BasicEntityObjective_end", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__BasicEntityT_ampl__ObjectiveInstance_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BasicEntityObjective_end" "', argument " "1"" of type '" "ampl::BasicEntity< ampl::ObjectiveInstance > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::BasicEntity< ampl::ObjectiveInstance > * >(argp1);
  {
    try {
      result = (arg1)->end();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::BasicEntity< ampl::ObjectiveInstance >::iterator(static_cast< const ampl::BasicEntity< ampl::ObjectiveInstance >::iterator& >(result))), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BasicEntityObjective_find(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::BasicEntity< ampl::ObjectiveInstance > *arg1 = (ampl::BasicEntity< ampl::ObjectiveInstance > *) 0 ;
  ampl::Tuple arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  ampl::BasicEntity< ampl::ObjectiveInstance >::iterator result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__BasicEntityT_ampl__ObjectiveInstance_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BasicEntityObjective_find" "', argument " "1"" of type '" "ampl::BasicEntity< ampl::ObjectiveInstance > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::BasicEntity< ampl::ObjectiveInstance > * >(argp1);
  {
    SetTupleFromPyObject(swig_obj[0], &arg2);
  }
  {
    try {
      result = (arg1)->find(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::BasicEntity< ampl::ObjectiveInstance >::iterator(static_cast< const ampl::BasicEntity< ampl::ObjectiveInstance >::iterator& >(result))), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BasicEntityObjective_get__SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **SWIGUNUSEDPARM(swig_obj)) {
  PyObject *resultobj = 0;
  ampl::BasicEntity< ampl::ObjectiveInstance > *arg1 = (ampl::BasicEntity< ampl::ObjectiveInstance > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< ampl::ObjectiveInstance > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__BasicEntityT_ampl__ObjectiveInstance_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BasicEntityObjective_get" "', argument " "1"" of type '" "ampl::BasicEntity< ampl::ObjectiveInstance > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::BasicEntity< ampl::ObjectiveInstance > * >(argp1);
  {
    try {
      result = (arg1)->get();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::ObjectiveInstance(static_cast< const ampl::ObjectiveInstance& >(result))), SWIGTYPE_p_ampl__ObjectiveInstance, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BasicEntityObjective_get__SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  ampl::BasicEntity< ampl::ObjectiveInstance > *arg1 = (ampl::BasicEntity< ampl::ObjectiveInstance > *) 0 ;
  ampl::Tuple arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< ampl::ObjectiveInstance > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__BasicEntityT_ampl__ObjectiveInstance_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BasicEntityObjective_get" "', argument " "1"" of type '" "ampl::BasicEntity< ampl::ObjectiveInstance > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::BasicEntity< ampl::ObjectiveInstance > * >(argp1);
  {
    SetTupleFromPyObject(swig_obj[1], &arg2);
  }
  {
    try {
      result = (arg1)->get(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::ObjectiveInstance(static_cast< const ampl::ObjectiveInstance& >(result))), SWIGTYPE_p_ampl__ObjectiveInstance, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BasicEntityObjective_get(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "BasicEntityObjective_get", 0, 2, argv+1))) SWIG_fail;
  argv[0] = self;
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__BasicEntityT_ampl__ObjectiveInstance_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_BasicEntityObjective_get__SWIG_0(self, argc, argv);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__BasicEntityT_ampl__ObjectiveInstance_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        _v = PyTuple_Check(argv[1]) ? 1 : 0;
      }
      if (_v) {
        return _wrap_BasicEntityObjective_get__SWIG_1(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'BasicEntityObjective_get'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    ampl::BasicEntity< ampl::ObjectiveInstance >::get()\n"
    "    ampl::BasicEntity< ampl::ObjectiveInstance >::get(ampl::Tuple)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_delete_BasicEntityObjective(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::BasicEntity< ampl::ObjectiveInstance > *arg1 = (ampl::BasicEntity< ampl::ObjectiveInstance > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_BasicEntityObjective", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__BasicEntityT_ampl__ObjectiveInstance_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_BasicEntityObjective" "', argument " "1"" of type '" "ampl::BasicEntity< ampl::ObjectiveInstance > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::BasicEntity< ampl::ObjectiveInstance > * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_BasicEntityObjective) /* defines _wrap_delete_BasicEntityObjective_destructor_closure */

SWIGINTERN PyObject *_wrap_BasicEntityParameter_begin(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::BasicEntity< ampl::VariantRef > *arg1 = (ampl::BasicEntity< ampl::VariantRef > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ampl::BasicEntity< ampl::VariantRef >::iterator result;
  
  if (!SWIG_Python_UnpackTuple(args, "BasicEntityParameter_begin", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__BasicEntityT_ampl__VariantRef_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BasicEntityParameter_begin" "', argument " "1"" of type '" "ampl::BasicEntity< ampl::VariantRef > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::BasicEntity< ampl::VariantRef > * >(argp1);
  {
    try {
      result = (arg1)->begin();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::BasicEntity< ampl::VariantRef >::iterator(static_cast< const ampl::BasicEntity< ampl::VariantRef >::iterator& >(result))), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BasicEntityParameter_end(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::BasicEntity< ampl::VariantRef > *arg1 = (ampl::BasicEntity< ampl::VariantRef > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ampl::BasicEntity< ampl::VariantRef >::iterator result;
  
  if (!SWIG_Python_UnpackTuple(args, "BasicEntityParameter_end", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__BasicEntityT_ampl__VariantRef_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BasicEntityParameter_end" "', argument " "1"" of type '" "ampl::BasicEntity< ampl::VariantRef > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::BasicEntity< ampl::VariantRef > * >(argp1);
  {
    try {
      result = (arg1)->end();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::BasicEntity< ampl::VariantRef >::iterator(static_cast< const ampl::BasicEntity< ampl::VariantRef >::iterator& >(result))), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BasicEntityParameter_find(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::BasicEntity< ampl::VariantRef > *arg1 = (ampl::BasicEntity< ampl::VariantRef > *) 0 ;
  ampl::Tuple arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  ampl::BasicEntity< ampl::VariantRef >::iterator result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__BasicEntityT_ampl__VariantRef_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BasicEntityParameter_find" "', argument " "1"" of type '" "ampl::BasicEntity< ampl::VariantRef > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::BasicEntity< ampl::VariantRef > * >(argp1);
  {
    SetTupleFromPyObject(swig_obj[0], &arg2);
  }
  {
    try {
      result = (arg1)->find(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::BasicEntity< ampl::VariantRef >::iterator(static_cast< const ampl::BasicEntity< ampl::VariantRef >::iterator& >(result))), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BasicEntityParameter_get__SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **SWIGUNUSEDPARM(swig_obj)) {
  PyObject *resultobj = 0;
  ampl::BasicEntity< ampl::VariantRef > *arg1 = (ampl::BasicEntity< ampl::VariantRef > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< ampl::VariantRef > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__BasicEntityT_ampl__VariantRef_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BasicEntityParameter_get" "', argument " "1"" of type '" "ampl::BasicEntity< ampl::VariantRef > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::BasicEntity< ampl::VariantRef > * >(argp1);
  {
    try {
      result = (arg1)->get();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  {
    switch ((&result)->type()) {
    case ampl::STRING:
      resultobj = PyString_FromString((&result)->c_str());
      break;
    case ampl::NUMERIC:
      resultobj = PyFloat_FromDouble((&result)->dbl());
      break;
    default:
      resultobj = Py_None;
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BasicEntityParameter_get__SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  ampl::BasicEntity< ampl::VariantRef > *arg1 = (ampl::BasicEntity< ampl::VariantRef > *) 0 ;
  ampl::Tuple arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< ampl::VariantRef > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__BasicEntityT_ampl__VariantRef_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BasicEntityParameter_get" "', argument " "1"" of type '" "ampl::BasicEntity< ampl::VariantRef > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::BasicEntity< ampl::VariantRef > * >(argp1);
  {
    SetTupleFromPyObject(swig_obj[1], &arg2);
  }
  {
    try {
      result = (arg1)->get(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  {
    switch ((&result)->type()) {
    case ampl::STRING:
      resultobj = PyString_FromString((&result)->c_str());
      break;
    case ampl::NUMERIC:
      resultobj = PyFloat_FromDouble((&result)->dbl());
      break;
    default:
      resultobj = Py_None;
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BasicEntityParameter_get(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "BasicEntityParameter_get", 0, 2, argv+1))) SWIG_fail;
  argv[0] = self;
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__BasicEntityT_ampl__VariantRef_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_BasicEntityParameter_get__SWIG_0(self, argc, argv);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__BasicEntityT_ampl__VariantRef_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        _v = PyTuple_Check(argv[1]) ? 1 : 0;
      }
      if (_v) {
        return _wrap_BasicEntityParameter_get__SWIG_1(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'BasicEntityParameter_get'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    ampl::BasicEntity< ampl::VariantRef >::get()\n"
    "    ampl::BasicEntity< ampl::VariantRef >::get(ampl::Tuple)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_delete_BasicEntityParameter(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::BasicEntity< ampl::VariantRef > *arg1 = (ampl::BasicEntity< ampl::VariantRef > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_BasicEntityParameter", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__BasicEntityT_ampl__VariantRef_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_BasicEntityParameter" "', argument " "1"" of type '" "ampl::BasicEntity< ampl::VariantRef > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::BasicEntity< ampl::VariantRef > * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_BasicEntityParameter) /* defines _wrap_delete_BasicEntityParameter_destructor_closure */

SWIGINTERN PyObject *_wrap_BasicEntityTable_begin(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::BasicEntity< ampl::TableInstance > *arg1 = (ampl::BasicEntity< ampl::TableInstance > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ampl::BasicEntity< ampl::TableInstance >::iterator result;
  
  if (!SWIG_Python_UnpackTuple(args, "BasicEntityTable_begin", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__BasicEntityT_ampl__TableInstance_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BasicEntityTable_begin" "', argument " "1"" of type '" "ampl::BasicEntity< ampl::TableInstance > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::BasicEntity< ampl::TableInstance > * >(argp1);
  {
    try {
      result = (arg1)->begin();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::BasicEntity< ampl::TableInstance >::iterator(static_cast< const ampl::BasicEntity< ampl::TableInstance >::iterator& >(result))), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__TableInstance_t_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BasicEntityTable_end(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::BasicEntity< ampl::TableInstance > *arg1 = (ampl::BasicEntity< ampl::TableInstance > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ampl::BasicEntity< ampl::TableInstance >::iterator result;
  
  if (!SWIG_Python_UnpackTuple(args, "BasicEntityTable_end", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__BasicEntityT_ampl__TableInstance_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BasicEntityTable_end" "', argument " "1"" of type '" "ampl::BasicEntity< ampl::TableInstance > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::BasicEntity< ampl::TableInstance > * >(argp1);
  {
    try {
      result = (arg1)->end();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::BasicEntity< ampl::TableInstance >::iterator(static_cast< const ampl::BasicEntity< ampl::TableInstance >::iterator& >(result))), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__TableInstance_t_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BasicEntityTable_find(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::BasicEntity< ampl::TableInstance > *arg1 = (ampl::BasicEntity< ampl::TableInstance > *) 0 ;
  ampl::Tuple arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  ampl::BasicEntity< ampl::TableInstance >::iterator result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__BasicEntityT_ampl__TableInstance_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BasicEntityTable_find" "', argument " "1"" of type '" "ampl::BasicEntity< ampl::TableInstance > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::BasicEntity< ampl::TableInstance > * >(argp1);
  {
    SetTupleFromPyObject(swig_obj[0], &arg2);
  }
  {
    try {
      result = (arg1)->find(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::BasicEntity< ampl::TableInstance >::iterator(static_cast< const ampl::BasicEntity< ampl::TableInstance >::iterator& >(result))), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__TableInstance_t_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BasicEntityTable_get__SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **SWIGUNUSEDPARM(swig_obj)) {
  PyObject *resultobj = 0;
  ampl::BasicEntity< ampl::TableInstance > *arg1 = (ampl::BasicEntity< ampl::TableInstance > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< ampl::TableInstance > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__BasicEntityT_ampl__TableInstance_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BasicEntityTable_get" "', argument " "1"" of type '" "ampl::BasicEntity< ampl::TableInstance > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::BasicEntity< ampl::TableInstance > * >(argp1);
  {
    try {
      result = (arg1)->get();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::TableInstance(static_cast< const ampl::TableInstance& >(result))), SWIGTYPE_p_ampl__TableInstance, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BasicEntityTable_get__SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  ampl::BasicEntity< ampl::TableInstance > *arg1 = (ampl::BasicEntity< ampl::TableInstance > *) 0 ;
  ampl::Tuple arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< ampl::TableInstance > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__BasicEntityT_ampl__TableInstance_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BasicEntityTable_get" "', argument " "1"" of type '" "ampl::BasicEntity< ampl::TableInstance > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::BasicEntity< ampl::TableInstance > * >(argp1);
  {
    SetTupleFromPyObject(swig_obj[1], &arg2);
  }
  {
    try {
      result = (arg1)->get(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::TableInstance(static_cast< const ampl::TableInstance& >(result))), SWIGTYPE_p_ampl__TableInstance, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BasicEntityTable_get(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "BasicEntityTable_get", 0, 2, argv+1))) SWIG_fail;
  argv[0] = self;
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__BasicEntityT_ampl__TableInstance_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_BasicEntityTable_get__SWIG_0(self, argc, argv);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__BasicEntityT_ampl__TableInstance_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        _v = PyTuple_Check(argv[1]) ? 1 : 0;
      }
      if (_v) {
        return _wrap_BasicEntityTable_get__SWIG_1(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'BasicEntityTable_get'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    ampl::BasicEntity< ampl::TableInstance >::get()\n"
    "    ampl::BasicEntity< ampl::TableInstance >::get(ampl::Tuple)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_delete_BasicEntityTable(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::BasicEntity< ampl::TableInstance > *arg1 = (ampl::BasicEntity< ampl::TableInstance > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_BasicEntityTable", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__BasicEntityT_ampl__TableInstance_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_BasicEntityTable" "', argument " "1"" of type '" "ampl::BasicEntity< ampl::TableInstance > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::BasicEntity< ampl::TableInstance > * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_BasicEntityTable) /* defines _wrap_delete_BasicEntityTable_destructor_closure */

SWIGINTERN PyObject *_wrap_Constraint_isLogical(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Constraint *arg1 = (ampl::Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args, "Constraint_isLogical", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Constraint_isLogical" "', argument " "1"" of type '" "ampl::Constraint *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Constraint * >(argp1);
  {
    try {
      result = (bool)(arg1)->isLogical();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Constraint_drop(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Constraint *arg1 = (ampl::Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "Constraint_drop", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Constraint_drop" "', argument " "1"" of type '" "ampl::Constraint *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Constraint * >(argp1);
  {
    try {
      (arg1)->drop();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Constraint_restore(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Constraint *arg1 = (ampl::Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "Constraint_restore", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Constraint_restore" "', argument " "1"" of type '" "ampl::Constraint *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Constraint * >(argp1);
  {
    try {
      (arg1)->restore();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Constraint_body(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Constraint *arg1 = (ampl::Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "Constraint_body", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Constraint_body" "', argument " "1"" of type '" "ampl::Constraint *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Constraint * >(argp1);
  {
    try {
      result = (double)(arg1)->body();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Constraint_astatus(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Constraint *arg1 = (ampl::Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "Constraint_astatus", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Constraint_astatus" "', argument " "1"" of type '" "ampl::Constraint *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Constraint * >(argp1);
  {
    try {
      result = (arg1)->astatus();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Constraint_defvar(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Constraint *arg1 = (ampl::Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  int result;
  
  if (!SWIG_Python_UnpackTuple(args, "Constraint_defvar", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Constraint_defvar" "', argument " "1"" of type '" "ampl::Constraint *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Constraint * >(argp1);
  {
    try {
      result = (int)(arg1)->defvar();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Constraint_dinit(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Constraint *arg1 = (ampl::Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "Constraint_dinit", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Constraint_dinit" "', argument " "1"" of type '" "ampl::Constraint *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Constraint * >(argp1);
  {
    try {
      result = (double)(arg1)->dinit();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Constraint_dinit0(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Constraint *arg1 = (ampl::Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "Constraint_dinit0", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Constraint_dinit0" "', argument " "1"" of type '" "ampl::Constraint *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Constraint * >(argp1);
  {
    try {
      result = (double)(arg1)->dinit0();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Constraint_dual(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Constraint *arg1 = (ampl::Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "Constraint_dual", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Constraint_dual" "', argument " "1"" of type '" "ampl::Constraint *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Constraint * >(argp1);
  {
    try {
      result = (double)(arg1)->dual();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Constraint_lb(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Constraint *arg1 = (ampl::Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "Constraint_lb", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Constraint_lb" "', argument " "1"" of type '" "ampl::Constraint *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Constraint * >(argp1);
  {
    try {
      result = (double)(arg1)->lb();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Constraint_ub(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Constraint *arg1 = (ampl::Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "Constraint_ub", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Constraint_ub" "', argument " "1"" of type '" "ampl::Constraint *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Constraint * >(argp1);
  {
    try {
      result = (double)(arg1)->ub();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Constraint_lbs(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Constraint *arg1 = (ampl::Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "Constraint_lbs", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Constraint_lbs" "', argument " "1"" of type '" "ampl::Constraint *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Constraint * >(argp1);
  {
    try {
      result = (double)(arg1)->lbs();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Constraint_ubs(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Constraint *arg1 = (ampl::Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "Constraint_ubs", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Constraint_ubs" "', argument " "1"" of type '" "ampl::Constraint *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Constraint * >(argp1);
  {
    try {
      result = (double)(arg1)->ubs();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Constraint_ldual(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Constraint *arg1 = (ampl::Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "Constraint_ldual", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Constraint_ldual" "', argument " "1"" of type '" "ampl::Constraint *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Constraint * >(argp1);
  {
    try {
      result = (double)(arg1)->ldual();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Constraint_udual(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Constraint *arg1 = (ampl::Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "Constraint_udual", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Constraint_udual" "', argument " "1"" of type '" "ampl::Constraint *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Constraint * >(argp1);
  {
    try {
      result = (double)(arg1)->udual();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Constraint_lslack(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Constraint *arg1 = (ampl::Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "Constraint_lslack", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Constraint_lslack" "', argument " "1"" of type '" "ampl::Constraint *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Constraint * >(argp1);
  {
    try {
      result = (double)(arg1)->lslack();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Constraint_uslack(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Constraint *arg1 = (ampl::Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "Constraint_uslack", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Constraint_uslack" "', argument " "1"" of type '" "ampl::Constraint *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Constraint * >(argp1);
  {
    try {
      result = (double)(arg1)->uslack();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Constraint_slack(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Constraint *arg1 = (ampl::Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "Constraint_slack", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Constraint_slack" "', argument " "1"" of type '" "ampl::Constraint *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Constraint * >(argp1);
  {
    try {
      result = (double)(arg1)->slack();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Constraint_sstatus(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Constraint *arg1 = (ampl::Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "Constraint_sstatus", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Constraint_sstatus" "', argument " "1"" of type '" "ampl::Constraint *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Constraint * >(argp1);
  {
    try {
      result = (arg1)->sstatus();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Constraint_status(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Constraint *arg1 = (ampl::Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "Constraint_status", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Constraint_status" "', argument " "1"" of type '" "ampl::Constraint *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Constraint * >(argp1);
  {
    try {
      result = (arg1)->status();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Constraint_setDual(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Constraint *arg1 = (ampl::Constraint *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Constraint_setDual" "', argument " "1"" of type '" "ampl::Constraint *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Constraint * >(argp1);
  ecode2 = SWIG_AsVal_double(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Constraint_setDual" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->setDual(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Constraint_val(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Constraint *arg1 = (ampl::Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "Constraint_val", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Constraint_val" "', argument " "1"" of type '" "ampl::Constraint *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Constraint * >(argp1);
  {
    try {
      result = (double)(arg1)->val();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_Constraint(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Constraint *arg1 = (ampl::Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_Constraint", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Constraint, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Constraint" "', argument " "1"" of type '" "ampl::Constraint *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Constraint * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_Constraint) /* defines _wrap_delete_Constraint_destructor_closure */

SWIGINTERN PyObject *_wrap_Variable_integrality(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Variable *arg1 = (ampl::Variable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ampl::var::Integrality result;
  
  if (!SWIG_Python_UnpackTuple(args, "Variable_integrality", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Variable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variable_integrality" "', argument " "1"" of type '" "ampl::Variable *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Variable * >(argp1);
  {
    try {
      result = (ampl::var::Integrality)(arg1)->integrality();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variable_fix__SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **SWIGUNUSEDPARM(swig_obj)) {
  PyObject *resultobj = 0;
  ampl::Variable *arg1 = (ampl::Variable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Variable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variable_fix" "', argument " "1"" of type '" "ampl::Variable *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Variable * >(argp1);
  {
    try {
      (arg1)->fix();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variable_fix__SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  ampl::Variable *arg1 = (ampl::Variable *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Variable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variable_fix" "', argument " "1"" of type '" "ampl::Variable *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Variable * >(argp1);
  ecode2 = SWIG_AsVal_double(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Variable_fix" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->fix(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variable_fix(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "Variable_fix", 0, 2, argv+1))) SWIG_fail;
  argv[0] = self;
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__Variable, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Variable_fix__SWIG_0(self, argc, argv);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__Variable, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Variable_fix__SWIG_1(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'Variable_fix'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    ampl::Variable::fix()\n"
    "    ampl::Variable::fix(double)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_Variable_unfix(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Variable *arg1 = (ampl::Variable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "Variable_unfix", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Variable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variable_unfix" "', argument " "1"" of type '" "ampl::Variable *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Variable * >(argp1);
  {
    try {
      (arg1)->unfix();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variable_setValue(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Variable *arg1 = (ampl::Variable *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Variable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variable_setValue" "', argument " "1"" of type '" "ampl::Variable *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Variable * >(argp1);
  ecode2 = SWIG_AsVal_double(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Variable_setValue" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->setValue(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variable_value(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Variable *arg1 = (ampl::Variable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "Variable_value", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Variable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variable_value" "', argument " "1"" of type '" "ampl::Variable *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Variable * >(argp1);
  {
    try {
      result = (double)(arg1)->value();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variable_astatus(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Variable *arg1 = (ampl::Variable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "Variable_astatus", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Variable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variable_astatus" "', argument " "1"" of type '" "ampl::Variable *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Variable * >(argp1);
  {
    try {
      result = (arg1)->astatus();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variable_defeqn(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Variable *arg1 = (ampl::Variable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  int result;
  
  if (!SWIG_Python_UnpackTuple(args, "Variable_defeqn", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Variable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variable_defeqn" "', argument " "1"" of type '" "ampl::Variable *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Variable * >(argp1);
  {
    try {
      result = (int)(arg1)->defeqn();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variable_dual(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Variable *arg1 = (ampl::Variable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "Variable_dual", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Variable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variable_dual" "', argument " "1"" of type '" "ampl::Variable *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Variable * >(argp1);
  {
    try {
      result = (double)(arg1)->dual();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variable_init(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Variable *arg1 = (ampl::Variable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "Variable_init", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Variable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variable_init" "', argument " "1"" of type '" "ampl::Variable *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Variable * >(argp1);
  {
    try {
      result = (double)(arg1)->init();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variable_init0(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Variable *arg1 = (ampl::Variable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "Variable_init0", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Variable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variable_init0" "', argument " "1"" of type '" "ampl::Variable *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Variable * >(argp1);
  {
    try {
      result = (double)(arg1)->init0();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variable_lb(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Variable *arg1 = (ampl::Variable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "Variable_lb", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Variable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variable_lb" "', argument " "1"" of type '" "ampl::Variable *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Variable * >(argp1);
  {
    try {
      result = (double)(arg1)->lb();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variable_ub(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Variable *arg1 = (ampl::Variable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "Variable_ub", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Variable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variable_ub" "', argument " "1"" of type '" "ampl::Variable *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Variable * >(argp1);
  {
    try {
      result = (double)(arg1)->ub();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variable_lb0(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Variable *arg1 = (ampl::Variable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "Variable_lb0", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Variable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variable_lb0" "', argument " "1"" of type '" "ampl::Variable *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Variable * >(argp1);
  {
    try {
      result = (double)(arg1)->lb0();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variable_ub0(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Variable *arg1 = (ampl::Variable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "Variable_ub0", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Variable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variable_ub0" "', argument " "1"" of type '" "ampl::Variable *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Variable * >(argp1);
  {
    try {
      result = (double)(arg1)->ub0();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variable_lb1(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Variable *arg1 = (ampl::Variable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "Variable_lb1", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Variable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variable_lb1" "', argument " "1"" of type '" "ampl::Variable *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Variable * >(argp1);
  {
    try {
      result = (double)(arg1)->lb1();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variable_ub1(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Variable *arg1 = (ampl::Variable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "Variable_ub1", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Variable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variable_ub1" "', argument " "1"" of type '" "ampl::Variable *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Variable * >(argp1);
  {
    try {
      result = (double)(arg1)->ub1();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variable_lb2(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Variable *arg1 = (ampl::Variable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "Variable_lb2", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Variable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variable_lb2" "', argument " "1"" of type '" "ampl::Variable *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Variable * >(argp1);
  {
    try {
      result = (double)(arg1)->lb2();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variable_ub2(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Variable *arg1 = (ampl::Variable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "Variable_ub2", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Variable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variable_ub2" "', argument " "1"" of type '" "ampl::Variable *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Variable * >(argp1);
  {
    try {
      result = (double)(arg1)->ub2();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variable_lrc(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Variable *arg1 = (ampl::Variable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "Variable_lrc", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Variable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variable_lrc" "', argument " "1"" of type '" "ampl::Variable *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Variable * >(argp1);
  {
    try {
      result = (double)(arg1)->lrc();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variable_urc(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Variable *arg1 = (ampl::Variable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "Variable_urc", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Variable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variable_urc" "', argument " "1"" of type '" "ampl::Variable *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Variable * >(argp1);
  {
    try {
      result = (double)(arg1)->urc();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variable_lslack(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Variable *arg1 = (ampl::Variable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "Variable_lslack", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Variable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variable_lslack" "', argument " "1"" of type '" "ampl::Variable *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Variable * >(argp1);
  {
    try {
      result = (double)(arg1)->lslack();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variable_uslack(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Variable *arg1 = (ampl::Variable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "Variable_uslack", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Variable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variable_uslack" "', argument " "1"" of type '" "ampl::Variable *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Variable * >(argp1);
  {
    try {
      result = (double)(arg1)->uslack();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variable_rc(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Variable *arg1 = (ampl::Variable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "Variable_rc", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Variable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variable_rc" "', argument " "1"" of type '" "ampl::Variable *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Variable * >(argp1);
  {
    try {
      result = (double)(arg1)->rc();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variable_slack(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Variable *arg1 = (ampl::Variable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "Variable_slack", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Variable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variable_slack" "', argument " "1"" of type '" "ampl::Variable *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Variable * >(argp1);
  {
    try {
      result = (double)(arg1)->slack();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variable_sstatus(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Variable *arg1 = (ampl::Variable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "Variable_sstatus", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Variable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variable_sstatus" "', argument " "1"" of type '" "ampl::Variable *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Variable * >(argp1);
  {
    try {
      result = (arg1)->sstatus();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variable_status(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Variable *arg1 = (ampl::Variable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "Variable_status", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Variable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variable_status" "', argument " "1"" of type '" "ampl::Variable *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Variable * >(argp1);
  {
    try {
      result = (arg1)->status();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_Variable(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Variable *arg1 = (ampl::Variable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_Variable", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Variable, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Variable" "', argument " "1"" of type '" "ampl::Variable *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Variable * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_Variable) /* defines _wrap_delete_Variable_destructor_closure */

SWIGINTERN PyObject *_wrap_Objective_value(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Objective *arg1 = (ampl::Objective *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "Objective_value", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Objective, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Objective_value" "', argument " "1"" of type '" "ampl::Objective *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Objective * >(argp1);
  {
    try {
      result = (double)(arg1)->value();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Objective_astatus(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Objective *arg1 = (ampl::Objective *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "Objective_astatus", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Objective, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Objective_astatus" "', argument " "1"" of type '" "ampl::Objective *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Objective * >(argp1);
  {
    try {
      result = (arg1)->astatus();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Objective_sstatus(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Objective *arg1 = (ampl::Objective *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "Objective_sstatus", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Objective, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Objective_sstatus" "', argument " "1"" of type '" "ampl::Objective *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Objective * >(argp1);
  {
    try {
      result = (arg1)->sstatus();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Objective_exitcode(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Objective *arg1 = (ampl::Objective *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  int result;
  
  if (!SWIG_Python_UnpackTuple(args, "Objective_exitcode", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Objective, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Objective_exitcode" "', argument " "1"" of type '" "ampl::Objective *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Objective * >(argp1);
  {
    try {
      result = (int)(arg1)->exitcode();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Objective_message(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Objective *arg1 = (ampl::Objective *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "Objective_message", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Objective, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Objective_message" "', argument " "1"" of type '" "ampl::Objective *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Objective * >(argp1);
  {
    try {
      result = (arg1)->message();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Objective_result(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Objective *arg1 = (ampl::Objective *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "Objective_result", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Objective, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Objective_result" "', argument " "1"" of type '" "ampl::Objective *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Objective * >(argp1);
  {
    try {
      result = (arg1)->result();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Objective_drop(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Objective *arg1 = (ampl::Objective *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "Objective_drop", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Objective, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Objective_drop" "', argument " "1"" of type '" "ampl::Objective *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Objective * >(argp1);
  {
    try {
      (arg1)->drop();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Objective_restore(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Objective *arg1 = (ampl::Objective *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "Objective_restore", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Objective, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Objective_restore" "', argument " "1"" of type '" "ampl::Objective *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Objective * >(argp1);
  {
    try {
      (arg1)->restore();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Objective_minimization(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Objective *arg1 = (ampl::Objective *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args, "Objective_minimization", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Objective, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Objective_minimization" "', argument " "1"" of type '" "ampl::Objective *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Objective * >(argp1);
  {
    try {
      result = (bool)(arg1)->minimization();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_Objective(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Objective *arg1 = (ampl::Objective *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_Objective", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Objective, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Objective" "', argument " "1"" of type '" "ampl::Objective *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Objective * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_Objective) /* defines _wrap_delete_Objective_destructor_closure */

SWIGINTERN PyObject *_wrap_Set_arity(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Set *arg1 = (ampl::Set *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::size_t result;
  
  if (!SWIG_Python_UnpackTuple(args, "Set_arity", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Set, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Set_arity" "', argument " "1"" of type '" "ampl::Set const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Set * >(argp1);
  {
    try {
      result = ((ampl::Set const *)arg1)->arity();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Set_getValues(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Set *arg1 = (ampl::Set *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  SwigValueWrapper< ampl::DataFrame > result;
  
  if (!SWIG_Python_UnpackTuple(args, "Set_getValues", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Set, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Set_getValues" "', argument " "1"" of type '" "ampl::Set const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Set * >(argp1);
  {
    try {
      result = ((ampl::Set const *)arg1)->getValues();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::DataFrame(static_cast< const ampl::DataFrame& >(result))), SWIGTYPE_p_ampl__DataFrame, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Set_size(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Set *arg1 = (ampl::Set *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::size_t result;
  
  if (!SWIG_Python_UnpackTuple(args, "Set_size", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Set, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Set_size" "', argument " "1"" of type '" "ampl::Set const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Set * >(argp1);
  {
    try {
      result = ((ampl::Set const *)arg1)->size();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Set_members(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Set *arg1 = (ampl::Set *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  SwigValueWrapper< ampl::SetInstance::MemberRange > result;
  
  if (!SWIG_Python_UnpackTuple(args, "Set_members", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Set, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Set_members" "', argument " "1"" of type '" "ampl::Set const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Set * >(argp1);
  {
    try {
      result = ((ampl::Set const *)arg1)->members();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::SetInstance::MemberRange(static_cast< const ampl::SetInstance::MemberRange& >(result))), SWIGTYPE_p_ampl__SetInstance__MemberRange, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Set_setValuesDf(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Set *arg1 = (ampl::Set *) 0 ;
  SwigValueWrapper< ampl::DataFrame > arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Set, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Set_setValuesDf" "', argument " "1"" of type '" "ampl::Set *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Set * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ampl__DataFrame,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Set_setValuesDf" "', argument " "2"" of type '" "ampl::DataFrame""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Set_setValuesDf" "', argument " "2"" of type '" "ampl::DataFrame""'");
    } else {
      ampl::DataFrame * temp = reinterpret_cast< ampl::DataFrame * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      (arg1)->setValues(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Set_contains(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Set *arg1 = (ampl::Set *) 0 ;
  ampl::Tuple arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Set, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Set_contains" "', argument " "1"" of type '" "ampl::Set const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Set * >(argp1);
  {
    SetTupleFromPyObject(swig_obj[0], &arg2);
  }
  {
    try {
      result = (bool)ampl_Set_contains((ampl::Set const *)arg1,arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Set_setValuesTuples(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Set *arg1 = (ampl::Set *) 0 ;
  ampl::Tuple *arg2 = (ampl::Tuple *) 0 ;
  std::size_t arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  
  {
    arg2 = NULL;
  }
  if (!SWIG_Python_UnpackTuple(args, "Set_setValuesTuples", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Set, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Set_setValuesTuples" "', argument " "1"" of type '" "ampl::Set *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Set * >(argp1);
  {
    /* Check if is a list */
    ampl::Tuple t;
    if (PyList_Check(swig_obj[0])) {
      int size = PyList_Size(swig_obj[0]);
      int i = 0;
      arg2 = (ampl::Tuple *)malloc(size * sizeof(ampl::Tuple));
      memset(arg2, 0, size * sizeof(ampl::Tuple));
      for (i = 0; i < size; i++) {
        PyObject *obj = PyList_GetItem(swig_obj[0], i);
        SetTupleFromPyObject(obj, &t);
        arg2[i] = t;
      }
    } else {
      SetTupleFromPyObject(swig_obj[0], &t);
      arg2 = (ampl::Tuple *)malloc(1 * sizeof(ampl::Tuple));
      memset(arg2, 0, 1 * sizeof(ampl::Tuple));
      arg2[0] = t;
    }
  }
  ecode3 = SWIG_AsVal_size_t(swig_obj[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Set_setValuesTuples" "', argument " "3"" of type '" "std::size_t""'");
  } 
  arg3 = static_cast< std::size_t >(val3);
  {
    try {
      ampl_Set_setValuesTuples(arg1,(ampl::Tuple const *)arg2,arg3);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  {
    free((ampl::Tuple *)arg2);
  }
  return resultobj;
fail:
  {
    free((ampl::Tuple *)arg2);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_Set_setValues(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Set *arg1 = (ampl::Set *) 0 ;
  TupleArray *arg2 = 0 ;
  std::size_t arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args, "Set_setValues", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Set, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Set_setValues" "', argument " "1"" of type '" "ampl::Set *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Set * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_TupleArray,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Set_setValues" "', argument " "2"" of type '" "TupleArray &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Set_setValues" "', argument " "2"" of type '" "TupleArray &""'"); 
  }
  arg2 = reinterpret_cast< TupleArray * >(argp2);
  ecode3 = SWIG_AsVal_size_t(swig_obj[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Set_setValues" "', argument " "3"" of type '" "std::size_t""'");
  } 
  arg3 = static_cast< std::size_t >(val3);
  {
    try {
      ampl_Set_setValues(arg1,*arg2,arg3);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Set_setValuesDbl(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Set *arg1 = (ampl::Set *) 0 ;
  double *arg2 = (double *) 0 ;
  std::size_t arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args, "Set_setValuesDbl", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Set, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Set_setValuesDbl" "', argument " "1"" of type '" "ampl::Set *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Set * >(argp1);
  {
    /* Check if is a list */
    if (PyList_Check(swig_obj[0])) {
      int size = PyList_Size(swig_obj[0]);
      int i = 0;
      arg2 = (double *)malloc(size * sizeof(double));
      for (i = 0; i < size; i++) {
        PyObject *o = PyList_GetItem(swig_obj[0],i);
        if (PyFloat_Check(o))
        arg2[i] = PyFloat_AsDouble(PyList_GetItem(swig_obj[0],i));
        else {
          PyErr_SetString(PyExc_TypeError, "The input list must contain floating point numbers");
          free(arg2);
          return NULL;
        }
      }
    }
    else {
      PyErr_SetString(PyExc_TypeError,"The input is not a list");
      return NULL;
    }
  }
  ecode3 = SWIG_AsVal_size_t(swig_obj[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Set_setValuesDbl" "', argument " "3"" of type '" "std::size_t""'");
  } 
  arg3 = static_cast< std::size_t >(val3);
  {
    try {
      ampl_Set_setValuesDbl(arg1,arg2,arg3);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  {
    free((double *)arg2);
  }
  return resultobj;
fail:
  {
    free((double *)arg2);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_Set_setValuesStr(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Set *arg1 = (ampl::Set *) 0 ;
  char **arg2 ;
  std::size_t arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  
  {
    arg2 = NULL;
  }
  if (!SWIG_Python_UnpackTuple(args, "Set_setValuesStr", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Set, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Set_setValuesStr" "', argument " "1"" of type '" "ampl::Set *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Set * >(argp1);
  {
    /* Check if is a list */
    if (PyList_Check(swig_obj[0])) {
      std::size_t size = PyList_Size(swig_obj[0]);
      std::size_t i = 0;
      arg2 = (char **)malloc((size + 1) * sizeof(char *));
      for (i = 0; i < size; i++) {
        PyObject *obj = PyList_GetItem(swig_obj[0],i);
        if (_PyString_Check(obj)) {
          arg2[i] = (char *)_PyString_AsString(PyList_GetItem(swig_obj[0],i));
        } else {
          PyErr_SetString(PyExc_TypeError, "list must contain strings");
          free(arg2);
          return NULL;
        }
      }
      arg2[i] = 0;
    } else {
      PyErr_SetString(PyExc_TypeError, "not a list");
      return NULL;
    }
  }
  ecode3 = SWIG_AsVal_size_t(swig_obj[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Set_setValuesStr" "', argument " "3"" of type '" "std::size_t""'");
  } 
  arg3 = static_cast< std::size_t >(val3);
  {
    try {
      ampl_Set_setValuesStr(arg1,(char const *(*))arg2,arg3);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  {
    free((char *)arg2);
  }
  return resultobj;
fail:
  {
    free((char *)arg2);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_Set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Set *arg1 = (ampl::Set *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_Set", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Set, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Set" "', argument " "1"" of type '" "ampl::Set *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Set * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_Set) /* defines _wrap_delete_Set_destructor_closure */

SWIGINTERN PyObject *_wrap_delete_Table(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Table *arg1 = (ampl::Table *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_Table", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Table, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Table" "', argument " "1"" of type '" "ampl::Table *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Table * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_Table) /* defines _wrap_delete_Table_destructor_closure */

SWIGINTERN PyObject *_wrap_Parameter_isSymbolic(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Parameter *arg1 = (ampl::Parameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_isSymbolic", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_isSymbolic" "', argument " "1"" of type '" "ampl::Parameter *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Parameter * >(argp1);
  {
    try {
      result = (bool)(arg1)->isSymbolic();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_hasDefault(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Parameter *arg1 = (ampl::Parameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_hasDefault", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_hasDefault" "', argument " "1"" of type '" "ampl::Parameter *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Parameter * >(argp1);
  {
    try {
      result = (bool)(arg1)->hasDefault();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_set__SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  ampl::Parameter *arg1 = (ampl::Parameter *) 0 ;
  SwigValueWrapper< ampl::Variant > arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_set" "', argument " "1"" of type '" "ampl::Parameter *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Parameter * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_ampl__Variant,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Parameter_set" "', argument " "2"" of type '" "ampl::Variant""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Parameter_set" "', argument " "2"" of type '" "ampl::Variant""'");
    } else {
      ampl::Variant * temp = reinterpret_cast< ampl::Variant * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      ampl_Parameter_set__SWIG_0(arg1,arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_set__SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  ampl::Parameter *arg1 = (ampl::Parameter *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_set" "', argument " "1"" of type '" "ampl::Parameter *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Parameter * >(argp1);
  ecode2 = SWIG_AsVal_double(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Parameter_set" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      ampl_Parameter_set__SWIG_1(arg1,arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_set__SWIG_2(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  ampl::Parameter *arg1 = (ampl::Parameter *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_set" "', argument " "1"" of type '" "ampl::Parameter *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Parameter * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Parameter_set" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      ampl_Parameter_set__SWIG_2(arg1,(char const *)arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_set__SWIG_3(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  ampl::Parameter *arg1 = (ampl::Parameter *) 0 ;
  ampl::Tuple arg2 ;
  SwigValueWrapper< ampl::Variant > arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_set" "', argument " "1"" of type '" "ampl::Parameter *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Parameter * >(argp1);
  {
    SetTupleFromPyObject(swig_obj[1], &arg2);
  }
  {
    res3 = SWIG_ConvertPtr(swig_obj[2], &argp3, SWIGTYPE_p_ampl__Variant,  0  | 0);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Parameter_set" "', argument " "3"" of type '" "ampl::Variant""'"); 
    }  
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Parameter_set" "', argument " "3"" of type '" "ampl::Variant""'");
    } else {
      ampl::Variant * temp = reinterpret_cast< ampl::Variant * >(argp3);
      arg3 = *temp;
      if (SWIG_IsNewObj(res3)) delete temp;
    }
  }
  {
    try {
      ampl_Parameter_set__SWIG_3(arg1,arg2,arg3);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_set(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "Parameter_set", 0, 3, argv+1))) SWIG_fail;
  argv[0] = self;
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__Parameter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_ampl__Variant, SWIG_POINTER_NO_NULL | 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Parameter_set__SWIG_0(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__Parameter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Parameter_set__SWIG_1(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__Parameter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Parameter_set__SWIG_2(self, argc, argv);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__Parameter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        _v = PyTuple_Check(argv[1]) ? 1 : 0;
      }
      if (_v) {
        int res = SWIG_ConvertPtr(argv[2], 0, SWIGTYPE_p_ampl__Variant, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_Parameter_set__SWIG_3(self, argc, argv);
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'Parameter_set'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    ampl::Parameter::set(ampl::Variant)\n"
    "    ampl::Parameter::set(double)\n"
    "    ampl::Parameter::set(char const *)\n"
    "    ampl::Parameter::set(ampl::Tuple,ampl::Variant)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_Parameter_setTplDbl(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Parameter *arg1 = (ampl::Parameter *) 0 ;
  ampl::Tuple arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_setTplDbl", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_setTplDbl" "', argument " "1"" of type '" "ampl::Parameter *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Parameter * >(argp1);
  {
    SetTupleFromPyObject(swig_obj[0], &arg2);
  }
  ecode3 = SWIG_AsVal_double(swig_obj[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Parameter_setTplDbl" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  {
    try {
      ampl_Parameter_set(arg1,arg2,arg3);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_setTplStr(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Parameter *arg1 = (ampl::Parameter *) 0 ;
  ampl::Tuple arg2 ;
  char *arg3 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_setTplStr", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_setTplStr" "', argument " "1"" of type '" "ampl::Parameter *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Parameter * >(argp1);
  {
    SetTupleFromPyObject(swig_obj[0], &arg2);
  }
  res3 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Parameter_setTplStr" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = reinterpret_cast< char * >(buf3);
  {
    try {
      ampl_Parameter_set(arg1,arg2,(char const *)arg3);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return resultobj;
fail:
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_setValuesTaDbl(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Parameter *arg1 = (ampl::Parameter *) 0 ;
  ampl::Tuple *arg2 = (ampl::Tuple *) 0 ;
  double *arg3 = (double *) 0 ;
  std::size_t arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val4 ;
  int ecode4 = 0 ;
  PyObject *swig_obj[4] ;
  
  {
    arg2 = NULL;
  }
  if (!SWIG_Python_UnpackTuple(args, "Parameter_setValuesTaDbl", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_setValuesTaDbl" "', argument " "1"" of type '" "ampl::Parameter *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Parameter * >(argp1);
  {
    /* Check if is a list */
    ampl::Tuple t;
    if (PyList_Check(swig_obj[0])) {
      int size = PyList_Size(swig_obj[0]);
      int i = 0;
      arg2 = (ampl::Tuple *)malloc(size * sizeof(ampl::Tuple));
      memset(arg2, 0, size * sizeof(ampl::Tuple));
      for (i = 0; i < size; i++) {
        PyObject *obj = PyList_GetItem(swig_obj[0], i);
        SetTupleFromPyObject(obj, &t);
        arg2[i] = t;
      }
    } else {
      SetTupleFromPyObject(swig_obj[0], &t);
      arg2 = (ampl::Tuple *)malloc(1 * sizeof(ampl::Tuple));
      memset(arg2, 0, 1 * sizeof(ampl::Tuple));
      arg2[0] = t;
    }
  }
  {
    /* Check if is a list */
    if (PyList_Check(swig_obj[1])) {
      int size = PyList_Size(swig_obj[1]);
      int i = 0;
      arg3 = (double *)malloc(size * sizeof(double));
      for (i = 0; i < size; i++) {
        PyObject *o = PyList_GetItem(swig_obj[1],i);
        if (PyFloat_Check(o))
        arg3[i] = PyFloat_AsDouble(PyList_GetItem(swig_obj[1],i));
        else {
          PyErr_SetString(PyExc_TypeError, "The input list must contain floating point numbers");
          free(arg3);
          return NULL;
        }
      }
    }
    else {
      PyErr_SetString(PyExc_TypeError,"The input is not a list");
      return NULL;
    }
  }
  ecode4 = SWIG_AsVal_size_t(swig_obj[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Parameter_setValuesTaDbl" "', argument " "4"" of type '" "std::size_t""'");
  } 
  arg4 = static_cast< std::size_t >(val4);
  {
    try {
      ampl_Parameter_setValues(arg1,(ampl::Tuple const *)arg2,(double const *)arg3,arg4);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  {
    free((ampl::Tuple *)arg2);
  }
  {
    free((double *)arg3);
  }
  return resultobj;
fail:
  {
    free((ampl::Tuple *)arg2);
  }
  {
    free((double *)arg3);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_setValuesTupleArrayDbl(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Parameter *arg1 = (ampl::Parameter *) 0 ;
  TupleArray *arg2 = 0 ;
  double *arg3 = (double *) 0 ;
  std::size_t arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  size_t val4 ;
  int ecode4 = 0 ;
  PyObject *swig_obj[4] ;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_setValuesTupleArrayDbl", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_setValuesTupleArrayDbl" "', argument " "1"" of type '" "ampl::Parameter *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Parameter * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_TupleArray,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Parameter_setValuesTupleArrayDbl" "', argument " "2"" of type '" "TupleArray &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Parameter_setValuesTupleArrayDbl" "', argument " "2"" of type '" "TupleArray &""'"); 
  }
  arg2 = reinterpret_cast< TupleArray * >(argp2);
  {
    /* Check if is a list */
    if (PyList_Check(swig_obj[1])) {
      int size = PyList_Size(swig_obj[1]);
      int i = 0;
      arg3 = (double *)malloc(size * sizeof(double));
      for (i = 0; i < size; i++) {
        PyObject *o = PyList_GetItem(swig_obj[1],i);
        if (PyFloat_Check(o))
        arg3[i] = PyFloat_AsDouble(PyList_GetItem(swig_obj[1],i));
        else {
          PyErr_SetString(PyExc_TypeError, "The input list must contain floating point numbers");
          free(arg3);
          return NULL;
        }
      }
    }
    else {
      PyErr_SetString(PyExc_TypeError,"The input is not a list");
      return NULL;
    }
  }
  ecode4 = SWIG_AsVal_size_t(swig_obj[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Parameter_setValuesTupleArrayDbl" "', argument " "4"" of type '" "std::size_t""'");
  } 
  arg4 = static_cast< std::size_t >(val4);
  {
    try {
      ampl_Parameter_setValues(arg1,*arg2,arg3,arg4);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  {
    free((double *)arg3);
  }
  return resultobj;
fail:
  {
    free((double *)arg3);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_setValuesTaStr(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Parameter *arg1 = (ampl::Parameter *) 0 ;
  ampl::Tuple *arg2 = (ampl::Tuple *) 0 ;
  char **arg3 ;
  std::size_t arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val4 ;
  int ecode4 = 0 ;
  PyObject *swig_obj[4] ;
  
  {
    arg2 = NULL;
  }
  {
    arg3 = NULL;
  }
  if (!SWIG_Python_UnpackTuple(args, "Parameter_setValuesTaStr", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_setValuesTaStr" "', argument " "1"" of type '" "ampl::Parameter *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Parameter * >(argp1);
  {
    /* Check if is a list */
    ampl::Tuple t;
    if (PyList_Check(swig_obj[0])) {
      int size = PyList_Size(swig_obj[0]);
      int i = 0;
      arg2 = (ampl::Tuple *)malloc(size * sizeof(ampl::Tuple));
      memset(arg2, 0, size * sizeof(ampl::Tuple));
      for (i = 0; i < size; i++) {
        PyObject *obj = PyList_GetItem(swig_obj[0], i);
        SetTupleFromPyObject(obj, &t);
        arg2[i] = t;
      }
    } else {
      SetTupleFromPyObject(swig_obj[0], &t);
      arg2 = (ampl::Tuple *)malloc(1 * sizeof(ampl::Tuple));
      memset(arg2, 0, 1 * sizeof(ampl::Tuple));
      arg2[0] = t;
    }
  }
  {
    /* Check if is a list */
    if (PyList_Check(swig_obj[1])) {
      std::size_t size = PyList_Size(swig_obj[1]);
      std::size_t i = 0;
      arg3 = (char **)malloc((size + 1) * sizeof(char *));
      for (i = 0; i < size; i++) {
        PyObject *obj = PyList_GetItem(swig_obj[1],i);
        if (_PyString_Check(obj)) {
          arg3[i] = (char *)_PyString_AsString(PyList_GetItem(swig_obj[1],i));
        } else {
          PyErr_SetString(PyExc_TypeError, "list must contain strings");
          free(arg3);
          return NULL;
        }
      }
      arg3[i] = 0;
    } else {
      PyErr_SetString(PyExc_TypeError, "not a list");
      return NULL;
    }
  }
  ecode4 = SWIG_AsVal_size_t(swig_obj[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Parameter_setValuesTaStr" "', argument " "4"" of type '" "std::size_t""'");
  } 
  arg4 = static_cast< std::size_t >(val4);
  {
    try {
      ampl_Parameter_setValues(arg1,(ampl::Tuple const *)arg2,(char const *(*))arg3,arg4);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  {
    free((ampl::Tuple *)arg2);
  }
  {
    free((char *)arg3);
  }
  return resultobj;
fail:
  {
    free((ampl::Tuple *)arg2);
  }
  {
    free((char *)arg3);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_setValuesTupleArrayStr(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Parameter *arg1 = (ampl::Parameter *) 0 ;
  TupleArray *arg2 = 0 ;
  char **arg3 ;
  std::size_t arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  size_t val4 ;
  int ecode4 = 0 ;
  PyObject *swig_obj[4] ;
  
  {
    arg3 = NULL;
  }
  if (!SWIG_Python_UnpackTuple(args, "Parameter_setValuesTupleArrayStr", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_setValuesTupleArrayStr" "', argument " "1"" of type '" "ampl::Parameter *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Parameter * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_TupleArray,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Parameter_setValuesTupleArrayStr" "', argument " "2"" of type '" "TupleArray &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Parameter_setValuesTupleArrayStr" "', argument " "2"" of type '" "TupleArray &""'"); 
  }
  arg2 = reinterpret_cast< TupleArray * >(argp2);
  {
    /* Check if is a list */
    if (PyList_Check(swig_obj[1])) {
      std::size_t size = PyList_Size(swig_obj[1]);
      std::size_t i = 0;
      arg3 = (char **)malloc((size + 1) * sizeof(char *));
      for (i = 0; i < size; i++) {
        PyObject *obj = PyList_GetItem(swig_obj[1],i);
        if (_PyString_Check(obj)) {
          arg3[i] = (char *)_PyString_AsString(PyList_GetItem(swig_obj[1],i));
        } else {
          PyErr_SetString(PyExc_TypeError, "list must contain strings");
          free(arg3);
          return NULL;
        }
      }
      arg3[i] = 0;
    } else {
      PyErr_SetString(PyExc_TypeError, "not a list");
      return NULL;
    }
  }
  ecode4 = SWIG_AsVal_size_t(swig_obj[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Parameter_setValuesTupleArrayStr" "', argument " "4"" of type '" "std::size_t""'");
  } 
  arg4 = static_cast< std::size_t >(val4);
  {
    try {
      ampl_Parameter_setValues(arg1,*arg2,(char const *(*))arg3,arg4);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  {
    free((char *)arg3);
  }
  return resultobj;
fail:
  {
    free((char *)arg3);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_setValuesDbl(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Parameter *arg1 = (ampl::Parameter *) 0 ;
  double *arg2 = (double *) 0 ;
  std::size_t arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args, "Parameter_setValuesDbl", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_setValuesDbl" "', argument " "1"" of type '" "ampl::Parameter *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Parameter * >(argp1);
  {
    /* Check if is a list */
    if (PyList_Check(swig_obj[0])) {
      int size = PyList_Size(swig_obj[0]);
      int i = 0;
      arg2 = (double *)malloc(size * sizeof(double));
      for (i = 0; i < size; i++) {
        PyObject *o = PyList_GetItem(swig_obj[0],i);
        if (PyFloat_Check(o))
        arg2[i] = PyFloat_AsDouble(PyList_GetItem(swig_obj[0],i));
        else {
          PyErr_SetString(PyExc_TypeError, "The input list must contain floating point numbers");
          free(arg2);
          return NULL;
        }
      }
    }
    else {
      PyErr_SetString(PyExc_TypeError,"The input is not a list");
      return NULL;
    }
  }
  ecode3 = SWIG_AsVal_size_t(swig_obj[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Parameter_setValuesDbl" "', argument " "3"" of type '" "std::size_t""'");
  } 
  arg3 = static_cast< std::size_t >(val3);
  {
    try {
      ampl_Parameter_setValues(arg1,arg2,arg3);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  {
    free((double *)arg2);
  }
  return resultobj;
fail:
  {
    free((double *)arg2);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_setValuesStr(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Parameter *arg1 = (ampl::Parameter *) 0 ;
  char **arg2 ;
  std::size_t arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  
  {
    arg2 = NULL;
  }
  if (!SWIG_Python_UnpackTuple(args, "Parameter_setValuesStr", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_setValuesStr" "', argument " "1"" of type '" "ampl::Parameter *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Parameter * >(argp1);
  {
    /* Check if is a list */
    if (PyList_Check(swig_obj[0])) {
      std::size_t size = PyList_Size(swig_obj[0]);
      std::size_t i = 0;
      arg2 = (char **)malloc((size + 1) * sizeof(char *));
      for (i = 0; i < size; i++) {
        PyObject *obj = PyList_GetItem(swig_obj[0],i);
        if (_PyString_Check(obj)) {
          arg2[i] = (char *)_PyString_AsString(PyList_GetItem(swig_obj[0],i));
        } else {
          PyErr_SetString(PyExc_TypeError, "list must contain strings");
          free(arg2);
          return NULL;
        }
      }
      arg2[i] = 0;
    } else {
      PyErr_SetString(PyExc_TypeError, "not a list");
      return NULL;
    }
  }
  ecode3 = SWIG_AsVal_size_t(swig_obj[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Parameter_setValuesStr" "', argument " "3"" of type '" "std::size_t""'");
  } 
  arg3 = static_cast< std::size_t >(val3);
  {
    try {
      ampl_Parameter_setValues(arg1,(char const *(*))arg2,arg3);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  {
    free((char *)arg2);
  }
  return resultobj;
fail:
  {
    free((char *)arg2);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_setValues__SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  ampl::Parameter *arg1 = (ampl::Parameter *) 0 ;
  std::size_t arg2 ;
  char **arg3 ;
  std::size_t arg4 ;
  char **arg5 ;
  double *arg6 = (double *) 0 ;
  bool arg7 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  size_t val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  bool val7 ;
  int ecode7 = 0 ;
  
  if ((nobjs < 7) || (nobjs > 7)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_setValues" "', argument " "1"" of type '" "ampl::Parameter *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Parameter * >(argp1);
  ecode2 = SWIG_AsVal_size_t(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Parameter_setValues" "', argument " "2"" of type '" "std::size_t""'");
  } 
  arg2 = static_cast< std::size_t >(val2);
  res3 = SWIG_ConvertPtr(swig_obj[2], &argp3,SWIGTYPE_p_p_char, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Parameter_setValues" "', argument " "3"" of type '" "char const *[]""'"); 
  } 
  arg3 = reinterpret_cast< char ** >(argp3);
  ecode4 = SWIG_AsVal_size_t(swig_obj[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Parameter_setValues" "', argument " "4"" of type '" "std::size_t""'");
  } 
  arg4 = static_cast< std::size_t >(val4);
  res5 = SWIG_ConvertPtr(swig_obj[4], &argp5,SWIGTYPE_p_p_char, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "Parameter_setValues" "', argument " "5"" of type '" "char const *[]""'"); 
  } 
  arg5 = reinterpret_cast< char ** >(argp5);
  {
    /* Check if is a list */
    if (PyList_Check(swig_obj[5])) {
      int size = PyList_Size(swig_obj[5]);
      int i = 0;
      arg6 = (double *)malloc(size * sizeof(double));
      for (i = 0; i < size; i++) {
        PyObject *o = PyList_GetItem(swig_obj[5],i);
        if (PyFloat_Check(o))
        arg6[i] = PyFloat_AsDouble(PyList_GetItem(swig_obj[5],i));
        else {
          PyErr_SetString(PyExc_TypeError, "The input list must contain floating point numbers");
          free(arg6);
          return NULL;
        }
      }
    }
    else {
      PyErr_SetString(PyExc_TypeError,"The input is not a list");
      return NULL;
    }
  }
  ecode7 = SWIG_AsVal_bool(swig_obj[6], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "Parameter_setValues" "', argument " "7"" of type '" "bool""'");
  } 
  arg7 = static_cast< bool >(val7);
  {
    try {
      ampl_Parameter_setValues__SWIG_0(arg1,arg2,(char const *(*))arg3,arg4,(char const *(*))arg5,(double const *)arg6,arg7);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  {
    free((double *)arg6);
  }
  return resultobj;
fail:
  {
    free((double *)arg6);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_setValues__SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  ampl::Parameter *arg1 = (ampl::Parameter *) 0 ;
  std::size_t arg2 ;
  double *arg3 = (double *) 0 ;
  std::size_t arg4 ;
  double *arg5 = (double *) 0 ;
  double *arg6 = (double *) 0 ;
  bool arg7 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  size_t val4 ;
  int ecode4 = 0 ;
  bool val7 ;
  int ecode7 = 0 ;
  
  if ((nobjs < 7) || (nobjs > 7)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_setValues" "', argument " "1"" of type '" "ampl::Parameter *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Parameter * >(argp1);
  ecode2 = SWIG_AsVal_size_t(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Parameter_setValues" "', argument " "2"" of type '" "std::size_t""'");
  } 
  arg2 = static_cast< std::size_t >(val2);
  {
    /* Check if is a list */
    if (PyList_Check(swig_obj[2])) {
      int size = PyList_Size(swig_obj[2]);
      int i = 0;
      arg3 = (double *)malloc(size * sizeof(double));
      for (i = 0; i < size; i++) {
        PyObject *o = PyList_GetItem(swig_obj[2],i);
        if (PyFloat_Check(o))
        arg3[i] = PyFloat_AsDouble(PyList_GetItem(swig_obj[2],i));
        else {
          PyErr_SetString(PyExc_TypeError, "The input list must contain floating point numbers");
          free(arg3);
          return NULL;
        }
      }
    }
    else {
      PyErr_SetString(PyExc_TypeError,"The input is not a list");
      return NULL;
    }
  }
  ecode4 = SWIG_AsVal_size_t(swig_obj[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Parameter_setValues" "', argument " "4"" of type '" "std::size_t""'");
  } 
  arg4 = static_cast< std::size_t >(val4);
  {
    /* Check if is a list */
    if (PyList_Check(swig_obj[4])) {
      int size = PyList_Size(swig_obj[4]);
      int i = 0;
      arg5 = (double *)malloc(size * sizeof(double));
      for (i = 0; i < size; i++) {
        PyObject *o = PyList_GetItem(swig_obj[4],i);
        if (PyFloat_Check(o))
        arg5[i] = PyFloat_AsDouble(PyList_GetItem(swig_obj[4],i));
        else {
          PyErr_SetString(PyExc_TypeError, "The input list must contain floating point numbers");
          free(arg5);
          return NULL;
        }
      }
    }
    else {
      PyErr_SetString(PyExc_TypeError,"The input is not a list");
      return NULL;
    }
  }
  {
    /* Check if is a list */
    if (PyList_Check(swig_obj[5])) {
      int size = PyList_Size(swig_obj[5]);
      int i = 0;
      arg6 = (double *)malloc(size * sizeof(double));
      for (i = 0; i < size; i++) {
        PyObject *o = PyList_GetItem(swig_obj[5],i);
        if (PyFloat_Check(o))
        arg6[i] = PyFloat_AsDouble(PyList_GetItem(swig_obj[5],i));
        else {
          PyErr_SetString(PyExc_TypeError, "The input list must contain floating point numbers");
          free(arg6);
          return NULL;
        }
      }
    }
    else {
      PyErr_SetString(PyExc_TypeError,"The input is not a list");
      return NULL;
    }
  }
  ecode7 = SWIG_AsVal_bool(swig_obj[6], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "Parameter_setValues" "', argument " "7"" of type '" "bool""'");
  } 
  arg7 = static_cast< bool >(val7);
  {
    try {
      ampl_Parameter_setValues__SWIG_1(arg1,arg2,arg3,arg4,arg5,(double const *)arg6,arg7);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  {
    free((double *)arg3);
  }
  {
    free((double *)arg5);
  }
  {
    free((double *)arg6);
  }
  return resultobj;
fail:
  {
    free((double *)arg3);
  }
  {
    free((double *)arg5);
  }
  {
    free((double *)arg6);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_setValues(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[8] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "Parameter_setValues", 0, 7, argv+1))) SWIG_fail;
  argv[0] = self;
  if (argc == 7) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__Parameter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_p_char, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_size_t(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            void *vptr = 0;
            int res = SWIG_ConvertPtr(argv[4], &vptr, SWIGTYPE_p_p_char, 0);
            _v = SWIG_CheckState(res);
            if (_v) {
              void *vptr = 0;
              int res = SWIG_ConvertPtr(argv[5], &vptr, SWIGTYPE_p_double, 0);
              _v = SWIG_CheckState(res);
              if (_v) {
                {
                  int res = SWIG_AsVal_bool(argv[6], NULL);
                  _v = SWIG_CheckState(res);
                }
                if (_v) {
                  return _wrap_Parameter_setValues__SWIG_0(self, argc, argv);
                }
              }
            }
          }
        }
      }
    }
  }
  if (argc == 7) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__Parameter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_double, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_size_t(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            void *vptr = 0;
            int res = SWIG_ConvertPtr(argv[4], &vptr, SWIGTYPE_p_double, 0);
            _v = SWIG_CheckState(res);
            if (_v) {
              void *vptr = 0;
              int res = SWIG_ConvertPtr(argv[5], &vptr, SWIGTYPE_p_double, 0);
              _v = SWIG_CheckState(res);
              if (_v) {
                {
                  int res = SWIG_AsVal_bool(argv[6], NULL);
                  _v = SWIG_CheckState(res);
                }
                if (_v) {
                  return _wrap_Parameter_setValues__SWIG_1(self, argc, argv);
                }
              }
            }
          }
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'Parameter_setValues'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    ampl::Parameter::setValues(std::size_t,char const *[],std::size_t,char const *[],double const *,bool)\n"
    "    ampl::Parameter::setValues(std::size_t,double *,std::size_t,double *,double const *,bool)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_Parameter_setValuesPyDict(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Parameter *arg1 = (ampl::Parameter *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_setValuesPyDict" "', argument " "1"" of type '" "ampl::Parameter *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Parameter * >(argp1);
  arg2 = swig_obj[0];
  {
    try {
      ampl_Parameter_setValuesPyDict(arg1,arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_Parameter(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Parameter *arg1 = (ampl::Parameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_Parameter", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Parameter, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Parameter" "', argument " "1"" of type '" "ampl::Parameter *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Parameter * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_Parameter) /* defines _wrap_delete_Parameter_destructor_closure */

SWIGINTERN PyObject *_wrap_delete_VariableIteratorWrapper(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::EntityWrapper< ampl::VariableInstance > *arg1 = (ampl::internal::EntityWrapper< ampl::VariableInstance > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_VariableIteratorWrapper", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__EntityWrapperT_ampl__VariableInstance_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_VariableIteratorWrapper" "', argument " "1"" of type '" "ampl::internal::EntityWrapper< ampl::VariableInstance > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::EntityWrapper< ampl::VariableInstance > * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_VariableIteratorWrapper) /* defines _wrap_delete_VariableIteratorWrapper_destructor_closure */

SWIGINTERN PyObject *_wrap_VariableIterator_equals(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > *) 0 ;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariableIterator_equals" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VariableIterator_equals" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VariableIterator_equals" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > * >(argp2);
  {
    try {
      result = (bool)((ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > const *)arg1)->operator ==((ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_VariableIterator_differs(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > *) 0 ;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariableIterator_differs" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VariableIterator_differs" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VariableIterator_differs" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > * >(argp2);
  {
    try {
      result = (bool)((ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > const *)arg1)->operator !=((ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_VariableIterator_clone(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > *) 0 ;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariableIterator_clone" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VariableIterator_clone" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VariableIterator_clone" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > * >(argp2);
  {
    try {
      result = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > *) &(arg1)->operator =((ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariableIterator_postIncrement(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "VariableIterator_postIncrement", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariableIterator_postIncrement" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > * >(argp1);
  {
    try {
      result = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > *) &(arg1)->operator ++();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariableIterator_postIncrementBy(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariableIterator_postIncrementBy" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > * >(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VariableIterator_postIncrementBy" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  {
    try {
      result = (arg1)->operator ++(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > >(static_cast< const ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > >& >(result))), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariableIterator_first(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  SwigValueWrapper< ampl::TupleRef > result;
  
  if (!SWIG_Python_UnpackTuple(args, "VariableIterator_first", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariableIterator_first" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > * >(argp1);
  {
    try {
      result = ampl_internal_CountedIterator_Sl_ampl_internal_EntityWrapper_Sl_ampl_VariableInstance_Sg__Sg__first(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  {
    const ampl::TupleRef &tuple = result; // to avoid issues with result[i];
    std::size_t size = tuple.size();
    if (size != 1) {
      resultobj = PyTuple_New(size);
    }
    for (std::size_t i = 0; i < size; i++) {
      const ampl::VariantRef &v = tuple[i];
      PyObject *item = NULL;
      switch (v.type()) {
      case ampl::STRING:
        item = PyString_FromString(v.c_str());
        break;
      case ampl::NUMERIC:
        item = PyFloat_FromDouble(v.dbl());
        break;
      case ampl::EMPTY:
        item = Py_None;
        break;
      }
      if (size != 1) {
        PyTuple_SetItem(resultobj, i, item);
      } else {
        resultobj = item;
      }
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariableIterator_second(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  SwigValueWrapper< ampl::VariableInstance > result;
  
  if (!SWIG_Python_UnpackTuple(args, "VariableIterator_second", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariableIterator_second" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > * >(argp1);
  {
    try {
      result = ampl_internal_CountedIterator_Sl_ampl_internal_EntityWrapper_Sl_ampl_VariableInstance_Sg__Sg__second(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::internal::EntityWrapper< ampl::VariableInstance >::InstanceType(static_cast< const ampl::internal::EntityWrapper< ampl::VariableInstance >::InstanceType& >(result))), SWIGTYPE_p_ampl__VariableInstance, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_VariableIterator(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_VariableIterator", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_VariableIterator" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_VariableIterator) /* defines _wrap_delete_VariableIterator_destructor_closure */

SWIGINTERN PyObject *_wrap_delete_ConstraintIteratorWrapper(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::EntityWrapper< ampl::ConstraintInstance > *arg1 = (ampl::internal::EntityWrapper< ampl::ConstraintInstance > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_ConstraintIteratorWrapper", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ConstraintIteratorWrapper" "', argument " "1"" of type '" "ampl::internal::EntityWrapper< ampl::ConstraintInstance > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::EntityWrapper< ampl::ConstraintInstance > * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_ConstraintIteratorWrapper) /* defines _wrap_delete_ConstraintIteratorWrapper_destructor_closure */

SWIGINTERN PyObject *_wrap_ConstraintIterator_equals(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > *) 0 ;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConstraintIterator_equals" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ConstraintIterator_equals" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ConstraintIterator_equals" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > * >(argp2);
  {
    try {
      result = (bool)((ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > const *)arg1)->operator ==((ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_ConstraintIterator_differs(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > *) 0 ;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConstraintIterator_differs" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ConstraintIterator_differs" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ConstraintIterator_differs" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > * >(argp2);
  {
    try {
      result = (bool)((ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > const *)arg1)->operator !=((ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_ConstraintIterator_clone(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > *) 0 ;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConstraintIterator_clone" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ConstraintIterator_clone" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ConstraintIterator_clone" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > * >(argp2);
  {
    try {
      result = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > *) &(arg1)->operator =((ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ConstraintIterator_postIncrement(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "ConstraintIterator_postIncrement", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConstraintIterator_postIncrement" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > * >(argp1);
  {
    try {
      result = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > *) &(arg1)->operator ++();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ConstraintIterator_postIncrementBy(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConstraintIterator_postIncrementBy" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > * >(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ConstraintIterator_postIncrementBy" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  {
    try {
      result = (arg1)->operator ++(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > >(static_cast< const ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > >& >(result))), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ConstraintIterator_first(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  SwigValueWrapper< ampl::TupleRef > result;
  
  if (!SWIG_Python_UnpackTuple(args, "ConstraintIterator_first", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConstraintIterator_first" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > * >(argp1);
  {
    try {
      result = ampl_internal_CountedIterator_Sl_ampl_internal_EntityWrapper_Sl_ampl_ConstraintInstance_Sg__Sg__first(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  {
    const ampl::TupleRef &tuple = result; // to avoid issues with result[i];
    std::size_t size = tuple.size();
    if (size != 1) {
      resultobj = PyTuple_New(size);
    }
    for (std::size_t i = 0; i < size; i++) {
      const ampl::VariantRef &v = tuple[i];
      PyObject *item = NULL;
      switch (v.type()) {
      case ampl::STRING:
        item = PyString_FromString(v.c_str());
        break;
      case ampl::NUMERIC:
        item = PyFloat_FromDouble(v.dbl());
        break;
      case ampl::EMPTY:
        item = Py_None;
        break;
      }
      if (size != 1) {
        PyTuple_SetItem(resultobj, i, item);
      } else {
        resultobj = item;
      }
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ConstraintIterator_second(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  SwigValueWrapper< ampl::ConstraintInstance > result;
  
  if (!SWIG_Python_UnpackTuple(args, "ConstraintIterator_second", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConstraintIterator_second" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > * >(argp1);
  {
    try {
      result = ampl_internal_CountedIterator_Sl_ampl_internal_EntityWrapper_Sl_ampl_ConstraintInstance_Sg__Sg__second(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::internal::EntityWrapper< ampl::ConstraintInstance >::InstanceType(static_cast< const ampl::internal::EntityWrapper< ampl::ConstraintInstance >::InstanceType& >(result))), SWIGTYPE_p_ampl__ConstraintInstance, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ConstraintIterator(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_ConstraintIterator", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ConstraintIterator" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_ConstraintIterator) /* defines _wrap_delete_ConstraintIterator_destructor_closure */

SWIGINTERN PyObject *_wrap_delete_ObjectiveIteratorWrapper(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::EntityWrapper< ampl::ObjectiveInstance > *arg1 = (ampl::internal::EntityWrapper< ampl::ObjectiveInstance > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_ObjectiveIteratorWrapper", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ObjectiveIteratorWrapper" "', argument " "1"" of type '" "ampl::internal::EntityWrapper< ampl::ObjectiveInstance > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_ObjectiveIteratorWrapper) /* defines _wrap_delete_ObjectiveIteratorWrapper_destructor_closure */

SWIGINTERN PyObject *_wrap_ObjectiveIterator_equals(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > *) 0 ;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ObjectiveIterator_equals" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ObjectiveIterator_equals" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ObjectiveIterator_equals" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > * >(argp2);
  {
    try {
      result = (bool)((ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > const *)arg1)->operator ==((ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_ObjectiveIterator_differs(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > *) 0 ;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ObjectiveIterator_differs" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ObjectiveIterator_differs" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ObjectiveIterator_differs" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > * >(argp2);
  {
    try {
      result = (bool)((ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > const *)arg1)->operator !=((ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_ObjectiveIterator_clone(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > *) 0 ;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ObjectiveIterator_clone" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ObjectiveIterator_clone" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ObjectiveIterator_clone" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > * >(argp2);
  {
    try {
      result = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > *) &(arg1)->operator =((ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ObjectiveIterator_postIncrement(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "ObjectiveIterator_postIncrement", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ObjectiveIterator_postIncrement" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > * >(argp1);
  {
    try {
      result = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > *) &(arg1)->operator ++();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ObjectiveIterator_postIncrementBy(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ObjectiveIterator_postIncrementBy" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > * >(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ObjectiveIterator_postIncrementBy" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  {
    try {
      result = (arg1)->operator ++(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > >(static_cast< const ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > >& >(result))), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ObjectiveIterator_first(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  SwigValueWrapper< ampl::TupleRef > result;
  
  if (!SWIG_Python_UnpackTuple(args, "ObjectiveIterator_first", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ObjectiveIterator_first" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > * >(argp1);
  {
    try {
      result = ampl_internal_CountedIterator_Sl_ampl_internal_EntityWrapper_Sl_ampl_ObjectiveInstance_Sg__Sg__first(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  {
    const ampl::TupleRef &tuple = result; // to avoid issues with result[i];
    std::size_t size = tuple.size();
    if (size != 1) {
      resultobj = PyTuple_New(size);
    }
    for (std::size_t i = 0; i < size; i++) {
      const ampl::VariantRef &v = tuple[i];
      PyObject *item = NULL;
      switch (v.type()) {
      case ampl::STRING:
        item = PyString_FromString(v.c_str());
        break;
      case ampl::NUMERIC:
        item = PyFloat_FromDouble(v.dbl());
        break;
      case ampl::EMPTY:
        item = Py_None;
        break;
      }
      if (size != 1) {
        PyTuple_SetItem(resultobj, i, item);
      } else {
        resultobj = item;
      }
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ObjectiveIterator_second(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  SwigValueWrapper< ampl::ObjectiveInstance > result;
  
  if (!SWIG_Python_UnpackTuple(args, "ObjectiveIterator_second", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ObjectiveIterator_second" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > * >(argp1);
  {
    try {
      result = ampl_internal_CountedIterator_Sl_ampl_internal_EntityWrapper_Sl_ampl_ObjectiveInstance_Sg__Sg__second(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::internal::EntityWrapper< ampl::ObjectiveInstance >::InstanceType(static_cast< const ampl::internal::EntityWrapper< ampl::ObjectiveInstance >::InstanceType& >(result))), SWIGTYPE_p_ampl__ObjectiveInstance, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ObjectiveIterator(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_ObjectiveIterator", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ObjectiveIterator" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_ObjectiveIterator) /* defines _wrap_delete_ObjectiveIterator_destructor_closure */

SWIGINTERN PyObject *_wrap_delete_SetIteratorWrapper(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::EntityWrapper< ampl::SetInstance > *arg1 = (ampl::internal::EntityWrapper< ampl::SetInstance > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_SetIteratorWrapper", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__EntityWrapperT_ampl__SetInstance_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SetIteratorWrapper" "', argument " "1"" of type '" "ampl::internal::EntityWrapper< ampl::SetInstance > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::EntityWrapper< ampl::SetInstance > * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_SetIteratorWrapper) /* defines _wrap_delete_SetIteratorWrapper_destructor_closure */

SWIGINTERN PyObject *_wrap_SetIterator_equals(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > *) 0 ;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetIterator_equals" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetIterator_equals" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetIterator_equals" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > * >(argp2);
  {
    try {
      result = (bool)((ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > const *)arg1)->operator ==((ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_SetIterator_differs(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > *) 0 ;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetIterator_differs" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetIterator_differs" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetIterator_differs" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > * >(argp2);
  {
    try {
      result = (bool)((ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > const *)arg1)->operator !=((ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_SetIterator_clone(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > *) 0 ;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetIterator_clone" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetIterator_clone" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetIterator_clone" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > * >(argp2);
  {
    try {
      result = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > *) &(arg1)->operator =((ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SetIterator_postIncrement(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "SetIterator_postIncrement", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetIterator_postIncrement" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > * >(argp1);
  {
    try {
      result = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > *) &(arg1)->operator ++();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SetIterator_postIncrementBy(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetIterator_postIncrementBy" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > * >(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetIterator_postIncrementBy" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  {
    try {
      result = (arg1)->operator ++(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > >(static_cast< const ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > >& >(result))), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SetIterator_first(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  SwigValueWrapper< ampl::TupleRef > result;
  
  if (!SWIG_Python_UnpackTuple(args, "SetIterator_first", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetIterator_first" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > * >(argp1);
  {
    try {
      result = ampl_internal_CountedIterator_Sl_ampl_internal_EntityWrapper_Sl_ampl_SetInstance_Sg__Sg__first(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  {
    const ampl::TupleRef &tuple = result; // to avoid issues with result[i];
    std::size_t size = tuple.size();
    if (size != 1) {
      resultobj = PyTuple_New(size);
    }
    for (std::size_t i = 0; i < size; i++) {
      const ampl::VariantRef &v = tuple[i];
      PyObject *item = NULL;
      switch (v.type()) {
      case ampl::STRING:
        item = PyString_FromString(v.c_str());
        break;
      case ampl::NUMERIC:
        item = PyFloat_FromDouble(v.dbl());
        break;
      case ampl::EMPTY:
        item = Py_None;
        break;
      }
      if (size != 1) {
        PyTuple_SetItem(resultobj, i, item);
      } else {
        resultobj = item;
      }
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SetIterator_second(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  SwigValueWrapper< ampl::SetInstance > result;
  
  if (!SWIG_Python_UnpackTuple(args, "SetIterator_second", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetIterator_second" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > * >(argp1);
  {
    try {
      result = ampl_internal_CountedIterator_Sl_ampl_internal_EntityWrapper_Sl_ampl_SetInstance_Sg__Sg__second(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::internal::EntityWrapper< ampl::SetInstance >::InstanceType(static_cast< const ampl::internal::EntityWrapper< ampl::SetInstance >::InstanceType& >(result))), SWIGTYPE_p_ampl__SetInstance, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_SetIterator(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_SetIterator", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SetIterator" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_SetIterator) /* defines _wrap_delete_SetIterator_destructor_closure */

SWIGINTERN PyObject *_wrap_delete_TableIteratorWrapper(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::EntityWrapper< ampl::TableInstance > *arg1 = (ampl::internal::EntityWrapper< ampl::TableInstance > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_TableIteratorWrapper", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__EntityWrapperT_ampl__TableInstance_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_TableIteratorWrapper" "', argument " "1"" of type '" "ampl::internal::EntityWrapper< ampl::TableInstance > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::EntityWrapper< ampl::TableInstance > * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_TableIteratorWrapper) /* defines _wrap_delete_TableIteratorWrapper_destructor_closure */

SWIGINTERN PyObject *_wrap_TableIterator_equals(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::TableInstance > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::TableInstance > > *) 0 ;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::TableInstance > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__TableInstance_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TableIterator_equals" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::TableInstance > > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::TableInstance > > * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__TableInstance_t_t,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "TableIterator_equals" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::TableInstance > > const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "TableIterator_equals" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::TableInstance > > const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::TableInstance > > * >(argp2);
  {
    try {
      result = (bool)((ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::TableInstance > > const *)arg1)->operator ==((ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::TableInstance > > const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_TableIterator_differs(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::TableInstance > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::TableInstance > > *) 0 ;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::TableInstance > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__TableInstance_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TableIterator_differs" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::TableInstance > > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::TableInstance > > * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__TableInstance_t_t,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "TableIterator_differs" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::TableInstance > > const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "TableIterator_differs" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::TableInstance > > const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::TableInstance > > * >(argp2);
  {
    try {
      result = (bool)((ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::TableInstance > > const *)arg1)->operator !=((ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::TableInstance > > const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_TableIterator_clone(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::TableInstance > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::TableInstance > > *) 0 ;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::TableInstance > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::TableInstance > > *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__TableInstance_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TableIterator_clone" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::TableInstance > > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::TableInstance > > * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__TableInstance_t_t,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "TableIterator_clone" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::TableInstance > > const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "TableIterator_clone" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::TableInstance > > const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::TableInstance > > * >(argp2);
  {
    try {
      result = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::TableInstance > > *) &(arg1)->operator =((ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::TableInstance > > const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__TableInstance_t_t, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_TableIterator_postIncrement(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::TableInstance > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::TableInstance > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::TableInstance > > *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "TableIterator_postIncrement", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__TableInstance_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TableIterator_postIncrement" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::TableInstance > > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::TableInstance > > * >(argp1);
  {
    try {
      result = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::TableInstance > > *) &(arg1)->operator ++();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__TableInstance_t_t, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_TableIterator_postIncrementBy(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::TableInstance > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::TableInstance > > *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::TableInstance > > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__TableInstance_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TableIterator_postIncrementBy" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::TableInstance > > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::TableInstance > > * >(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "TableIterator_postIncrementBy" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  {
    try {
      result = (arg1)->operator ++(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::TableInstance > >(static_cast< const ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::TableInstance > >& >(result))), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__TableInstance_t_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_TableIterator_first(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::TableInstance > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::TableInstance > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  SwigValueWrapper< ampl::TupleRef > result;
  
  if (!SWIG_Python_UnpackTuple(args, "TableIterator_first", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__TableInstance_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TableIterator_first" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::TableInstance > > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::TableInstance > > * >(argp1);
  {
    try {
      result = ampl_internal_CountedIterator_Sl_ampl_internal_EntityWrapper_Sl_ampl_TableInstance_Sg__Sg__first(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  {
    const ampl::TupleRef &tuple = result; // to avoid issues with result[i];
    std::size_t size = tuple.size();
    if (size != 1) {
      resultobj = PyTuple_New(size);
    }
    for (std::size_t i = 0; i < size; i++) {
      const ampl::VariantRef &v = tuple[i];
      PyObject *item = NULL;
      switch (v.type()) {
      case ampl::STRING:
        item = PyString_FromString(v.c_str());
        break;
      case ampl::NUMERIC:
        item = PyFloat_FromDouble(v.dbl());
        break;
      case ampl::EMPTY:
        item = Py_None;
        break;
      }
      if (size != 1) {
        PyTuple_SetItem(resultobj, i, item);
      } else {
        resultobj = item;
      }
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_TableIterator_second(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::TableInstance > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::TableInstance > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  SwigValueWrapper< ampl::TableInstance > result;
  
  if (!SWIG_Python_UnpackTuple(args, "TableIterator_second", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__TableInstance_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TableIterator_second" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::TableInstance > > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::TableInstance > > * >(argp1);
  {
    try {
      result = ampl_internal_CountedIterator_Sl_ampl_internal_EntityWrapper_Sl_ampl_TableInstance_Sg__Sg__second(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::internal::EntityWrapper< ampl::TableInstance >::InstanceType(static_cast< const ampl::internal::EntityWrapper< ampl::TableInstance >::InstanceType& >(result))), SWIGTYPE_p_ampl__TableInstance, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_TableIterator(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::TableInstance > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::TableInstance > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_TableIterator", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__TableInstance_t_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_TableIterator" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::TableInstance > > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::TableInstance > > * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_TableIterator) /* defines _wrap_delete_TableIterator_destructor_closure */

SWIGINTERN PyObject *_wrap_delete_ParameterIteratorWrapper(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::EntityWrapper< ampl::VariantRef > *arg1 = (ampl::internal::EntityWrapper< ampl::VariantRef > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_ParameterIteratorWrapper", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__EntityWrapperT_ampl__VariantRef_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ParameterIteratorWrapper" "', argument " "1"" of type '" "ampl::internal::EntityWrapper< ampl::VariantRef > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::EntityWrapper< ampl::VariantRef > * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_ParameterIteratorWrapper) /* defines _wrap_delete_ParameterIteratorWrapper_destructor_closure */

SWIGINTERN PyObject *_wrap_ParameterIterator_equals(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > *) 0 ;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ParameterIterator_equals" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ParameterIterator_equals" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ParameterIterator_equals" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > * >(argp2);
  {
    try {
      result = (bool)((ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > const *)arg1)->operator ==((ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_ParameterIterator_differs(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > *) 0 ;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ParameterIterator_differs" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ParameterIterator_differs" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ParameterIterator_differs" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > * >(argp2);
  {
    try {
      result = (bool)((ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > const *)arg1)->operator !=((ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_ParameterIterator_clone(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > *) 0 ;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ParameterIterator_clone" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ParameterIterator_clone" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ParameterIterator_clone" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > * >(argp2);
  {
    try {
      result = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > *) &(arg1)->operator =((ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ParameterIterator_postIncrement(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "ParameterIterator_postIncrement", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ParameterIterator_postIncrement" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > * >(argp1);
  {
    try {
      result = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > *) &(arg1)->operator ++();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ParameterIterator_postIncrementBy(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ParameterIterator_postIncrementBy" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > * >(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ParameterIterator_postIncrementBy" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  {
    try {
      result = (arg1)->operator ++(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > >(static_cast< const ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > >& >(result))), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ParameterIterator_first(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  SwigValueWrapper< ampl::TupleRef > result;
  
  if (!SWIG_Python_UnpackTuple(args, "ParameterIterator_first", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ParameterIterator_first" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > * >(argp1);
  {
    try {
      result = ampl_internal_CountedIterator_Sl_ampl_internal_EntityWrapper_Sl_ampl_VariantRef_Sg__Sg__first(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  {
    const ampl::TupleRef &tuple = result; // to avoid issues with result[i];
    std::size_t size = tuple.size();
    if (size != 1) {
      resultobj = PyTuple_New(size);
    }
    for (std::size_t i = 0; i < size; i++) {
      const ampl::VariantRef &v = tuple[i];
      PyObject *item = NULL;
      switch (v.type()) {
      case ampl::STRING:
        item = PyString_FromString(v.c_str());
        break;
      case ampl::NUMERIC:
        item = PyFloat_FromDouble(v.dbl());
        break;
      case ampl::EMPTY:
        item = Py_None;
        break;
      }
      if (size != 1) {
        PyTuple_SetItem(resultobj, i, item);
      } else {
        resultobj = item;
      }
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ParameterIterator_second(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  SwigValueWrapper< ampl::VariantRef > result;
  
  if (!SWIG_Python_UnpackTuple(args, "ParameterIterator_second", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ParameterIterator_second" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > * >(argp1);
  {
    try {
      result = ampl_internal_CountedIterator_Sl_ampl_internal_EntityWrapper_Sl_ampl_VariantRef_Sg__Sg__second(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  {
    switch ((&result)->type()) {
    case ampl::STRING:
      resultobj = PyString_FromString((&result)->c_str());
      break;
    case ampl::NUMERIC:
      resultobj = PyFloat_FromDouble((&result)->dbl());
      break;
    default:
      resultobj = Py_None;
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ParameterIterator(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_ParameterIterator", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ParameterIterator" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_ParameterIterator) /* defines _wrap_delete_ParameterIterator_destructor_closure */

SWIGINTERN PyObject *_wrap_EntityMapVariable_begin(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Variable > *arg1 = (ampl::EntityMap< ampl::Variable > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ampl::EntityMap< ampl::Variable >::iterator result;
  
  if (!SWIG_Python_UnpackTuple(args, "EntityMapVariable_begin", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Variable_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapVariable_begin" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Variable > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Variable > * >(argp1);
  {
    try {
      result = ((ampl::EntityMap< ampl::Variable > const *)arg1)->begin();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::EntityMap< ampl::Variable >::iterator(static_cast< const ampl::EntityMap< ampl::Variable >::iterator& >(result))), SWIGTYPE_p_ampl__EntityMapT_ampl__Variable_t__iterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapVariable_end(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Variable > *arg1 = (ampl::EntityMap< ampl::Variable > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ampl::EntityMap< ampl::Variable >::iterator result;
  
  if (!SWIG_Python_UnpackTuple(args, "EntityMapVariable_end", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Variable_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapVariable_end" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Variable > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Variable > * >(argp1);
  {
    try {
      result = ((ampl::EntityMap< ampl::Variable > const *)arg1)->end();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::EntityMap< ampl::Variable >::iterator(static_cast< const ampl::EntityMap< ampl::Variable >::iterator& >(result))), SWIGTYPE_p_ampl__EntityMapT_ampl__Variable_t__iterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapVariable_find(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Variable > *arg1 = (ampl::EntityMap< ampl::Variable > *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject *swig_obj[2] ;
  ampl::EntityMap< ampl::Variable >::iterator result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Variable_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapVariable_find" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Variable > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Variable > * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "EntityMapVariable_find" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      result = (arg1)->find(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::EntityMap< ampl::Variable >::iterator(static_cast< const ampl::EntityMap< ampl::Variable >::iterator& >(result))), SWIGTYPE_p_ampl__EntityMapT_ampl__Variable_t__iterator, SWIG_POINTER_OWN |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapVariable_size(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Variable > *arg1 = (ampl::EntityMap< ampl::Variable > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::size_t result;
  
  if (!SWIG_Python_UnpackTuple(args, "EntityMapVariable_size", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Variable_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapVariable_size" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Variable > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Variable > * >(argp1);
  {
    try {
      result = ((ampl::EntityMap< ampl::Variable > const *)arg1)->size();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapVariable_getIndex(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Variable > *arg1 = (ampl::EntityMap< ampl::Variable > *) 0 ;
  fmt::CStringRef arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  SwigValueWrapper< ampl::Variable > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Variable_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapVariable_getIndex" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Variable > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Variable > * >(argp1);
  
  arg2 = _PyString_AsString(swig_obj[0]);
  
  {
    try {
      result = ((ampl::EntityMap< ampl::Variable > const *)arg1)->operator [](arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::Variable(static_cast< const ampl::Variable& >(result))), SWIGTYPE_p_ampl__Variable, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_EntityMapVariable(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Variable > *arg1 = (ampl::EntityMap< ampl::Variable > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_EntityMapVariable", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Variable_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_EntityMapVariable" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Variable > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Variable > * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_EntityMapVariable) /* defines _wrap_delete_EntityMapVariable_destructor_closure */

SWIGINTERN PyObject *_wrap_EntityMapVariableIterator_equals(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Variable >::iterator *arg1 = (ampl::EntityMap< ampl::Variable >::iterator *) 0 ;
  ampl::EntityMap< ampl::Variable >::iterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Variable_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapVariableIterator_equals" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Variable >::iterator const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Variable >::iterator * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ampl__EntityMapT_ampl__Variable_t__iterator,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "EntityMapVariableIterator_equals" "', argument " "2"" of type '" "ampl::EntityMap< ampl::Variable >::iterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "EntityMapVariableIterator_equals" "', argument " "2"" of type '" "ampl::EntityMap< ampl::Variable >::iterator const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::EntityMap< ampl::Variable >::iterator * >(argp2);
  {
    try {
      result = (bool)((ampl::EntityMap< ampl::Variable >::iterator const *)arg1)->operator ==((ampl::EntityMap< ampl::Variable >::iterator const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_EntityMapVariableIterator_differs(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Variable >::iterator *arg1 = (ampl::EntityMap< ampl::Variable >::iterator *) 0 ;
  ampl::EntityMap< ampl::Variable >::iterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Variable_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapVariableIterator_differs" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Variable >::iterator const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Variable >::iterator * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ampl__EntityMapT_ampl__Variable_t__iterator,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "EntityMapVariableIterator_differs" "', argument " "2"" of type '" "ampl::EntityMap< ampl::Variable >::iterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "EntityMapVariableIterator_differs" "', argument " "2"" of type '" "ampl::EntityMap< ampl::Variable >::iterator const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::EntityMap< ampl::Variable >::iterator * >(argp2);
  {
    try {
      result = (bool)((ampl::EntityMap< ampl::Variable >::iterator const *)arg1)->operator !=((ampl::EntityMap< ampl::Variable >::iterator const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_EntityMapVariableIterator___ref__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Variable >::iterator *arg1 = (ampl::EntityMap< ampl::Variable >::iterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  SwigValueWrapper< ampl::Variable > result;
  
  if (!SWIG_Python_UnpackTuple(args, "EntityMapVariableIterator___ref__", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Variable_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapVariableIterator___ref__" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Variable >::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Variable >::iterator * >(argp1);
  {
    try {
      result = (arg1)->operator *();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::Variable(static_cast< const ampl::Variable& >(result))), SWIGTYPE_p_ampl__Variable, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_EntityMapVariableIterator_clone(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Variable >::iterator *arg1 = (ampl::EntityMap< ampl::Variable >::iterator *) 0 ;
  ampl::EntityMap< ampl::Variable >::iterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  ampl::EntityMap< ampl::Variable >::iterator *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Variable_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapVariableIterator_clone" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Variable >::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Variable >::iterator * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ampl__EntityMapT_ampl__Variable_t__iterator,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "EntityMapVariableIterator_clone" "', argument " "2"" of type '" "ampl::EntityMap< ampl::Variable >::iterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "EntityMapVariableIterator_clone" "', argument " "2"" of type '" "ampl::EntityMap< ampl::Variable >::iterator const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::EntityMap< ampl::Variable >::iterator * >(argp2);
  {
    try {
      result = (ampl::EntityMap< ampl::Variable >::iterator *) &(arg1)->operator =((ampl::EntityMap< ampl::Variable >::iterator const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__EntityMapT_ampl__Variable_t__iterator, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapVariableIterator_postIncrement(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Variable >::iterator *arg1 = (ampl::EntityMap< ampl::Variable >::iterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ampl::EntityMap< ampl::Variable >::iterator *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "EntityMapVariableIterator_postIncrement", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Variable_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapVariableIterator_postIncrement" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Variable >::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Variable >::iterator * >(argp1);
  {
    try {
      result = (ampl::EntityMap< ampl::Variable >::iterator *) &(arg1)->operator ++();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__EntityMapT_ampl__Variable_t__iterator, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapVariableIterator_postIncrementBy(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Variable >::iterator *arg1 = (ampl::EntityMap< ampl::Variable >::iterator *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  ampl::EntityMap< ampl::Variable >::iterator result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Variable_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapVariableIterator_postIncrementBy" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Variable >::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Variable >::iterator * >(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "EntityMapVariableIterator_postIncrementBy" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  {
    try {
      result = (arg1)->operator ++(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::EntityMap< ampl::Variable >::iterator(static_cast< const ampl::EntityMap< ampl::Variable >::iterator& >(result))), SWIGTYPE_p_ampl__EntityMapT_ampl__Variable_t__iterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_EntityMapVariableIterator(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Variable >::iterator *arg1 = (ampl::EntityMap< ampl::Variable >::iterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_EntityMapVariableIterator", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Variable_t__iterator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_EntityMapVariableIterator" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Variable >::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Variable >::iterator * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_EntityMapVariableIterator) /* defines _wrap_delete_EntityMapVariableIterator_destructor_closure */

SWIGINTERN PyObject *_wrap_EntityMapConstraint_begin(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Constraint > *arg1 = (ampl::EntityMap< ampl::Constraint > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ampl::EntityMap< ampl::Constraint >::iterator result;
  
  if (!SWIG_Python_UnpackTuple(args, "EntityMapConstraint_begin", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Constraint_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapConstraint_begin" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Constraint > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Constraint > * >(argp1);
  {
    try {
      result = ((ampl::EntityMap< ampl::Constraint > const *)arg1)->begin();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::EntityMap< ampl::Constraint >::iterator(static_cast< const ampl::EntityMap< ampl::Constraint >::iterator& >(result))), SWIGTYPE_p_ampl__EntityMapT_ampl__Constraint_t__iterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapConstraint_end(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Constraint > *arg1 = (ampl::EntityMap< ampl::Constraint > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ampl::EntityMap< ampl::Constraint >::iterator result;
  
  if (!SWIG_Python_UnpackTuple(args, "EntityMapConstraint_end", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Constraint_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapConstraint_end" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Constraint > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Constraint > * >(argp1);
  {
    try {
      result = ((ampl::EntityMap< ampl::Constraint > const *)arg1)->end();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::EntityMap< ampl::Constraint >::iterator(static_cast< const ampl::EntityMap< ampl::Constraint >::iterator& >(result))), SWIGTYPE_p_ampl__EntityMapT_ampl__Constraint_t__iterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapConstraint_find(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Constraint > *arg1 = (ampl::EntityMap< ampl::Constraint > *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject *swig_obj[2] ;
  ampl::EntityMap< ampl::Constraint >::iterator result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Constraint_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapConstraint_find" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Constraint > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Constraint > * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "EntityMapConstraint_find" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      result = (arg1)->find(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::EntityMap< ampl::Constraint >::iterator(static_cast< const ampl::EntityMap< ampl::Constraint >::iterator& >(result))), SWIGTYPE_p_ampl__EntityMapT_ampl__Constraint_t__iterator, SWIG_POINTER_OWN |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapConstraint_size(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Constraint > *arg1 = (ampl::EntityMap< ampl::Constraint > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::size_t result;
  
  if (!SWIG_Python_UnpackTuple(args, "EntityMapConstraint_size", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Constraint_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapConstraint_size" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Constraint > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Constraint > * >(argp1);
  {
    try {
      result = ((ampl::EntityMap< ampl::Constraint > const *)arg1)->size();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapConstraint_getIndex(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Constraint > *arg1 = (ampl::EntityMap< ampl::Constraint > *) 0 ;
  fmt::CStringRef arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  SwigValueWrapper< ampl::Constraint > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Constraint_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapConstraint_getIndex" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Constraint > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Constraint > * >(argp1);
  
  arg2 = _PyString_AsString(swig_obj[0]);
  
  {
    try {
      result = ((ampl::EntityMap< ampl::Constraint > const *)arg1)->operator [](arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::Constraint(static_cast< const ampl::Constraint& >(result))), SWIGTYPE_p_ampl__Constraint, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_EntityMapConstraint(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Constraint > *arg1 = (ampl::EntityMap< ampl::Constraint > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_EntityMapConstraint", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Constraint_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_EntityMapConstraint" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Constraint > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Constraint > * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_EntityMapConstraint) /* defines _wrap_delete_EntityMapConstraint_destructor_closure */

SWIGINTERN PyObject *_wrap_EntityMapConstraintIterator_equals(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Constraint >::iterator *arg1 = (ampl::EntityMap< ampl::Constraint >::iterator *) 0 ;
  ampl::EntityMap< ampl::Constraint >::iterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Constraint_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapConstraintIterator_equals" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Constraint >::iterator const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Constraint >::iterator * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ampl__EntityMapT_ampl__Constraint_t__iterator,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "EntityMapConstraintIterator_equals" "', argument " "2"" of type '" "ampl::EntityMap< ampl::Constraint >::iterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "EntityMapConstraintIterator_equals" "', argument " "2"" of type '" "ampl::EntityMap< ampl::Constraint >::iterator const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::EntityMap< ampl::Constraint >::iterator * >(argp2);
  {
    try {
      result = (bool)((ampl::EntityMap< ampl::Constraint >::iterator const *)arg1)->operator ==((ampl::EntityMap< ampl::Constraint >::iterator const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_EntityMapConstraintIterator_differs(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Constraint >::iterator *arg1 = (ampl::EntityMap< ampl::Constraint >::iterator *) 0 ;
  ampl::EntityMap< ampl::Constraint >::iterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Constraint_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapConstraintIterator_differs" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Constraint >::iterator const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Constraint >::iterator * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ampl__EntityMapT_ampl__Constraint_t__iterator,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "EntityMapConstraintIterator_differs" "', argument " "2"" of type '" "ampl::EntityMap< ampl::Constraint >::iterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "EntityMapConstraintIterator_differs" "', argument " "2"" of type '" "ampl::EntityMap< ampl::Constraint >::iterator const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::EntityMap< ampl::Constraint >::iterator * >(argp2);
  {
    try {
      result = (bool)((ampl::EntityMap< ampl::Constraint >::iterator const *)arg1)->operator !=((ampl::EntityMap< ampl::Constraint >::iterator const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_EntityMapConstraintIterator___ref__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Constraint >::iterator *arg1 = (ampl::EntityMap< ampl::Constraint >::iterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  SwigValueWrapper< ampl::Constraint > result;
  
  if (!SWIG_Python_UnpackTuple(args, "EntityMapConstraintIterator___ref__", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Constraint_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapConstraintIterator___ref__" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Constraint >::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Constraint >::iterator * >(argp1);
  {
    try {
      result = (arg1)->operator *();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::Constraint(static_cast< const ampl::Constraint& >(result))), SWIGTYPE_p_ampl__Constraint, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_EntityMapConstraintIterator_clone(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Constraint >::iterator *arg1 = (ampl::EntityMap< ampl::Constraint >::iterator *) 0 ;
  ampl::EntityMap< ampl::Constraint >::iterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  ampl::EntityMap< ampl::Constraint >::iterator *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Constraint_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapConstraintIterator_clone" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Constraint >::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Constraint >::iterator * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ampl__EntityMapT_ampl__Constraint_t__iterator,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "EntityMapConstraintIterator_clone" "', argument " "2"" of type '" "ampl::EntityMap< ampl::Constraint >::iterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "EntityMapConstraintIterator_clone" "', argument " "2"" of type '" "ampl::EntityMap< ampl::Constraint >::iterator const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::EntityMap< ampl::Constraint >::iterator * >(argp2);
  {
    try {
      result = (ampl::EntityMap< ampl::Constraint >::iterator *) &(arg1)->operator =((ampl::EntityMap< ampl::Constraint >::iterator const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__EntityMapT_ampl__Constraint_t__iterator, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapConstraintIterator_postIncrement(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Constraint >::iterator *arg1 = (ampl::EntityMap< ampl::Constraint >::iterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ampl::EntityMap< ampl::Constraint >::iterator *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "EntityMapConstraintIterator_postIncrement", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Constraint_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapConstraintIterator_postIncrement" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Constraint >::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Constraint >::iterator * >(argp1);
  {
    try {
      result = (ampl::EntityMap< ampl::Constraint >::iterator *) &(arg1)->operator ++();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__EntityMapT_ampl__Constraint_t__iterator, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapConstraintIterator_postIncrementBy(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Constraint >::iterator *arg1 = (ampl::EntityMap< ampl::Constraint >::iterator *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  ampl::EntityMap< ampl::Constraint >::iterator result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Constraint_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapConstraintIterator_postIncrementBy" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Constraint >::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Constraint >::iterator * >(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "EntityMapConstraintIterator_postIncrementBy" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  {
    try {
      result = (arg1)->operator ++(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::EntityMap< ampl::Constraint >::iterator(static_cast< const ampl::EntityMap< ampl::Constraint >::iterator& >(result))), SWIGTYPE_p_ampl__EntityMapT_ampl__Constraint_t__iterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_EntityMapConstraintIterator(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Constraint >::iterator *arg1 = (ampl::EntityMap< ampl::Constraint >::iterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_EntityMapConstraintIterator", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Constraint_t__iterator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_EntityMapConstraintIterator" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Constraint >::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Constraint >::iterator * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_EntityMapConstraintIterator) /* defines _wrap_delete_EntityMapConstraintIterator_destructor_closure */

SWIGINTERN PyObject *_wrap_EntityMapObjective_begin(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Objective > *arg1 = (ampl::EntityMap< ampl::Objective > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ampl::EntityMap< ampl::Objective >::iterator result;
  
  if (!SWIG_Python_UnpackTuple(args, "EntityMapObjective_begin", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Objective_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapObjective_begin" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Objective > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Objective > * >(argp1);
  {
    try {
      result = ((ampl::EntityMap< ampl::Objective > const *)arg1)->begin();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::EntityMap< ampl::Objective >::iterator(static_cast< const ampl::EntityMap< ampl::Objective >::iterator& >(result))), SWIGTYPE_p_ampl__EntityMapT_ampl__Objective_t__iterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapObjective_end(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Objective > *arg1 = (ampl::EntityMap< ampl::Objective > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ampl::EntityMap< ampl::Objective >::iterator result;
  
  if (!SWIG_Python_UnpackTuple(args, "EntityMapObjective_end", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Objective_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapObjective_end" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Objective > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Objective > * >(argp1);
  {
    try {
      result = ((ampl::EntityMap< ampl::Objective > const *)arg1)->end();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::EntityMap< ampl::Objective >::iterator(static_cast< const ampl::EntityMap< ampl::Objective >::iterator& >(result))), SWIGTYPE_p_ampl__EntityMapT_ampl__Objective_t__iterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapObjective_find(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Objective > *arg1 = (ampl::EntityMap< ampl::Objective > *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject *swig_obj[2] ;
  ampl::EntityMap< ampl::Objective >::iterator result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Objective_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapObjective_find" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Objective > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Objective > * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "EntityMapObjective_find" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      result = (arg1)->find(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::EntityMap< ampl::Objective >::iterator(static_cast< const ampl::EntityMap< ampl::Objective >::iterator& >(result))), SWIGTYPE_p_ampl__EntityMapT_ampl__Objective_t__iterator, SWIG_POINTER_OWN |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapObjective_size(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Objective > *arg1 = (ampl::EntityMap< ampl::Objective > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::size_t result;
  
  if (!SWIG_Python_UnpackTuple(args, "EntityMapObjective_size", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Objective_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapObjective_size" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Objective > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Objective > * >(argp1);
  {
    try {
      result = ((ampl::EntityMap< ampl::Objective > const *)arg1)->size();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapObjective_getIndex(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Objective > *arg1 = (ampl::EntityMap< ampl::Objective > *) 0 ;
  fmt::CStringRef arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  SwigValueWrapper< ampl::Objective > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Objective_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapObjective_getIndex" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Objective > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Objective > * >(argp1);
  
  arg2 = _PyString_AsString(swig_obj[0]);
  
  {
    try {
      result = ((ampl::EntityMap< ampl::Objective > const *)arg1)->operator [](arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::Objective(static_cast< const ampl::Objective& >(result))), SWIGTYPE_p_ampl__Objective, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_EntityMapObjective(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Objective > *arg1 = (ampl::EntityMap< ampl::Objective > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_EntityMapObjective", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Objective_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_EntityMapObjective" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Objective > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Objective > * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_EntityMapObjective) /* defines _wrap_delete_EntityMapObjective_destructor_closure */

SWIGINTERN PyObject *_wrap_EntityMapObjectiveIterator_equals(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Objective >::iterator *arg1 = (ampl::EntityMap< ampl::Objective >::iterator *) 0 ;
  ampl::EntityMap< ampl::Objective >::iterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Objective_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapObjectiveIterator_equals" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Objective >::iterator const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Objective >::iterator * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ampl__EntityMapT_ampl__Objective_t__iterator,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "EntityMapObjectiveIterator_equals" "', argument " "2"" of type '" "ampl::EntityMap< ampl::Objective >::iterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "EntityMapObjectiveIterator_equals" "', argument " "2"" of type '" "ampl::EntityMap< ampl::Objective >::iterator const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::EntityMap< ampl::Objective >::iterator * >(argp2);
  {
    try {
      result = (bool)((ampl::EntityMap< ampl::Objective >::iterator const *)arg1)->operator ==((ampl::EntityMap< ampl::Objective >::iterator const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_EntityMapObjectiveIterator_differs(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Objective >::iterator *arg1 = (ampl::EntityMap< ampl::Objective >::iterator *) 0 ;
  ampl::EntityMap< ampl::Objective >::iterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Objective_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapObjectiveIterator_differs" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Objective >::iterator const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Objective >::iterator * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ampl__EntityMapT_ampl__Objective_t__iterator,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "EntityMapObjectiveIterator_differs" "', argument " "2"" of type '" "ampl::EntityMap< ampl::Objective >::iterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "EntityMapObjectiveIterator_differs" "', argument " "2"" of type '" "ampl::EntityMap< ampl::Objective >::iterator const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::EntityMap< ampl::Objective >::iterator * >(argp2);
  {
    try {
      result = (bool)((ampl::EntityMap< ampl::Objective >::iterator const *)arg1)->operator !=((ampl::EntityMap< ampl::Objective >::iterator const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_EntityMapObjectiveIterator___ref__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Objective >::iterator *arg1 = (ampl::EntityMap< ampl::Objective >::iterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  SwigValueWrapper< ampl::Objective > result;
  
  if (!SWIG_Python_UnpackTuple(args, "EntityMapObjectiveIterator___ref__", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Objective_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapObjectiveIterator___ref__" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Objective >::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Objective >::iterator * >(argp1);
  {
    try {
      result = (arg1)->operator *();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::Objective(static_cast< const ampl::Objective& >(result))), SWIGTYPE_p_ampl__Objective, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_EntityMapObjectiveIterator_clone(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Objective >::iterator *arg1 = (ampl::EntityMap< ampl::Objective >::iterator *) 0 ;
  ampl::EntityMap< ampl::Objective >::iterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  ampl::EntityMap< ampl::Objective >::iterator *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Objective_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapObjectiveIterator_clone" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Objective >::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Objective >::iterator * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ampl__EntityMapT_ampl__Objective_t__iterator,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "EntityMapObjectiveIterator_clone" "', argument " "2"" of type '" "ampl::EntityMap< ampl::Objective >::iterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "EntityMapObjectiveIterator_clone" "', argument " "2"" of type '" "ampl::EntityMap< ampl::Objective >::iterator const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::EntityMap< ampl::Objective >::iterator * >(argp2);
  {
    try {
      result = (ampl::EntityMap< ampl::Objective >::iterator *) &(arg1)->operator =((ampl::EntityMap< ampl::Objective >::iterator const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__EntityMapT_ampl__Objective_t__iterator, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapObjectiveIterator_postIncrement(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Objective >::iterator *arg1 = (ampl::EntityMap< ampl::Objective >::iterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ampl::EntityMap< ampl::Objective >::iterator *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "EntityMapObjectiveIterator_postIncrement", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Objective_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapObjectiveIterator_postIncrement" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Objective >::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Objective >::iterator * >(argp1);
  {
    try {
      result = (ampl::EntityMap< ampl::Objective >::iterator *) &(arg1)->operator ++();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__EntityMapT_ampl__Objective_t__iterator, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapObjectiveIterator_postIncrementBy(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Objective >::iterator *arg1 = (ampl::EntityMap< ampl::Objective >::iterator *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  ampl::EntityMap< ampl::Objective >::iterator result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Objective_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapObjectiveIterator_postIncrementBy" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Objective >::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Objective >::iterator * >(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "EntityMapObjectiveIterator_postIncrementBy" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  {
    try {
      result = (arg1)->operator ++(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::EntityMap< ampl::Objective >::iterator(static_cast< const ampl::EntityMap< ampl::Objective >::iterator& >(result))), SWIGTYPE_p_ampl__EntityMapT_ampl__Objective_t__iterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_EntityMapObjectiveIterator(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Objective >::iterator *arg1 = (ampl::EntityMap< ampl::Objective >::iterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_EntityMapObjectiveIterator", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Objective_t__iterator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_EntityMapObjectiveIterator" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Objective >::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Objective >::iterator * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_EntityMapObjectiveIterator) /* defines _wrap_delete_EntityMapObjectiveIterator_destructor_closure */

SWIGINTERN PyObject *_wrap_EntityMapSet_begin(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Set > *arg1 = (ampl::EntityMap< ampl::Set > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ampl::EntityMap< ampl::Set >::iterator result;
  
  if (!SWIG_Python_UnpackTuple(args, "EntityMapSet_begin", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Set_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapSet_begin" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Set > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Set > * >(argp1);
  {
    try {
      result = ((ampl::EntityMap< ampl::Set > const *)arg1)->begin();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::EntityMap< ampl::Set >::iterator(static_cast< const ampl::EntityMap< ampl::Set >::iterator& >(result))), SWIGTYPE_p_ampl__EntityMapT_ampl__Set_t__iterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapSet_end(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Set > *arg1 = (ampl::EntityMap< ampl::Set > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ampl::EntityMap< ampl::Set >::iterator result;
  
  if (!SWIG_Python_UnpackTuple(args, "EntityMapSet_end", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Set_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapSet_end" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Set > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Set > * >(argp1);
  {
    try {
      result = ((ampl::EntityMap< ampl::Set > const *)arg1)->end();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::EntityMap< ampl::Set >::iterator(static_cast< const ampl::EntityMap< ampl::Set >::iterator& >(result))), SWIGTYPE_p_ampl__EntityMapT_ampl__Set_t__iterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapSet_find(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Set > *arg1 = (ampl::EntityMap< ampl::Set > *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject *swig_obj[2] ;
  ampl::EntityMap< ampl::Set >::iterator result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Set_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapSet_find" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Set > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Set > * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "EntityMapSet_find" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      result = (arg1)->find(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::EntityMap< ampl::Set >::iterator(static_cast< const ampl::EntityMap< ampl::Set >::iterator& >(result))), SWIGTYPE_p_ampl__EntityMapT_ampl__Set_t__iterator, SWIG_POINTER_OWN |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapSet_size(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Set > *arg1 = (ampl::EntityMap< ampl::Set > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::size_t result;
  
  if (!SWIG_Python_UnpackTuple(args, "EntityMapSet_size", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Set_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapSet_size" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Set > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Set > * >(argp1);
  {
    try {
      result = ((ampl::EntityMap< ampl::Set > const *)arg1)->size();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapSet_getIndex(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Set > *arg1 = (ampl::EntityMap< ampl::Set > *) 0 ;
  fmt::CStringRef arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  SwigValueWrapper< ampl::Set > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Set_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapSet_getIndex" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Set > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Set > * >(argp1);
  
  arg2 = _PyString_AsString(swig_obj[0]);
  
  {
    try {
      result = ((ampl::EntityMap< ampl::Set > const *)arg1)->operator [](arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::Set(static_cast< const ampl::Set& >(result))), SWIGTYPE_p_ampl__Set, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_EntityMapSet(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Set > *arg1 = (ampl::EntityMap< ampl::Set > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_EntityMapSet", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Set_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_EntityMapSet" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Set > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Set > * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_EntityMapSet) /* defines _wrap_delete_EntityMapSet_destructor_closure */

SWIGINTERN PyObject *_wrap_EntityMapSetIterator_equals(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Set >::iterator *arg1 = (ampl::EntityMap< ampl::Set >::iterator *) 0 ;
  ampl::EntityMap< ampl::Set >::iterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Set_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapSetIterator_equals" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Set >::iterator const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Set >::iterator * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ampl__EntityMapT_ampl__Set_t__iterator,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "EntityMapSetIterator_equals" "', argument " "2"" of type '" "ampl::EntityMap< ampl::Set >::iterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "EntityMapSetIterator_equals" "', argument " "2"" of type '" "ampl::EntityMap< ampl::Set >::iterator const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::EntityMap< ampl::Set >::iterator * >(argp2);
  {
    try {
      result = (bool)((ampl::EntityMap< ampl::Set >::iterator const *)arg1)->operator ==((ampl::EntityMap< ampl::Set >::iterator const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_EntityMapSetIterator_differs(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Set >::iterator *arg1 = (ampl::EntityMap< ampl::Set >::iterator *) 0 ;
  ampl::EntityMap< ampl::Set >::iterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Set_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapSetIterator_differs" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Set >::iterator const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Set >::iterator * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ampl__EntityMapT_ampl__Set_t__iterator,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "EntityMapSetIterator_differs" "', argument " "2"" of type '" "ampl::EntityMap< ampl::Set >::iterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "EntityMapSetIterator_differs" "', argument " "2"" of type '" "ampl::EntityMap< ampl::Set >::iterator const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::EntityMap< ampl::Set >::iterator * >(argp2);
  {
    try {
      result = (bool)((ampl::EntityMap< ampl::Set >::iterator const *)arg1)->operator !=((ampl::EntityMap< ampl::Set >::iterator const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_EntityMapSetIterator___ref__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Set >::iterator *arg1 = (ampl::EntityMap< ampl::Set >::iterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  SwigValueWrapper< ampl::Set > result;
  
  if (!SWIG_Python_UnpackTuple(args, "EntityMapSetIterator___ref__", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Set_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapSetIterator___ref__" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Set >::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Set >::iterator * >(argp1);
  {
    try {
      result = (arg1)->operator *();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::Set(static_cast< const ampl::Set& >(result))), SWIGTYPE_p_ampl__Set, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_EntityMapSetIterator_clone(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Set >::iterator *arg1 = (ampl::EntityMap< ampl::Set >::iterator *) 0 ;
  ampl::EntityMap< ampl::Set >::iterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  ampl::EntityMap< ampl::Set >::iterator *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Set_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapSetIterator_clone" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Set >::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Set >::iterator * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ampl__EntityMapT_ampl__Set_t__iterator,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "EntityMapSetIterator_clone" "', argument " "2"" of type '" "ampl::EntityMap< ampl::Set >::iterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "EntityMapSetIterator_clone" "', argument " "2"" of type '" "ampl::EntityMap< ampl::Set >::iterator const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::EntityMap< ampl::Set >::iterator * >(argp2);
  {
    try {
      result = (ampl::EntityMap< ampl::Set >::iterator *) &(arg1)->operator =((ampl::EntityMap< ampl::Set >::iterator const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__EntityMapT_ampl__Set_t__iterator, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapSetIterator_postIncrement(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Set >::iterator *arg1 = (ampl::EntityMap< ampl::Set >::iterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ampl::EntityMap< ampl::Set >::iterator *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "EntityMapSetIterator_postIncrement", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Set_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapSetIterator_postIncrement" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Set >::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Set >::iterator * >(argp1);
  {
    try {
      result = (ampl::EntityMap< ampl::Set >::iterator *) &(arg1)->operator ++();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__EntityMapT_ampl__Set_t__iterator, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapSetIterator_postIncrementBy(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Set >::iterator *arg1 = (ampl::EntityMap< ampl::Set >::iterator *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  ampl::EntityMap< ampl::Set >::iterator result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Set_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapSetIterator_postIncrementBy" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Set >::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Set >::iterator * >(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "EntityMapSetIterator_postIncrementBy" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  {
    try {
      result = (arg1)->operator ++(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::EntityMap< ampl::Set >::iterator(static_cast< const ampl::EntityMap< ampl::Set >::iterator& >(result))), SWIGTYPE_p_ampl__EntityMapT_ampl__Set_t__iterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_EntityMapSetIterator(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Set >::iterator *arg1 = (ampl::EntityMap< ampl::Set >::iterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_EntityMapSetIterator", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Set_t__iterator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_EntityMapSetIterator" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Set >::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Set >::iterator * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_EntityMapSetIterator) /* defines _wrap_delete_EntityMapSetIterator_destructor_closure */

SWIGINTERN PyObject *_wrap_EntityMapTable_begin(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Table > *arg1 = (ampl::EntityMap< ampl::Table > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ampl::EntityMap< ampl::Table >::iterator result;
  
  if (!SWIG_Python_UnpackTuple(args, "EntityMapTable_begin", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Table_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapTable_begin" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Table > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Table > * >(argp1);
  {
    try {
      result = ((ampl::EntityMap< ampl::Table > const *)arg1)->begin();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::EntityMap< ampl::Table >::iterator(static_cast< const ampl::EntityMap< ampl::Table >::iterator& >(result))), SWIGTYPE_p_ampl__EntityMapT_ampl__Table_t__iterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapTable_end(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Table > *arg1 = (ampl::EntityMap< ampl::Table > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ampl::EntityMap< ampl::Table >::iterator result;
  
  if (!SWIG_Python_UnpackTuple(args, "EntityMapTable_end", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Table_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapTable_end" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Table > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Table > * >(argp1);
  {
    try {
      result = ((ampl::EntityMap< ampl::Table > const *)arg1)->end();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::EntityMap< ampl::Table >::iterator(static_cast< const ampl::EntityMap< ampl::Table >::iterator& >(result))), SWIGTYPE_p_ampl__EntityMapT_ampl__Table_t__iterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapTable_find(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Table > *arg1 = (ampl::EntityMap< ampl::Table > *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject *swig_obj[2] ;
  ampl::EntityMap< ampl::Table >::iterator result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Table_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapTable_find" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Table > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Table > * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "EntityMapTable_find" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      result = (arg1)->find(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::EntityMap< ampl::Table >::iterator(static_cast< const ampl::EntityMap< ampl::Table >::iterator& >(result))), SWIGTYPE_p_ampl__EntityMapT_ampl__Table_t__iterator, SWIG_POINTER_OWN |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapTable_size(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Table > *arg1 = (ampl::EntityMap< ampl::Table > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::size_t result;
  
  if (!SWIG_Python_UnpackTuple(args, "EntityMapTable_size", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Table_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapTable_size" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Table > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Table > * >(argp1);
  {
    try {
      result = ((ampl::EntityMap< ampl::Table > const *)arg1)->size();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapTable_getIndex(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Table > *arg1 = (ampl::EntityMap< ampl::Table > *) 0 ;
  fmt::CStringRef arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  SwigValueWrapper< ampl::Table > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Table_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapTable_getIndex" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Table > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Table > * >(argp1);
  
  arg2 = _PyString_AsString(swig_obj[0]);
  
  {
    try {
      result = ((ampl::EntityMap< ampl::Table > const *)arg1)->operator [](arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::Table(static_cast< const ampl::Table& >(result))), SWIGTYPE_p_ampl__Table, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_EntityMapTable(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Table > *arg1 = (ampl::EntityMap< ampl::Table > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_EntityMapTable", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Table_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_EntityMapTable" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Table > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Table > * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_EntityMapTable) /* defines _wrap_delete_EntityMapTable_destructor_closure */

SWIGINTERN PyObject *_wrap_EntityMapTableIterator_equals(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Table >::iterator *arg1 = (ampl::EntityMap< ampl::Table >::iterator *) 0 ;
  ampl::EntityMap< ampl::Table >::iterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Table_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapTableIterator_equals" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Table >::iterator const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Table >::iterator * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ampl__EntityMapT_ampl__Table_t__iterator,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "EntityMapTableIterator_equals" "', argument " "2"" of type '" "ampl::EntityMap< ampl::Table >::iterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "EntityMapTableIterator_equals" "', argument " "2"" of type '" "ampl::EntityMap< ampl::Table >::iterator const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::EntityMap< ampl::Table >::iterator * >(argp2);
  {
    try {
      result = (bool)((ampl::EntityMap< ampl::Table >::iterator const *)arg1)->operator ==((ampl::EntityMap< ampl::Table >::iterator const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_EntityMapTableIterator_differs(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Table >::iterator *arg1 = (ampl::EntityMap< ampl::Table >::iterator *) 0 ;
  ampl::EntityMap< ampl::Table >::iterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Table_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapTableIterator_differs" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Table >::iterator const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Table >::iterator * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ampl__EntityMapT_ampl__Table_t__iterator,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "EntityMapTableIterator_differs" "', argument " "2"" of type '" "ampl::EntityMap< ampl::Table >::iterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "EntityMapTableIterator_differs" "', argument " "2"" of type '" "ampl::EntityMap< ampl::Table >::iterator const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::EntityMap< ampl::Table >::iterator * >(argp2);
  {
    try {
      result = (bool)((ampl::EntityMap< ampl::Table >::iterator const *)arg1)->operator !=((ampl::EntityMap< ampl::Table >::iterator const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_EntityMapTableIterator___ref__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Table >::iterator *arg1 = (ampl::EntityMap< ampl::Table >::iterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  SwigValueWrapper< ampl::Table > result;
  
  if (!SWIG_Python_UnpackTuple(args, "EntityMapTableIterator___ref__", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Table_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapTableIterator___ref__" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Table >::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Table >::iterator * >(argp1);
  {
    try {
      result = (arg1)->operator *();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::Table(static_cast< const ampl::Table& >(result))), SWIGTYPE_p_ampl__Table, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_EntityMapTableIterator_clone(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Table >::iterator *arg1 = (ampl::EntityMap< ampl::Table >::iterator *) 0 ;
  ampl::EntityMap< ampl::Table >::iterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  ampl::EntityMap< ampl::Table >::iterator *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Table_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapTableIterator_clone" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Table >::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Table >::iterator * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ampl__EntityMapT_ampl__Table_t__iterator,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "EntityMapTableIterator_clone" "', argument " "2"" of type '" "ampl::EntityMap< ampl::Table >::iterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "EntityMapTableIterator_clone" "', argument " "2"" of type '" "ampl::EntityMap< ampl::Table >::iterator const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::EntityMap< ampl::Table >::iterator * >(argp2);
  {
    try {
      result = (ampl::EntityMap< ampl::Table >::iterator *) &(arg1)->operator =((ampl::EntityMap< ampl::Table >::iterator const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__EntityMapT_ampl__Table_t__iterator, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapTableIterator_postIncrement(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Table >::iterator *arg1 = (ampl::EntityMap< ampl::Table >::iterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ampl::EntityMap< ampl::Table >::iterator *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "EntityMapTableIterator_postIncrement", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Table_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapTableIterator_postIncrement" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Table >::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Table >::iterator * >(argp1);
  {
    try {
      result = (ampl::EntityMap< ampl::Table >::iterator *) &(arg1)->operator ++();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__EntityMapT_ampl__Table_t__iterator, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapTableIterator_postIncrementBy(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Table >::iterator *arg1 = (ampl::EntityMap< ampl::Table >::iterator *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  ampl::EntityMap< ampl::Table >::iterator result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Table_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapTableIterator_postIncrementBy" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Table >::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Table >::iterator * >(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "EntityMapTableIterator_postIncrementBy" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  {
    try {
      result = (arg1)->operator ++(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::EntityMap< ampl::Table >::iterator(static_cast< const ampl::EntityMap< ampl::Table >::iterator& >(result))), SWIGTYPE_p_ampl__EntityMapT_ampl__Table_t__iterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_EntityMapTableIterator(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Table >::iterator *arg1 = (ampl::EntityMap< ampl::Table >::iterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_EntityMapTableIterator", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Table_t__iterator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_EntityMapTableIterator" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Table >::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Table >::iterator * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_EntityMapTableIterator) /* defines _wrap_delete_EntityMapTableIterator_destructor_closure */

SWIGINTERN PyObject *_wrap_EntityMapParameter_begin(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Parameter > *arg1 = (ampl::EntityMap< ampl::Parameter > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ampl::EntityMap< ampl::Parameter >::iterator result;
  
  if (!SWIG_Python_UnpackTuple(args, "EntityMapParameter_begin", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Parameter_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapParameter_begin" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Parameter > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Parameter > * >(argp1);
  {
    try {
      result = ((ampl::EntityMap< ampl::Parameter > const *)arg1)->begin();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::EntityMap< ampl::Parameter >::iterator(static_cast< const ampl::EntityMap< ampl::Parameter >::iterator& >(result))), SWIGTYPE_p_ampl__EntityMapT_ampl__Parameter_t__iterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapParameter_end(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Parameter > *arg1 = (ampl::EntityMap< ampl::Parameter > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ampl::EntityMap< ampl::Parameter >::iterator result;
  
  if (!SWIG_Python_UnpackTuple(args, "EntityMapParameter_end", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Parameter_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapParameter_end" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Parameter > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Parameter > * >(argp1);
  {
    try {
      result = ((ampl::EntityMap< ampl::Parameter > const *)arg1)->end();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::EntityMap< ampl::Parameter >::iterator(static_cast< const ampl::EntityMap< ampl::Parameter >::iterator& >(result))), SWIGTYPE_p_ampl__EntityMapT_ampl__Parameter_t__iterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapParameter_find(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Parameter > *arg1 = (ampl::EntityMap< ampl::Parameter > *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject *swig_obj[2] ;
  ampl::EntityMap< ampl::Parameter >::iterator result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Parameter_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapParameter_find" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Parameter > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Parameter > * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "EntityMapParameter_find" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      result = (arg1)->find(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::EntityMap< ampl::Parameter >::iterator(static_cast< const ampl::EntityMap< ampl::Parameter >::iterator& >(result))), SWIGTYPE_p_ampl__EntityMapT_ampl__Parameter_t__iterator, SWIG_POINTER_OWN |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapParameter_size(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Parameter > *arg1 = (ampl::EntityMap< ampl::Parameter > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::size_t result;
  
  if (!SWIG_Python_UnpackTuple(args, "EntityMapParameter_size", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Parameter_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapParameter_size" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Parameter > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Parameter > * >(argp1);
  {
    try {
      result = ((ampl::EntityMap< ampl::Parameter > const *)arg1)->size();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapParameter_getIndex(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Parameter > *arg1 = (ampl::EntityMap< ampl::Parameter > *) 0 ;
  fmt::CStringRef arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  SwigValueWrapper< ampl::Parameter > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Parameter_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapParameter_getIndex" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Parameter > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Parameter > * >(argp1);
  
  arg2 = _PyString_AsString(swig_obj[0]);
  
  {
    try {
      result = ((ampl::EntityMap< ampl::Parameter > const *)arg1)->operator [](arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::Parameter(static_cast< const ampl::Parameter& >(result))), SWIGTYPE_p_ampl__Parameter, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_EntityMapParameter(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Parameter > *arg1 = (ampl::EntityMap< ampl::Parameter > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_EntityMapParameter", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Parameter_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_EntityMapParameter" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Parameter > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Parameter > * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_EntityMapParameter) /* defines _wrap_delete_EntityMapParameter_destructor_closure */

SWIGINTERN PyObject *_wrap_EntityMapParameterIterator_equals(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Parameter >::iterator *arg1 = (ampl::EntityMap< ampl::Parameter >::iterator *) 0 ;
  ampl::EntityMap< ampl::Parameter >::iterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Parameter_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapParameterIterator_equals" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Parameter >::iterator const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Parameter >::iterator * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ampl__EntityMapT_ampl__Parameter_t__iterator,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "EntityMapParameterIterator_equals" "', argument " "2"" of type '" "ampl::EntityMap< ampl::Parameter >::iterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "EntityMapParameterIterator_equals" "', argument " "2"" of type '" "ampl::EntityMap< ampl::Parameter >::iterator const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::EntityMap< ampl::Parameter >::iterator * >(argp2);
  {
    try {
      result = (bool)((ampl::EntityMap< ampl::Parameter >::iterator const *)arg1)->operator ==((ampl::EntityMap< ampl::Parameter >::iterator const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_EntityMapParameterIterator_differs(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Parameter >::iterator *arg1 = (ampl::EntityMap< ampl::Parameter >::iterator *) 0 ;
  ampl::EntityMap< ampl::Parameter >::iterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Parameter_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapParameterIterator_differs" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Parameter >::iterator const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Parameter >::iterator * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ampl__EntityMapT_ampl__Parameter_t__iterator,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "EntityMapParameterIterator_differs" "', argument " "2"" of type '" "ampl::EntityMap< ampl::Parameter >::iterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "EntityMapParameterIterator_differs" "', argument " "2"" of type '" "ampl::EntityMap< ampl::Parameter >::iterator const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::EntityMap< ampl::Parameter >::iterator * >(argp2);
  {
    try {
      result = (bool)((ampl::EntityMap< ampl::Parameter >::iterator const *)arg1)->operator !=((ampl::EntityMap< ampl::Parameter >::iterator const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_EntityMapParameterIterator___ref__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Parameter >::iterator *arg1 = (ampl::EntityMap< ampl::Parameter >::iterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  SwigValueWrapper< ampl::Parameter > result;
  
  if (!SWIG_Python_UnpackTuple(args, "EntityMapParameterIterator___ref__", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Parameter_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapParameterIterator___ref__" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Parameter >::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Parameter >::iterator * >(argp1);
  {
    try {
      result = (arg1)->operator *();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::Parameter(static_cast< const ampl::Parameter& >(result))), SWIGTYPE_p_ampl__Parameter, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_EntityMapParameterIterator_clone(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Parameter >::iterator *arg1 = (ampl::EntityMap< ampl::Parameter >::iterator *) 0 ;
  ampl::EntityMap< ampl::Parameter >::iterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  ampl::EntityMap< ampl::Parameter >::iterator *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Parameter_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapParameterIterator_clone" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Parameter >::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Parameter >::iterator * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ampl__EntityMapT_ampl__Parameter_t__iterator,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "EntityMapParameterIterator_clone" "', argument " "2"" of type '" "ampl::EntityMap< ampl::Parameter >::iterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "EntityMapParameterIterator_clone" "', argument " "2"" of type '" "ampl::EntityMap< ampl::Parameter >::iterator const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::EntityMap< ampl::Parameter >::iterator * >(argp2);
  {
    try {
      result = (ampl::EntityMap< ampl::Parameter >::iterator *) &(arg1)->operator =((ampl::EntityMap< ampl::Parameter >::iterator const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__EntityMapT_ampl__Parameter_t__iterator, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapParameterIterator_postIncrement(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Parameter >::iterator *arg1 = (ampl::EntityMap< ampl::Parameter >::iterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ampl::EntityMap< ampl::Parameter >::iterator *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "EntityMapParameterIterator_postIncrement", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Parameter_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapParameterIterator_postIncrement" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Parameter >::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Parameter >::iterator * >(argp1);
  {
    try {
      result = (ampl::EntityMap< ampl::Parameter >::iterator *) &(arg1)->operator ++();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__EntityMapT_ampl__Parameter_t__iterator, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapParameterIterator_postIncrementBy(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Parameter >::iterator *arg1 = (ampl::EntityMap< ampl::Parameter >::iterator *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  ampl::EntityMap< ampl::Parameter >::iterator result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Parameter_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapParameterIterator_postIncrementBy" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Parameter >::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Parameter >::iterator * >(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "EntityMapParameterIterator_postIncrementBy" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  {
    try {
      result = (arg1)->operator ++(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::EntityMap< ampl::Parameter >::iterator(static_cast< const ampl::EntityMap< ampl::Parameter >::iterator& >(result))), SWIGTYPE_p_ampl__EntityMapT_ampl__Parameter_t__iterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_EntityMapParameterIterator(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Parameter >::iterator *arg1 = (ampl::EntityMap< ampl::Parameter >::iterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_EntityMapParameterIterator", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Parameter_t__iterator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_EntityMapParameterIterator" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Parameter >::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Parameter >::iterator * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_EntityMapParameterIterator) /* defines _wrap_delete_EntityMapParameterIterator_destructor_closure */

SWIGINTERN int _wrap_new_AMPLException__SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  ampl::AMPLException *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ampl::AMPLException *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_ampl__AMPLException,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_AMPLException" "', argument " "1"" of type '" "ampl::AMPLException const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_AMPLException" "', argument " "1"" of type '" "ampl::AMPLException const &""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPLException * >(argp1);
  {
    try {
      result = (ampl::AMPLException *)new ampl::AMPLException((ampl::AMPLException const &)*arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__AMPLException, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN int _wrap_new_AMPLException__SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  fmt::CStringRef arg1 ;
  ampl::AMPLException *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  
  arg1 = _PyString_AsString(swig_obj[0]);
  
  {
    try {
      result = (ampl::AMPLException *)new ampl::AMPLException(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__AMPLException, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN int _wrap_new_AMPLException__SWIG_2(PyObject *self, Py_ssize_t nobjs, PyObject **SWIGUNUSEDPARM(swig_obj)) {
  PyObject *resultobj = 0;
  ampl::AMPLException *result = 0 ;
  
  if ((nobjs < 0) || (nobjs > 0)) SWIG_fail;
  {
    try {
      result = (ampl::AMPLException *)new ampl::AMPLException();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__AMPLException, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN int _wrap_new_AMPLException__SWIG_3(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  fmt::CStringRef arg1 ;
  int arg2 ;
  int arg3 ;
  fmt::CStringRef arg4 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  ampl::AMPLException *result = 0 ;
  
  if ((nobjs < 4) || (nobjs > 4)) SWIG_fail;
  
  arg1 = _PyString_AsString(swig_obj[0]);
  
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_AMPLException" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_AMPLException" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  
  arg4 = _PyString_AsString(swig_obj[3]);
  
  {
    try {
      result = (ampl::AMPLException *)new ampl::AMPLException(arg1,arg2,arg3,arg4);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__AMPLException, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN int _wrap_new_AMPLException(PyObject *self, PyObject *args, PyObject *kwargs) {
  Py_ssize_t argc;
  PyObject *argv[5] = {
    0
  };
  
  if (!SWIG_Python_CheckNoKeywords(kwargs, "new_AMPLException")) SWIG_fail;
  if (!(argc = SWIG_Python_UnpackTuple(args, "new_AMPLException", 0, 4, argv))) SWIG_fail;
  --argc;
  if (argc == 0) {
    return _wrap_new_AMPLException__SWIG_2(self, argc, argv);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_ampl__AMPLException, SWIG_POINTER_NO_NULL | 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_AMPLException__SWIG_0(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_AMPLException__SWIG_1(self, argc, argv);
    }
  }
  if (argc == 4) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          int res = SWIG_AsCharPtrAndSize(argv[3], 0, NULL, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_new_AMPLException__SWIG_3(self, argc, argv);
          }
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'new_AMPLException'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    ampl::AMPLException::AMPLException(ampl::AMPLException const &)\n"
    "    ampl::AMPLException::AMPLException(fmt::CStringRef)\n"
    "    ampl::AMPLException::AMPLException()\n"
    "    ampl::AMPLException::AMPLException(fmt::CStringRef,int,int,fmt::CStringRef)\n");
  return -1;
}


SWIGINTERN PyObject *_wrap_delete_AMPLException(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPLException *arg1 = (ampl::AMPLException *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_AMPLException", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPLException, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_AMPLException" "', argument " "1"" of type '" "ampl::AMPLException *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPLException * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPLException_getSourceName(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPLException *arg1 = (ampl::AMPLException *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "AMPLException_getSourceName", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPLException, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPLException_getSourceName" "', argument " "1"" of type '" "ampl::AMPLException const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPLException * >(argp1);
  {
    try {
      result = (std::string *) &((ampl::AMPLException const *)arg1)->getSourceName();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPLException_getLineNumber(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPLException *arg1 = (ampl::AMPLException *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  int result;
  
  if (!SWIG_Python_UnpackTuple(args, "AMPLException_getLineNumber", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPLException, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPLException_getLineNumber" "', argument " "1"" of type '" "ampl::AMPLException const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPLException * >(argp1);
  {
    try {
      result = (int)((ampl::AMPLException const *)arg1)->getLineNumber();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPLException_getOffset(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPLException *arg1 = (ampl::AMPLException *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  int result;
  
  if (!SWIG_Python_UnpackTuple(args, "AMPLException_getOffset", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPLException, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPLException_getOffset" "', argument " "1"" of type '" "ampl::AMPLException const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPLException * >(argp1);
  {
    try {
      result = (int)((ampl::AMPLException const *)arg1)->getOffset();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPLException_getMessage(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPLException *arg1 = (ampl::AMPLException *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "AMPLException_getMessage", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPLException, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPLException_getMessage" "', argument " "1"" of type '" "ampl::AMPLException const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPLException * >(argp1);
  {
    try {
      result = (std::string *) &((ampl::AMPLException const *)arg1)->getMessage();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPLException_setSourceName(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPLException *arg1 = (ampl::AMPLException *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPLException, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPLException_setSourceName" "', argument " "1"" of type '" "ampl::AMPLException *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPLException * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(swig_obj[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AMPLException_setSourceName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "AMPLException_setSourceName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    try {
      (arg1)->setSourceName((std::string const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_AMPLException) /* defines _wrap_delete_AMPLException_destructor_closure */

SWIGINTERN int _wrap_new_LicenseException(PyObject *self, PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  PyObject *swig_obj[1] ;
  ampl::LicenseException *result = 0 ;
  
  if (!SWIG_Python_CheckNoKeywords(kwargs, "new_LicenseException")) SWIG_fail;
  if (!SWIG_Python_UnpackTuple(args, "new_LicenseException", 1, 1, swig_obj)) SWIG_fail;
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(swig_obj[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_LicenseException" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_LicenseException" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (ampl::LicenseException *)new ampl::LicenseException((std::string const &)*arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__LicenseException, SWIG_BUILTIN_INIT |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  return resultobj == Py_None ? -1 : 0;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return -1;
}


SWIGINTERN PyObject *_wrap_delete_LicenseException(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::LicenseException *arg1 = (ampl::LicenseException *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_LicenseException", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__LicenseException, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_LicenseException" "', argument " "1"" of type '" "ampl::LicenseException *""'"); 
  }
  arg1 = reinterpret_cast< ampl::LicenseException * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_LicenseException) /* defines _wrap_delete_LicenseException_destructor_closure */

SWIGINTERN int _wrap_new_FileIOException(PyObject *self, PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  PyObject *swig_obj[1] ;
  ampl::FileIOException *result = 0 ;
  
  if (!SWIG_Python_CheckNoKeywords(kwargs, "new_FileIOException")) SWIG_fail;
  if (!SWIG_Python_UnpackTuple(args, "new_FileIOException", 1, 1, swig_obj)) SWIG_fail;
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(swig_obj[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_FileIOException" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_FileIOException" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (ampl::FileIOException *)new ampl::FileIOException((std::string const &)*arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__FileIOException, SWIG_BUILTIN_INIT |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  return resultobj == Py_None ? -1 : 0;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return -1;
}


SWIGINTERN PyObject *_wrap_delete_FileIOException(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::FileIOException *arg1 = (ampl::FileIOException *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_FileIOException", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__FileIOException, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_FileIOException" "', argument " "1"" of type '" "ampl::FileIOException *""'"); 
  }
  arg1 = reinterpret_cast< ampl::FileIOException * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_FileIOException) /* defines _wrap_delete_FileIOException_destructor_closure */

SWIGINTERN int _wrap_new_UnsupportedOperationException(PyObject *self, PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  PyObject *swig_obj[1] ;
  ampl::UnsupportedOperationException *result = 0 ;
  
  if (!SWIG_Python_CheckNoKeywords(kwargs, "new_UnsupportedOperationException")) SWIG_fail;
  if (!SWIG_Python_UnpackTuple(args, "new_UnsupportedOperationException", 1, 1, swig_obj)) SWIG_fail;
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(swig_obj[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_UnsupportedOperationException" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_UnsupportedOperationException" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (ampl::UnsupportedOperationException *)new ampl::UnsupportedOperationException((std::string const &)*arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__UnsupportedOperationException, SWIG_BUILTIN_INIT |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  return resultobj == Py_None ? -1 : 0;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return -1;
}


SWIGINTERN PyObject *_wrap_delete_UnsupportedOperationException(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::UnsupportedOperationException *arg1 = (ampl::UnsupportedOperationException *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_UnsupportedOperationException", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__UnsupportedOperationException, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_UnsupportedOperationException" "', argument " "1"" of type '" "ampl::UnsupportedOperationException *""'"); 
  }
  arg1 = reinterpret_cast< ampl::UnsupportedOperationException * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_UnsupportedOperationException) /* defines _wrap_delete_UnsupportedOperationException_destructor_closure */

SWIGINTERN int _wrap_new_InvalidSubscriptException(PyObject *self, PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  fmt::CStringRef arg1 ;
  int arg2 ;
  int arg3 ;
  fmt::CStringRef arg4 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[4] ;
  ampl::InvalidSubscriptException *result = 0 ;
  
  if (!SWIG_Python_CheckNoKeywords(kwargs, "new_InvalidSubscriptException")) SWIG_fail;
  if (!SWIG_Python_UnpackTuple(args, "new_InvalidSubscriptException", 4, 4, swig_obj)) SWIG_fail;
  
  arg1 = _PyString_AsString(swig_obj[0]);
  
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_InvalidSubscriptException" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_InvalidSubscriptException" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  
  arg4 = _PyString_AsString(swig_obj[3]);
  
  {
    try {
      result = (ampl::InvalidSubscriptException *)new ampl::InvalidSubscriptException(arg1,arg2,arg3,arg4);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__InvalidSubscriptException, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN PyObject *_wrap_delete_InvalidSubscriptException(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::InvalidSubscriptException *arg1 = (ampl::InvalidSubscriptException *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_InvalidSubscriptException", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__InvalidSubscriptException, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_InvalidSubscriptException" "', argument " "1"" of type '" "ampl::InvalidSubscriptException *""'"); 
  }
  arg1 = reinterpret_cast< ampl::InvalidSubscriptException * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_InvalidSubscriptException) /* defines _wrap_delete_InvalidSubscriptException_destructor_closure */

SWIGINTERN int _wrap_new_SyntaxErrorException(PyObject *self, PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  fmt::CStringRef arg1 ;
  int arg2 ;
  int arg3 ;
  fmt::CStringRef arg4 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[4] ;
  ampl::SyntaxErrorException *result = 0 ;
  
  if (!SWIG_Python_CheckNoKeywords(kwargs, "new_SyntaxErrorException")) SWIG_fail;
  if (!SWIG_Python_UnpackTuple(args, "new_SyntaxErrorException", 4, 4, swig_obj)) SWIG_fail;
  
  arg1 = _PyString_AsString(swig_obj[0]);
  
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_SyntaxErrorException" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_SyntaxErrorException" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  
  arg4 = _PyString_AsString(swig_obj[3]);
  
  {
    try {
      result = (ampl::SyntaxErrorException *)new ampl::SyntaxErrorException(arg1,arg2,arg3,arg4);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__SyntaxErrorException, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN PyObject *_wrap_delete_SyntaxErrorException(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::SyntaxErrorException *arg1 = (ampl::SyntaxErrorException *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_SyntaxErrorException", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__SyntaxErrorException, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SyntaxErrorException" "', argument " "1"" of type '" "ampl::SyntaxErrorException *""'"); 
  }
  arg1 = reinterpret_cast< ampl::SyntaxErrorException * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_SyntaxErrorException) /* defines _wrap_delete_SyntaxErrorException_destructor_closure */

SWIGINTERN int _wrap_new_NoDataException(PyObject *self, PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  fmt::CStringRef arg1 ;
  PyObject *swig_obj[1] ;
  ampl::NoDataException *result = 0 ;
  
  if (!SWIG_Python_CheckNoKeywords(kwargs, "new_NoDataException")) SWIG_fail;
  if (!SWIG_Python_UnpackTuple(args, "new_NoDataException", 1, 1, swig_obj)) SWIG_fail;
  
  arg1 = _PyString_AsString(swig_obj[0]);
  
  {
    try {
      result = (ampl::NoDataException *)new ampl::NoDataException(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__NoDataException, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN PyObject *_wrap_delete_NoDataException(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::NoDataException *arg1 = (ampl::NoDataException *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_NoDataException", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__NoDataException, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_NoDataException" "', argument " "1"" of type '" "ampl::NoDataException *""'"); 
  }
  arg1 = reinterpret_cast< ampl::NoDataException * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_NoDataException) /* defines _wrap_delete_NoDataException_destructor_closure */

SWIGINTERN int _wrap_new_ErrorHandler(PyObject *self, PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) 0 ;
  PyObject *swig_obj[1] ;
  ampl::ErrorHandler *result = 0 ;
  
  if (!SWIG_Python_CheckNoKeywords(kwargs, "new_ErrorHandler")) SWIG_fail;
  if (!SWIG_Python_UnpackTuple(args, "new_ErrorHandler", 0, 0, 0)) SWIG_fail;
  arg1 = self;
  {
    try {
      if ( self->ob_type != ((SwigPyClientData *)(SWIGTYPE_p_ampl__ErrorHandler)->clientdata)->pytype ) {
        /* subclassed */
        result = (ampl::ErrorHandler *)new SwigDirector_ErrorHandler(arg1); 
      } else {
        SWIG_SetErrorMsg(PyExc_RuntimeError,"accessing abstract class or protected constructor"); 
        SWIG_fail;
      }
      
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__ErrorHandler, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN PyObject *_wrap_delete_ErrorHandler(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::ErrorHandler *arg1 = (ampl::ErrorHandler *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_ErrorHandler", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__ErrorHandler, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ErrorHandler" "', argument " "1"" of type '" "ampl::ErrorHandler *""'"); 
  }
  arg1 = reinterpret_cast< ampl::ErrorHandler * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ErrorHandler_error(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::ErrorHandler *arg1 = (ampl::ErrorHandler *) 0 ;
  ampl::AMPLException *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  Swig::Director *director = 0;
  bool upcall = false;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__ErrorHandler, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ErrorHandler_error" "', argument " "1"" of type '" "ampl::ErrorHandler *""'"); 
  }
  arg1 = reinterpret_cast< ampl::ErrorHandler * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ampl__AMPLException,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ErrorHandler_error" "', argument " "2"" of type '" "ampl::AMPLException const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ErrorHandler_error" "', argument " "2"" of type '" "ampl::AMPLException const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::AMPLException * >(argp2);
  director = SWIG_DIRECTOR_CAST(arg1);
  upcall = (director && (director->swig_get_self()==self));
  try {
    {
      try {
        if (upcall) {
          Swig::DirectorPureVirtualException::raise("ampl::ErrorHandler::error");
        } else {
          (arg1)->error((ampl::AMPLException const &)*arg2);
        }
      }
      catch (std::range_error) {
        SWIG_exception(SWIG_ValueError, "Range Error");
      }
      catch (ampl::AMPLException e) {
        SWIG_exception(SWIG_RuntimeError, e.what());
      }
      catch (std::invalid_argument e) {
        SWIG_exception(SWIG_ValueError, e.what());
      }
      catch (std::out_of_range e) {
        // SWIG_KeyError does not exist
        SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
      }
      catch (std::logic_error e) {
        SWIG_exception(SWIG_TypeError, e.what());
      }
      catch (ampl::UnsupportedOperationException e)
      {
        SWIG_exception(SWIG_TypeError, e.what());
      }
      catch (ampl::LicenseException e) {
        SWIG_exception(SWIG_SystemError, e.what());
      }
      catch (ampl::FileIOException e) {
        SWIG_exception(SWIG_IOError, e.what());
      }
      catch (std::runtime_error e) {
        SWIG_exception(SWIG_RuntimeError, e.what());
      }
      catch (std::exception e) {
        SWIG_exception(SWIG_UnknownError, e.what());
      }
      catch (...) {
        SWIG_exception(SWIG_UnknownError,"Unknown exception");
      }
    }
  } catch (Swig::DirectorException&) {
    SWIG_fail;
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ErrorHandler_warning(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::ErrorHandler *arg1 = (ampl::ErrorHandler *) 0 ;
  ampl::AMPLException *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  Swig::Director *director = 0;
  bool upcall = false;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__ErrorHandler, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ErrorHandler_warning" "', argument " "1"" of type '" "ampl::ErrorHandler *""'"); 
  }
  arg1 = reinterpret_cast< ampl::ErrorHandler * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ampl__AMPLException,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ErrorHandler_warning" "', argument " "2"" of type '" "ampl::AMPLException const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ErrorHandler_warning" "', argument " "2"" of type '" "ampl::AMPLException const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::AMPLException * >(argp2);
  director = SWIG_DIRECTOR_CAST(arg1);
  upcall = (director && (director->swig_get_self()==self));
  try {
    {
      try {
        if (upcall) {
          Swig::DirectorPureVirtualException::raise("ampl::ErrorHandler::warning");
        } else {
          (arg1)->warning((ampl::AMPLException const &)*arg2);
        }
      }
      catch (std::range_error) {
        SWIG_exception(SWIG_ValueError, "Range Error");
      }
      catch (ampl::AMPLException e) {
        SWIG_exception(SWIG_RuntimeError, e.what());
      }
      catch (std::invalid_argument e) {
        SWIG_exception(SWIG_ValueError, e.what());
      }
      catch (std::out_of_range e) {
        // SWIG_KeyError does not exist
        SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
      }
      catch (std::logic_error e) {
        SWIG_exception(SWIG_TypeError, e.what());
      }
      catch (ampl::UnsupportedOperationException e)
      {
        SWIG_exception(SWIG_TypeError, e.what());
      }
      catch (ampl::LicenseException e) {
        SWIG_exception(SWIG_SystemError, e.what());
      }
      catch (ampl::FileIOException e) {
        SWIG_exception(SWIG_IOError, e.what());
      }
      catch (std::runtime_error e) {
        SWIG_exception(SWIG_RuntimeError, e.what());
      }
      catch (std::exception e) {
        SWIG_exception(SWIG_UnknownError, e.what());
      }
      catch (...) {
        SWIG_exception(SWIG_UnknownError,"Unknown exception");
      }
    }
  } catch (Swig::DirectorException&) {
    SWIG_fail;
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_disown_ErrorHandler(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::ErrorHandler *arg1 = (ampl::ErrorHandler *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_ampl__ErrorHandler, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "disown_ErrorHandler" "', argument " "1"" of type '" "ampl::ErrorHandler *""'"); 
  }
  arg1 = reinterpret_cast< ampl::ErrorHandler * >(argp1);
  {
    Swig::Director *director = SWIG_DIRECTOR_CAST(arg1);
    if (director) director->swig_disown();
  }
  
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_ErrorHandler) /* defines _wrap_delete_ErrorHandler_destructor_closure */

SWIGINTERN PyObject *_wrap_delete_Runnable(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Runnable *arg1 = (ampl::Runnable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_Runnable", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Runnable, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Runnable" "', argument " "1"" of type '" "ampl::Runnable *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Runnable * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Runnable_run(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Runnable *arg1 = (ampl::Runnable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  Swig::Director *director = 0;
  bool upcall = false;
  
  if (!SWIG_Python_UnpackTuple(args, "Runnable_run", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Runnable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Runnable_run" "', argument " "1"" of type '" "ampl::Runnable *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Runnable * >(argp1);
  director = SWIG_DIRECTOR_CAST(arg1);
  upcall = (director && (director->swig_get_self()==self));
  try {
    {
      try {
        if (upcall) {
          Swig::DirectorPureVirtualException::raise("ampl::Runnable::run");
        } else {
          (arg1)->run();
        }
      }
      catch (std::range_error) {
        SWIG_exception(SWIG_ValueError, "Range Error");
      }
      catch (ampl::AMPLException e) {
        SWIG_exception(SWIG_RuntimeError, e.what());
      }
      catch (std::invalid_argument e) {
        SWIG_exception(SWIG_ValueError, e.what());
      }
      catch (std::out_of_range e) {
        // SWIG_KeyError does not exist
        SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
      }
      catch (std::logic_error e) {
        SWIG_exception(SWIG_TypeError, e.what());
      }
      catch (ampl::UnsupportedOperationException e)
      {
        SWIG_exception(SWIG_TypeError, e.what());
      }
      catch (ampl::LicenseException e) {
        SWIG_exception(SWIG_SystemError, e.what());
      }
      catch (ampl::FileIOException e) {
        SWIG_exception(SWIG_IOError, e.what());
      }
      catch (std::runtime_error e) {
        SWIG_exception(SWIG_RuntimeError, e.what());
      }
      catch (std::exception e) {
        SWIG_exception(SWIG_UnknownError, e.what());
      }
      catch (...) {
        SWIG_exception(SWIG_UnknownError,"Unknown exception");
      }
    }
  } catch (Swig::DirectorException&) {
    SWIG_fail;
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN int _wrap_new_Runnable(PyObject *self, PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) 0 ;
  PyObject *swig_obj[1] ;
  ampl::Runnable *result = 0 ;
  
  if (!SWIG_Python_CheckNoKeywords(kwargs, "new_Runnable")) SWIG_fail;
  if (!SWIG_Python_UnpackTuple(args, "new_Runnable", 0, 0, 0)) SWIG_fail;
  arg1 = self;
  {
    try {
      if ( self->ob_type != ((SwigPyClientData *)(SWIGTYPE_p_ampl__Runnable)->clientdata)->pytype ) {
        /* subclassed */
        result = (ampl::Runnable *)new SwigDirector_Runnable(arg1); 
      } else {
        SWIG_SetErrorMsg(PyExc_RuntimeError,"accessing abstract class or protected constructor"); 
        SWIG_fail;
      }
      
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__Runnable, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN PyObject *_wrap_disown_Runnable(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Runnable *arg1 = (ampl::Runnable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_ampl__Runnable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "disown_Runnable" "', argument " "1"" of type '" "ampl::Runnable *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Runnable * >(argp1);
  {
    Swig::Director *director = SWIG_DIRECTOR_CAST(arg1);
    if (director) director->swig_disown();
  }
  
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_Runnable) /* defines _wrap_delete_Runnable_destructor_closure */

SWIGINTERN PyObject *_wrap_delete_OutputHandler(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::OutputHandler *arg1 = (ampl::OutputHandler *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_OutputHandler", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__OutputHandler, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_OutputHandler" "', argument " "1"" of type '" "ampl::OutputHandler *""'"); 
  }
  arg1 = reinterpret_cast< ampl::OutputHandler * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_OutputHandler_output(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::OutputHandler *arg1 = (ampl::OutputHandler *) 0 ;
  ampl::output::Kind arg2 ;
  char *arg3 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  PyObject *swig_obj[3] ;
  Swig::Director *director = 0;
  bool upcall = false;
  
  if (!SWIG_Python_UnpackTuple(args, "OutputHandler_output", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__OutputHandler, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OutputHandler_output" "', argument " "1"" of type '" "ampl::OutputHandler *""'"); 
  }
  arg1 = reinterpret_cast< ampl::OutputHandler * >(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "OutputHandler_output" "', argument " "2"" of type '" "ampl::output::Kind""'");
  } 
  arg2 = static_cast< ampl::output::Kind >(val2);
  res3 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "OutputHandler_output" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = reinterpret_cast< char * >(buf3);
  director = SWIG_DIRECTOR_CAST(arg1);
  upcall = (director && (director->swig_get_self()==self));
  try {
    {
      try {
        if (upcall) {
          Swig::DirectorPureVirtualException::raise("ampl::OutputHandler::output");
        } else {
          (arg1)->output(arg2,(char const *)arg3);
        }
      }
      catch (std::range_error) {
        SWIG_exception(SWIG_ValueError, "Range Error");
      }
      catch (ampl::AMPLException e) {
        SWIG_exception(SWIG_RuntimeError, e.what());
      }
      catch (std::invalid_argument e) {
        SWIG_exception(SWIG_ValueError, e.what());
      }
      catch (std::out_of_range e) {
        // SWIG_KeyError does not exist
        SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
      }
      catch (std::logic_error e) {
        SWIG_exception(SWIG_TypeError, e.what());
      }
      catch (ampl::UnsupportedOperationException e)
      {
        SWIG_exception(SWIG_TypeError, e.what());
      }
      catch (ampl::LicenseException e) {
        SWIG_exception(SWIG_SystemError, e.what());
      }
      catch (ampl::FileIOException e) {
        SWIG_exception(SWIG_IOError, e.what());
      }
      catch (std::runtime_error e) {
        SWIG_exception(SWIG_RuntimeError, e.what());
      }
      catch (std::exception e) {
        SWIG_exception(SWIG_UnknownError, e.what());
      }
      catch (...) {
        SWIG_exception(SWIG_UnknownError,"Unknown exception");
      }
    }
  } catch (Swig::DirectorException&) {
    SWIG_fail;
  }
  resultobj = SWIG_Py_Void();
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return resultobj;
fail:
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return NULL;
}


SWIGINTERN int _wrap_new_OutputHandler(PyObject *self, PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) 0 ;
  PyObject *swig_obj[1] ;
  ampl::OutputHandler *result = 0 ;
  
  if (!SWIG_Python_CheckNoKeywords(kwargs, "new_OutputHandler")) SWIG_fail;
  if (!SWIG_Python_UnpackTuple(args, "new_OutputHandler", 0, 0, 0)) SWIG_fail;
  arg1 = self;
  {
    try {
      if ( self->ob_type != ((SwigPyClientData *)(SWIGTYPE_p_ampl__OutputHandler)->clientdata)->pytype ) {
        /* subclassed */
        result = (ampl::OutputHandler *)new SwigDirector_OutputHandler(arg1); 
      } else {
        SWIG_SetErrorMsg(PyExc_RuntimeError,"accessing abstract class or protected constructor"); 
        SWIG_fail;
      }
      
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__OutputHandler, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN PyObject *_wrap_disown_OutputHandler(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::OutputHandler *arg1 = (ampl::OutputHandler *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_ampl__OutputHandler, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "disown_OutputHandler" "', argument " "1"" of type '" "ampl::OutputHandler *""'"); 
  }
  arg1 = reinterpret_cast< ampl::OutputHandler * >(argp1);
  {
    Swig::Director *director = SWIG_DIRECTOR_CAST(arg1);
    if (director) director->swig_disown();
  }
  
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_OutputHandler) /* defines _wrap_delete_OutputHandler_destructor_closure */

SWIGINTERN int _wrap_new_EnvironmentIterator(PyObject *self, PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  ampl::internal::EnvironmentIterator *result = 0 ;
  
  if (!SWIG_Python_CheckNoKeywords(kwargs, "new_EnvironmentIterator")) SWIG_fail;
  if (!SWIG_Python_UnpackTuple(args, "new_EnvironmentIterator", 0, 0, 0)) SWIG_fail;
  {
    try {
      result = (ampl::internal::EnvironmentIterator *)new ampl::internal::EnvironmentIterator();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__internal__EnvironmentIterator, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN PyObject *_wrap_delete_EnvironmentIterator(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::EnvironmentIterator *arg1 = (ampl::internal::EnvironmentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_EnvironmentIterator", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__EnvironmentIterator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_EnvironmentIterator" "', argument " "1"" of type '" "ampl::internal::EnvironmentIterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::EnvironmentIterator * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_EnvironmentIterator) /* defines _wrap_delete_EnvironmentIterator_destructor_closure */

SWIGINTERN int _wrap_new_Environment__SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **SWIGUNUSEDPARM(swig_obj)) {
  PyObject *resultobj = 0;
  ampl::Environment *result = 0 ;
  
  if ((nobjs < 0) || (nobjs > 0)) SWIG_fail;
  {
    try {
      result = (ampl::Environment *)new ampl::Environment();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__Environment, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN int _wrap_new_Environment__SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  ampl::Environment *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ampl::Environment *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_ampl__Environment,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Environment" "', argument " "1"" of type '" "ampl::Environment const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Environment" "', argument " "1"" of type '" "ampl::Environment const &""'"); 
  }
  arg1 = reinterpret_cast< ampl::Environment * >(argp1);
  {
    try {
      result = (ampl::Environment *)new ampl::Environment((ampl::Environment const &)*arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__Environment, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN PyObject *_wrap_Environment_Clone(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Environment *arg1 = (ampl::Environment *) 0 ;
  ampl::Environment *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  ampl::Environment *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Environment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Environment_Clone" "', argument " "1"" of type '" "ampl::Environment *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Environment * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ampl__Environment,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Environment_Clone" "', argument " "2"" of type '" "ampl::Environment const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Environment_Clone" "', argument " "2"" of type '" "ampl::Environment const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::Environment * >(argp2);
  {
    try {
      result = (ampl::Environment *) &(arg1)->operator =((ampl::Environment const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__Environment, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN int _wrap_new_Environment__SWIG_2(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  fmt::CStringRef arg1 ;
  fmt::CStringRef arg2 ;
  ampl::Environment *result = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  
  arg1 = _PyString_AsString(swig_obj[0]);
  
  
  arg2 = _PyString_AsString(swig_obj[1]);
  
  {
    try {
      result = (ampl::Environment *)new ampl::Environment(arg1,arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__Environment, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN int _wrap_new_Environment__SWIG_3(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  fmt::CStringRef arg1 ;
  ampl::Environment *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  
  arg1 = _PyString_AsString(swig_obj[0]);
  
  {
    try {
      result = (ampl::Environment *)new ampl::Environment(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__Environment, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN int _wrap_new_Environment(PyObject *self, PyObject *args, PyObject *kwargs) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!SWIG_Python_CheckNoKeywords(kwargs, "new_Environment")) SWIG_fail;
  if (!(argc = SWIG_Python_UnpackTuple(args, "new_Environment", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 0) {
    return _wrap_new_Environment__SWIG_0(self, argc, argv);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_ampl__Environment, SWIG_POINTER_NO_NULL | 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Environment__SWIG_1(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Environment__SWIG_3(self, argc, argv);
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_Environment__SWIG_2(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'new_Environment'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    ampl::Environment::Environment()\n"
    "    ampl::Environment::Environment(ampl::Environment const &)\n"
    "    ampl::Environment::Environment(fmt::CStringRef,fmt::CStringRef)\n"
    "    ampl::Environment::Environment(fmt::CStringRef)\n");
  return -1;
}


SWIGINTERN PyObject *_wrap_delete_Environment(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Environment *arg1 = (ampl::Environment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_Environment", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Environment, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Environment" "', argument " "1"" of type '" "ampl::Environment *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Environment * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Environment_put(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Environment *arg1 = (ampl::Environment *) 0 ;
  fmt::CStringRef arg2 ;
  fmt::CStringRef arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args, "Environment_put", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Environment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Environment_put" "', argument " "1"" of type '" "ampl::Environment *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Environment * >(argp1);
  
  arg2 = _PyString_AsString(swig_obj[0]);
  
  
  arg3 = _PyString_AsString(swig_obj[1]);
  
  {
    try {
      (arg1)->put(arg2,arg3);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Environment_setBinDir(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Environment *arg1 = (ampl::Environment *) 0 ;
  fmt::CStringRef arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Environment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Environment_setBinDir" "', argument " "1"" of type '" "ampl::Environment *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Environment * >(argp1);
  
  arg2 = _PyString_AsString(swig_obj[0]);
  
  {
    try {
      (arg1)->setBinDir(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Environment_getBinDir(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Environment *arg1 = (ampl::Environment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "Environment_getBinDir", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Environment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Environment_getBinDir" "', argument " "1"" of type '" "ampl::Environment const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Environment * >(argp1);
  {
    try {
      result = ((ampl::Environment const *)arg1)->getBinDir();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Environment_setBinName(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Environment *arg1 = (ampl::Environment *) 0 ;
  fmt::CStringRef arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Environment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Environment_setBinName" "', argument " "1"" of type '" "ampl::Environment *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Environment * >(argp1);
  
  arg2 = _PyString_AsString(swig_obj[0]);
  
  {
    try {
      (arg1)->setBinName(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Environment_getBinName(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Environment *arg1 = (ampl::Environment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "Environment_getBinName", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Environment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Environment_getBinName" "', argument " "1"" of type '" "ampl::Environment const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Environment * >(argp1);
  {
    try {
      result = ((ampl::Environment const *)arg1)->getBinName();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Environment_toString(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Environment *arg1 = (ampl::Environment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "Environment_toString", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Environment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Environment_toString" "', argument " "1"" of type '" "ampl::Environment const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Environment * >(argp1);
  {
    try {
      result = ((ampl::Environment const *)arg1)->toString();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Environment_begin(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Environment *arg1 = (ampl::Environment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ampl::Environment::iterator result;
  
  if (!SWIG_Python_UnpackTuple(args, "Environment_begin", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Environment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Environment_begin" "', argument " "1"" of type '" "ampl::Environment const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Environment * >(argp1);
  {
    try {
      result = ((ampl::Environment const *)arg1)->begin();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::Environment::iterator(static_cast< const ampl::Environment::iterator& >(result))), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Environment_end(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Environment *arg1 = (ampl::Environment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ampl::Environment::iterator result;
  
  if (!SWIG_Python_UnpackTuple(args, "Environment_end", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Environment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Environment_end" "', argument " "1"" of type '" "ampl::Environment const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Environment * >(argp1);
  {
    try {
      result = ((ampl::Environment const *)arg1)->end();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::Environment::iterator(static_cast< const ampl::Environment::iterator& >(result))), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Environment_find(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Environment *arg1 = (ampl::Environment *) 0 ;
  fmt::CStringRef arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  ampl::Environment::iterator result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Environment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Environment_find" "', argument " "1"" of type '" "ampl::Environment const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Environment * >(argp1);
  
  arg2 = _PyString_AsString(swig_obj[0]);
  
  {
    try {
      result = ((ampl::Environment const *)arg1)->find(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::Environment::iterator(static_cast< const ampl::Environment::iterator& >(result))), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Environment_size(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Environment *arg1 = (ampl::Environment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::size_t result;
  
  if (!SWIG_Python_UnpackTuple(args, "Environment_size", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Environment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Environment_size" "', argument " "1"" of type '" "ampl::Environment const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Environment * >(argp1);
  {
    try {
      result = ((ampl::Environment const *)arg1)->size();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_Environment) /* defines _wrap_delete_Environment_destructor_closure */

SWIGINTERN PyObject *_wrap_EnvironmentIteratorTemplate_equals(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > *) 0 ;
  ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EnvironmentIteratorTemplate_equals" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "EnvironmentIteratorTemplate_equals" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "EnvironmentIteratorTemplate_equals" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > * >(argp2);
  {
    try {
      result = (bool)((ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > const *)arg1)->operator ==((ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_EnvironmentIteratorTemplate_differs(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > *) 0 ;
  ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EnvironmentIteratorTemplate_differs" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "EnvironmentIteratorTemplate_differs" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "EnvironmentIteratorTemplate_differs" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > * >(argp2);
  {
    try {
      result = (bool)((ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > const *)arg1)->operator !=((ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_EnvironmentIteratorTemplate_Clone(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > *) 0 ;
  ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EnvironmentIteratorTemplate_Clone" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "EnvironmentIteratorTemplate_Clone" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "EnvironmentIteratorTemplate_Clone" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > * >(argp2);
  {
    try {
      result = (ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > *) &(arg1)->operator =((ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EnvironmentIteratorTemplate_postIncrement(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "EnvironmentIteratorTemplate_postIncrement", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EnvironmentIteratorTemplate_postIncrement" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > * >(argp1);
  {
    try {
      result = (ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > *) &(arg1)->operator ++();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EnvironmentIteratorTemplate_postIncrementBy(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EnvironmentIteratorTemplate_postIncrementBy" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > * >(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "EnvironmentIteratorTemplate_postIncrementBy" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  {
    try {
      result = (arg1)->operator ++(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator >(static_cast< const ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator >& >(result))), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EnvironmentIteratorTemplate_first(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ampl::internal::EnvironmentIterator::KeyType result;
  
  if (!SWIG_Python_UnpackTuple(args, "EnvironmentIteratorTemplate_first", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EnvironmentIteratorTemplate_first" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > * >(argp1);
  {
    try {
      result = (ampl::internal::EnvironmentIterator::KeyType)ampl_internal_CountedIterator_Sl_ampl_internal_EnvironmentIterator_Sg__first(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EnvironmentIteratorTemplate_second(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ampl::internal::EnvironmentIterator::InstanceType result;
  
  if (!SWIG_Python_UnpackTuple(args, "EnvironmentIteratorTemplate_second", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EnvironmentIteratorTemplate_second" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > * >(argp1);
  {
    try {
      result = (ampl::internal::EnvironmentIterator::InstanceType)ampl_internal_CountedIterator_Sl_ampl_internal_EnvironmentIterator_Sg__second(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_EnvironmentIteratorTemplate(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_EnvironmentIteratorTemplate", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_EnvironmentIteratorTemplate" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_EnvironmentIteratorTemplate) /* defines _wrap_delete_EnvironmentIteratorTemplate_destructor_closure */

SWIGINTERN int _wrap_new_AMPL__SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **SWIGUNUSEDPARM(swig_obj)) {
  PyObject *resultobj = 0;
  ampl::AMPL *result = 0 ;
  
  if ((nobjs < 0) || (nobjs > 0)) SWIG_fail;
  {
    try {
      result = (ampl::AMPL *)new ampl::AMPL();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__AMPL, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN int _wrap_new_AMPL__SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  ampl::Environment *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ampl::AMPL *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_ampl__Environment,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_AMPL" "', argument " "1"" of type '" "ampl::Environment const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_AMPL" "', argument " "1"" of type '" "ampl::Environment const &""'"); 
  }
  arg1 = reinterpret_cast< ampl::Environment * >(argp1);
  {
    try {
      result = (ampl::AMPL *)new ampl::AMPL((ampl::Environment const &)*arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__AMPL, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN int _wrap_new_AMPL(PyObject *self, PyObject *args, PyObject *kwargs) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!SWIG_Python_CheckNoKeywords(kwargs, "new_AMPL")) SWIG_fail;
  if (!(argc = SWIG_Python_UnpackTuple(args, "new_AMPL", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 0) {
    return _wrap_new_AMPL__SWIG_0(self, argc, argv);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_ampl__Environment, SWIG_POINTER_NO_NULL | 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_AMPL__SWIG_1(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'new_AMPL'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    ampl::AMPL::AMPL()\n"
    "    ampl::AMPL::AMPL(ampl::Environment const &)\n");
  return -1;
}


SWIGINTERN PyObject *_wrap_delete_AMPL(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "delete_AMPL", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_AMPL" "', argument " "1"" of type '" "ampl::AMPL *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_exportData__SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  std::string result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_exportData" "', argument " "1"" of type '" "ampl::AMPL const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  ecode2 = SWIG_AsVal_bool(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "AMPL_exportData" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  {
    try {
      result = ((ampl::AMPL const *)arg1)->exportData(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_exportData__SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **SWIGUNUSEDPARM(swig_obj)) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_exportData" "', argument " "1"" of type '" "ampl::AMPL const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  {
    try {
      result = ((ampl::AMPL const *)arg1)->exportData();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_exportData__SWIG_2(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  fmt::CStringRef arg2 ;
  bool arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_exportData" "', argument " "1"" of type '" "ampl::AMPL *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  
  arg2 = _PyString_AsString(swig_obj[1]);
  
  ecode3 = SWIG_AsVal_bool(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "AMPL_exportData" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  {
    try {
      (arg1)->exportData(arg2,arg3);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_exportData__SWIG_3(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  fmt::CStringRef arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_exportData" "', argument " "1"" of type '" "ampl::AMPL *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  
  arg2 = _PyString_AsString(swig_obj[1]);
  
  {
    try {
      (arg1)->exportData(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_exportData(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "AMPL_exportData", 0, 3, argv+1))) SWIG_fail;
  argv[0] = self;
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__AMPL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_AMPL_exportData__SWIG_1(self, argc, argv);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__AMPL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_AMPL_exportData__SWIG_0(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__AMPL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_AMPL_exportData__SWIG_3(self, argc, argv);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__AMPL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_bool(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_AMPL_exportData__SWIG_2(self, argc, argv);
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'AMPL_exportData'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    ampl::AMPL::exportData(bool) const\n"
    "    ampl::AMPL::exportData() const\n"
    "    ampl::AMPL::exportData(fmt::CStringRef,bool)\n"
    "    ampl::AMPL::exportData(fmt::CStringRef)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_AMPL_exportModel__SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **SWIGUNUSEDPARM(swig_obj)) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_exportModel" "', argument " "1"" of type '" "ampl::AMPL const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  {
    try {
      result = ((ampl::AMPL const *)arg1)->exportModel();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_exportModel__SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  fmt::CStringRef arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_exportModel" "', argument " "1"" of type '" "ampl::AMPL const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  
  arg2 = _PyString_AsString(swig_obj[1]);
  
  {
    try {
      ((ampl::AMPL const *)arg1)->exportModel(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_exportModel(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "AMPL_exportModel", 0, 2, argv+1))) SWIG_fail;
  argv[0] = self;
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__AMPL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_AMPL_exportModel__SWIG_0(self, argc, argv);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__AMPL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_AMPL_exportModel__SWIG_1(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'AMPL_exportModel'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    ampl::AMPL::exportModel() const\n"
    "    ampl::AMPL::exportModel(fmt::CStringRef) const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_AMPL_getEntity(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  fmt::CStringRef arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  SwigValueWrapper< ampl::Entity > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_getEntity" "', argument " "1"" of type '" "ampl::AMPL const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  
  arg2 = _PyString_AsString(swig_obj[0]);
  
  {
    try {
      result = ((ampl::AMPL const *)arg1)->getEntity(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::Entity(static_cast< const ampl::Entity& >(result))), SWIGTYPE_p_ampl__Entity, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_getVariable(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  fmt::CStringRef arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  SwigValueWrapper< ampl::Variable > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_getVariable" "', argument " "1"" of type '" "ampl::AMPL const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  
  arg2 = _PyString_AsString(swig_obj[0]);
  
  {
    try {
      result = ((ampl::AMPL const *)arg1)->getVariable(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::Variable(static_cast< const ampl::Variable& >(result))), SWIGTYPE_p_ampl__Variable, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_getConstraint(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  fmt::CStringRef arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  SwigValueWrapper< ampl::Constraint > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_getConstraint" "', argument " "1"" of type '" "ampl::AMPL const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  
  arg2 = _PyString_AsString(swig_obj[0]);
  
  {
    try {
      result = ((ampl::AMPL const *)arg1)->getConstraint(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::Constraint(static_cast< const ampl::Constraint& >(result))), SWIGTYPE_p_ampl__Constraint, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_getObjective(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  fmt::CStringRef arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  SwigValueWrapper< ampl::Objective > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_getObjective" "', argument " "1"" of type '" "ampl::AMPL const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  
  arg2 = _PyString_AsString(swig_obj[0]);
  
  {
    try {
      result = ((ampl::AMPL const *)arg1)->getObjective(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::Objective(static_cast< const ampl::Objective& >(result))), SWIGTYPE_p_ampl__Objective, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_getSet(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  fmt::CStringRef arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  SwigValueWrapper< ampl::Set > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_getSet" "', argument " "1"" of type '" "ampl::AMPL const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  
  arg2 = _PyString_AsString(swig_obj[0]);
  
  {
    try {
      result = ((ampl::AMPL const *)arg1)->getSet(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::Set(static_cast< const ampl::Set& >(result))), SWIGTYPE_p_ampl__Set, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_getParameter(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  fmt::CStringRef arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  SwigValueWrapper< ampl::Parameter > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_getParameter" "', argument " "1"" of type '" "ampl::AMPL const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  
  arg2 = _PyString_AsString(swig_obj[0]);
  
  {
    try {
      result = ((ampl::AMPL const *)arg1)->getParameter(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::Parameter(static_cast< const ampl::Parameter& >(result))), SWIGTYPE_p_ampl__Parameter, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_getTable(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  fmt::CStringRef arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  SwigValueWrapper< ampl::Table > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_getTable" "', argument " "1"" of type '" "ampl::AMPL const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  
  arg2 = _PyString_AsString(swig_obj[0]);
  
  {
    try {
      result = ((ampl::AMPL const *)arg1)->getTable(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::Table(static_cast< const ampl::Table& >(result))), SWIGTYPE_p_ampl__Table, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_eval(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  fmt::CStringRef arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_eval" "', argument " "1"" of type '" "ampl::AMPL *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  
  arg2 = _PyString_AsString(swig_obj[0]);
  
  {
    try {
      (arg1)->eval(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_reset(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "AMPL_reset", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_reset" "', argument " "1"" of type '" "ampl::AMPL *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  {
    try {
      (arg1)->reset();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_close(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "AMPL_close", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_close" "', argument " "1"" of type '" "ampl::AMPL *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  {
    try {
      (arg1)->close();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_isRunning(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args, "AMPL_isRunning", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_isRunning" "', argument " "1"" of type '" "ampl::AMPL const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  {
    try {
      result = (bool)((ampl::AMPL const *)arg1)->isRunning();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_isBusy(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args, "AMPL_isBusy", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_isBusy" "', argument " "1"" of type '" "ampl::AMPL const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  {
    try {
      result = (bool)((ampl::AMPL const *)arg1)->isBusy();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_solve(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "AMPL_solve", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_solve" "', argument " "1"" of type '" "ampl::AMPL *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  {
    try {
      (arg1)->solve();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_readAsync(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  fmt::CStringRef arg2 ;
  ampl::Runnable *arg3 = (ampl::Runnable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args, "AMPL_readAsync", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_readAsync" "', argument " "1"" of type '" "ampl::AMPL *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  
  arg2 = _PyString_AsString(swig_obj[0]);
  
  res3 = SWIG_ConvertPtr(swig_obj[1], &argp3,SWIGTYPE_p_ampl__Runnable, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "AMPL_readAsync" "', argument " "3"" of type '" "ampl::Runnable *""'"); 
  }
  arg3 = reinterpret_cast< ampl::Runnable * >(argp3);
  {
    try {
      (arg1)->readAsync(arg2,arg3);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_readDataAsync(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  fmt::CStringRef arg2 ;
  ampl::Runnable *arg3 = (ampl::Runnable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args, "AMPL_readDataAsync", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_readDataAsync" "', argument " "1"" of type '" "ampl::AMPL *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  
  arg2 = _PyString_AsString(swig_obj[0]);
  
  res3 = SWIG_ConvertPtr(swig_obj[1], &argp3,SWIGTYPE_p_ampl__Runnable, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "AMPL_readDataAsync" "', argument " "3"" of type '" "ampl::Runnable *""'"); 
  }
  arg3 = reinterpret_cast< ampl::Runnable * >(argp3);
  {
    try {
      (arg1)->readDataAsync(arg2,arg3);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_evalAsync(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  fmt::CStringRef arg2 ;
  ampl::Runnable *arg3 = (ampl::Runnable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args, "AMPL_evalAsync", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_evalAsync" "', argument " "1"" of type '" "ampl::AMPL *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  
  arg2 = _PyString_AsString(swig_obj[0]);
  
  res3 = SWIG_ConvertPtr(swig_obj[1], &argp3,SWIGTYPE_p_ampl__Runnable, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "AMPL_evalAsync" "', argument " "3"" of type '" "ampl::Runnable *""'"); 
  }
  arg3 = reinterpret_cast< ampl::Runnable * >(argp3);
  {
    try {
      (arg1)->evalAsync(arg2,arg3);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_solveAsync(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  ampl::Runnable *arg2 = (ampl::Runnable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_solveAsync" "', argument " "1"" of type '" "ampl::AMPL *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2,SWIGTYPE_p_ampl__Runnable, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AMPL_solveAsync" "', argument " "2"" of type '" "ampl::Runnable *""'"); 
  }
  arg2 = reinterpret_cast< ampl::Runnable * >(argp2);
  {
    try {
      (arg1)->solveAsync(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_interrupt(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "AMPL_interrupt", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_interrupt" "', argument " "1"" of type '" "ampl::AMPL *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  {
    try {
      (arg1)->interrupt();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_cd__SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **SWIGUNUSEDPARM(swig_obj)) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_cd" "', argument " "1"" of type '" "ampl::AMPL const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  {
    try {
      result = ((ampl::AMPL const *)arg1)->cd();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_cd__SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  fmt::CStringRef arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_cd" "', argument " "1"" of type '" "ampl::AMPL *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  
  arg2 = _PyString_AsString(swig_obj[1]);
  
  {
    try {
      result = (arg1)->cd(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_cd(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "AMPL_cd", 0, 2, argv+1))) SWIG_fail;
  argv[0] = self;
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__AMPL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_AMPL_cd__SWIG_0(self, argc, argv);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__AMPL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_AMPL_cd__SWIG_1(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'AMPL_cd'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    ampl::AMPL::cd() const\n"
    "    ampl::AMPL::cd(fmt::CStringRef)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_AMPL_setOption(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  fmt::CStringRef arg2 ;
  fmt::CStringRef arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args, "AMPL_setOption", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_setOption" "', argument " "1"" of type '" "ampl::AMPL *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  
  arg2 = _PyString_AsString(swig_obj[0]);
  
  
  arg3 = _PyString_AsString(swig_obj[1]);
  
  {
    try {
      (arg1)->setOption(arg2,arg3);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_getOption(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  fmt::CStringRef arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  ampl::Optional< std::string > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_getOption" "', argument " "1"" of type '" "ampl::AMPL const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  
  arg2 = _PyString_AsString(swig_obj[0]);
  
  {
    try {
      result = ((ampl::AMPL const *)arg1)->getOption(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::Optional< std::string >(static_cast< const ampl::Optional< std::string >& >(result))), SWIGTYPE_p_ampl__OptionalT_std__string_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_getIntOption(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  fmt::CStringRef arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  ampl::Optional< int > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_getIntOption" "', argument " "1"" of type '" "ampl::AMPL const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  
  arg2 = _PyString_AsString(swig_obj[0]);
  
  {
    try {
      result = ((ampl::AMPL const *)arg1)->getIntOption(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::Optional< int >(static_cast< const ampl::Optional< int >& >(result))), SWIGTYPE_p_ampl__OptionalT_int_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_setIntOption(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  fmt::CStringRef arg2 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args, "AMPL_setIntOption", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_setIntOption" "', argument " "1"" of type '" "ampl::AMPL *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  
  arg2 = _PyString_AsString(swig_obj[0]);
  
  ecode3 = SWIG_AsVal_int(swig_obj[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "AMPL_setIntOption" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  {
    try {
      (arg1)->setIntOption(arg2,arg3);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_getDblOption(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  fmt::CStringRef arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  ampl::Optional< double > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_getDblOption" "', argument " "1"" of type '" "ampl::AMPL const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  
  arg2 = _PyString_AsString(swig_obj[0]);
  
  {
    try {
      result = ((ampl::AMPL const *)arg1)->getDblOption(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::Optional< double >(static_cast< const ampl::Optional< double >& >(result))), SWIGTYPE_p_ampl__OptionalT_double_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_setDblOption(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  fmt::CStringRef arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args, "AMPL_setDblOption", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_setDblOption" "', argument " "1"" of type '" "ampl::AMPL *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  
  arg2 = _PyString_AsString(swig_obj[0]);
  
  ecode3 = SWIG_AsVal_double(swig_obj[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "AMPL_setDblOption" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  {
    try {
      (arg1)->setDblOption(arg2,arg3);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_getBoolOption(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  fmt::CStringRef arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  ampl::Optional< bool > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_getBoolOption" "', argument " "1"" of type '" "ampl::AMPL const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  
  arg2 = _PyString_AsString(swig_obj[0]);
  
  {
    try {
      result = ((ampl::AMPL const *)arg1)->getBoolOption(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::Optional< bool >(static_cast< const ampl::Optional< bool >& >(result))), SWIGTYPE_p_ampl__OptionalT_bool_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_getCurrentObjectiveName(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "AMPL_getCurrentObjectiveName", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_getCurrentObjectiveName" "', argument " "1"" of type '" "ampl::AMPL *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  {
    try {
      result = (arg1)->getCurrentObjectiveName();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_setBoolOption(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  fmt::CStringRef arg2 ;
  bool arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args, "AMPL_setBoolOption", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_setBoolOption" "', argument " "1"" of type '" "ampl::AMPL *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  
  arg2 = _PyString_AsString(swig_obj[0]);
  
  ecode3 = SWIG_AsVal_bool(swig_obj[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "AMPL_setBoolOption" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  {
    try {
      (arg1)->setBoolOption(arg2,arg3);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_read(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  fmt::CStringRef arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_read" "', argument " "1"" of type '" "ampl::AMPL *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  
  arg2 = _PyString_AsString(swig_obj[0]);
  
  {
    try {
      (arg1)->read(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_readData(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  fmt::CStringRef arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_readData" "', argument " "1"" of type '" "ampl::AMPL *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  
  arg2 = _PyString_AsString(swig_obj[0]);
  
  {
    try {
      (arg1)->readData(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_getValue(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  fmt::CStringRef arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  SwigValueWrapper< ampl::Variant > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_getValue" "', argument " "1"" of type '" "ampl::AMPL const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  
  arg2 = _PyString_AsString(swig_obj[0]);
  
  {
    try {
      result = ((ampl::AMPL const *)arg1)->getValue(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  {
    switch ((&result)->type()) {
    case ampl::STRING:
      resultobj = PyString_FromString((&result)->c_str());
      break;
    case ampl::NUMERIC:
      resultobj = PyFloat_FromDouble((&result)->dbl());
      break;
    default:
      resultobj = Py_None;
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_getOutput(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  fmt::CStringRef arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  std::string result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_getOutput" "', argument " "1"" of type '" "ampl::AMPL *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  
  arg2 = _PyString_AsString(swig_obj[0]);
  
  {
    try {
      result = (arg1)->getOutput(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_setData__SWIG_0(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  ampl::DataFrame *arg2 = 0 ;
  fmt::CStringRef arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_setData" "', argument " "1"" of type '" "ampl::AMPL *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_ampl__DataFrame,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AMPL_setData" "', argument " "2"" of type '" "ampl::DataFrame const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "AMPL_setData" "', argument " "2"" of type '" "ampl::DataFrame const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::DataFrame * >(argp2);
  
  arg3 = _PyString_AsString(swig_obj[2]);
  
  {
    try {
      (arg1)->setData((ampl::DataFrame const &)*arg2,arg3);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_setData__SWIG_1(PyObject *self, Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  ampl::DataFrame *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_setData" "', argument " "1"" of type '" "ampl::AMPL *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_ampl__DataFrame,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AMPL_setData" "', argument " "2"" of type '" "ampl::DataFrame const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "AMPL_setData" "', argument " "2"" of type '" "ampl::DataFrame const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::DataFrame * >(argp2);
  {
    try {
      (arg1)->setData((ampl::DataFrame const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_setData(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "AMPL_setData", 0, 3, argv+1))) SWIG_fail;
  argv[0] = self;
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__AMPL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_ampl__DataFrame, SWIG_POINTER_NO_NULL | 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_AMPL_setData__SWIG_1(self, argc, argv);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__AMPL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_ampl__DataFrame, SWIG_POINTER_NO_NULL | 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_AMPL_setData__SWIG_0(self, argc, argv);
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'AMPL_setData'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    ampl::AMPL::setData(ampl::DataFrame const &,fmt::CStringRef)\n"
    "    ampl::AMPL::setData(ampl::DataFrame const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_AMPL_toString(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "AMPL_toString", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_toString" "', argument " "1"" of type '" "ampl::AMPL const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  {
    try {
      result = ((ampl::AMPL const *)arg1)->toString();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_readTable(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  fmt::CStringRef arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_readTable" "', argument " "1"" of type '" "ampl::AMPL *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  
  arg2 = _PyString_AsString(swig_obj[0]);
  
  {
    try {
      (arg1)->readTable(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_writeTable(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  fmt::CStringRef arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_writeTable" "', argument " "1"" of type '" "ampl::AMPL *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  
  arg2 = _PyString_AsString(swig_obj[0]);
  
  {
    try {
      (arg1)->writeTable(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_display(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  SwigValueWrapper< ampl::EntityArgs > arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_display" "', argument " "1"" of type '" "ampl::AMPL *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ampl__EntityArgs,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AMPL_display" "', argument " "2"" of type '" "ampl::EntityArgs""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "AMPL_display" "', argument " "2"" of type '" "ampl::EntityArgs""'");
    } else {
      ampl::EntityArgs * temp = reinterpret_cast< ampl::EntityArgs * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      (arg1)->display(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_show(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  SwigValueWrapper< ampl::EntityArgs > arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_show" "', argument " "1"" of type '" "ampl::AMPL *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ampl__EntityArgs,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AMPL_show" "', argument " "2"" of type '" "ampl::EntityArgs""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "AMPL_show" "', argument " "2"" of type '" "ampl::EntityArgs""'");
    } else {
      ampl::EntityArgs * temp = reinterpret_cast< ampl::EntityArgs * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      (arg1)->show(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_expand(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  SwigValueWrapper< ampl::EntityArgs > arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_expand" "', argument " "1"" of type '" "ampl::AMPL *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ampl__EntityArgs,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AMPL_expand" "', argument " "2"" of type '" "ampl::EntityArgs""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "AMPL_expand" "', argument " "2"" of type '" "ampl::EntityArgs""'");
    } else {
      ampl::EntityArgs * temp = reinterpret_cast< ampl::EntityArgs * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      (arg1)->expand(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_setOutputHandler(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  ampl::OutputHandler *arg2 = (ampl::OutputHandler *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_setOutputHandler" "', argument " "1"" of type '" "ampl::AMPL *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2,SWIGTYPE_p_ampl__OutputHandler, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AMPL_setOutputHandler" "', argument " "2"" of type '" "ampl::OutputHandler *""'"); 
  }
  arg2 = reinterpret_cast< ampl::OutputHandler * >(argp2);
  {
    try {
      (arg1)->setOutputHandler(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_setErrorHandler(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  ampl::ErrorHandler *arg2 = (ampl::ErrorHandler *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_setErrorHandler" "', argument " "1"" of type '" "ampl::AMPL *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2,SWIGTYPE_p_ampl__ErrorHandler, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AMPL_setErrorHandler" "', argument " "2"" of type '" "ampl::ErrorHandler *""'"); 
  }
  arg2 = reinterpret_cast< ampl::ErrorHandler * >(argp2);
  {
    try {
      (arg1)->setErrorHandler(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_getOutputHandler(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  Swig::Director *director = 0;
  ampl::OutputHandler *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "AMPL_getOutputHandler", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_getOutputHandler" "', argument " "1"" of type '" "ampl::AMPL const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  {
    try {
      result = (ampl::OutputHandler *)((ampl::AMPL const *)arg1)->getOutputHandler();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  director = SWIG_DIRECTOR_CAST(result);
  if (director) {
    resultobj = director->swig_get_self();
    Py_INCREF(resultobj);
  } else {
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__OutputHandler, 0 |  0 );
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_getErrorHandler(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  Swig::Director *director = 0;
  ampl::ErrorHandler *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "AMPL_getErrorHandler", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_getErrorHandler" "', argument " "1"" of type '" "ampl::AMPL const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  {
    try {
      result = (ampl::ErrorHandler *)((ampl::AMPL const *)arg1)->getErrorHandler();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  director = SWIG_DIRECTOR_CAST(result);
  if (director) {
    resultobj = director->swig_get_self();
    Py_INCREF(resultobj);
  } else {
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__ErrorHandler, 0 |  0 );
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_getVariables(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  SwigValueWrapper< ampl::EntityMap< ampl::Variable > > result;
  
  if (!SWIG_Python_UnpackTuple(args, "AMPL_getVariables", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_getVariables" "', argument " "1"" of type '" "ampl::AMPL const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  {
    try {
      result = ((ampl::AMPL const *)arg1)->getVariables();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::EntityMap< ampl::Variable >(static_cast< const ampl::EntityMap< ampl::Variable >& >(result))), SWIGTYPE_p_ampl__EntityMapT_ampl__Variable_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_getConstraints(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  SwigValueWrapper< ampl::EntityMap< ampl::Constraint > > result;
  
  if (!SWIG_Python_UnpackTuple(args, "AMPL_getConstraints", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_getConstraints" "', argument " "1"" of type '" "ampl::AMPL const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  {
    try {
      result = ((ampl::AMPL const *)arg1)->getConstraints();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::EntityMap< ampl::Constraint >(static_cast< const ampl::EntityMap< ampl::Constraint >& >(result))), SWIGTYPE_p_ampl__EntityMapT_ampl__Constraint_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_getObjectives(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  SwigValueWrapper< ampl::EntityMap< ampl::Objective > > result;
  
  if (!SWIG_Python_UnpackTuple(args, "AMPL_getObjectives", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_getObjectives" "', argument " "1"" of type '" "ampl::AMPL const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  {
    try {
      result = ((ampl::AMPL const *)arg1)->getObjectives();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::EntityMap< ampl::Objective >(static_cast< const ampl::EntityMap< ampl::Objective >& >(result))), SWIGTYPE_p_ampl__EntityMapT_ampl__Objective_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_getSets(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  SwigValueWrapper< ampl::EntityMap< ampl::Set > > result;
  
  if (!SWIG_Python_UnpackTuple(args, "AMPL_getSets", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_getSets" "', argument " "1"" of type '" "ampl::AMPL const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  {
    try {
      result = ((ampl::AMPL const *)arg1)->getSets();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::EntityMap< ampl::Set >(static_cast< const ampl::EntityMap< ampl::Set >& >(result))), SWIGTYPE_p_ampl__EntityMapT_ampl__Set_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_getParameters(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  SwigValueWrapper< ampl::EntityMap< ampl::Parameter > > result;
  
  if (!SWIG_Python_UnpackTuple(args, "AMPL_getParameters", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_getParameters" "', argument " "1"" of type '" "ampl::AMPL const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  {
    try {
      result = ((ampl::AMPL const *)arg1)->getParameters();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::EntityMap< ampl::Parameter >(static_cast< const ampl::EntityMap< ampl::Parameter >& >(result))), SWIGTYPE_p_ampl__EntityMapT_ampl__Parameter_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_getTables(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  SwigValueWrapper< ampl::EntityMap< ampl::Table > > result;
  
  if (!SWIG_Python_UnpackTuple(args, "AMPL_getTables", 0, 0, 0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_getTables" "', argument " "1"" of type '" "ampl::AMPL const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  {
    try {
      result = ((ampl::AMPL const *)arg1)->getTables();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::EntityMap< ampl::Table >(static_cast< const ampl::EntityMap< ampl::Table >& >(result))), SWIGTYPE_p_ampl__EntityMapT_ampl__Table_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_displayLst(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  char **arg2 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  
  {
    arg2 = NULL;
  }
  if (!SWIG_Python_UnpackTuple(args, "AMPL_displayLst", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_displayLst" "', argument " "1"" of type '" "ampl::AMPL *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  {
    /* Check if is a list */
    if (PyList_Check(swig_obj[0])) {
      std::size_t size = PyList_Size(swig_obj[0]);
      std::size_t i = 0;
      arg2 = (char **)malloc((size + 1) * sizeof(char *));
      for (i = 0; i < size; i++) {
        PyObject *obj = PyList_GetItem(swig_obj[0],i);
        if (_PyString_Check(obj)) {
          arg2[i] = (char *)_PyString_AsString(PyList_GetItem(swig_obj[0],i));
        } else {
          PyErr_SetString(PyExc_TypeError, "list must contain strings");
          free(arg2);
          return NULL;
        }
      }
      arg2[i] = 0;
    } else {
      PyErr_SetString(PyExc_TypeError, "not a list");
      return NULL;
    }
  }
  ecode3 = SWIG_AsVal_int(swig_obj[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "AMPL_displayLst" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  {
    try {
      ampl_AMPL_display(arg1,(char const *(*))arg2,arg3);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  {
    free((char *)arg2);
  }
  return resultobj;
fail:
  {
    free((char *)arg2);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_getData(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  char **arg2 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  SwigValueWrapper< ampl::DataFrame > result;
  
  {
    arg2 = NULL;
  }
  if (!SWIG_Python_UnpackTuple(args, "AMPL_getData", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_getData" "', argument " "1"" of type '" "ampl::AMPL *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  {
    /* Check if is a list */
    if (PyList_Check(swig_obj[0])) {
      std::size_t size = PyList_Size(swig_obj[0]);
      std::size_t i = 0;
      arg2 = (char **)malloc((size + 1) * sizeof(char *));
      for (i = 0; i < size; i++) {
        PyObject *obj = PyList_GetItem(swig_obj[0],i);
        if (_PyString_Check(obj)) {
          arg2[i] = (char *)_PyString_AsString(PyList_GetItem(swig_obj[0],i));
        } else {
          PyErr_SetString(PyExc_TypeError, "list must contain strings");
          free(arg2);
          return NULL;
        }
      }
      arg2[i] = 0;
    } else {
      PyErr_SetString(PyExc_TypeError, "not a list");
      return NULL;
    }
  }
  ecode3 = SWIG_AsVal_int(swig_obj[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "AMPL_getData" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  {
    try {
      result = ampl_AMPL_getData(arg1,(char const *(*))arg2,arg3);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::invalid_argument e) {
      SWIG_exception(SWIG_ValueError, e.what());
    }
    catch (std::out_of_range e) {
      // SWIG_KeyError does not exist
      SWIG_Python_SetErrorMsg(PyExc_KeyError, e.what()); SWIG_fail;
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::DataFrame(static_cast< const ampl::DataFrame& >(result))), SWIGTYPE_p_ampl__DataFrame, SWIG_POINTER_OWN |  0 );
  {
    free((char *)arg2);
  }
  return resultobj;
fail:
  {
    free((char *)arg2);
  }
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_AMPL) /* defines _wrap_delete_AMPL_destructor_closure */

static PyMethodDef SwigMethods[] = {
	 { "SWIG_PyInstanceMethod_New", SWIG_PyInstanceMethod_New, METH_O, NULL},
	 { "VariantFromPyObject", _wrap_VariantFromPyObject, METH_O, NULL},
	 { "SetTupleFromPyObject", _wrap_SetTupleFromPyObject, METH_VARARGS, NULL},
	 { "VariantArray_frompointer", _wrap_VariantArray_frompointer, METH_O, NULL},
	 { "TupleArray_frompointer", _wrap_TupleArray_frompointer, METH_O, NULL},
	 { "Tuple_Factory", _wrap_Tuple_Factory, METH_VARARGS, NULL},
	 { "DataFrame_factory", _wrap_DataFrame_factory, METH_VARARGS, NULL},
	 { "EntityArray_frompointer", _wrap_EntityArray_frompointer, METH_O, NULL},
	 { "EntityArgs_Factory", _wrap_EntityArgs_Factory, METH_VARARGS, NULL},
	 { "disown_ErrorHandler", _wrap_disown_ErrorHandler, METH_O, NULL},
	 { "disown_Runnable", _wrap_disown_Runnable, METH_O, NULL},
	 { "disown_OutputHandler", _wrap_disown_OutputHandler, METH_O, NULL},
	 { NULL, NULL, 0, NULL }
};

static PyMethodDef SwigMethods_proxydocs[] = {
	 { NULL, NULL, 0, NULL }
};

static SwigPyGetSet StringArray___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__StringArray_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &StringArray___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__StringArray_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__StringArray_methods[] = {
  { "size", _wrap_StringArray_size, METH_NOARGS, "" },
  { "getIndex", _wrap_StringArray_getIndex, METH_O, "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__StringArray_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.StringArray",                 /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_StringArray_destructor_closure,                  /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__StringArray_type.as_number,             /* tp_as_number */
    &SwigPyBuiltin__ampl__StringArray_type.as_sequence,           /* tp_as_sequence */
    &SwigPyBuiltin__ampl__StringArray_type.as_mapping,            /* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__StringArray_type.as_buffer,             /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::StringArray",                      /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__ampl__StringArray_richcompare,                 /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__StringArray_methods, /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__StringArray_getset,  /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    SwigPyBuiltin_BadInit,                    /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__StringArray_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__StringArray_type};

static SwigPyGetSet StringRefArray___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__StringRefArray_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &StringRefArray___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__StringRefArray_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__StringRefArray_methods[] = {
  { "size", _wrap_StringRefArray_size, METH_NOARGS, "" },
  { "getIndex", _wrap_StringRefArray_getIndex, METH_O, "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__StringRefArray_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.StringRefArray",              /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_StringRefArray_destructor_closure,               /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__StringRefArray_type.as_number,          /* tp_as_number */
    &SwigPyBuiltin__ampl__StringRefArray_type.as_sequence,        /* tp_as_sequence */
    &SwigPyBuiltin__ampl__StringRefArray_type.as_mapping,         /* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__StringRefArray_type.as_buffer,          /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::StringRefArray",                   /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__ampl__StringRefArray_richcompare,              /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__StringRefArray_methods,                  /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__StringRefArray_getset,                   /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    SwigPyBuiltin_BadInit,                    /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__StringRefArray_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__StringRefArray_type};

static SwigPyGetSet runtime_error___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__std__runtime_error_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &runtime_error___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__std__runtime_error_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__std__runtime_error_methods[] = {
  { "what", _wrap_runtime_error_what, METH_NOARGS, "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__std__runtime_error_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.runtime_error",               /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_runtime_error_destructor_closure,                /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__std__runtime_error_type.as_number,            /* tp_as_number */
    &SwigPyBuiltin__std__runtime_error_type.as_sequence,          /* tp_as_sequence */
    &SwigPyBuiltin__std__runtime_error_type.as_mapping,           /* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__std__runtime_error_type.as_buffer,            /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "std::runtime_error",                     /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__std__runtime_error_richcompare,                /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__std__runtime_error_methods,/* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__std__runtime_error_getset, /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    SwigPyBuiltin_BadInit,                    /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__std__runtime_error_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__std__runtime_error_type};

static SwigPyGetSet VariantArray___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__VariantArray_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &VariantArray___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__VariantArray_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__VariantArray_methods[] = {
  { "__getitem__", _wrap_VariantArray___getitem__, METH_O, "" },
  { "__setitem__", _wrap_VariantArray___setitem__, METH_VARARGS, "" },
  { "cast", _wrap_VariantArray_cast, METH_NOARGS, "" },
  { "frompointer", (PyCFunction)(void(*)(void))_wrap_VariantArray_frompointer, METH_STATIC|METH_O, "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__VariantArray_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.VariantArray",                /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_VariantArray_destructor_closure,                 /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__VariantArray_type.as_number,                  /* tp_as_number */
    &SwigPyBuiltin__VariantArray_type.as_sequence,                /* tp_as_sequence */
    &SwigPyBuiltin__VariantArray_type.as_mapping,                 /* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__VariantArray_type.as_buffer,                  /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "::VariantArray",                         /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__VariantArray_richcompare,  /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__VariantArray_methods,      /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__VariantArray_getset,       /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    _wrap_new_VariantArray,                   /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    _wrap_VariantArray___getitem___ssizeargfunc_closure,          /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    _wrap_VariantArray___setitem___ssizeobjargproc_closure,       /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__VariantArray_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__VariantArray_type};

static SwigPyGetSet TupleArray___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__TupleArray_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &TupleArray___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__TupleArray_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__TupleArray_methods[] = {
  { "__getitem__", _wrap_TupleArray___getitem__, METH_O, "" },
  { "__setitem__", _wrap_TupleArray___setitem__, METH_VARARGS, "" },
  { "cast", _wrap_TupleArray_cast, METH_NOARGS, "" },
  { "frompointer", (PyCFunction)(void(*)(void))_wrap_TupleArray_frompointer, METH_STATIC|METH_O, "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__TupleArray_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.TupleArray",                  /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_TupleArray_destructor_closure,                   /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__TupleArray_type.as_number,/* tp_as_number */
    &SwigPyBuiltin__TupleArray_type.as_sequence,                  /* tp_as_sequence */
    &SwigPyBuiltin__TupleArray_type.as_mapping,                   /* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__TupleArray_type.as_buffer,/* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "::TupleArray",                           /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__TupleArray_richcompare,    /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__TupleArray_methods,        /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__TupleArray_getset,         /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    _wrap_new_TupleArray,                     /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    _wrap_TupleArray___getitem___ssizeargfunc_closure,            /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    _wrap_TupleArray___setitem___ssizeobjargproc_closure,         /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__TupleArray_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__TupleArray_type};

static SwigPyGetSet OptionalInt___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__OptionalT_int_t_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &OptionalInt___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__OptionalT_int_t_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__OptionalT_int_t_methods[] = {
  { "hasValue", _wrap_OptionalInt_hasValue, METH_NOARGS, "" },
  { "value", _wrap_OptionalInt_value, METH_NOARGS, "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__OptionalT_int_t_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.OptionalInt",                 /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_OptionalInt_destructor_closure,                  /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__OptionalT_int_t_type.as_number,         /* tp_as_number */
    &SwigPyBuiltin__ampl__OptionalT_int_t_type.as_sequence,       /* tp_as_sequence */
    &SwigPyBuiltin__ampl__OptionalT_int_t_type.as_mapping,        /* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__OptionalT_int_t_type.as_buffer,         /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::Optional< int >",                  /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__ampl__OptionalT_int_t_richcompare,             /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__OptionalT_int_t_methods,                 /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__OptionalT_int_t_getset,                  /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    _wrap_new_OptionalInt,                    /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    _wrap_OptionalInt_hasValue_inquiry_closure,                   /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__OptionalT_int_t_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__OptionalT_int_t_type};

static SwigPyGetSet OptionalString___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__OptionalT_std__string_t_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &OptionalString___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__OptionalT_std__string_t_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__OptionalT_std__string_t_methods[] = {
  { "hasValue", _wrap_OptionalString_hasValue, METH_NOARGS, "" },
  { "value", _wrap_OptionalString_value, METH_NOARGS, "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__OptionalT_std__string_t_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.OptionalString",              /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_OptionalString_destructor_closure,               /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__OptionalT_std__string_t_type.as_number, /* tp_as_number */
    &SwigPyBuiltin__ampl__OptionalT_std__string_t_type.as_sequence,/* tp_as_sequence */
    &SwigPyBuiltin__ampl__OptionalT_std__string_t_type.as_mapping,/* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__OptionalT_std__string_t_type.as_buffer, /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::Optional< std::string >",          /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__ampl__OptionalT_std__string_t_richcompare,     /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__OptionalT_std__string_t_methods,         /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__OptionalT_std__string_t_getset,          /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    _wrap_new_OptionalString,                 /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    _wrap_OptionalString_hasValue_inquiry_closure,                /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__OptionalT_std__string_t_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__OptionalT_std__string_t_type};

static SwigPyGetSet OptionalBool___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__OptionalT_bool_t_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &OptionalBool___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__OptionalT_bool_t_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__OptionalT_bool_t_methods[] = {
  { "hasValue", _wrap_OptionalBool_hasValue, METH_NOARGS, "" },
  { "value", _wrap_OptionalBool_value, METH_NOARGS, "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__OptionalT_bool_t_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.OptionalBool",                /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_OptionalBool_destructor_closure,                 /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__OptionalT_bool_t_type.as_number,        /* tp_as_number */
    &SwigPyBuiltin__ampl__OptionalT_bool_t_type.as_sequence,      /* tp_as_sequence */
    &SwigPyBuiltin__ampl__OptionalT_bool_t_type.as_mapping,       /* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__OptionalT_bool_t_type.as_buffer,        /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::Optional< bool >",                 /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__ampl__OptionalT_bool_t_richcompare,            /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__OptionalT_bool_t_methods,                /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__OptionalT_bool_t_getset,                 /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    _wrap_new_OptionalBool,                   /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    _wrap_OptionalBool_hasValue_inquiry_closure,                  /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__OptionalT_bool_t_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__OptionalT_bool_t_type};

static SwigPyGetSet OptionalDouble___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__OptionalT_double_t_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &OptionalDouble___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__OptionalT_double_t_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__OptionalT_double_t_methods[] = {
  { "hasValue", _wrap_OptionalDouble_hasValue, METH_NOARGS, "" },
  { "value", _wrap_OptionalDouble_value, METH_NOARGS, "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__OptionalT_double_t_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.OptionalDouble",              /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_OptionalDouble_destructor_closure,               /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__OptionalT_double_t_type.as_number,      /* tp_as_number */
    &SwigPyBuiltin__ampl__OptionalT_double_t_type.as_sequence,    /* tp_as_sequence */
    &SwigPyBuiltin__ampl__OptionalT_double_t_type.as_mapping,     /* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__OptionalT_double_t_type.as_buffer,      /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::Optional< double >",               /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__ampl__OptionalT_double_t_richcompare,          /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__OptionalT_double_t_methods,              /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__OptionalT_double_t_getset,               /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    _wrap_new_OptionalDouble,                 /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    _wrap_OptionalDouble_hasValue_inquiry_closure,                /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__OptionalT_double_t_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__OptionalT_double_t_type};

static SwigPyGetSet Variant___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__Variant_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &Variant___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__Variant_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__Variant_methods[] = {
  { "str", _wrap_Variant_str, METH_NOARGS, "" },
  { "dbl", _wrap_Variant_dbl, METH_NOARGS, "" },
  { "type", _wrap_Variant_type, METH_NOARGS, "" },
  { "toString", _wrap_Variant_toString, METH_NOARGS, "" },
  { "equals", _wrap_Variant_equals, METH_O, "" },
  { "compare", _wrap_Variant_compare, METH_O, "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__Variant_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.Variant",                     /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_Variant_destructor_closure,  /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__Variant_type.as_number,                 /* tp_as_number */
    &SwigPyBuiltin__ampl__Variant_type.as_sequence,               /* tp_as_sequence */
    &SwigPyBuiltin__ampl__Variant_type.as_mapping,                /* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__Variant_type.as_buffer,                 /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::Variant",                          /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__ampl__Variant_richcompare, /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__Variant_methods,     /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__Variant_getset,      /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    _wrap_new_Variant,                        /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__Variant_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__Variant_type};

static SwigPyGetSet VariantRef___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__VariantRef_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &VariantRef___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__VariantRef_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__VariantRef_methods[] = {
  { "str", _wrap_VariantRef_str, METH_NOARGS, "" },
  { "dbl", _wrap_VariantRef_dbl, METH_NOARGS, "" },
  { "type", _wrap_VariantRef_type, METH_NOARGS, "" },
  { "toString", _wrap_VariantRef_toString, METH_NOARGS, "" },
  { "equals", _wrap_VariantRef_equals, METH_O, "" },
  { "compare", _wrap_VariantRef_compare, METH_O, "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__VariantRef_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.VariantRef",                  /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_VariantRef_destructor_closure,                   /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__VariantRef_type.as_number,              /* tp_as_number */
    &SwigPyBuiltin__ampl__VariantRef_type.as_sequence,            /* tp_as_sequence */
    &SwigPyBuiltin__ampl__VariantRef_type.as_mapping,             /* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__VariantRef_type.as_buffer,              /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::VariantRef",                       /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__ampl__VariantRef_richcompare,                  /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__VariantRef_methods,  /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__VariantRef_getset,   /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    _wrap_new_VariantRef,                     /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__VariantRef_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__VariantRef_type};

static SwigPyGetSet TupleRef___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__TupleRef_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &TupleRef___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__TupleRef_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__TupleRef_methods[] = {
  { "size", _wrap_TupleRef_size, METH_NOARGS, "" },
  { "toString", _wrap_TupleRef_toString, METH_NOARGS, "" },
  { "getIndex", _wrap_TupleRef_getIndex, METH_O, "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__TupleRef_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.TupleRef",                    /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_TupleRef_destructor_closure, /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__TupleRef_type.as_number,                /* tp_as_number */
    &SwigPyBuiltin__ampl__TupleRef_type.as_sequence,              /* tp_as_sequence */
    &SwigPyBuiltin__ampl__TupleRef_type.as_mapping,               /* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__TupleRef_type.as_buffer,                /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::TupleRef",                         /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__ampl__TupleRef_richcompare,/* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__TupleRef_methods,    /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__TupleRef_getset,     /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    _wrap_new_TupleRef,                       /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__TupleRef_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__TupleRef_type};

static SwigPyGetSet Tuple___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__Tuple_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &Tuple___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__Tuple_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  switch (op) {
    case Py_EQ : result = _wrap_Tuple_equals(self, other); break;
    default : break;
  }
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__Tuple_methods[] = {
  { "size", _wrap_Tuple_size, METH_NOARGS, "" },
  { "toString", _wrap_Tuple_toString, METH_NOARGS, "" },
  { "getIndex", _wrap_Tuple_getIndex, METH_O, "" },
  { "equals", _wrap_Tuple_equals, METH_O, "" },
  { "Factory", (PyCFunction)(void(*)(void))_wrap_Tuple_Factory, METH_STATIC|METH_VARARGS, "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__Tuple_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.Tuple",                       /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_Tuple_destructor_closure,    /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__Tuple_type.as_number,                   /* tp_as_number */
    &SwigPyBuiltin__ampl__Tuple_type.as_sequence,                 /* tp_as_sequence */
    &SwigPyBuiltin__ampl__Tuple_type.as_mapping,                  /* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__Tuple_type.as_buffer,                   /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::Tuple",                            /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__ampl__Tuple_richcompare,   /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__Tuple_methods,       /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__Tuple_getset,        /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    _wrap_new_Tuple,                          /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__Tuple_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__Tuple_type};

static SwigPyGetSet DataFrame___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__DataFrame_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &DataFrame___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__DataFrame_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  switch (op) {
    case Py_EQ : result = _wrap_DataFrame_equals(self, other); break;
    case Py_NE : result = _wrap_DataFrame_differs(self, other); break;
    default : break;
  }
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__DataFrame_methods[] = {
  { "clone", _wrap_DataFrame_clone, METH_O, "" },
  { "equals", _wrap_DataFrame_equals, METH_O, "" },
  { "differs", _wrap_DataFrame_differs, METH_O, "" },
  { "getNumCols", _wrap_DataFrame_getNumCols, METH_NOARGS, "" },
  { "getNumRows", _wrap_DataFrame_getNumRows, METH_NOARGS, "" },
  { "getNumIndices", _wrap_DataFrame_getNumIndices, METH_NOARGS, "" },
  { "addRow", _wrap_DataFrame_addRow, METH_VARARGS, "" },
  { "reserve", _wrap_DataFrame_reserve, METH_O, "" },
  { "toString", _wrap_DataFrame_toString, METH_NOARGS, "" },
  { "getColumn", _wrap_DataFrame_getColumn, METH_O, "" },
  { "getRowByIndex", _wrap_DataFrame_getRowByIndex, METH_O, "" },
  { "getRow", _wrap_DataFrame_getRow, METH_VARARGS, "" },
  { "getHeaders", _wrap_DataFrame_getHeaders, METH_NOARGS, "" },
  { "impl", _wrap_DataFrame_impl, METH_NOARGS, "" },
  { "setValueSWIG", _wrap_DataFrame_setValueSWIG, METH_VARARGS, "" },
  { "addColumn", _wrap_DataFrame_addColumn, METH_O, "" },
  { "addColumnStr", _wrap_DataFrame_addColumnStr, METH_VARARGS, "" },
  { "addColumnDbl", _wrap_DataFrame_addColumnDbl, METH_VARARGS, "" },
  { "getRowTpl", _wrap_DataFrame_getRowTpl, METH_O, "" },
  { "setColumnStr", _wrap_DataFrame_setColumnStr, METH_VARARGS, "" },
  { "setColumnDbl", _wrap_DataFrame_setColumnDbl, METH_VARARGS, "" },
  { "setArrayDblDbl", _wrap_DataFrame_setArrayDblDbl, METH_VARARGS, "" },
  { "setArrayStrDbl", _wrap_DataFrame_setArrayStrDbl, METH_VARARGS, "" },
  { "setArrayDblStr", _wrap_DataFrame_setArrayDblStr, METH_VARARGS, "" },
  { "setArrayStrStr", _wrap_DataFrame_setArrayStrStr, METH_VARARGS, "" },
  { "setMatrixDblDblDbl", _wrap_DataFrame_setMatrixDblDblDbl, METH_VARARGS, "" },
  { "setMatrixStrStrDbl", _wrap_DataFrame_setMatrixStrStrDbl, METH_VARARGS, "" },
  { "setMatrixDblStrDbl", _wrap_DataFrame_setMatrixDblStrDbl, METH_VARARGS, "" },
  { "setMatrixStrDblDbl", _wrap_DataFrame_setMatrixStrDblDbl, METH_VARARGS, "" },
  { "setMatrixDblDblStr", _wrap_DataFrame_setMatrixDblDblStr, METH_VARARGS, "" },
  { "setMatrixDblStrStr", _wrap_DataFrame_setMatrixDblStrStr, METH_VARARGS, "" },
  { "setMatrixStrDblStr", _wrap_DataFrame_setMatrixStrDblStr, METH_VARARGS, "" },
  { "setMatrixStrStrStr", _wrap_DataFrame_setMatrixStrStrStr, METH_VARARGS, "" },
  { "factory", (PyCFunction)(void(*)(void))_wrap_DataFrame_factory, METH_STATIC|METH_VARARGS, "" },
  { "setColumnPyList", _wrap_DataFrame_setColumnPyList, METH_VARARGS, "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__DataFrame_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.DataFrame",                   /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_DataFrame_destructor_closure,/* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__DataFrame_type.as_number,               /* tp_as_number */
    &SwigPyBuiltin__ampl__DataFrame_type.as_sequence,             /* tp_as_sequence */
    &SwigPyBuiltin__ampl__DataFrame_type.as_mapping,              /* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__DataFrame_type.as_buffer,               /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::DataFrame",                        /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__ampl__DataFrame_richcompare,                   /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__DataFrame_methods,   /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__DataFrame_getset,    /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    _wrap_new_DataFrame,                      /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__DataFrame_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__DataFrame_type};

static SwigPyGetSet DataFrameColumn___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__internal__SliceT_false_t_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &DataFrameColumn___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__internal__SliceT_false_t_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__internal__SliceT_false_t_methods[] = {
  { "size", _wrap_DataFrameColumn_size, METH_NOARGS, "" },
  { "begin", _wrap_DataFrameColumn_begin, METH_NOARGS, "" },
  { "end", _wrap_DataFrameColumn_end, METH_NOARGS, "" },
  { "getIndex", _wrap_DataFrameColumn_getIndex, METH_O, "" },
  { "toPyList", _wrap_DataFrameColumn_toPyList, METH_NOARGS, "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__internal__SliceT_false_t_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.DataFrameColumn",             /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_DataFrameColumn_destructor_closure,              /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__internal__SliceT_false_t_type.as_number,/* tp_as_number */
    &SwigPyBuiltin__ampl__internal__SliceT_false_t_type.as_sequence,/* tp_as_sequence */
    &SwigPyBuiltin__ampl__internal__SliceT_false_t_type.as_mapping,/* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__internal__SliceT_false_t_type.as_buffer,/* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::internal::Slice< false >",         /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__ampl__internal__SliceT_false_t_richcompare,    /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__internal__SliceT_false_t_methods,        /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__internal__SliceT_false_t_getset,         /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    SwigPyBuiltin_BadInit,                    /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__internal__SliceT_false_t_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__internal__SliceT_false_t_type};

static SwigPyGetSet ColIterator___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__internal__SliceT_false_t__iterator_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &ColIterator___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__internal__SliceT_false_t__iterator_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  switch (op) {
    case Py_EQ : result = _wrap_ColIterator_equals(self, other); break;
    case Py_NE : result = _wrap_ColIterator_differs(self, other); break;
    default : break;
  }
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__internal__SliceT_false_t__iterator_methods[] = {
  { "equals", _wrap_ColIterator_equals, METH_O, "" },
  { "differs", _wrap_ColIterator_differs, METH_O, "" },
  { "__ref__", _wrap_ColIterator___ref__, METH_NOARGS, "" },
  { "clone", _wrap_ColIterator_clone, METH_O, "" },
  { "postIncrement", _wrap_ColIterator_postIncrement, METH_NOARGS, "" },
  { "postIncrementBy", _wrap_ColIterator_postIncrementBy, METH_O, "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__internal__SliceT_false_t__iterator_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.ColIterator",                 /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_ColIterator_destructor_closure,                  /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__internal__SliceT_false_t__iterator_type.as_number,/* tp_as_number */
    &SwigPyBuiltin__ampl__internal__SliceT_false_t__iterator_type.as_sequence,/* tp_as_sequence */
    &SwigPyBuiltin__ampl__internal__SliceT_false_t__iterator_type.as_mapping,/* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__internal__SliceT_false_t__iterator_type.as_buffer,/* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::internal::Slice< false >::iterator",                   /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__ampl__internal__SliceT_false_t__iterator_richcompare,/* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__internal__SliceT_false_t__iterator_methods,/* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__internal__SliceT_false_t__iterator_getset,/* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    SwigPyBuiltin_BadInit,                    /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    _wrap_ColIterator___ref__,                /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__internal__SliceT_false_t__iterator_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__internal__SliceT_false_t__iterator_type};

static SwigPyGetSet DataFrameRow___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__internal__SliceT_true_t_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &DataFrameRow___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__internal__SliceT_true_t_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__internal__SliceT_true_t_methods[] = {
  { "size", _wrap_DataFrameRow_size, METH_NOARGS, "" },
  { "begin", _wrap_DataFrameRow_begin, METH_NOARGS, "" },
  { "end", _wrap_DataFrameRow_end, METH_NOARGS, "" },
  { "getIndex", _wrap_DataFrameRow_getIndex, METH_O, "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__internal__SliceT_true_t_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.DataFrameRow",                /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_DataFrameRow_destructor_closure,                 /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__internal__SliceT_true_t_type.as_number, /* tp_as_number */
    &SwigPyBuiltin__ampl__internal__SliceT_true_t_type.as_sequence,/* tp_as_sequence */
    &SwigPyBuiltin__ampl__internal__SliceT_true_t_type.as_mapping,/* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__internal__SliceT_true_t_type.as_buffer, /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::internal::Slice< true >",          /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__ampl__internal__SliceT_true_t_richcompare,     /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__internal__SliceT_true_t_methods,         /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__internal__SliceT_true_t_getset,          /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    SwigPyBuiltin_BadInit,                    /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__internal__SliceT_true_t_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__internal__SliceT_true_t_type};

static SwigPyGetSet RowIterator___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__internal__SliceT_true_t__iterator_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &RowIterator___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__internal__SliceT_true_t__iterator_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  switch (op) {
    case Py_EQ : result = _wrap_RowIterator_equals(self, other); break;
    case Py_NE : result = _wrap_RowIterator_differs(self, other); break;
    default : break;
  }
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__internal__SliceT_true_t__iterator_methods[] = {
  { "equals", _wrap_RowIterator_equals, METH_O, "" },
  { "differs", _wrap_RowIterator_differs, METH_O, "" },
  { "__ref__", _wrap_RowIterator___ref__, METH_NOARGS, "" },
  { "clone", _wrap_RowIterator_clone, METH_O, "" },
  { "postIncrement", _wrap_RowIterator_postIncrement, METH_NOARGS, "" },
  { "postIncrementBy", _wrap_RowIterator_postIncrementBy, METH_O, "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__internal__SliceT_true_t__iterator_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.RowIterator",                 /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_RowIterator_destructor_closure,                  /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__internal__SliceT_true_t__iterator_type.as_number,/* tp_as_number */
    &SwigPyBuiltin__ampl__internal__SliceT_true_t__iterator_type.as_sequence,/* tp_as_sequence */
    &SwigPyBuiltin__ampl__internal__SliceT_true_t__iterator_type.as_mapping,/* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__internal__SliceT_true_t__iterator_type.as_buffer,/* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::internal::Slice< true >::iterator",/* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__ampl__internal__SliceT_true_t__iterator_richcompare,/* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__internal__SliceT_true_t__iterator_methods,/* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__internal__SliceT_true_t__iterator_getset,/* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    SwigPyBuiltin_BadInit,                    /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    _wrap_RowIterator___ref__,                /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__internal__SliceT_true_t__iterator_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__internal__SliceT_true_t__iterator_type};

static SwigPyGetSet Instance___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__Instance_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &Instance___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__Instance_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__Instance_methods[] = {
  { "toString", _wrap_Instance_toString, METH_NOARGS, "" },
  { "name", _wrap_Instance_name, METH_NOARGS, "" },
  { "entity", _wrap_Instance_entity, METH_NOARGS, "" },
  { "key", _wrap_Instance_key, METH_NOARGS, "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__Instance_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.Instance",                    /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_Instance_destructor_closure, /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__Instance_type.as_number,                /* tp_as_number */
    &SwigPyBuiltin__ampl__Instance_type.as_sequence,              /* tp_as_sequence */
    &SwigPyBuiltin__ampl__Instance_type.as_mapping,               /* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__Instance_type.as_buffer,                /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::Instance",                         /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__ampl__Instance_richcompare,/* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__Instance_methods,    /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__Instance_getset,     /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    SwigPyBuiltin_BadInit,                    /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__Instance_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__Instance_type};

static SwigPyGetSet SetInstance___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__SetInstance_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &SetInstance___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__SetInstance_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__SetInstance_methods[] = {
  { "size", _wrap_SetInstance_size, METH_NOARGS, "" },
  { "contains", _wrap_SetInstance_contains, METH_O, "" },
  { "getValues", _wrap_SetInstance_getValues, METH_NOARGS, "" },
  { "setValuesDf", _wrap_SetInstance_setValuesDf, METH_O, "" },
  { "members", _wrap_SetInstance_members, METH_NOARGS, "" },
  { "Contains", _wrap_SetInstance_Contains, METH_O, "" },
  { "setValuesTuples", _wrap_SetInstance_setValuesTuples, METH_VARARGS, "" },
  { "setValues", _wrap_SetInstance_setValues, METH_VARARGS, "" },
  { "setValuesDbl", _wrap_SetInstance_setValuesDbl, METH_VARARGS, "" },
  { "setValuesStr", _wrap_SetInstance_setValuesStr, METH_VARARGS, "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__SetInstance_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.SetInstance",                 /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_SetInstance_destructor_closure,                  /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__SetInstance_type.as_number,             /* tp_as_number */
    &SwigPyBuiltin__ampl__SetInstance_type.as_sequence,           /* tp_as_sequence */
    &SwigPyBuiltin__ampl__SetInstance_type.as_mapping,            /* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__SetInstance_type.as_buffer,             /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::SetInstance",                      /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__ampl__SetInstance_richcompare,                 /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__SetInstance_methods, /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__SetInstance_getset,  /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    SwigPyBuiltin_BadInit,                    /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__SetInstance_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__SetInstance_type};

static SwigPyGetSet MemberRange___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__SetInstance__MemberRange_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &MemberRange___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__SetInstance__MemberRange_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__SetInstance__MemberRange_methods[] = {
  { "begin", _wrap_MemberRange_begin, METH_NOARGS, "" },
  { "end", _wrap_MemberRange_end, METH_NOARGS, "" },
  { "size", _wrap_MemberRange_size, METH_NOARGS, "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__SetInstance__MemberRange_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.MemberRange",                 /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_MemberRange_destructor_closure,                  /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__SetInstance__MemberRange_type.as_number,/* tp_as_number */
    &SwigPyBuiltin__ampl__SetInstance__MemberRange_type.as_sequence,/* tp_as_sequence */
    &SwigPyBuiltin__ampl__SetInstance__MemberRange_type.as_mapping,/* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__SetInstance__MemberRange_type.as_buffer,/* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::SetInstance::MemberRange",         /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__ampl__SetInstance__MemberRange_richcompare,    /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__SetInstance__MemberRange_methods,        /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__SetInstance__MemberRange_getset,         /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    _wrap_new_MemberRange,                    /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__SetInstance__MemberRange_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__SetInstance__MemberRange_type};

static SwigPyGetSet iterator___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__SetInstance__MemberRange__iterator_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &iterator___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__SetInstance__MemberRange__iterator_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  switch (op) {
    case Py_EQ : result = _wrap_iterator_equals(self, other); break;
    case Py_NE : result = _wrap_iterator_differs(self, other); break;
    default : break;
  }
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__SetInstance__MemberRange__iterator_methods[] = {
  { "__ref__", _wrap_iterator___ref__, METH_NOARGS, "" },
  { "postIncrement", _wrap_iterator_postIncrement, METH_NOARGS, "" },
  { "postIncrementBy", _wrap_iterator_postIncrementBy, METH_O, "" },
  { "equals", _wrap_iterator_equals, METH_O, "" },
  { "differs", _wrap_iterator_differs, METH_O, "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__SetInstance__MemberRange__iterator_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.iterator",                    /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_iterator_destructor_closure, /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__SetInstance__MemberRange__iterator_type.as_number,/* tp_as_number */
    &SwigPyBuiltin__ampl__SetInstance__MemberRange__iterator_type.as_sequence,/* tp_as_sequence */
    &SwigPyBuiltin__ampl__SetInstance__MemberRange__iterator_type.as_mapping,/* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__SetInstance__MemberRange__iterator_type.as_buffer,/* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::SetInstance::MemberRange::iterator",                   /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__ampl__SetInstance__MemberRange__iterator_richcompare,/* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__SetInstance__MemberRange__iterator_methods,/* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__SetInstance__MemberRange__iterator_getset,/* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    SwigPyBuiltin_BadInit,                    /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    _wrap_iterator___ref__,                   /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__SetInstance__MemberRange__iterator_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__SetInstance__MemberRange__iterator_type};

static SwigPyGetSet ObjectiveInstance___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__ObjectiveInstance_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &ObjectiveInstance___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__ObjectiveInstance_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__ObjectiveInstance_methods[] = {
  { "value", _wrap_ObjectiveInstance_value, METH_NOARGS, "" },
  { "astatus", _wrap_ObjectiveInstance_astatus, METH_NOARGS, "" },
  { "sstatus", _wrap_ObjectiveInstance_sstatus, METH_NOARGS, "" },
  { "exitcode", _wrap_ObjectiveInstance_exitcode, METH_NOARGS, "" },
  { "message", _wrap_ObjectiveInstance_message, METH_NOARGS, "" },
  { "result", _wrap_ObjectiveInstance_result, METH_NOARGS, "" },
  { "drop", _wrap_ObjectiveInstance_drop, METH_NOARGS, "" },
  { "restore", _wrap_ObjectiveInstance_restore, METH_NOARGS, "" },
  { "minimization", _wrap_ObjectiveInstance_minimization, METH_NOARGS, "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__ObjectiveInstance_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.ObjectiveInstance",           /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_ObjectiveInstance_destructor_closure,            /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__ObjectiveInstance_type.as_number,       /* tp_as_number */
    &SwigPyBuiltin__ampl__ObjectiveInstance_type.as_sequence,     /* tp_as_sequence */
    &SwigPyBuiltin__ampl__ObjectiveInstance_type.as_mapping,      /* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__ObjectiveInstance_type.as_buffer,       /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::ObjectiveInstance",                /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__ampl__ObjectiveInstance_richcompare,           /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__ObjectiveInstance_methods,               /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__ObjectiveInstance_getset,                /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    SwigPyBuiltin_BadInit,                    /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__ObjectiveInstance_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__ObjectiveInstance_type};

static SwigPyGetSet VariableInstance___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__VariableInstance_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &VariableInstance___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__VariableInstance_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__VariableInstance_methods[] = {
  { "fix", _wrap_VariableInstance_fix, METH_VARARGS, "" },
  { "unfix", _wrap_VariableInstance_unfix, METH_NOARGS, "" },
  { "setValue", _wrap_VariableInstance_setValue, METH_O, "" },
  { "value", _wrap_VariableInstance_value, METH_NOARGS, "" },
  { "defeqn", _wrap_VariableInstance_defeqn, METH_NOARGS, "" },
  { "dual", _wrap_VariableInstance_dual, METH_NOARGS, "" },
  { "init", _wrap_VariableInstance_init, METH_NOARGS, "" },
  { "init0", _wrap_VariableInstance_init0, METH_NOARGS, "" },
  { "lb", _wrap_VariableInstance_lb, METH_NOARGS, "" },
  { "ub", _wrap_VariableInstance_ub, METH_NOARGS, "" },
  { "lb0", _wrap_VariableInstance_lb0, METH_NOARGS, "" },
  { "ub0", _wrap_VariableInstance_ub0, METH_NOARGS, "" },
  { "lb1", _wrap_VariableInstance_lb1, METH_NOARGS, "" },
  { "ub1", _wrap_VariableInstance_ub1, METH_NOARGS, "" },
  { "lb2", _wrap_VariableInstance_lb2, METH_NOARGS, "" },
  { "ub2", _wrap_VariableInstance_ub2, METH_NOARGS, "" },
  { "lrc", _wrap_VariableInstance_lrc, METH_NOARGS, "" },
  { "urc", _wrap_VariableInstance_urc, METH_NOARGS, "" },
  { "lslack", _wrap_VariableInstance_lslack, METH_NOARGS, "" },
  { "uslack", _wrap_VariableInstance_uslack, METH_NOARGS, "" },
  { "rc", _wrap_VariableInstance_rc, METH_NOARGS, "" },
  { "slack", _wrap_VariableInstance_slack, METH_NOARGS, "" },
  { "astatus", _wrap_VariableInstance_astatus, METH_NOARGS, "" },
  { "sstatus", _wrap_VariableInstance_sstatus, METH_NOARGS, "" },
  { "status", _wrap_VariableInstance_status, METH_NOARGS, "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__VariableInstance_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.VariableInstance",            /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_VariableInstance_destructor_closure,             /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__VariableInstance_type.as_number,        /* tp_as_number */
    &SwigPyBuiltin__ampl__VariableInstance_type.as_sequence,      /* tp_as_sequence */
    &SwigPyBuiltin__ampl__VariableInstance_type.as_mapping,       /* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__VariableInstance_type.as_buffer,        /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::VariableInstance",                 /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__ampl__VariableInstance_richcompare,            /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__VariableInstance_methods,                /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__VariableInstance_getset,                 /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    SwigPyBuiltin_BadInit,                    /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__VariableInstance_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__VariableInstance_type};

static SwigPyGetSet ConstraintInstance___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__ConstraintInstance_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &ConstraintInstance___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__ConstraintInstance_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__ConstraintInstance_methods[] = {
  { "drop", _wrap_ConstraintInstance_drop, METH_NOARGS, "" },
  { "restore", _wrap_ConstraintInstance_restore, METH_NOARGS, "" },
  { "body", _wrap_ConstraintInstance_body, METH_NOARGS, "" },
  { "astatus", _wrap_ConstraintInstance_astatus, METH_NOARGS, "" },
  { "defvar", _wrap_ConstraintInstance_defvar, METH_NOARGS, "" },
  { "dinit", _wrap_ConstraintInstance_dinit, METH_NOARGS, "" },
  { "dinit0", _wrap_ConstraintInstance_dinit0, METH_NOARGS, "" },
  { "dual", _wrap_ConstraintInstance_dual, METH_NOARGS, "" },
  { "lb", _wrap_ConstraintInstance_lb, METH_NOARGS, "" },
  { "ub", _wrap_ConstraintInstance_ub, METH_NOARGS, "" },
  { "lbs", _wrap_ConstraintInstance_lbs, METH_NOARGS, "" },
  { "ubs", _wrap_ConstraintInstance_ubs, METH_NOARGS, "" },
  { "ldual", _wrap_ConstraintInstance_ldual, METH_NOARGS, "" },
  { "udual", _wrap_ConstraintInstance_udual, METH_NOARGS, "" },
  { "lslack", _wrap_ConstraintInstance_lslack, METH_NOARGS, "" },
  { "uslack", _wrap_ConstraintInstance_uslack, METH_NOARGS, "" },
  { "slack", _wrap_ConstraintInstance_slack, METH_NOARGS, "" },
  { "sstatus", _wrap_ConstraintInstance_sstatus, METH_NOARGS, "" },
  { "status", _wrap_ConstraintInstance_status, METH_NOARGS, "" },
  { "setDual", _wrap_ConstraintInstance_setDual, METH_O, "" },
  { "val", _wrap_ConstraintInstance_val, METH_NOARGS, "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__ConstraintInstance_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.ConstraintInstance",          /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_ConstraintInstance_destructor_closure,           /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__ConstraintInstance_type.as_number,      /* tp_as_number */
    &SwigPyBuiltin__ampl__ConstraintInstance_type.as_sequence,    /* tp_as_sequence */
    &SwigPyBuiltin__ampl__ConstraintInstance_type.as_mapping,     /* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__ConstraintInstance_type.as_buffer,      /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::ConstraintInstance",               /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__ampl__ConstraintInstance_richcompare,          /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__ConstraintInstance_methods,              /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__ConstraintInstance_getset,               /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    SwigPyBuiltin_BadInit,                    /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__ConstraintInstance_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__ConstraintInstance_type};

static SwigPyGetSet TableInstance___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__TableInstance_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &TableInstance___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__TableInstance_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__TableInstance_methods[] = {
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__TableInstance_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.TableInstance",               /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_TableInstance_destructor_closure,                /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__TableInstance_type.as_number,           /* tp_as_number */
    &SwigPyBuiltin__ampl__TableInstance_type.as_sequence,         /* tp_as_sequence */
    &SwigPyBuiltin__ampl__TableInstance_type.as_mapping,          /* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__TableInstance_type.as_buffer,           /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::TableInstance",                    /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__ampl__TableInstance_richcompare,               /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__TableInstance_methods,                   /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__TableInstance_getset,/* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    SwigPyBuiltin_BadInit,                    /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__TableInstance_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__TableInstance_type};

static SwigPyGetSet EntityArray___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__EntityArray_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &EntityArray___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__EntityArray_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__EntityArray_methods[] = {
  { "__getitem__", _wrap_EntityArray___getitem__, METH_O, "" },
  { "__setitem__", _wrap_EntityArray___setitem__, METH_VARARGS, "" },
  { "cast", _wrap_EntityArray_cast, METH_NOARGS, "" },
  { "frompointer", (PyCFunction)(void(*)(void))_wrap_EntityArray_frompointer, METH_STATIC|METH_O, "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__EntityArray_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.EntityArray",                 /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_EntityArray_destructor_closure,                  /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__EntityArray_type.as_number,                   /* tp_as_number */
    &SwigPyBuiltin__EntityArray_type.as_sequence,                 /* tp_as_sequence */
    &SwigPyBuiltin__EntityArray_type.as_mapping,                  /* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__EntityArray_type.as_buffer,                   /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "::EntityArray",                          /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__EntityArray_richcompare,   /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__EntityArray_methods,       /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__EntityArray_getset,        /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    _wrap_new_EntityArray,                    /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    _wrap_EntityArray___getitem___ssizeargfunc_closure,           /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    _wrap_EntityArray___setitem___ssizeobjargproc_closure,        /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__EntityArray_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__EntityArray_type};

static SwigPyGetSet Entity___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__Entity_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &Entity___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__Entity_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__Entity_methods[] = {
  { "toString", _wrap_Entity_toString, METH_NOARGS, "" },
  { "name", _wrap_Entity_name, METH_NOARGS, "" },
  { "type", _wrap_Entity_type, METH_NOARGS, "" },
  { "indexarity", _wrap_Entity_indexarity, METH_NOARGS, "" },
  { "isScalar", _wrap_Entity_isScalar, METH_NOARGS, "" },
  { "numInstances", _wrap_Entity_numInstances, METH_NOARGS, "" },
  { "getIndexingSets", _wrap_Entity_getIndexingSets, METH_NOARGS, "" },
  { "xref", _wrap_Entity_xref, METH_NOARGS, "" },
  { "getValues", _wrap_Entity_getValues, METH_NOARGS, "" },
  { "setValuesDf", _wrap_Entity_setValuesDf, METH_O, "" },
  { "getValuesLst", _wrap_Entity_getValuesLst, METH_VARARGS, "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__Entity_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.Entity",                      /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_Entity_destructor_closure,   /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__Entity_type.as_number,                  /* tp_as_number */
    &SwigPyBuiltin__ampl__Entity_type.as_sequence,                /* tp_as_sequence */
    &SwigPyBuiltin__ampl__Entity_type.as_mapping,                 /* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__Entity_type.as_buffer,                  /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::Entity",                           /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__ampl__Entity_richcompare,  /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__Entity_methods,      /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__Entity_getset,       /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    SwigPyBuiltin_BadInit,                    /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__Entity_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__Entity_type};

static SwigPyGetSet EntityArgs___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__EntityArgs_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &EntityArgs___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__EntityArgs_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__EntityArgs_methods[] = {
  { "Factory", (PyCFunction)(void(*)(void))_wrap_EntityArgs_Factory, METH_STATIC|METH_VARARGS, "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__EntityArgs_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.EntityArgs",                  /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_EntityArgs_destructor_closure,                   /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__EntityArgs_type.as_number,              /* tp_as_number */
    &SwigPyBuiltin__ampl__EntityArgs_type.as_sequence,            /* tp_as_sequence */
    &SwigPyBuiltin__ampl__EntityArgs_type.as_mapping,             /* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__EntityArgs_type.as_buffer,              /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::EntityArgs",                       /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__ampl__EntityArgs_richcompare,                  /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__EntityArgs_methods,  /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__EntityArgs_getset,   /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    SwigPyBuiltin_BadInit,                    /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__EntityArgs_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__EntityArgs_type};

static SwigPyGetSet BasicEntityVariable___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__BasicEntityT_ampl__VariableInstance_t_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &BasicEntityVariable___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__BasicEntityT_ampl__VariableInstance_t_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__BasicEntityT_ampl__VariableInstance_t_methods[] = {
  { "begin", _wrap_BasicEntityVariable_begin, METH_NOARGS, "" },
  { "end", _wrap_BasicEntityVariable_end, METH_NOARGS, "" },
  { "find", _wrap_BasicEntityVariable_find, METH_O, "" },
  { "get", _wrap_BasicEntityVariable_get, METH_VARARGS, "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__BasicEntityT_ampl__VariableInstance_t_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.BasicEntityVariable",         /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_BasicEntityVariable_destructor_closure,          /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__BasicEntityT_ampl__VariableInstance_t_type.as_number,/* tp_as_number */
    &SwigPyBuiltin__ampl__BasicEntityT_ampl__VariableInstance_t_type.as_sequence,/* tp_as_sequence */
    &SwigPyBuiltin__ampl__BasicEntityT_ampl__VariableInstance_t_type.as_mapping,/* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__BasicEntityT_ampl__VariableInstance_t_type.as_buffer,/* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::BasicEntity< ampl::VariableInstance >",                /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__ampl__BasicEntityT_ampl__VariableInstance_t_richcompare,/* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__BasicEntityT_ampl__VariableInstance_t_methods,/* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__BasicEntityT_ampl__VariableInstance_t_getset,/* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    SwigPyBuiltin_BadInit,                    /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__BasicEntityT_ampl__VariableInstance_t_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__BasicEntityT_ampl__VariableInstance_t_type};

static SwigPyGetSet BasicEntityConstraint___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__BasicEntityT_ampl__ConstraintInstance_t_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &BasicEntityConstraint___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__BasicEntityT_ampl__ConstraintInstance_t_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__BasicEntityT_ampl__ConstraintInstance_t_methods[] = {
  { "begin", _wrap_BasicEntityConstraint_begin, METH_NOARGS, "" },
  { "end", _wrap_BasicEntityConstraint_end, METH_NOARGS, "" },
  { "find", _wrap_BasicEntityConstraint_find, METH_O, "" },
  { "get", _wrap_BasicEntityConstraint_get, METH_VARARGS, "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__BasicEntityT_ampl__ConstraintInstance_t_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.BasicEntityConstraint",       /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_BasicEntityConstraint_destructor_closure,        /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__BasicEntityT_ampl__ConstraintInstance_t_type.as_number,/* tp_as_number */
    &SwigPyBuiltin__ampl__BasicEntityT_ampl__ConstraintInstance_t_type.as_sequence,/* tp_as_sequence */
    &SwigPyBuiltin__ampl__BasicEntityT_ampl__ConstraintInstance_t_type.as_mapping,/* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__BasicEntityT_ampl__ConstraintInstance_t_type.as_buffer,/* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::BasicEntity< ampl::ConstraintInstance >",              /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__ampl__BasicEntityT_ampl__ConstraintInstance_t_richcompare,/* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__BasicEntityT_ampl__ConstraintInstance_t_methods,/* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__BasicEntityT_ampl__ConstraintInstance_t_getset,/* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    SwigPyBuiltin_BadInit,                    /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__BasicEntityT_ampl__ConstraintInstance_t_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__BasicEntityT_ampl__ConstraintInstance_t_type};

static SwigPyGetSet BasicEntitySet___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__BasicEntityT_ampl__SetInstance_t_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &BasicEntitySet___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__BasicEntityT_ampl__SetInstance_t_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__BasicEntityT_ampl__SetInstance_t_methods[] = {
  { "begin", _wrap_BasicEntitySet_begin, METH_NOARGS, "" },
  { "end", _wrap_BasicEntitySet_end, METH_NOARGS, "" },
  { "find", _wrap_BasicEntitySet_find, METH_O, "" },
  { "get", _wrap_BasicEntitySet_get, METH_VARARGS, "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__BasicEntityT_ampl__SetInstance_t_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.BasicEntitySet",              /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_BasicEntitySet_destructor_closure,               /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__BasicEntityT_ampl__SetInstance_t_type.as_number,/* tp_as_number */
    &SwigPyBuiltin__ampl__BasicEntityT_ampl__SetInstance_t_type.as_sequence,/* tp_as_sequence */
    &SwigPyBuiltin__ampl__BasicEntityT_ampl__SetInstance_t_type.as_mapping,/* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__BasicEntityT_ampl__SetInstance_t_type.as_buffer,/* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::BasicEntity< ampl::SetInstance >", /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__ampl__BasicEntityT_ampl__SetInstance_t_richcompare,/* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__BasicEntityT_ampl__SetInstance_t_methods,/* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__BasicEntityT_ampl__SetInstance_t_getset, /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    SwigPyBuiltin_BadInit,                    /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__BasicEntityT_ampl__SetInstance_t_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__BasicEntityT_ampl__SetInstance_t_type};

static SwigPyGetSet BasicEntityObjective___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__BasicEntityT_ampl__ObjectiveInstance_t_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &BasicEntityObjective___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__BasicEntityT_ampl__ObjectiveInstance_t_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__BasicEntityT_ampl__ObjectiveInstance_t_methods[] = {
  { "begin", _wrap_BasicEntityObjective_begin, METH_NOARGS, "" },
  { "end", _wrap_BasicEntityObjective_end, METH_NOARGS, "" },
  { "find", _wrap_BasicEntityObjective_find, METH_O, "" },
  { "get", _wrap_BasicEntityObjective_get, METH_VARARGS, "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__BasicEntityT_ampl__ObjectiveInstance_t_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.BasicEntityObjective",        /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_BasicEntityObjective_destructor_closure,         /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__BasicEntityT_ampl__ObjectiveInstance_t_type.as_number,/* tp_as_number */
    &SwigPyBuiltin__ampl__BasicEntityT_ampl__ObjectiveInstance_t_type.as_sequence,/* tp_as_sequence */
    &SwigPyBuiltin__ampl__BasicEntityT_ampl__ObjectiveInstance_t_type.as_mapping,/* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__BasicEntityT_ampl__ObjectiveInstance_t_type.as_buffer,/* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::BasicEntity< ampl::ObjectiveInstance >",               /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__ampl__BasicEntityT_ampl__ObjectiveInstance_t_richcompare,/* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__BasicEntityT_ampl__ObjectiveInstance_t_methods,/* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__BasicEntityT_ampl__ObjectiveInstance_t_getset,/* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    SwigPyBuiltin_BadInit,                    /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__BasicEntityT_ampl__ObjectiveInstance_t_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__BasicEntityT_ampl__ObjectiveInstance_t_type};

static SwigPyGetSet BasicEntityParameter___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__BasicEntityT_ampl__VariantRef_t_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &BasicEntityParameter___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__BasicEntityT_ampl__VariantRef_t_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__BasicEntityT_ampl__VariantRef_t_methods[] = {
  { "begin", _wrap_BasicEntityParameter_begin, METH_NOARGS, "" },
  { "end", _wrap_BasicEntityParameter_end, METH_NOARGS, "" },
  { "find", _wrap_BasicEntityParameter_find, METH_O, "" },
  { "get", _wrap_BasicEntityParameter_get, METH_VARARGS, "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__BasicEntityT_ampl__VariantRef_t_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.BasicEntityParameter",        /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_BasicEntityParameter_destructor_closure,         /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__BasicEntityT_ampl__VariantRef_t_type.as_number,/* tp_as_number */
    &SwigPyBuiltin__ampl__BasicEntityT_ampl__VariantRef_t_type.as_sequence,/* tp_as_sequence */
    &SwigPyBuiltin__ampl__BasicEntityT_ampl__VariantRef_t_type.as_mapping,/* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__BasicEntityT_ampl__VariantRef_t_type.as_buffer,/* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::BasicEntity< ampl::VariantRef >",  /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__ampl__BasicEntityT_ampl__VariantRef_t_richcompare,/* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__BasicEntityT_ampl__VariantRef_t_methods, /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__BasicEntityT_ampl__VariantRef_t_getset,  /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    SwigPyBuiltin_BadInit,                    /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__BasicEntityT_ampl__VariantRef_t_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__BasicEntityT_ampl__VariantRef_t_type};

static SwigPyGetSet BasicEntityTable___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__BasicEntityT_ampl__TableInstance_t_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &BasicEntityTable___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__BasicEntityT_ampl__TableInstance_t_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__BasicEntityT_ampl__TableInstance_t_methods[] = {
  { "begin", _wrap_BasicEntityTable_begin, METH_NOARGS, "" },
  { "end", _wrap_BasicEntityTable_end, METH_NOARGS, "" },
  { "find", _wrap_BasicEntityTable_find, METH_O, "" },
  { "get", _wrap_BasicEntityTable_get, METH_VARARGS, "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__BasicEntityT_ampl__TableInstance_t_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.BasicEntityTable",            /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_BasicEntityTable_destructor_closure,             /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__BasicEntityT_ampl__TableInstance_t_type.as_number,/* tp_as_number */
    &SwigPyBuiltin__ampl__BasicEntityT_ampl__TableInstance_t_type.as_sequence,/* tp_as_sequence */
    &SwigPyBuiltin__ampl__BasicEntityT_ampl__TableInstance_t_type.as_mapping,/* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__BasicEntityT_ampl__TableInstance_t_type.as_buffer,/* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::BasicEntity< ampl::TableInstance >",                   /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__ampl__BasicEntityT_ampl__TableInstance_t_richcompare,/* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__BasicEntityT_ampl__TableInstance_t_methods,/* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__BasicEntityT_ampl__TableInstance_t_getset,/* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    SwigPyBuiltin_BadInit,                    /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__BasicEntityT_ampl__TableInstance_t_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__BasicEntityT_ampl__TableInstance_t_type};

static SwigPyGetSet Constraint___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__Constraint_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &Constraint___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__Constraint_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__Constraint_methods[] = {
  { "isLogical", _wrap_Constraint_isLogical, METH_NOARGS, "" },
  { "drop", _wrap_Constraint_drop, METH_NOARGS, "" },
  { "restore", _wrap_Constraint_restore, METH_NOARGS, "" },
  { "body", _wrap_Constraint_body, METH_NOARGS, "" },
  { "astatus", _wrap_Constraint_astatus, METH_NOARGS, "" },
  { "defvar", _wrap_Constraint_defvar, METH_NOARGS, "" },
  { "dinit", _wrap_Constraint_dinit, METH_NOARGS, "" },
  { "dinit0", _wrap_Constraint_dinit0, METH_NOARGS, "" },
  { "dual", _wrap_Constraint_dual, METH_NOARGS, "" },
  { "lb", _wrap_Constraint_lb, METH_NOARGS, "" },
  { "ub", _wrap_Constraint_ub, METH_NOARGS, "" },
  { "lbs", _wrap_Constraint_lbs, METH_NOARGS, "" },
  { "ubs", _wrap_Constraint_ubs, METH_NOARGS, "" },
  { "ldual", _wrap_Constraint_ldual, METH_NOARGS, "" },
  { "udual", _wrap_Constraint_udual, METH_NOARGS, "" },
  { "lslack", _wrap_Constraint_lslack, METH_NOARGS, "" },
  { "uslack", _wrap_Constraint_uslack, METH_NOARGS, "" },
  { "slack", _wrap_Constraint_slack, METH_NOARGS, "" },
  { "sstatus", _wrap_Constraint_sstatus, METH_NOARGS, "" },
  { "status", _wrap_Constraint_status, METH_NOARGS, "" },
  { "setDual", _wrap_Constraint_setDual, METH_O, "" },
  { "val", _wrap_Constraint_val, METH_NOARGS, "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__Constraint_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.Constraint",                  /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_Constraint_destructor_closure,                   /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__Constraint_type.as_number,              /* tp_as_number */
    &SwigPyBuiltin__ampl__Constraint_type.as_sequence,            /* tp_as_sequence */
    &SwigPyBuiltin__ampl__Constraint_type.as_mapping,             /* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__Constraint_type.as_buffer,              /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::Constraint",                       /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__ampl__Constraint_richcompare,                  /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__Constraint_methods,  /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__Constraint_getset,   /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    SwigPyBuiltin_BadInit,                    /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__Constraint_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__Constraint_type};

static SwigPyGetSet Variable___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__Variable_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &Variable___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__Variable_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__Variable_methods[] = {
  { "integrality", _wrap_Variable_integrality, METH_NOARGS, "" },
  { "fix", _wrap_Variable_fix, METH_VARARGS, "" },
  { "unfix", _wrap_Variable_unfix, METH_NOARGS, "" },
  { "setValue", _wrap_Variable_setValue, METH_O, "" },
  { "value", _wrap_Variable_value, METH_NOARGS, "" },
  { "astatus", _wrap_Variable_astatus, METH_NOARGS, "" },
  { "defeqn", _wrap_Variable_defeqn, METH_NOARGS, "" },
  { "dual", _wrap_Variable_dual, METH_NOARGS, "" },
  { "init", _wrap_Variable_init, METH_NOARGS, "" },
  { "init0", _wrap_Variable_init0, METH_NOARGS, "" },
  { "lb", _wrap_Variable_lb, METH_NOARGS, "" },
  { "ub", _wrap_Variable_ub, METH_NOARGS, "" },
  { "lb0", _wrap_Variable_lb0, METH_NOARGS, "" },
  { "ub0", _wrap_Variable_ub0, METH_NOARGS, "" },
  { "lb1", _wrap_Variable_lb1, METH_NOARGS, "" },
  { "ub1", _wrap_Variable_ub1, METH_NOARGS, "" },
  { "lb2", _wrap_Variable_lb2, METH_NOARGS, "" },
  { "ub2", _wrap_Variable_ub2, METH_NOARGS, "" },
  { "lrc", _wrap_Variable_lrc, METH_NOARGS, "" },
  { "urc", _wrap_Variable_urc, METH_NOARGS, "" },
  { "lslack", _wrap_Variable_lslack, METH_NOARGS, "" },
  { "uslack", _wrap_Variable_uslack, METH_NOARGS, "" },
  { "rc", _wrap_Variable_rc, METH_NOARGS, "" },
  { "slack", _wrap_Variable_slack, METH_NOARGS, "" },
  { "sstatus", _wrap_Variable_sstatus, METH_NOARGS, "" },
  { "status", _wrap_Variable_status, METH_NOARGS, "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__Variable_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.Variable",                    /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_Variable_destructor_closure, /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__Variable_type.as_number,                /* tp_as_number */
    &SwigPyBuiltin__ampl__Variable_type.as_sequence,              /* tp_as_sequence */
    &SwigPyBuiltin__ampl__Variable_type.as_mapping,               /* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__Variable_type.as_buffer,                /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::Variable",                         /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__ampl__Variable_richcompare,/* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__Variable_methods,    /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__Variable_getset,     /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    SwigPyBuiltin_BadInit,                    /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__Variable_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__Variable_type};

static SwigPyGetSet Objective___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__Objective_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &Objective___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__Objective_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__Objective_methods[] = {
  { "value", _wrap_Objective_value, METH_NOARGS, "" },
  { "astatus", _wrap_Objective_astatus, METH_NOARGS, "" },
  { "sstatus", _wrap_Objective_sstatus, METH_NOARGS, "" },
  { "exitcode", _wrap_Objective_exitcode, METH_NOARGS, "" },
  { "message", _wrap_Objective_message, METH_NOARGS, "" },
  { "result", _wrap_Objective_result, METH_NOARGS, "" },
  { "drop", _wrap_Objective_drop, METH_NOARGS, "" },
  { "restore", _wrap_Objective_restore, METH_NOARGS, "" },
  { "minimization", _wrap_Objective_minimization, METH_NOARGS, "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__Objective_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.Objective",                   /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_Objective_destructor_closure,/* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__Objective_type.as_number,               /* tp_as_number */
    &SwigPyBuiltin__ampl__Objective_type.as_sequence,             /* tp_as_sequence */
    &SwigPyBuiltin__ampl__Objective_type.as_mapping,              /* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__Objective_type.as_buffer,               /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::Objective",                        /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__ampl__Objective_richcompare,                   /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__Objective_methods,   /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__Objective_getset,    /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    SwigPyBuiltin_BadInit,                    /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__Objective_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__Objective_type};

static SwigPyGetSet Set___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__Set_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &Set___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__Set_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__Set_methods[] = {
  { "arity", _wrap_Set_arity, METH_NOARGS, "" },
  { "getValues", _wrap_Set_getValues, METH_NOARGS, "" },
  { "size", _wrap_Set_size, METH_NOARGS, "" },
  { "members", _wrap_Set_members, METH_NOARGS, "" },
  { "setValuesDf", _wrap_Set_setValuesDf, METH_O, "" },
  { "contains", _wrap_Set_contains, METH_O, "" },
  { "setValuesTuples", _wrap_Set_setValuesTuples, METH_VARARGS, "" },
  { "setValues", _wrap_Set_setValues, METH_VARARGS, "" },
  { "setValuesDbl", _wrap_Set_setValuesDbl, METH_VARARGS, "" },
  { "setValuesStr", _wrap_Set_setValuesStr, METH_VARARGS, "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__Set_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.Set",                         /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_Set_destructor_closure,      /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__Set_type.as_number, /* tp_as_number */
    &SwigPyBuiltin__ampl__Set_type.as_sequence,                   /* tp_as_sequence */
    &SwigPyBuiltin__ampl__Set_type.as_mapping,/* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__Set_type.as_buffer, /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::Set",                              /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__ampl__Set_richcompare,     /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__Set_methods,         /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__Set_getset,          /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    SwigPyBuiltin_BadInit,                    /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__Set_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__Set_type};

static SwigPyGetSet Table___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__Table_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &Table___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__Table_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__Table_methods[] = {
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__Table_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.Table",                       /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_Table_destructor_closure,    /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__Table_type.as_number,                   /* tp_as_number */
    &SwigPyBuiltin__ampl__Table_type.as_sequence,                 /* tp_as_sequence */
    &SwigPyBuiltin__ampl__Table_type.as_mapping,                  /* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__Table_type.as_buffer,                   /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::Table",                            /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__ampl__Table_richcompare,   /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__Table_methods,       /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__Table_getset,        /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    SwigPyBuiltin_BadInit,                    /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__Table_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__Table_type};

static SwigPyGetSet Parameter___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__Parameter_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &Parameter___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__Parameter_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__Parameter_methods[] = {
  { "isSymbolic", _wrap_Parameter_isSymbolic, METH_NOARGS, "" },
  { "hasDefault", _wrap_Parameter_hasDefault, METH_NOARGS, "" },
  { "set", _wrap_Parameter_set, METH_VARARGS, "" },
  { "setTplDbl", _wrap_Parameter_setTplDbl, METH_VARARGS, "" },
  { "setTplStr", _wrap_Parameter_setTplStr, METH_VARARGS, "" },
  { "setValuesTaDbl", _wrap_Parameter_setValuesTaDbl, METH_VARARGS, "" },
  { "setValuesTupleArrayDbl", _wrap_Parameter_setValuesTupleArrayDbl, METH_VARARGS, "" },
  { "setValuesTaStr", _wrap_Parameter_setValuesTaStr, METH_VARARGS, "" },
  { "setValuesTupleArrayStr", _wrap_Parameter_setValuesTupleArrayStr, METH_VARARGS, "" },
  { "setValuesDbl", _wrap_Parameter_setValuesDbl, METH_VARARGS, "" },
  { "setValuesStr", _wrap_Parameter_setValuesStr, METH_VARARGS, "" },
  { "setValues", _wrap_Parameter_setValues, METH_VARARGS, "" },
  { "setValuesPyDict", _wrap_Parameter_setValuesPyDict, METH_O, "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__Parameter_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.Parameter",                   /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_Parameter_destructor_closure,/* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__Parameter_type.as_number,               /* tp_as_number */
    &SwigPyBuiltin__ampl__Parameter_type.as_sequence,             /* tp_as_sequence */
    &SwigPyBuiltin__ampl__Parameter_type.as_mapping,              /* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__Parameter_type.as_buffer,               /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::Parameter",                        /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__ampl__Parameter_richcompare,                   /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__Parameter_methods,   /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__Parameter_getset,    /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    SwigPyBuiltin_BadInit,                    /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__Parameter_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__Parameter_type};

static SwigPyGetSet VariableIteratorWrapper___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__VariableInstance_t_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &VariableIteratorWrapper___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__VariableInstance_t_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__VariableInstance_t_methods[] = {
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__VariableInstance_t_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.VariableIteratorWrapper",     /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_VariableIteratorWrapper_destructor_closure,      /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__VariableInstance_t_type.as_number,/* tp_as_number */
    &SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__VariableInstance_t_type.as_sequence,/* tp_as_sequence */
    &SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__VariableInstance_t_type.as_mapping,/* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__VariableInstance_t_type.as_buffer,/* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::internal::EntityWrapper< ampl::VariableInstance >",    /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__VariableInstance_t_richcompare,/* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__VariableInstance_t_methods,/* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__VariableInstance_t_getset,/* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    SwigPyBuiltin_BadInit,                    /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__VariableInstance_t_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__VariableInstance_t_type};

static SwigPyGetSet VariableIterator___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &VariableIterator___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  switch (op) {
    case Py_EQ : result = _wrap_VariableIterator_equals(self, other); break;
    case Py_NE : result = _wrap_VariableIterator_differs(self, other); break;
    default : break;
  }
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t_methods[] = {
  { "equals", _wrap_VariableIterator_equals, METH_O, "" },
  { "differs", _wrap_VariableIterator_differs, METH_O, "" },
  { "clone", _wrap_VariableIterator_clone, METH_O, "" },
  { "postIncrement", _wrap_VariableIterator_postIncrement, METH_NOARGS, "" },
  { "postIncrementBy", _wrap_VariableIterator_postIncrementBy, METH_O, "" },
  { "first", _wrap_VariableIterator_first, METH_NOARGS, "" },
  { "second", _wrap_VariableIterator_second, METH_NOARGS, "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.VariableIterator",            /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_VariableIterator_destructor_closure,             /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t_type.as_number,/* tp_as_number */
    &SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t_type.as_sequence,/* tp_as_sequence */
    &SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t_type.as_mapping,/* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t_type.as_buffer,/* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > >",/* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t_richcompare,/* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t_methods,/* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t_getset,/* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    SwigPyBuiltin_BadInit,                    /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t_type};

static SwigPyGetSet ConstraintIteratorWrapper___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &ConstraintIteratorWrapper___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_methods[] = {
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.ConstraintIteratorWrapper",   /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_ConstraintIteratorWrapper_destructor_closure,    /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_type.as_number,/* tp_as_number */
    &SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_type.as_sequence,/* tp_as_sequence */
    &SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_type.as_mapping,/* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_type.as_buffer,/* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::internal::EntityWrapper< ampl::ConstraintInstance >",  /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_richcompare,/* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_methods,/* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_getset,/* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    SwigPyBuiltin_BadInit,                    /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_type};

static SwigPyGetSet ConstraintIterator___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &ConstraintIterator___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  switch (op) {
    case Py_EQ : result = _wrap_ConstraintIterator_equals(self, other); break;
    case Py_NE : result = _wrap_ConstraintIterator_differs(self, other); break;
    default : break;
  }
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t_methods[] = {
  { "equals", _wrap_ConstraintIterator_equals, METH_O, "" },
  { "differs", _wrap_ConstraintIterator_differs, METH_O, "" },
  { "clone", _wrap_ConstraintIterator_clone, METH_O, "" },
  { "postIncrement", _wrap_ConstraintIterator_postIncrement, METH_NOARGS, "" },
  { "postIncrementBy", _wrap_ConstraintIterator_postIncrementBy, METH_O, "" },
  { "first", _wrap_ConstraintIterator_first, METH_NOARGS, "" },
  { "second", _wrap_ConstraintIterator_second, METH_NOARGS, "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.ConstraintIterator",          /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_ConstraintIterator_destructor_closure,           /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t_type.as_number,/* tp_as_number */
    &SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t_type.as_sequence,/* tp_as_sequence */
    &SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t_type.as_mapping,/* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t_type.as_buffer,/* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > >",/* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t_richcompare,/* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t_methods,/* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t_getset,/* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    SwigPyBuiltin_BadInit,                    /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t_type};

static SwigPyGetSet ObjectiveIteratorWrapper___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &ObjectiveIteratorWrapper___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_methods[] = {
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.ObjectiveIteratorWrapper",    /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_ObjectiveIteratorWrapper_destructor_closure,     /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_type.as_number,/* tp_as_number */
    &SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_type.as_sequence,/* tp_as_sequence */
    &SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_type.as_mapping,/* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_type.as_buffer,/* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::internal::EntityWrapper< ampl::ObjectiveInstance >",   /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_richcompare,/* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_methods,/* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_getset,/* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    SwigPyBuiltin_BadInit,                    /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_type};

static SwigPyGetSet ObjectiveIterator___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &ObjectiveIterator___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  switch (op) {
    case Py_EQ : result = _wrap_ObjectiveIterator_equals(self, other); break;
    case Py_NE : result = _wrap_ObjectiveIterator_differs(self, other); break;
    default : break;
  }
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t_methods[] = {
  { "equals", _wrap_ObjectiveIterator_equals, METH_O, "" },
  { "differs", _wrap_ObjectiveIterator_differs, METH_O, "" },
  { "clone", _wrap_ObjectiveIterator_clone, METH_O, "" },
  { "postIncrement", _wrap_ObjectiveIterator_postIncrement, METH_NOARGS, "" },
  { "postIncrementBy", _wrap_ObjectiveIterator_postIncrementBy, METH_O, "" },
  { "first", _wrap_ObjectiveIterator_first, METH_NOARGS, "" },
  { "second", _wrap_ObjectiveIterator_second, METH_NOARGS, "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.ObjectiveIterator",           /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_ObjectiveIterator_destructor_closure,            /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t_type.as_number,/* tp_as_number */
    &SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t_type.as_sequence,/* tp_as_sequence */
    &SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t_type.as_mapping,/* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t_type.as_buffer,/* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > >",/* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t_richcompare,/* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t_methods,/* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t_getset,/* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    SwigPyBuiltin_BadInit,                    /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t_type};

static SwigPyGetSet SetIteratorWrapper___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__SetInstance_t_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &SetIteratorWrapper___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__SetInstance_t_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__SetInstance_t_methods[] = {
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__SetInstance_t_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.SetIteratorWrapper",          /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_SetIteratorWrapper_destructor_closure,           /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__SetInstance_t_type.as_number,/* tp_as_number */
    &SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__SetInstance_t_type.as_sequence,/* tp_as_sequence */
    &SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__SetInstance_t_type.as_mapping,/* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__SetInstance_t_type.as_buffer,/* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::internal::EntityWrapper< ampl::SetInstance >",         /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__SetInstance_t_richcompare,/* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__SetInstance_t_methods,/* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__SetInstance_t_getset,/* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    SwigPyBuiltin_BadInit,                    /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__SetInstance_t_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__SetInstance_t_type};

static SwigPyGetSet SetIterator___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &SetIterator___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  switch (op) {
    case Py_EQ : result = _wrap_SetIterator_equals(self, other); break;
    case Py_NE : result = _wrap_SetIterator_differs(self, other); break;
    default : break;
  }
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t_methods[] = {
  { "equals", _wrap_SetIterator_equals, METH_O, "" },
  { "differs", _wrap_SetIterator_differs, METH_O, "" },
  { "clone", _wrap_SetIterator_clone, METH_O, "" },
  { "postIncrement", _wrap_SetIterator_postIncrement, METH_NOARGS, "" },
  { "postIncrementBy", _wrap_SetIterator_postIncrementBy, METH_O, "" },
  { "first", _wrap_SetIterator_first, METH_NOARGS, "" },
  { "second", _wrap_SetIterator_second, METH_NOARGS, "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.SetIterator",                 /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_SetIterator_destructor_closure,                  /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t_type.as_number,/* tp_as_number */
    &SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t_type.as_sequence,/* tp_as_sequence */
    &SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t_type.as_mapping,/* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t_type.as_buffer,/* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > >",/* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t_richcompare,/* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t_methods,/* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t_getset,/* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    SwigPyBuiltin_BadInit,                    /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t_type};

static SwigPyGetSet TableIteratorWrapper___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__TableInstance_t_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &TableIteratorWrapper___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__TableInstance_t_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__TableInstance_t_methods[] = {
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__TableInstance_t_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.TableIteratorWrapper",        /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_TableIteratorWrapper_destructor_closure,         /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__TableInstance_t_type.as_number,/* tp_as_number */
    &SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__TableInstance_t_type.as_sequence,/* tp_as_sequence */
    &SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__TableInstance_t_type.as_mapping,/* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__TableInstance_t_type.as_buffer,/* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::internal::EntityWrapper< ampl::TableInstance >",       /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__TableInstance_t_richcompare,/* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__TableInstance_t_methods,/* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__TableInstance_t_getset,/* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    SwigPyBuiltin_BadInit,                    /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__TableInstance_t_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__TableInstance_t_type};

static SwigPyGetSet TableIterator___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__TableInstance_t_t_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &TableIterator___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__TableInstance_t_t_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  switch (op) {
    case Py_EQ : result = _wrap_TableIterator_equals(self, other); break;
    case Py_NE : result = _wrap_TableIterator_differs(self, other); break;
    default : break;
  }
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__TableInstance_t_t_methods[] = {
  { "equals", _wrap_TableIterator_equals, METH_O, "" },
  { "differs", _wrap_TableIterator_differs, METH_O, "" },
  { "clone", _wrap_TableIterator_clone, METH_O, "" },
  { "postIncrement", _wrap_TableIterator_postIncrement, METH_NOARGS, "" },
  { "postIncrementBy", _wrap_TableIterator_postIncrementBy, METH_O, "" },
  { "first", _wrap_TableIterator_first, METH_NOARGS, "" },
  { "second", _wrap_TableIterator_second, METH_NOARGS, "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__TableInstance_t_t_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.TableIterator",               /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_TableIterator_destructor_closure,                /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__TableInstance_t_t_type.as_number,/* tp_as_number */
    &SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__TableInstance_t_t_type.as_sequence,/* tp_as_sequence */
    &SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__TableInstance_t_t_type.as_mapping,/* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__TableInstance_t_t_type.as_buffer,/* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::TableInstance > >",/* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__TableInstance_t_t_richcompare,/* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__TableInstance_t_t_methods,/* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__TableInstance_t_t_getset,/* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    SwigPyBuiltin_BadInit,                    /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__TableInstance_t_t_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__TableInstance_t_t_type};

static SwigPyGetSet ParameterIteratorWrapper___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__VariantRef_t_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &ParameterIteratorWrapper___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__VariantRef_t_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__VariantRef_t_methods[] = {
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__VariantRef_t_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.ParameterIteratorWrapper",    /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_ParameterIteratorWrapper_destructor_closure,     /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__VariantRef_t_type.as_number,/* tp_as_number */
    &SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__VariantRef_t_type.as_sequence,/* tp_as_sequence */
    &SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__VariantRef_t_type.as_mapping,/* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__VariantRef_t_type.as_buffer,/* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::internal::EntityWrapper< ampl::VariantRef >",          /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__VariantRef_t_richcompare,/* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__VariantRef_t_methods,/* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__VariantRef_t_getset,/* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    SwigPyBuiltin_BadInit,                    /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__VariantRef_t_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__VariantRef_t_type};

static SwigPyGetSet ParameterIterator___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &ParameterIterator___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  switch (op) {
    case Py_EQ : result = _wrap_ParameterIterator_equals(self, other); break;
    case Py_NE : result = _wrap_ParameterIterator_differs(self, other); break;
    default : break;
  }
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t_methods[] = {
  { "equals", _wrap_ParameterIterator_equals, METH_O, "" },
  { "differs", _wrap_ParameterIterator_differs, METH_O, "" },
  { "clone", _wrap_ParameterIterator_clone, METH_O, "" },
  { "postIncrement", _wrap_ParameterIterator_postIncrement, METH_NOARGS, "" },
  { "postIncrementBy", _wrap_ParameterIterator_postIncrementBy, METH_O, "" },
  { "first", _wrap_ParameterIterator_first, METH_NOARGS, "" },
  { "second", _wrap_ParameterIterator_second, METH_NOARGS, "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.ParameterIterator",           /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_ParameterIterator_destructor_closure,            /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t_type.as_number,/* tp_as_number */
    &SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t_type.as_sequence,/* tp_as_sequence */
    &SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t_type.as_mapping,/* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t_type.as_buffer,/* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > >",/* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t_richcompare,/* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t_methods,/* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t_getset,/* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    SwigPyBuiltin_BadInit,                    /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t_type};

static SwigPyGetSet EntityMapVariable___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__EntityMapT_ampl__Variable_t_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &EntityMapVariable___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__EntityMapT_ampl__Variable_t_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__EntityMapT_ampl__Variable_t_methods[] = {
  { "begin", _wrap_EntityMapVariable_begin, METH_NOARGS, "" },
  { "end", _wrap_EntityMapVariable_end, METH_NOARGS, "" },
  { "find", _wrap_EntityMapVariable_find, METH_O, "" },
  { "size", _wrap_EntityMapVariable_size, METH_NOARGS, "" },
  { "getIndex", _wrap_EntityMapVariable_getIndex, METH_O, "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__EntityMapT_ampl__Variable_t_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.EntityMapVariable",           /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_EntityMapVariable_destructor_closure,            /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Variable_t_type.as_number,/* tp_as_number */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Variable_t_type.as_sequence,/* tp_as_sequence */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Variable_t_type.as_mapping,/* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Variable_t_type.as_buffer,/* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::EntityMap< ampl::Variable >",      /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__ampl__EntityMapT_ampl__Variable_t_richcompare, /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__EntityMapT_ampl__Variable_t_methods,     /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__EntityMapT_ampl__Variable_t_getset,      /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    SwigPyBuiltin_BadInit,                    /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__EntityMapT_ampl__Variable_t_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__EntityMapT_ampl__Variable_t_type};

static SwigPyGetSet EntityMapVariableIterator___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__EntityMapT_ampl__Variable_t__iterator_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &EntityMapVariableIterator___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__EntityMapT_ampl__Variable_t__iterator_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  switch (op) {
    case Py_EQ : result = _wrap_EntityMapVariableIterator_equals(self, other); break;
    case Py_NE : result = _wrap_EntityMapVariableIterator_differs(self, other); break;
    default : break;
  }
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__EntityMapT_ampl__Variable_t__iterator_methods[] = {
  { "equals", _wrap_EntityMapVariableIterator_equals, METH_O, "" },
  { "differs", _wrap_EntityMapVariableIterator_differs, METH_O, "" },
  { "__ref__", _wrap_EntityMapVariableIterator___ref__, METH_NOARGS, "" },
  { "clone", _wrap_EntityMapVariableIterator_clone, METH_O, "" },
  { "postIncrement", _wrap_EntityMapVariableIterator_postIncrement, METH_NOARGS, "" },
  { "postIncrementBy", _wrap_EntityMapVariableIterator_postIncrementBy, METH_O, "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__EntityMapT_ampl__Variable_t__iterator_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.EntityMapVariableIterator",   /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_EntityMapVariableIterator_destructor_closure,    /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Variable_t__iterator_type.as_number,/* tp_as_number */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Variable_t__iterator_type.as_sequence,/* tp_as_sequence */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Variable_t__iterator_type.as_mapping,/* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Variable_t__iterator_type.as_buffer,/* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::EntityMap< ampl::Variable >::iterator",                /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__ampl__EntityMapT_ampl__Variable_t__iterator_richcompare,/* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__EntityMapT_ampl__Variable_t__iterator_methods,/* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__EntityMapT_ampl__Variable_t__iterator_getset,/* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    SwigPyBuiltin_BadInit,                    /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    _wrap_EntityMapVariableIterator___ref__,  /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__EntityMapT_ampl__Variable_t__iterator_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__EntityMapT_ampl__Variable_t__iterator_type};

static SwigPyGetSet EntityMapConstraint___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__EntityMapT_ampl__Constraint_t_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &EntityMapConstraint___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__EntityMapT_ampl__Constraint_t_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__EntityMapT_ampl__Constraint_t_methods[] = {
  { "begin", _wrap_EntityMapConstraint_begin, METH_NOARGS, "" },
  { "end", _wrap_EntityMapConstraint_end, METH_NOARGS, "" },
  { "find", _wrap_EntityMapConstraint_find, METH_O, "" },
  { "size", _wrap_EntityMapConstraint_size, METH_NOARGS, "" },
  { "getIndex", _wrap_EntityMapConstraint_getIndex, METH_O, "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__EntityMapT_ampl__Constraint_t_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.EntityMapConstraint",         /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_EntityMapConstraint_destructor_closure,          /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Constraint_t_type.as_number,/* tp_as_number */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Constraint_t_type.as_sequence,/* tp_as_sequence */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Constraint_t_type.as_mapping,/* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Constraint_t_type.as_buffer,/* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::EntityMap< ampl::Constraint >",    /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__ampl__EntityMapT_ampl__Constraint_t_richcompare,/* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__EntityMapT_ampl__Constraint_t_methods,   /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__EntityMapT_ampl__Constraint_t_getset,    /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    SwigPyBuiltin_BadInit,                    /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__EntityMapT_ampl__Constraint_t_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__EntityMapT_ampl__Constraint_t_type};

static SwigPyGetSet EntityMapConstraintIterator___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__EntityMapT_ampl__Constraint_t__iterator_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &EntityMapConstraintIterator___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__EntityMapT_ampl__Constraint_t__iterator_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  switch (op) {
    case Py_EQ : result = _wrap_EntityMapConstraintIterator_equals(self, other); break;
    case Py_NE : result = _wrap_EntityMapConstraintIterator_differs(self, other); break;
    default : break;
  }
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__EntityMapT_ampl__Constraint_t__iterator_methods[] = {
  { "equals", _wrap_EntityMapConstraintIterator_equals, METH_O, "" },
  { "differs", _wrap_EntityMapConstraintIterator_differs, METH_O, "" },
  { "__ref__", _wrap_EntityMapConstraintIterator___ref__, METH_NOARGS, "" },
  { "clone", _wrap_EntityMapConstraintIterator_clone, METH_O, "" },
  { "postIncrement", _wrap_EntityMapConstraintIterator_postIncrement, METH_NOARGS, "" },
  { "postIncrementBy", _wrap_EntityMapConstraintIterator_postIncrementBy, METH_O, "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__EntityMapT_ampl__Constraint_t__iterator_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.EntityMapConstraintIterator", /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_EntityMapConstraintIterator_destructor_closure,  /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Constraint_t__iterator_type.as_number,/* tp_as_number */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Constraint_t__iterator_type.as_sequence,/* tp_as_sequence */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Constraint_t__iterator_type.as_mapping,/* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Constraint_t__iterator_type.as_buffer,/* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::EntityMap< ampl::Constraint >::iterator",              /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__ampl__EntityMapT_ampl__Constraint_t__iterator_richcompare,/* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__EntityMapT_ampl__Constraint_t__iterator_methods,/* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__EntityMapT_ampl__Constraint_t__iterator_getset,/* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    SwigPyBuiltin_BadInit,                    /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    _wrap_EntityMapConstraintIterator___ref__,/* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__EntityMapT_ampl__Constraint_t__iterator_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__EntityMapT_ampl__Constraint_t__iterator_type};

static SwigPyGetSet EntityMapObjective___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__EntityMapT_ampl__Objective_t_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &EntityMapObjective___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__EntityMapT_ampl__Objective_t_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__EntityMapT_ampl__Objective_t_methods[] = {
  { "begin", _wrap_EntityMapObjective_begin, METH_NOARGS, "" },
  { "end", _wrap_EntityMapObjective_end, METH_NOARGS, "" },
  { "find", _wrap_EntityMapObjective_find, METH_O, "" },
  { "size", _wrap_EntityMapObjective_size, METH_NOARGS, "" },
  { "getIndex", _wrap_EntityMapObjective_getIndex, METH_O, "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__EntityMapT_ampl__Objective_t_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.EntityMapObjective",          /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_EntityMapObjective_destructor_closure,           /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Objective_t_type.as_number,/* tp_as_number */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Objective_t_type.as_sequence,/* tp_as_sequence */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Objective_t_type.as_mapping,/* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Objective_t_type.as_buffer,/* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::EntityMap< ampl::Objective >",     /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__ampl__EntityMapT_ampl__Objective_t_richcompare,/* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__EntityMapT_ampl__Objective_t_methods,    /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__EntityMapT_ampl__Objective_t_getset,     /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    SwigPyBuiltin_BadInit,                    /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__EntityMapT_ampl__Objective_t_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__EntityMapT_ampl__Objective_t_type};

static SwigPyGetSet EntityMapObjectiveIterator___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__EntityMapT_ampl__Objective_t__iterator_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &EntityMapObjectiveIterator___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__EntityMapT_ampl__Objective_t__iterator_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  switch (op) {
    case Py_EQ : result = _wrap_EntityMapObjectiveIterator_equals(self, other); break;
    case Py_NE : result = _wrap_EntityMapObjectiveIterator_differs(self, other); break;
    default : break;
  }
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__EntityMapT_ampl__Objective_t__iterator_methods[] = {
  { "equals", _wrap_EntityMapObjectiveIterator_equals, METH_O, "" },
  { "differs", _wrap_EntityMapObjectiveIterator_differs, METH_O, "" },
  { "__ref__", _wrap_EntityMapObjectiveIterator___ref__, METH_NOARGS, "" },
  { "clone", _wrap_EntityMapObjectiveIterator_clone, METH_O, "" },
  { "postIncrement", _wrap_EntityMapObjectiveIterator_postIncrement, METH_NOARGS, "" },
  { "postIncrementBy", _wrap_EntityMapObjectiveIterator_postIncrementBy, METH_O, "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__EntityMapT_ampl__Objective_t__iterator_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.EntityMapObjectiveIterator",  /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_EntityMapObjectiveIterator_destructor_closure,   /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Objective_t__iterator_type.as_number,/* tp_as_number */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Objective_t__iterator_type.as_sequence,/* tp_as_sequence */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Objective_t__iterator_type.as_mapping,/* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Objective_t__iterator_type.as_buffer,/* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::EntityMap< ampl::Objective >::iterator",               /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__ampl__EntityMapT_ampl__Objective_t__iterator_richcompare,/* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__EntityMapT_ampl__Objective_t__iterator_methods,/* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__EntityMapT_ampl__Objective_t__iterator_getset,/* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    SwigPyBuiltin_BadInit,                    /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    _wrap_EntityMapObjectiveIterator___ref__, /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__EntityMapT_ampl__Objective_t__iterator_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__EntityMapT_ampl__Objective_t__iterator_type};

static SwigPyGetSet EntityMapSet___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__EntityMapT_ampl__Set_t_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &EntityMapSet___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__EntityMapT_ampl__Set_t_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__EntityMapT_ampl__Set_t_methods[] = {
  { "begin", _wrap_EntityMapSet_begin, METH_NOARGS, "" },
  { "end", _wrap_EntityMapSet_end, METH_NOARGS, "" },
  { "find", _wrap_EntityMapSet_find, METH_O, "" },
  { "size", _wrap_EntityMapSet_size, METH_NOARGS, "" },
  { "getIndex", _wrap_EntityMapSet_getIndex, METH_O, "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__EntityMapT_ampl__Set_t_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.EntityMapSet",                /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_EntityMapSet_destructor_closure,                 /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Set_t_type.as_number,  /* tp_as_number */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Set_t_type.as_sequence,/* tp_as_sequence */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Set_t_type.as_mapping, /* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Set_t_type.as_buffer,  /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::EntityMap< ampl::Set >",           /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__ampl__EntityMapT_ampl__Set_t_richcompare,      /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__EntityMapT_ampl__Set_t_methods,          /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__EntityMapT_ampl__Set_t_getset,           /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    SwigPyBuiltin_BadInit,                    /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__EntityMapT_ampl__Set_t_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__EntityMapT_ampl__Set_t_type};

static SwigPyGetSet EntityMapSetIterator___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__EntityMapT_ampl__Set_t__iterator_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &EntityMapSetIterator___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__EntityMapT_ampl__Set_t__iterator_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  switch (op) {
    case Py_EQ : result = _wrap_EntityMapSetIterator_equals(self, other); break;
    case Py_NE : result = _wrap_EntityMapSetIterator_differs(self, other); break;
    default : break;
  }
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__EntityMapT_ampl__Set_t__iterator_methods[] = {
  { "equals", _wrap_EntityMapSetIterator_equals, METH_O, "" },
  { "differs", _wrap_EntityMapSetIterator_differs, METH_O, "" },
  { "__ref__", _wrap_EntityMapSetIterator___ref__, METH_NOARGS, "" },
  { "clone", _wrap_EntityMapSetIterator_clone, METH_O, "" },
  { "postIncrement", _wrap_EntityMapSetIterator_postIncrement, METH_NOARGS, "" },
  { "postIncrementBy", _wrap_EntityMapSetIterator_postIncrementBy, METH_O, "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__EntityMapT_ampl__Set_t__iterator_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.EntityMapSetIterator",        /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_EntityMapSetIterator_destructor_closure,         /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Set_t__iterator_type.as_number,/* tp_as_number */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Set_t__iterator_type.as_sequence,/* tp_as_sequence */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Set_t__iterator_type.as_mapping,/* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Set_t__iterator_type.as_buffer,/* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::EntityMap< ampl::Set >::iterator", /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__ampl__EntityMapT_ampl__Set_t__iterator_richcompare,/* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__EntityMapT_ampl__Set_t__iterator_methods,/* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__EntityMapT_ampl__Set_t__iterator_getset, /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    SwigPyBuiltin_BadInit,                    /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    _wrap_EntityMapSetIterator___ref__,       /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__EntityMapT_ampl__Set_t__iterator_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__EntityMapT_ampl__Set_t__iterator_type};

static SwigPyGetSet EntityMapTable___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__EntityMapT_ampl__Table_t_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &EntityMapTable___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__EntityMapT_ampl__Table_t_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__EntityMapT_ampl__Table_t_methods[] = {
  { "begin", _wrap_EntityMapTable_begin, METH_NOARGS, "" },
  { "end", _wrap_EntityMapTable_end, METH_NOARGS, "" },
  { "find", _wrap_EntityMapTable_find, METH_O, "" },
  { "size", _wrap_EntityMapTable_size, METH_NOARGS, "" },
  { "getIndex", _wrap_EntityMapTable_getIndex, METH_O, "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__EntityMapT_ampl__Table_t_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.EntityMapTable",              /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_EntityMapTable_destructor_closure,               /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Table_t_type.as_number,/* tp_as_number */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Table_t_type.as_sequence,/* tp_as_sequence */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Table_t_type.as_mapping,/* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Table_t_type.as_buffer,/* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::EntityMap< ampl::Table >",         /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__ampl__EntityMapT_ampl__Table_t_richcompare,    /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__EntityMapT_ampl__Table_t_methods,        /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__EntityMapT_ampl__Table_t_getset,         /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    SwigPyBuiltin_BadInit,                    /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__EntityMapT_ampl__Table_t_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__EntityMapT_ampl__Table_t_type};

static SwigPyGetSet EntityMapTableIterator___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__EntityMapT_ampl__Table_t__iterator_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &EntityMapTableIterator___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__EntityMapT_ampl__Table_t__iterator_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  switch (op) {
    case Py_EQ : result = _wrap_EntityMapTableIterator_equals(self, other); break;
    case Py_NE : result = _wrap_EntityMapTableIterator_differs(self, other); break;
    default : break;
  }
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__EntityMapT_ampl__Table_t__iterator_methods[] = {
  { "equals", _wrap_EntityMapTableIterator_equals, METH_O, "" },
  { "differs", _wrap_EntityMapTableIterator_differs, METH_O, "" },
  { "__ref__", _wrap_EntityMapTableIterator___ref__, METH_NOARGS, "" },
  { "clone", _wrap_EntityMapTableIterator_clone, METH_O, "" },
  { "postIncrement", _wrap_EntityMapTableIterator_postIncrement, METH_NOARGS, "" },
  { "postIncrementBy", _wrap_EntityMapTableIterator_postIncrementBy, METH_O, "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__EntityMapT_ampl__Table_t__iterator_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.EntityMapTableIterator",      /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_EntityMapTableIterator_destructor_closure,       /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Table_t__iterator_type.as_number,/* tp_as_number */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Table_t__iterator_type.as_sequence,/* tp_as_sequence */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Table_t__iterator_type.as_mapping,/* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Table_t__iterator_type.as_buffer,/* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::EntityMap< ampl::Table >::iterator",                   /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__ampl__EntityMapT_ampl__Table_t__iterator_richcompare,/* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__EntityMapT_ampl__Table_t__iterator_methods,/* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__EntityMapT_ampl__Table_t__iterator_getset,/* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    SwigPyBuiltin_BadInit,                    /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    _wrap_EntityMapTableIterator___ref__,     /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__EntityMapT_ampl__Table_t__iterator_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__EntityMapT_ampl__Table_t__iterator_type};

static SwigPyGetSet EntityMapParameter___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__EntityMapT_ampl__Parameter_t_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &EntityMapParameter___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__EntityMapT_ampl__Parameter_t_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__EntityMapT_ampl__Parameter_t_methods[] = {
  { "begin", _wrap_EntityMapParameter_begin, METH_NOARGS, "" },
  { "end", _wrap_EntityMapParameter_end, METH_NOARGS, "" },
  { "find", _wrap_EntityMapParameter_find, METH_O, "" },
  { "size", _wrap_EntityMapParameter_size, METH_NOARGS, "" },
  { "getIndex", _wrap_EntityMapParameter_getIndex, METH_O, "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__EntityMapT_ampl__Parameter_t_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.EntityMapParameter",          /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_EntityMapParameter_destructor_closure,           /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Parameter_t_type.as_number,/* tp_as_number */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Parameter_t_type.as_sequence,/* tp_as_sequence */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Parameter_t_type.as_mapping,/* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Parameter_t_type.as_buffer,/* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::EntityMap< ampl::Parameter >",     /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__ampl__EntityMapT_ampl__Parameter_t_richcompare,/* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__EntityMapT_ampl__Parameter_t_methods,    /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__EntityMapT_ampl__Parameter_t_getset,     /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    SwigPyBuiltin_BadInit,                    /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__EntityMapT_ampl__Parameter_t_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__EntityMapT_ampl__Parameter_t_type};

static SwigPyGetSet EntityMapParameterIterator___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__EntityMapT_ampl__Parameter_t__iterator_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &EntityMapParameterIterator___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__EntityMapT_ampl__Parameter_t__iterator_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  switch (op) {
    case Py_EQ : result = _wrap_EntityMapParameterIterator_equals(self, other); break;
    case Py_NE : result = _wrap_EntityMapParameterIterator_differs(self, other); break;
    default : break;
  }
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__EntityMapT_ampl__Parameter_t__iterator_methods[] = {
  { "equals", _wrap_EntityMapParameterIterator_equals, METH_O, "" },
  { "differs", _wrap_EntityMapParameterIterator_differs, METH_O, "" },
  { "__ref__", _wrap_EntityMapParameterIterator___ref__, METH_NOARGS, "" },
  { "clone", _wrap_EntityMapParameterIterator_clone, METH_O, "" },
  { "postIncrement", _wrap_EntityMapParameterIterator_postIncrement, METH_NOARGS, "" },
  { "postIncrementBy", _wrap_EntityMapParameterIterator_postIncrementBy, METH_O, "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__EntityMapT_ampl__Parameter_t__iterator_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.EntityMapParameterIterator",  /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_EntityMapParameterIterator_destructor_closure,   /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Parameter_t__iterator_type.as_number,/* tp_as_number */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Parameter_t__iterator_type.as_sequence,/* tp_as_sequence */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Parameter_t__iterator_type.as_mapping,/* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Parameter_t__iterator_type.as_buffer,/* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::EntityMap< ampl::Parameter >::iterator",               /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__ampl__EntityMapT_ampl__Parameter_t__iterator_richcompare,/* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__EntityMapT_ampl__Parameter_t__iterator_methods,/* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__EntityMapT_ampl__Parameter_t__iterator_getset,/* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    SwigPyBuiltin_BadInit,                    /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    _wrap_EntityMapParameterIterator___ref__, /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__EntityMapT_ampl__Parameter_t__iterator_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__EntityMapT_ampl__Parameter_t__iterator_type};

static SwigPyGetSet AMPLException___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__AMPLException_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &AMPLException___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__AMPLException_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__AMPLException_methods[] = {
  { "getSourceName", _wrap_AMPLException_getSourceName, METH_NOARGS, "" },
  { "getLineNumber", _wrap_AMPLException_getLineNumber, METH_NOARGS, "" },
  { "getOffset", _wrap_AMPLException_getOffset, METH_NOARGS, "" },
  { "getMessage", _wrap_AMPLException_getMessage, METH_NOARGS, "" },
  { "setSourceName", _wrap_AMPLException_setSourceName, METH_O, "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__AMPLException_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.AMPLException",               /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_AMPLException_destructor_closure,                /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__AMPLException_type.as_number,           /* tp_as_number */
    &SwigPyBuiltin__ampl__AMPLException_type.as_sequence,         /* tp_as_sequence */
    &SwigPyBuiltin__ampl__AMPLException_type.as_mapping,          /* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__AMPLException_type.as_buffer,           /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::AMPLException",                    /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__ampl__AMPLException_richcompare,               /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__AMPLException_methods,                   /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__AMPLException_getset,/* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    _wrap_new_AMPLException,                  /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__AMPLException_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__AMPLException_type};

static SwigPyGetSet LicenseException___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__LicenseException_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &LicenseException___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__LicenseException_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__LicenseException_methods[] = {
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__LicenseException_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.LicenseException",            /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_LicenseException_destructor_closure,             /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__LicenseException_type.as_number,        /* tp_as_number */
    &SwigPyBuiltin__ampl__LicenseException_type.as_sequence,      /* tp_as_sequence */
    &SwigPyBuiltin__ampl__LicenseException_type.as_mapping,       /* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__LicenseException_type.as_buffer,        /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::LicenseException",                 /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__ampl__LicenseException_richcompare,            /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__LicenseException_methods,                /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__LicenseException_getset,                 /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    _wrap_new_LicenseException,               /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__LicenseException_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__LicenseException_type};

static SwigPyGetSet FileIOException___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__FileIOException_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &FileIOException___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__FileIOException_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__FileIOException_methods[] = {
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__FileIOException_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.FileIOException",             /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_FileIOException_destructor_closure,              /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__FileIOException_type.as_number,         /* tp_as_number */
    &SwigPyBuiltin__ampl__FileIOException_type.as_sequence,       /* tp_as_sequence */
    &SwigPyBuiltin__ampl__FileIOException_type.as_mapping,        /* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__FileIOException_type.as_buffer,         /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::FileIOException",                  /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__ampl__FileIOException_richcompare,             /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__FileIOException_methods,                 /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__FileIOException_getset,                  /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    _wrap_new_FileIOException,                /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__FileIOException_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__FileIOException_type};

static SwigPyGetSet UnsupportedOperationException___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__UnsupportedOperationException_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &UnsupportedOperationException___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__UnsupportedOperationException_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__UnsupportedOperationException_methods[] = {
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__UnsupportedOperationException_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.UnsupportedOperationException",                   /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_UnsupportedOperationException_destructor_closure,/* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__UnsupportedOperationException_type.as_number,/* tp_as_number */
    &SwigPyBuiltin__ampl__UnsupportedOperationException_type.as_sequence,/* tp_as_sequence */
    &SwigPyBuiltin__ampl__UnsupportedOperationException_type.as_mapping,/* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__UnsupportedOperationException_type.as_buffer,/* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::UnsupportedOperationException",    /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__ampl__UnsupportedOperationException_richcompare,/* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__UnsupportedOperationException_methods,   /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__UnsupportedOperationException_getset,    /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    _wrap_new_UnsupportedOperationException,  /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__UnsupportedOperationException_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__UnsupportedOperationException_type};

static SwigPyGetSet InvalidSubscriptException___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__InvalidSubscriptException_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &InvalidSubscriptException___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__InvalidSubscriptException_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__InvalidSubscriptException_methods[] = {
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__InvalidSubscriptException_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.InvalidSubscriptException",   /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_InvalidSubscriptException_destructor_closure,    /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__InvalidSubscriptException_type.as_number,/* tp_as_number */
    &SwigPyBuiltin__ampl__InvalidSubscriptException_type.as_sequence,/* tp_as_sequence */
    &SwigPyBuiltin__ampl__InvalidSubscriptException_type.as_mapping,/* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__InvalidSubscriptException_type.as_buffer,/* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::InvalidSubscriptException",        /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__ampl__InvalidSubscriptException_richcompare,   /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__InvalidSubscriptException_methods,       /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__InvalidSubscriptException_getset,        /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    _wrap_new_InvalidSubscriptException,      /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__InvalidSubscriptException_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__InvalidSubscriptException_type};

static SwigPyGetSet SyntaxErrorException___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__SyntaxErrorException_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &SyntaxErrorException___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__SyntaxErrorException_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__SyntaxErrorException_methods[] = {
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__SyntaxErrorException_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.SyntaxErrorException",        /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_SyntaxErrorException_destructor_closure,         /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__SyntaxErrorException_type.as_number,    /* tp_as_number */
    &SwigPyBuiltin__ampl__SyntaxErrorException_type.as_sequence,  /* tp_as_sequence */
    &SwigPyBuiltin__ampl__SyntaxErrorException_type.as_mapping,   /* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__SyntaxErrorException_type.as_buffer,    /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::SyntaxErrorException",             /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__ampl__SyntaxErrorException_richcompare,        /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__SyntaxErrorException_methods,            /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__SyntaxErrorException_getset,             /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    _wrap_new_SyntaxErrorException,           /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__SyntaxErrorException_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__SyntaxErrorException_type};

static SwigPyGetSet NoDataException___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__NoDataException_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &NoDataException___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__NoDataException_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__NoDataException_methods[] = {
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__NoDataException_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.NoDataException",             /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_NoDataException_destructor_closure,              /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__NoDataException_type.as_number,         /* tp_as_number */
    &SwigPyBuiltin__ampl__NoDataException_type.as_sequence,       /* tp_as_sequence */
    &SwigPyBuiltin__ampl__NoDataException_type.as_mapping,        /* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__NoDataException_type.as_buffer,         /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::NoDataException",                  /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__ampl__NoDataException_richcompare,             /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__NoDataException_methods,                 /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__NoDataException_getset,                  /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    _wrap_new_NoDataException,                /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__NoDataException_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__NoDataException_type};

static SwigPyGetSet ErrorHandler___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__ErrorHandler_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &ErrorHandler___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__ErrorHandler_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__ErrorHandler_methods[] = {
  { "error", _wrap_ErrorHandler_error, METH_O, "" },
  { "warning", _wrap_ErrorHandler_warning, METH_O, "" },
  { "__disown__", Swig::Director::swig_pyobj_disown< ampl::ErrorHandler >, METH_NOARGS, "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__ErrorHandler_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.ErrorHandler",                /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_ErrorHandler_destructor_closure,                 /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__ErrorHandler_type.as_number,            /* tp_as_number */
    &SwigPyBuiltin__ampl__ErrorHandler_type.as_sequence,          /* tp_as_sequence */
    &SwigPyBuiltin__ampl__ErrorHandler_type.as_mapping,           /* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__ErrorHandler_type.as_buffer,            /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::ErrorHandler",                     /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__ampl__ErrorHandler_richcompare,                /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__ErrorHandler_methods,/* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__ErrorHandler_getset, /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    _wrap_new_ErrorHandler,                   /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__ErrorHandler_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__ErrorHandler_type};

static SwigPyGetSet Runnable___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__Runnable_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &Runnable___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__Runnable_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__Runnable_methods[] = {
  { "run", _wrap_Runnable_run, METH_NOARGS, "" },
  { "__disown__", Swig::Director::swig_pyobj_disown< ampl::Runnable >, METH_NOARGS, "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__Runnable_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.Runnable",                    /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_Runnable_destructor_closure, /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__Runnable_type.as_number,                /* tp_as_number */
    &SwigPyBuiltin__ampl__Runnable_type.as_sequence,              /* tp_as_sequence */
    &SwigPyBuiltin__ampl__Runnable_type.as_mapping,               /* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__Runnable_type.as_buffer,                /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::Runnable",                         /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__ampl__Runnable_richcompare,/* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__Runnable_methods,    /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__Runnable_getset,     /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    _wrap_new_Runnable,                       /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__Runnable_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__Runnable_type};

static SwigPyGetSet OutputHandler___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__OutputHandler_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &OutputHandler___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__OutputHandler_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__OutputHandler_methods[] = {
  { "output", _wrap_OutputHandler_output, METH_VARARGS, "" },
  { "__disown__", Swig::Director::swig_pyobj_disown< ampl::OutputHandler >, METH_NOARGS, "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__OutputHandler_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.OutputHandler",               /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_OutputHandler_destructor_closure,                /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__OutputHandler_type.as_number,           /* tp_as_number */
    &SwigPyBuiltin__ampl__OutputHandler_type.as_sequence,         /* tp_as_sequence */
    &SwigPyBuiltin__ampl__OutputHandler_type.as_mapping,          /* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__OutputHandler_type.as_buffer,           /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::OutputHandler",                    /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__ampl__OutputHandler_richcompare,               /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__OutputHandler_methods,                   /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__OutputHandler_getset,/* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    _wrap_new_OutputHandler,                  /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__OutputHandler_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__OutputHandler_type};

static SwigPyGetSet EnvironmentIterator___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__internal__EnvironmentIterator_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &EnvironmentIterator___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__internal__EnvironmentIterator_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__internal__EnvironmentIterator_methods[] = {
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__internal__EnvironmentIterator_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.EnvironmentIterator",         /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_EnvironmentIterator_destructor_closure,          /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__internal__EnvironmentIterator_type.as_number,/* tp_as_number */
    &SwigPyBuiltin__ampl__internal__EnvironmentIterator_type.as_sequence,/* tp_as_sequence */
    &SwigPyBuiltin__ampl__internal__EnvironmentIterator_type.as_mapping,/* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__internal__EnvironmentIterator_type.as_buffer,/* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::internal::EnvironmentIterator",    /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__ampl__internal__EnvironmentIterator_richcompare,/* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__internal__EnvironmentIterator_methods,   /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__internal__EnvironmentIterator_getset,    /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    _wrap_new_EnvironmentIterator,            /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__internal__EnvironmentIterator_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__internal__EnvironmentIterator_type};

static SwigPyGetSet Environment___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__Environment_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &Environment___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__Environment_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__Environment_methods[] = {
  { "Clone", _wrap_Environment_Clone, METH_O, "" },
  { "put", _wrap_Environment_put, METH_VARARGS, "" },
  { "setBinDir", _wrap_Environment_setBinDir, METH_O, "" },
  { "getBinDir", _wrap_Environment_getBinDir, METH_NOARGS, "" },
  { "setBinName", _wrap_Environment_setBinName, METH_O, "" },
  { "getBinName", _wrap_Environment_getBinName, METH_NOARGS, "" },
  { "toString", _wrap_Environment_toString, METH_NOARGS, "" },
  { "begin", _wrap_Environment_begin, METH_NOARGS, "" },
  { "end", _wrap_Environment_end, METH_NOARGS, "" },
  { "find", _wrap_Environment_find, METH_O, "" },
  { "size", _wrap_Environment_size, METH_NOARGS, "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__Environment_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.Environment",                 /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_Environment_destructor_closure,                  /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__Environment_type.as_number,             /* tp_as_number */
    &SwigPyBuiltin__ampl__Environment_type.as_sequence,           /* tp_as_sequence */
    &SwigPyBuiltin__ampl__Environment_type.as_mapping,            /* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__Environment_type.as_buffer,             /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::Environment",                      /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__ampl__Environment_richcompare,                 /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__Environment_methods, /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__Environment_getset,  /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    _wrap_new_Environment,                    /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__Environment_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__Environment_type};

static SwigPyGetSet EnvironmentIteratorTemplate___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &EnvironmentIteratorTemplate___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  switch (op) {
    case Py_EQ : result = _wrap_EnvironmentIteratorTemplate_equals(self, other); break;
    case Py_NE : result = _wrap_EnvironmentIteratorTemplate_differs(self, other); break;
    default : break;
  }
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t_methods[] = {
  { "equals", _wrap_EnvironmentIteratorTemplate_equals, METH_O, "" },
  { "differs", _wrap_EnvironmentIteratorTemplate_differs, METH_O, "" },
  { "Clone", _wrap_EnvironmentIteratorTemplate_Clone, METH_O, "" },
  { "postIncrement", _wrap_EnvironmentIteratorTemplate_postIncrement, METH_NOARGS, "" },
  { "postIncrementBy", _wrap_EnvironmentIteratorTemplate_postIncrementBy, METH_O, "" },
  { "first", _wrap_EnvironmentIteratorTemplate_first, METH_NOARGS, "" },
  { "second", _wrap_EnvironmentIteratorTemplate_second, METH_NOARGS, "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.EnvironmentIteratorTemplate", /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_EnvironmentIteratorTemplate_destructor_closure,  /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t_type.as_number,/* tp_as_number */
    &SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t_type.as_sequence,/* tp_as_sequence */
    &SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t_type.as_mapping,/* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t_type.as_buffer,/* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator >",/* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t_richcompare,/* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t_methods,/* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t_getset,/* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    SwigPyBuiltin_BadInit,                    /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t_type};

static SwigPyGetSet AMPL___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__AMPL_getset[] = {
    { (char *)"__dict__", SwigPyBuiltin_FunpackGetterClosure, 0, (char *)"", &AMPL___dict___getset },
    { NULL, NULL, NULL, NULL, NULL } /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__AMPL_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__AMPL_methods[] = {
  { "exportData", _wrap_AMPL_exportData, METH_VARARGS, "" },
  { "exportModel", _wrap_AMPL_exportModel, METH_VARARGS, "" },
  { "getEntity", _wrap_AMPL_getEntity, METH_O, "" },
  { "getVariable", _wrap_AMPL_getVariable, METH_O, "" },
  { "getConstraint", _wrap_AMPL_getConstraint, METH_O, "" },
  { "getObjective", _wrap_AMPL_getObjective, METH_O, "" },
  { "getSet", _wrap_AMPL_getSet, METH_O, "" },
  { "getParameter", _wrap_AMPL_getParameter, METH_O, "" },
  { "getTable", _wrap_AMPL_getTable, METH_O, "" },
  { "eval", _wrap_AMPL_eval, METH_O, "" },
  { "reset", _wrap_AMPL_reset, METH_NOARGS, "" },
  { "close", _wrap_AMPL_close, METH_NOARGS, "" },
  { "isRunning", _wrap_AMPL_isRunning, METH_NOARGS, "" },
  { "isBusy", _wrap_AMPL_isBusy, METH_NOARGS, "" },
  { "solve", _wrap_AMPL_solve, METH_NOARGS, "" },
  { "readAsync", _wrap_AMPL_readAsync, METH_VARARGS, "" },
  { "readDataAsync", _wrap_AMPL_readDataAsync, METH_VARARGS, "" },
  { "evalAsync", _wrap_AMPL_evalAsync, METH_VARARGS, "" },
  { "solveAsync", _wrap_AMPL_solveAsync, METH_O, "" },
  { "interrupt", _wrap_AMPL_interrupt, METH_NOARGS, "" },
  { "cd", _wrap_AMPL_cd, METH_VARARGS, "" },
  { "setOption", _wrap_AMPL_setOption, METH_VARARGS, "" },
  { "getOption", _wrap_AMPL_getOption, METH_O, "" },
  { "getIntOption", _wrap_AMPL_getIntOption, METH_O, "" },
  { "setIntOption", _wrap_AMPL_setIntOption, METH_VARARGS, "" },
  { "getDblOption", _wrap_AMPL_getDblOption, METH_O, "" },
  { "setDblOption", _wrap_AMPL_setDblOption, METH_VARARGS, "" },
  { "getBoolOption", _wrap_AMPL_getBoolOption, METH_O, "" },
  { "getCurrentObjectiveName", _wrap_AMPL_getCurrentObjectiveName, METH_NOARGS, "" },
  { "setBoolOption", _wrap_AMPL_setBoolOption, METH_VARARGS, "" },
  { "read", _wrap_AMPL_read, METH_O, "" },
  { "readData", _wrap_AMPL_readData, METH_O, "" },
  { "getValue", _wrap_AMPL_getValue, METH_O, "" },
  { "getOutput", _wrap_AMPL_getOutput, METH_O, "" },
  { "setData", _wrap_AMPL_setData, METH_VARARGS, "" },
  { "toString", _wrap_AMPL_toString, METH_NOARGS, "" },
  { "readTable", _wrap_AMPL_readTable, METH_O, "" },
  { "writeTable", _wrap_AMPL_writeTable, METH_O, "" },
  { "display", _wrap_AMPL_display, METH_O, "" },
  { "show", _wrap_AMPL_show, METH_O, "" },
  { "expand", _wrap_AMPL_expand, METH_O, "" },
  { "setOutputHandler", _wrap_AMPL_setOutputHandler, METH_O, "" },
  { "setErrorHandler", _wrap_AMPL_setErrorHandler, METH_O, "" },
  { "getOutputHandler", _wrap_AMPL_getOutputHandler, METH_NOARGS, "" },
  { "getErrorHandler", _wrap_AMPL_getErrorHandler, METH_NOARGS, "" },
  { "getVariables", _wrap_AMPL_getVariables, METH_NOARGS, "" },
  { "getConstraints", _wrap_AMPL_getConstraints, METH_NOARGS, "" },
  { "getObjectives", _wrap_AMPL_getObjectives, METH_NOARGS, "" },
  { "getSets", _wrap_AMPL_getSets, METH_NOARGS, "" },
  { "getParameters", _wrap_AMPL_getParameters, METH_NOARGS, "" },
  { "getTables", _wrap_AMPL_getTables, METH_NOARGS, "" },
  { "displayLst", _wrap_AMPL_displayLst, METH_VARARGS, "" },
  { "getData", _wrap_AMPL_getData, METH_VARARGS, "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__AMPL_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.AMPL",                        /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    _wrap_delete_AMPL_destructor_closure,     /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__AMPL_type.as_number,/* tp_as_number */
    &SwigPyBuiltin__ampl__AMPL_type.as_sequence,                  /* tp_as_sequence */
    &SwigPyBuiltin__ampl__AMPL_type.as_mapping,                   /* tp_as_mapping */
    SwigPyObject_hash,                        /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__AMPL_type.as_buffer,/* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::AMPL",                             /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    SwigPyBuiltin__ampl__AMPL_richcompare,    /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__AMPL_methods,        /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__AMPL_getset,         /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    offsetof(SwigPyObject, dict),             /* tp_dictoffset */
    _wrap_new_AMPL,                           /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
    (int) 0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
    (vectorcallfunc) 0,                       /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
    0,                                        /* tp_print */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
    0,                                        /* tp_prev */
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
    (unaryfunc) 0,                            /* nb_index */
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__AMPL_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__AMPL_type};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

static void *_p_VariantArrayTo_p_ampl__Variant(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ampl::Variant *)  ((VariantArray *) x));
}
static void *_p_ampl__TableTo_p_ampl__BasicEntityT_ampl__TableInstance_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ampl::BasicEntity< ampl::TableInstance > *)  ((ampl::Table *) x));
}
static void *_p_ampl__SetTo_p_ampl__BasicEntityT_ampl__SetInstance_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ampl::BasicEntity< ampl::SetInstance > *)  ((ampl::Set *) x));
}
static void *_p_ampl__ObjectiveTo_p_ampl__BasicEntityT_ampl__ObjectiveInstance_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ampl::BasicEntity< ampl::ObjectiveInstance > *)  ((ampl::Objective *) x));
}
static void *_p_ampl__VariableTo_p_ampl__BasicEntityT_ampl__VariableInstance_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ampl::BasicEntity< ampl::VariableInstance > *)  ((ampl::Variable *) x));
}
static void *_p_ampl__ConstraintTo_p_ampl__BasicEntityT_ampl__ConstraintInstance_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ampl::BasicEntity< ampl::ConstraintInstance > *)  ((ampl::Constraint *) x));
}
static void *_p_ampl__SetTo_p_ampl__Entity(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ampl::Entity *) (ampl::BasicEntity< ampl::SetInstance > *) ((ampl::Set *) x));
}
static void *_p_EntityArrayTo_p_ampl__Entity(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ampl::Entity *)  ((EntityArray *) x));
}
static void *_p_ampl__ConstraintTo_p_ampl__Entity(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ampl::Entity *) (ampl::BasicEntity< ampl::ConstraintInstance > *) ((ampl::Constraint *) x));
}
static void *_p_ampl__VariableTo_p_ampl__Entity(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ampl::Entity *) (ampl::BasicEntity< ampl::VariableInstance > *) ((ampl::Variable *) x));
}
static void *_p_ampl__ParameterTo_p_ampl__Entity(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ampl::Entity *) (ampl::BasicEntity< ampl::VariantRef > *) ((ampl::Parameter *) x));
}
static void *_p_ampl__BasicEntityT_ampl__VariableInstance_tTo_p_ampl__Entity(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ampl::Entity *)  ((ampl::BasicEntity< ampl::VariableInstance > *) x));
}
static void *_p_ampl__BasicEntityT_ampl__ConstraintInstance_tTo_p_ampl__Entity(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ampl::Entity *)  ((ampl::BasicEntity< ampl::ConstraintInstance > *) x));
}
static void *_p_ampl__BasicEntityT_ampl__SetInstance_tTo_p_ampl__Entity(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ampl::Entity *)  ((ampl::BasicEntity< ampl::SetInstance > *) x));
}
static void *_p_ampl__BasicEntityT_ampl__ObjectiveInstance_tTo_p_ampl__Entity(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ampl::Entity *)  ((ampl::BasicEntity< ampl::ObjectiveInstance > *) x));
}
static void *_p_ampl__BasicEntityT_ampl__VariantRef_tTo_p_ampl__Entity(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ampl::Entity *)  ((ampl::BasicEntity< ampl::VariantRef > *) x));
}
static void *_p_ampl__BasicEntityT_ampl__TableInstance_tTo_p_ampl__Entity(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ampl::Entity *)  ((ampl::BasicEntity< ampl::TableInstance > *) x));
}
static void *_p_ampl__ObjectiveTo_p_ampl__Entity(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ampl::Entity *) (ampl::BasicEntity< ampl::ObjectiveInstance > *) ((ampl::Objective *) x));
}
static void *_p_ampl__TableTo_p_ampl__Entity(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ampl::Entity *) (ampl::BasicEntity< ampl::TableInstance > *) ((ampl::Table *) x));
}
static void *_p_ampl__InvalidSubscriptExceptionTo_p_ampl__AMPLException(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ampl::AMPLException *)  ((ampl::InvalidSubscriptException *) x));
}
static void *_p_ampl__SyntaxErrorExceptionTo_p_ampl__AMPLException(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ampl::AMPLException *)  ((ampl::SyntaxErrorException *) x));
}
static void *_p_ampl__AMPLExceptionTo_p_std__runtime_error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::runtime_error *)  ((ampl::AMPLException *) x));
}
static void *_p_ampl__LicenseExceptionTo_p_std__runtime_error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::runtime_error *)  ((ampl::LicenseException *) x));
}
static void *_p_ampl__FileIOExceptionTo_p_std__runtime_error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::runtime_error *)  ((ampl::FileIOException *) x));
}
static void *_p_ampl__UnsupportedOperationExceptionTo_p_std__runtime_error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::runtime_error *)  ((ampl::UnsupportedOperationException *) x));
}
static void *_p_ampl__InvalidSubscriptExceptionTo_p_std__runtime_error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::runtime_error *) (ampl::AMPLException *) ((ampl::InvalidSubscriptException *) x));
}
static void *_p_ampl__SyntaxErrorExceptionTo_p_std__runtime_error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::runtime_error *) (ampl::AMPLException *) ((ampl::SyntaxErrorException *) x));
}
static void *_p_ampl__NoDataExceptionTo_p_std__runtime_error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::runtime_error *)  ((ampl::NoDataException *) x));
}
static void *_p_ampl__SetInstanceTo_p_ampl__Instance(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ampl::Instance *)  ((ampl::SetInstance *) x));
}
static void *_p_ampl__ObjectiveInstanceTo_p_ampl__Instance(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ampl::Instance *)  ((ampl::ObjectiveInstance *) x));
}
static void *_p_ampl__VariableInstanceTo_p_ampl__Instance(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ampl::Instance *)  ((ampl::VariableInstance *) x));
}
static void *_p_ampl__ConstraintInstanceTo_p_ampl__Instance(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ampl::Instance *)  ((ampl::ConstraintInstance *) x));
}
static void *_p_ampl__TableInstanceTo_p_ampl__Instance(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ampl::Instance *)  ((ampl::TableInstance *) x));
}
static void *_p_TupleArrayTo_p_ampl__Tuple(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ampl::Tuple *)  ((TupleArray *) x));
}
static void *_p_ampl__ParameterTo_p_ampl__BasicEntityT_ampl__VariantRef_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ampl::BasicEntity< ampl::VariantRef > *)  ((ampl::Parameter *) x));
}
static swig_type_info _swigt__p_Column = {"_p_Column", "Column *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_EntityArray = {"_p_EntityArray", "EntityArray *", 0, 0, (void*)&SwigPyBuiltin__EntityArray_clientdata, 0};
static swig_type_info _swigt__p_InstanceType = {"_p_InstanceType", "InstanceType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_KeyType = {"_p_KeyType", "KeyType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Row = {"_p_Row", "Row *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SwigPyObject = {"_p_SwigPyObject", "SwigPyObject *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_TupleArray = {"_p_TupleArray", "TupleArray *", 0, 0, (void*)&SwigPyBuiltin__TupleArray_clientdata, 0};
static swig_type_info _swigt__p_ValueType = {"_p_ValueType", "ValueType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_VariantArray = {"_p_VariantArray", "VariantArray *", 0, 0, (void*)&SwigPyBuiltin__VariantArray_clientdata, 0};
static swig_type_info _swigt__p_ampl__AMPL = {"_p_ampl__AMPL", "ampl::AMPL *", 0, 0, (void*)&SwigPyBuiltin__ampl__AMPL_clientdata, 0};
static swig_type_info _swigt__p_ampl__AMPLException = {"_p_ampl__AMPLException", "ampl::AMPLException *", 0, 0, (void*)&SwigPyBuiltin__ampl__AMPLException_clientdata, 0};
static swig_type_info _swigt__p_ampl__BasicEntityT_ampl__ConstraintInstance_t = {"_p_ampl__BasicEntityT_ampl__ConstraintInstance_t", "ampl::BasicEntity< ampl::ConstraintInstance > *", 0, 0, (void*)&SwigPyBuiltin__ampl__BasicEntityT_ampl__ConstraintInstance_t_clientdata, 0};
static swig_type_info _swigt__p_ampl__BasicEntityT_ampl__ObjectiveInstance_t = {"_p_ampl__BasicEntityT_ampl__ObjectiveInstance_t", "ampl::BasicEntity< ampl::ObjectiveInstance > *", 0, 0, (void*)&SwigPyBuiltin__ampl__BasicEntityT_ampl__ObjectiveInstance_t_clientdata, 0};
static swig_type_info _swigt__p_ampl__BasicEntityT_ampl__SetInstance_t = {"_p_ampl__BasicEntityT_ampl__SetInstance_t", "ampl::BasicEntity< ampl::SetInstance > *", 0, 0, (void*)&SwigPyBuiltin__ampl__BasicEntityT_ampl__SetInstance_t_clientdata, 0};
static swig_type_info _swigt__p_ampl__BasicEntityT_ampl__TableInstance_t = {"_p_ampl__BasicEntityT_ampl__TableInstance_t", "ampl::BasicEntity< ampl::TableInstance > *", 0, 0, (void*)&SwigPyBuiltin__ampl__BasicEntityT_ampl__TableInstance_t_clientdata, 0};
static swig_type_info _swigt__p_ampl__BasicEntityT_ampl__VariableInstance_t = {"_p_ampl__BasicEntityT_ampl__VariableInstance_t", "ampl::BasicEntity< ampl::VariableInstance > *", 0, 0, (void*)&SwigPyBuiltin__ampl__BasicEntityT_ampl__VariableInstance_t_clientdata, 0};
static swig_type_info _swigt__p_ampl__BasicEntityT_ampl__VariantRef_t = {"_p_ampl__BasicEntityT_ampl__VariantRef_t", "ampl::BasicEntity< ampl::VariantRef > *", 0, 0, (void*)&SwigPyBuiltin__ampl__BasicEntityT_ampl__VariantRef_t_clientdata, 0};
static swig_type_info _swigt__p_ampl__Constraint = {"_p_ampl__Constraint", "ampl::Constraint *", 0, 0, (void*)&SwigPyBuiltin__ampl__Constraint_clientdata, 0};
static swig_type_info _swigt__p_ampl__ConstraintInstance = {"_p_ampl__ConstraintInstance", "ampl::internal::EntityWrapper< ampl::ConstraintInstance >::InstanceType *|ampl::ConstraintInstance *", 0, 0, (void*)&SwigPyBuiltin__ampl__ConstraintInstance_clientdata, 0};
static swig_type_info _swigt__p_ampl__DataFrame = {"_p_ampl__DataFrame", "ampl::DataFrame *|ampl::internal::DataFrame *", 0, 0, (void*)&SwigPyBuiltin__ampl__DataFrame_clientdata, 0};
static swig_type_info _swigt__p_ampl__Entity = {"_p_ampl__Entity", "ampl::Entity *", 0, 0, (void*)&SwigPyBuiltin__ampl__Entity_clientdata, 0};
static swig_type_info _swigt__p_ampl__EntityArgs = {"_p_ampl__EntityArgs", "ampl::EntityArgs *", 0, 0, (void*)&SwigPyBuiltin__ampl__EntityArgs_clientdata, 0};
static swig_type_info _swigt__p_ampl__EntityMapT_ampl__Constraint_t = {"_p_ampl__EntityMapT_ampl__Constraint_t", "ampl::EntityMap< ampl::Constraint > *", 0, 0, (void*)&SwigPyBuiltin__ampl__EntityMapT_ampl__Constraint_t_clientdata, 0};
static swig_type_info _swigt__p_ampl__EntityMapT_ampl__Constraint_t__iterator = {"_p_ampl__EntityMapT_ampl__Constraint_t__iterator", "ampl::EntityMap< ampl::Constraint >::iterator *", 0, 0, (void*)&SwigPyBuiltin__ampl__EntityMapT_ampl__Constraint_t__iterator_clientdata, 0};
static swig_type_info _swigt__p_ampl__EntityMapT_ampl__Objective_t = {"_p_ampl__EntityMapT_ampl__Objective_t", "ampl::EntityMap< ampl::Objective > *", 0, 0, (void*)&SwigPyBuiltin__ampl__EntityMapT_ampl__Objective_t_clientdata, 0};
static swig_type_info _swigt__p_ampl__EntityMapT_ampl__Objective_t__iterator = {"_p_ampl__EntityMapT_ampl__Objective_t__iterator", "ampl::EntityMap< ampl::Objective >::iterator *", 0, 0, (void*)&SwigPyBuiltin__ampl__EntityMapT_ampl__Objective_t__iterator_clientdata, 0};
static swig_type_info _swigt__p_ampl__EntityMapT_ampl__Parameter_t = {"_p_ampl__EntityMapT_ampl__Parameter_t", "ampl::EntityMap< ampl::Parameter > *", 0, 0, (void*)&SwigPyBuiltin__ampl__EntityMapT_ampl__Parameter_t_clientdata, 0};
static swig_type_info _swigt__p_ampl__EntityMapT_ampl__Parameter_t__iterator = {"_p_ampl__EntityMapT_ampl__Parameter_t__iterator", "ampl::EntityMap< ampl::Parameter >::iterator *", 0, 0, (void*)&SwigPyBuiltin__ampl__EntityMapT_ampl__Parameter_t__iterator_clientdata, 0};
static swig_type_info _swigt__p_ampl__EntityMapT_ampl__Set_t = {"_p_ampl__EntityMapT_ampl__Set_t", "ampl::EntityMap< ampl::Set > *", 0, 0, (void*)&SwigPyBuiltin__ampl__EntityMapT_ampl__Set_t_clientdata, 0};
static swig_type_info _swigt__p_ampl__EntityMapT_ampl__Set_t__iterator = {"_p_ampl__EntityMapT_ampl__Set_t__iterator", "ampl::EntityMap< ampl::Set >::iterator *", 0, 0, (void*)&SwigPyBuiltin__ampl__EntityMapT_ampl__Set_t__iterator_clientdata, 0};
static swig_type_info _swigt__p_ampl__EntityMapT_ampl__Table_t = {"_p_ampl__EntityMapT_ampl__Table_t", "ampl::EntityMap< ampl::Table > *", 0, 0, (void*)&SwigPyBuiltin__ampl__EntityMapT_ampl__Table_t_clientdata, 0};
static swig_type_info _swigt__p_ampl__EntityMapT_ampl__Table_t__iterator = {"_p_ampl__EntityMapT_ampl__Table_t__iterator", "ampl::EntityMap< ampl::Table >::iterator *", 0, 0, (void*)&SwigPyBuiltin__ampl__EntityMapT_ampl__Table_t__iterator_clientdata, 0};
static swig_type_info _swigt__p_ampl__EntityMapT_ampl__Variable_t = {"_p_ampl__EntityMapT_ampl__Variable_t", "ampl::EntityMap< ampl::Variable > *", 0, 0, (void*)&SwigPyBuiltin__ampl__EntityMapT_ampl__Variable_t_clientdata, 0};
static swig_type_info _swigt__p_ampl__EntityMapT_ampl__Variable_t__iterator = {"_p_ampl__EntityMapT_ampl__Variable_t__iterator", "ampl::EntityMap< ampl::Variable >::iterator *", 0, 0, (void*)&SwigPyBuiltin__ampl__EntityMapT_ampl__Variable_t__iterator_clientdata, 0};
static swig_type_info _swigt__p_ampl__Environment = {"_p_ampl__Environment", "ampl::Environment *", 0, 0, (void*)&SwigPyBuiltin__ampl__Environment_clientdata, 0};
static swig_type_info _swigt__p_ampl__ErrorHandler = {"_p_ampl__ErrorHandler", "ampl::ErrorHandler *", 0, 0, (void*)&SwigPyBuiltin__ampl__ErrorHandler_clientdata, 0};
static swig_type_info _swigt__p_ampl__FileIOException = {"_p_ampl__FileIOException", "ampl::FileIOException *", 0, 0, (void*)&SwigPyBuiltin__ampl__FileIOException_clientdata, 0};
static swig_type_info _swigt__p_ampl__Instance = {"_p_ampl__Instance", "ampl::Instance *", 0, 0, (void*)&SwigPyBuiltin__ampl__Instance_clientdata, 0};
static swig_type_info _swigt__p_ampl__InvalidSubscriptException = {"_p_ampl__InvalidSubscriptException", "ampl::InvalidSubscriptException *", 0, 0, (void*)&SwigPyBuiltin__ampl__InvalidSubscriptException_clientdata, 0};
static swig_type_info _swigt__p_ampl__LicenseException = {"_p_ampl__LicenseException", "ampl::LicenseException *", 0, 0, (void*)&SwigPyBuiltin__ampl__LicenseException_clientdata, 0};
static swig_type_info _swigt__p_ampl__NoDataException = {"_p_ampl__NoDataException", "ampl::NoDataException *", 0, 0, (void*)&SwigPyBuiltin__ampl__NoDataException_clientdata, 0};
static swig_type_info _swigt__p_ampl__Objective = {"_p_ampl__Objective", "ampl::Objective *", 0, 0, (void*)&SwigPyBuiltin__ampl__Objective_clientdata, 0};
static swig_type_info _swigt__p_ampl__ObjectiveInstance = {"_p_ampl__ObjectiveInstance", "ampl::internal::EntityWrapper< ampl::ObjectiveInstance >::InstanceType *|ampl::ObjectiveInstance *", 0, 0, (void*)&SwigPyBuiltin__ampl__ObjectiveInstance_clientdata, 0};
static swig_type_info _swigt__p_ampl__OptionalT_bool_t = {"_p_ampl__OptionalT_bool_t", "ampl::Optional< bool > *", 0, 0, (void*)&SwigPyBuiltin__ampl__OptionalT_bool_t_clientdata, 0};
static swig_type_info _swigt__p_ampl__OptionalT_double_t = {"_p_ampl__OptionalT_double_t", "ampl::Optional< double > *", 0, 0, (void*)&SwigPyBuiltin__ampl__OptionalT_double_t_clientdata, 0};
static swig_type_info _swigt__p_ampl__OptionalT_int_t = {"_p_ampl__OptionalT_int_t", "ampl::Optional< int > *", 0, 0, (void*)&SwigPyBuiltin__ampl__OptionalT_int_t_clientdata, 0};
static swig_type_info _swigt__p_ampl__OptionalT_std__string_t = {"_p_ampl__OptionalT_std__string_t", "ampl::Optional< std::string > *", 0, 0, (void*)&SwigPyBuiltin__ampl__OptionalT_std__string_t_clientdata, 0};
static swig_type_info _swigt__p_ampl__OutputHandler = {"_p_ampl__OutputHandler", "ampl::OutputHandler *", 0, 0, (void*)&SwigPyBuiltin__ampl__OutputHandler_clientdata, 0};
static swig_type_info _swigt__p_ampl__Parameter = {"_p_ampl__Parameter", "ampl::Parameter *", 0, 0, (void*)&SwigPyBuiltin__ampl__Parameter_clientdata, 0};
static swig_type_info _swigt__p_ampl__Runnable = {"_p_ampl__Runnable", "ampl::Runnable *", 0, 0, (void*)&SwigPyBuiltin__ampl__Runnable_clientdata, 0};
static swig_type_info _swigt__p_ampl__Set = {"_p_ampl__Set", "ampl::Set *", 0, 0, (void*)&SwigPyBuiltin__ampl__Set_clientdata, 0};
static swig_type_info _swigt__p_ampl__SetInstance = {"_p_ampl__SetInstance", "ampl::internal::EntityWrapper< ampl::SetInstance >::InstanceType *|ampl::SetInstance *|ampl::internal::SetInstance *", 0, 0, (void*)&SwigPyBuiltin__ampl__SetInstance_clientdata, 0};
static swig_type_info _swigt__p_ampl__SetInstance__MemberRange = {"_p_ampl__SetInstance__MemberRange", "ampl::SetInstance::MemberRange *", 0, 0, (void*)&SwigPyBuiltin__ampl__SetInstance__MemberRange_clientdata, 0};
static swig_type_info _swigt__p_ampl__SetInstance__MemberRange__iterator = {"_p_ampl__SetInstance__MemberRange__iterator", "ampl::SetInstance::MemberRange::iterator *", 0, 0, (void*)&SwigPyBuiltin__ampl__SetInstance__MemberRange__iterator_clientdata, 0};
static swig_type_info _swigt__p_ampl__StringArray = {"_p_ampl__StringArray", "ampl::StringArray *", 0, 0, (void*)&SwigPyBuiltin__ampl__StringArray_clientdata, 0};
static swig_type_info _swigt__p_ampl__StringRefArray = {"_p_ampl__StringRefArray", "ampl::StringRefArray *", 0, 0, (void*)&SwigPyBuiltin__ampl__StringRefArray_clientdata, 0};
static swig_type_info _swigt__p_ampl__SyntaxErrorException = {"_p_ampl__SyntaxErrorException", "ampl::SyntaxErrorException *", 0, 0, (void*)&SwigPyBuiltin__ampl__SyntaxErrorException_clientdata, 0};
static swig_type_info _swigt__p_ampl__Table = {"_p_ampl__Table", "ampl::Table *", 0, 0, (void*)&SwigPyBuiltin__ampl__Table_clientdata, 0};
static swig_type_info _swigt__p_ampl__TableInstance = {"_p_ampl__TableInstance", "ampl::internal::EntityWrapper< ampl::TableInstance >::InstanceType *|ampl::TableInstance *", 0, 0, (void*)&SwigPyBuiltin__ampl__TableInstance_clientdata, 0};
static swig_type_info _swigt__p_ampl__Tuple = {"_p_ampl__Tuple", "ampl::Tuple *", 0, 0, (void*)&SwigPyBuiltin__ampl__Tuple_clientdata, 0};
static swig_type_info _swigt__p_ampl__TupleRef = {"_p_ampl__TupleRef", "ampl::TupleRef *", 0, 0, (void*)&SwigPyBuiltin__ampl__TupleRef_clientdata, 0};
static swig_type_info _swigt__p_ampl__UnsupportedOperationException = {"_p_ampl__UnsupportedOperationException", "ampl::UnsupportedOperationException *", 0, 0, (void*)&SwigPyBuiltin__ampl__UnsupportedOperationException_clientdata, 0};
static swig_type_info _swigt__p_ampl__Variable = {"_p_ampl__Variable", "ampl::Variable *", 0, 0, (void*)&SwigPyBuiltin__ampl__Variable_clientdata, 0};
static swig_type_info _swigt__p_ampl__VariableInstance = {"_p_ampl__VariableInstance", "ampl::internal::EntityWrapper< ampl::VariableInstance >::InstanceType *|ampl::VariableInstance *", 0, 0, (void*)&SwigPyBuiltin__ampl__VariableInstance_clientdata, 0};
static swig_type_info _swigt__p_ampl__Variant = {"_p_ampl__Variant", "ampl::Variant *", 0, 0, (void*)&SwigPyBuiltin__ampl__Variant_clientdata, 0};
static swig_type_info _swigt__p_ampl__VariantRef = {"_p_ampl__VariantRef", "ampl::VariantRef *", 0, 0, (void*)&SwigPyBuiltin__ampl__VariantRef_clientdata, 0};
static swig_type_info _swigt__p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t = {"_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t", "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > *|ampl::BasicEntity< ampl::ConstraintInstance >::iterator *", 0, 0, (void*)&SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t_clientdata, 0};
static swig_type_info _swigt__p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t = {"_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t", "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > *|ampl::BasicEntity< ampl::ObjectiveInstance >::iterator *", 0, 0, (void*)&SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t_clientdata, 0};
static swig_type_info _swigt__p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t = {"_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t", "ampl::BasicEntity< ampl::SetInstance >::iterator *|ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > *", 0, 0, (void*)&SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t_clientdata, 0};
static swig_type_info _swigt__p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__TableInstance_t_t = {"_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__TableInstance_t_t", "ampl::BasicEntity< ampl::TableInstance >::iterator *|ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::TableInstance > > *", 0, 0, (void*)&SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__TableInstance_t_t_clientdata, 0};
static swig_type_info _swigt__p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t = {"_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t", "ampl::BasicEntity< ampl::VariableInstance >::iterator *|ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > *", 0, 0, (void*)&SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t_clientdata, 0};
static swig_type_info _swigt__p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t = {"_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t", "ampl::BasicEntity< ampl::VariantRef >::iterator *|ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > *", 0, 0, (void*)&SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t_clientdata, 0};
static swig_type_info _swigt__p_ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t = {"_p_ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t", "ampl::Environment::iterator *|ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > *", 0, 0, (void*)&SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t_clientdata, 0};
static swig_type_info _swigt__p_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t = {"_p_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t", "ampl::internal::EntityWrapper< ampl::ConstraintInstance > *", 0, 0, (void*)&SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_clientdata, 0};
static swig_type_info _swigt__p_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t = {"_p_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t", "ampl::internal::EntityWrapper< ampl::ObjectiveInstance > *", 0, 0, (void*)&SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_clientdata, 0};
static swig_type_info _swigt__p_ampl__internal__EntityWrapperT_ampl__SetInstance_t = {"_p_ampl__internal__EntityWrapperT_ampl__SetInstance_t", "ampl::internal::EntityWrapper< ampl::SetInstance > *", 0, 0, (void*)&SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__SetInstance_t_clientdata, 0};
static swig_type_info _swigt__p_ampl__internal__EntityWrapperT_ampl__TableInstance_t = {"_p_ampl__internal__EntityWrapperT_ampl__TableInstance_t", "ampl::internal::EntityWrapper< ampl::TableInstance > *", 0, 0, (void*)&SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__TableInstance_t_clientdata, 0};
static swig_type_info _swigt__p_ampl__internal__EntityWrapperT_ampl__VariableInstance_t = {"_p_ampl__internal__EntityWrapperT_ampl__VariableInstance_t", "ampl::internal::EntityWrapper< ampl::VariableInstance > *", 0, 0, (void*)&SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__VariableInstance_t_clientdata, 0};
static swig_type_info _swigt__p_ampl__internal__EntityWrapperT_ampl__VariantRef_t = {"_p_ampl__internal__EntityWrapperT_ampl__VariantRef_t", "ampl::internal::EntityWrapper< ampl::VariantRef > *", 0, 0, (void*)&SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__VariantRef_t_clientdata, 0};
static swig_type_info _swigt__p_ampl__internal__EnvironmentIterator = {"_p_ampl__internal__EnvironmentIterator", "ampl::internal::EnvironmentIterator *", 0, 0, (void*)&SwigPyBuiltin__ampl__internal__EnvironmentIterator_clientdata, 0};
static swig_type_info _swigt__p_ampl__internal__SliceT_false_t = {"_p_ampl__internal__SliceT_false_t", "ampl::DataFrame::Column *|ampl::internal::Slice< false > *", 0, 0, (void*)&SwigPyBuiltin__ampl__internal__SliceT_false_t_clientdata, 0};
static swig_type_info _swigt__p_ampl__internal__SliceT_false_t__iterator = {"_p_ampl__internal__SliceT_false_t__iterator", "ampl::internal::Slice< false >::iterator *", 0, 0, (void*)&SwigPyBuiltin__ampl__internal__SliceT_false_t__iterator_clientdata, 0};
static swig_type_info _swigt__p_ampl__internal__SliceT_true_t = {"_p_ampl__internal__SliceT_true_t", "ampl::internal::Slice< true > *|ampl::DataFrame::Row *", 0, 0, (void*)&SwigPyBuiltin__ampl__internal__SliceT_true_t_clientdata, 0};
static swig_type_info _swigt__p_ampl__internal__SliceT_true_t__iterator = {"_p_ampl__internal__SliceT_true_t__iterator", "ampl::internal::Slice< true >::iterator *", 0, 0, (void*)&SwigPyBuiltin__ampl__internal__SliceT_true_t__iterator_clientdata, 0};
static swig_type_info _swigt__p_char = {"_p_char", "char *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_double = {"_p_double", "double *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_iterator = {"_p_iterator", "iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_char = {"_p_p_char", "char **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__runtime_error = {"_p_std__runtime_error", "std::runtime_error *", 0, 0, (void*)&SwigPyBuiltin__std__runtime_error_clientdata, 0};

static swig_type_info *swig_type_initial[] = {
  &_swigt__p_Column,
  &_swigt__p_EntityArray,
  &_swigt__p_InstanceType,
  &_swigt__p_KeyType,
  &_swigt__p_Row,
  &_swigt__p_SwigPyObject,
  &_swigt__p_TupleArray,
  &_swigt__p_ValueType,
  &_swigt__p_VariantArray,
  &_swigt__p_ampl__AMPL,
  &_swigt__p_ampl__AMPLException,
  &_swigt__p_ampl__BasicEntityT_ampl__ConstraintInstance_t,
  &_swigt__p_ampl__BasicEntityT_ampl__ObjectiveInstance_t,
  &_swigt__p_ampl__BasicEntityT_ampl__SetInstance_t,
  &_swigt__p_ampl__BasicEntityT_ampl__TableInstance_t,
  &_swigt__p_ampl__BasicEntityT_ampl__VariableInstance_t,
  &_swigt__p_ampl__BasicEntityT_ampl__VariantRef_t,
  &_swigt__p_ampl__Constraint,
  &_swigt__p_ampl__ConstraintInstance,
  &_swigt__p_ampl__DataFrame,
  &_swigt__p_ampl__Entity,
  &_swigt__p_ampl__EntityArgs,
  &_swigt__p_ampl__EntityMapT_ampl__Constraint_t,
  &_swigt__p_ampl__EntityMapT_ampl__Constraint_t__iterator,
  &_swigt__p_ampl__EntityMapT_ampl__Objective_t,
  &_swigt__p_ampl__EntityMapT_ampl__Objective_t__iterator,
  &_swigt__p_ampl__EntityMapT_ampl__Parameter_t,
  &_swigt__p_ampl__EntityMapT_ampl__Parameter_t__iterator,
  &_swigt__p_ampl__EntityMapT_ampl__Set_t,
  &_swigt__p_ampl__EntityMapT_ampl__Set_t__iterator,
  &_swigt__p_ampl__EntityMapT_ampl__Table_t,
  &_swigt__p_ampl__EntityMapT_ampl__Table_t__iterator,
  &_swigt__p_ampl__EntityMapT_ampl__Variable_t,
  &_swigt__p_ampl__EntityMapT_ampl__Variable_t__iterator,
  &_swigt__p_ampl__Environment,
  &_swigt__p_ampl__ErrorHandler,
  &_swigt__p_ampl__FileIOException,
  &_swigt__p_ampl__Instance,
  &_swigt__p_ampl__InvalidSubscriptException,
  &_swigt__p_ampl__LicenseException,
  &_swigt__p_ampl__NoDataException,
  &_swigt__p_ampl__Objective,
  &_swigt__p_ampl__ObjectiveInstance,
  &_swigt__p_ampl__OptionalT_bool_t,
  &_swigt__p_ampl__OptionalT_double_t,
  &_swigt__p_ampl__OptionalT_int_t,
  &_swigt__p_ampl__OptionalT_std__string_t,
  &_swigt__p_ampl__OutputHandler,
  &_swigt__p_ampl__Parameter,
  &_swigt__p_ampl__Runnable,
  &_swigt__p_ampl__Set,
  &_swigt__p_ampl__SetInstance,
  &_swigt__p_ampl__SetInstance__MemberRange,
  &_swigt__p_ampl__SetInstance__MemberRange__iterator,
  &_swigt__p_ampl__StringArray,
  &_swigt__p_ampl__StringRefArray,
  &_swigt__p_ampl__SyntaxErrorException,
  &_swigt__p_ampl__Table,
  &_swigt__p_ampl__TableInstance,
  &_swigt__p_ampl__Tuple,
  &_swigt__p_ampl__TupleRef,
  &_swigt__p_ampl__UnsupportedOperationException,
  &_swigt__p_ampl__Variable,
  &_swigt__p_ampl__VariableInstance,
  &_swigt__p_ampl__Variant,
  &_swigt__p_ampl__VariantRef,
  &_swigt__p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t,
  &_swigt__p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t,
  &_swigt__p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t,
  &_swigt__p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__TableInstance_t_t,
  &_swigt__p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t,
  &_swigt__p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t,
  &_swigt__p_ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t,
  &_swigt__p_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t,
  &_swigt__p_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t,
  &_swigt__p_ampl__internal__EntityWrapperT_ampl__SetInstance_t,
  &_swigt__p_ampl__internal__EntityWrapperT_ampl__TableInstance_t,
  &_swigt__p_ampl__internal__EntityWrapperT_ampl__VariableInstance_t,
  &_swigt__p_ampl__internal__EntityWrapperT_ampl__VariantRef_t,
  &_swigt__p_ampl__internal__EnvironmentIterator,
  &_swigt__p_ampl__internal__SliceT_false_t,
  &_swigt__p_ampl__internal__SliceT_false_t__iterator,
  &_swigt__p_ampl__internal__SliceT_true_t,
  &_swigt__p_ampl__internal__SliceT_true_t__iterator,
  &_swigt__p_char,
  &_swigt__p_double,
  &_swigt__p_iterator,
  &_swigt__p_p_char,
  &_swigt__p_std__runtime_error,
};

static swig_cast_info _swigc__p_Column[] = {  {&_swigt__p_Column, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_EntityArray[] = {  {&_swigt__p_EntityArray, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_InstanceType[] = {  {&_swigt__p_InstanceType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_KeyType[] = {  {&_swigt__p_KeyType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Row[] = {  {&_swigt__p_Row, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SwigPyObject[] = {  {&_swigt__p_SwigPyObject, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_TupleArray[] = {  {&_swigt__p_TupleArray, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ValueType[] = {  {&_swigt__p_ValueType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_VariantArray[] = {  {&_swigt__p_VariantArray, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__AMPL[] = {  {&_swigt__p_ampl__AMPL, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__AMPLException[] = {  {&_swigt__p_ampl__AMPLException, 0, 0, 0},  {&_swigt__p_ampl__InvalidSubscriptException, _p_ampl__InvalidSubscriptExceptionTo_p_ampl__AMPLException, 0, 0},  {&_swigt__p_ampl__SyntaxErrorException, _p_ampl__SyntaxErrorExceptionTo_p_ampl__AMPLException, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__BasicEntityT_ampl__ConstraintInstance_t[] = {  {&_swigt__p_ampl__BasicEntityT_ampl__ConstraintInstance_t, 0, 0, 0},  {&_swigt__p_ampl__Constraint, _p_ampl__ConstraintTo_p_ampl__BasicEntityT_ampl__ConstraintInstance_t, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__BasicEntityT_ampl__ObjectiveInstance_t[] = {  {&_swigt__p_ampl__BasicEntityT_ampl__ObjectiveInstance_t, 0, 0, 0},  {&_swigt__p_ampl__Objective, _p_ampl__ObjectiveTo_p_ampl__BasicEntityT_ampl__ObjectiveInstance_t, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__BasicEntityT_ampl__SetInstance_t[] = {  {&_swigt__p_ampl__BasicEntityT_ampl__SetInstance_t, 0, 0, 0},  {&_swigt__p_ampl__Set, _p_ampl__SetTo_p_ampl__BasicEntityT_ampl__SetInstance_t, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__BasicEntityT_ampl__TableInstance_t[] = {  {&_swigt__p_ampl__BasicEntityT_ampl__TableInstance_t, 0, 0, 0},  {&_swigt__p_ampl__Table, _p_ampl__TableTo_p_ampl__BasicEntityT_ampl__TableInstance_t, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__BasicEntityT_ampl__VariableInstance_t[] = {  {&_swigt__p_ampl__BasicEntityT_ampl__VariableInstance_t, 0, 0, 0},  {&_swigt__p_ampl__Variable, _p_ampl__VariableTo_p_ampl__BasicEntityT_ampl__VariableInstance_t, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__BasicEntityT_ampl__VariantRef_t[] = {  {&_swigt__p_ampl__BasicEntityT_ampl__VariantRef_t, 0, 0, 0},  {&_swigt__p_ampl__Parameter, _p_ampl__ParameterTo_p_ampl__BasicEntityT_ampl__VariantRef_t, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__Constraint[] = {  {&_swigt__p_ampl__Constraint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__ConstraintInstance[] = {  {&_swigt__p_ampl__ConstraintInstance, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__DataFrame[] = {  {&_swigt__p_ampl__DataFrame, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__Entity[] = {  {&_swigt__p_ampl__Parameter, _p_ampl__ParameterTo_p_ampl__Entity, 0, 0},  {&_swigt__p_ampl__BasicEntityT_ampl__VariableInstance_t, _p_ampl__BasicEntityT_ampl__VariableInstance_tTo_p_ampl__Entity, 0, 0},  {&_swigt__p_ampl__BasicEntityT_ampl__ConstraintInstance_t, _p_ampl__BasicEntityT_ampl__ConstraintInstance_tTo_p_ampl__Entity, 0, 0},  {&_swigt__p_ampl__BasicEntityT_ampl__SetInstance_t, _p_ampl__BasicEntityT_ampl__SetInstance_tTo_p_ampl__Entity, 0, 0},  {&_swigt__p_ampl__BasicEntityT_ampl__ObjectiveInstance_t, _p_ampl__BasicEntityT_ampl__ObjectiveInstance_tTo_p_ampl__Entity, 0, 0},  {&_swigt__p_ampl__BasicEntityT_ampl__TableInstance_t, _p_ampl__BasicEntityT_ampl__TableInstance_tTo_p_ampl__Entity, 0, 0},  {&_swigt__p_ampl__Set, _p_ampl__SetTo_p_ampl__Entity, 0, 0},  {&_swigt__p_ampl__BasicEntityT_ampl__VariantRef_t, _p_ampl__BasicEntityT_ampl__VariantRef_tTo_p_ampl__Entity, 0, 0},  {&_swigt__p_ampl__Entity, 0, 0, 0},  {&_swigt__p_ampl__Table, _p_ampl__TableTo_p_ampl__Entity, 0, 0},  {&_swigt__p_ampl__Variable, _p_ampl__VariableTo_p_ampl__Entity, 0, 0},  {&_swigt__p_ampl__Constraint, _p_ampl__ConstraintTo_p_ampl__Entity, 0, 0},  {&_swigt__p_ampl__Objective, _p_ampl__ObjectiveTo_p_ampl__Entity, 0, 0},  {&_swigt__p_EntityArray, _p_EntityArrayTo_p_ampl__Entity, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__EntityArgs[] = {  {&_swigt__p_ampl__EntityArgs, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__EntityMapT_ampl__Constraint_t[] = {  {&_swigt__p_ampl__EntityMapT_ampl__Constraint_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__EntityMapT_ampl__Constraint_t__iterator[] = {  {&_swigt__p_ampl__EntityMapT_ampl__Constraint_t__iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__EntityMapT_ampl__Objective_t[] = {  {&_swigt__p_ampl__EntityMapT_ampl__Objective_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__EntityMapT_ampl__Objective_t__iterator[] = {  {&_swigt__p_ampl__EntityMapT_ampl__Objective_t__iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__EntityMapT_ampl__Parameter_t[] = {  {&_swigt__p_ampl__EntityMapT_ampl__Parameter_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__EntityMapT_ampl__Parameter_t__iterator[] = {  {&_swigt__p_ampl__EntityMapT_ampl__Parameter_t__iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__EntityMapT_ampl__Set_t[] = {  {&_swigt__p_ampl__EntityMapT_ampl__Set_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__EntityMapT_ampl__Set_t__iterator[] = {  {&_swigt__p_ampl__EntityMapT_ampl__Set_t__iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__EntityMapT_ampl__Table_t[] = {  {&_swigt__p_ampl__EntityMapT_ampl__Table_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__EntityMapT_ampl__Table_t__iterator[] = {  {&_swigt__p_ampl__EntityMapT_ampl__Table_t__iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__EntityMapT_ampl__Variable_t[] = {  {&_swigt__p_ampl__EntityMapT_ampl__Variable_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__EntityMapT_ampl__Variable_t__iterator[] = {  {&_swigt__p_ampl__EntityMapT_ampl__Variable_t__iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__Environment[] = {  {&_swigt__p_ampl__Environment, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__ErrorHandler[] = {  {&_swigt__p_ampl__ErrorHandler, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__FileIOException[] = {  {&_swigt__p_ampl__FileIOException, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__Instance[] = {  {&_swigt__p_ampl__Instance, 0, 0, 0},  {&_swigt__p_ampl__SetInstance, _p_ampl__SetInstanceTo_p_ampl__Instance, 0, 0},  {&_swigt__p_ampl__ObjectiveInstance, _p_ampl__ObjectiveInstanceTo_p_ampl__Instance, 0, 0},  {&_swigt__p_ampl__VariableInstance, _p_ampl__VariableInstanceTo_p_ampl__Instance, 0, 0},  {&_swigt__p_ampl__ConstraintInstance, _p_ampl__ConstraintInstanceTo_p_ampl__Instance, 0, 0},  {&_swigt__p_ampl__TableInstance, _p_ampl__TableInstanceTo_p_ampl__Instance, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__InvalidSubscriptException[] = {  {&_swigt__p_ampl__InvalidSubscriptException, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__LicenseException[] = {  {&_swigt__p_ampl__LicenseException, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__NoDataException[] = {  {&_swigt__p_ampl__NoDataException, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__Objective[] = {  {&_swigt__p_ampl__Objective, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__ObjectiveInstance[] = {  {&_swigt__p_ampl__ObjectiveInstance, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__OptionalT_bool_t[] = {  {&_swigt__p_ampl__OptionalT_bool_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__OptionalT_double_t[] = {  {&_swigt__p_ampl__OptionalT_double_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__OptionalT_int_t[] = {  {&_swigt__p_ampl__OptionalT_int_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__OptionalT_std__string_t[] = {  {&_swigt__p_ampl__OptionalT_std__string_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__OutputHandler[] = {  {&_swigt__p_ampl__OutputHandler, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__Parameter[] = {  {&_swigt__p_ampl__Parameter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__Runnable[] = {  {&_swigt__p_ampl__Runnable, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__Set[] = {  {&_swigt__p_ampl__Set, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__SetInstance[] = {  {&_swigt__p_ampl__SetInstance, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__SetInstance__MemberRange[] = {  {&_swigt__p_ampl__SetInstance__MemberRange, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__SetInstance__MemberRange__iterator[] = {  {&_swigt__p_ampl__SetInstance__MemberRange__iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__StringArray[] = {  {&_swigt__p_ampl__StringArray, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__StringRefArray[] = {  {&_swigt__p_ampl__StringRefArray, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__SyntaxErrorException[] = {  {&_swigt__p_ampl__SyntaxErrorException, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__Table[] = {  {&_swigt__p_ampl__Table, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__TableInstance[] = {  {&_swigt__p_ampl__TableInstance, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__Tuple[] = {  {&_swigt__p_TupleArray, _p_TupleArrayTo_p_ampl__Tuple, 0, 0},  {&_swigt__p_ampl__Tuple, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__TupleRef[] = {  {&_swigt__p_ampl__TupleRef, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__UnsupportedOperationException[] = {  {&_swigt__p_ampl__UnsupportedOperationException, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__Variable[] = {  {&_swigt__p_ampl__Variable, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__VariableInstance[] = {  {&_swigt__p_ampl__VariableInstance, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__Variant[] = {  {&_swigt__p_VariantArray, _p_VariantArrayTo_p_ampl__Variant, 0, 0},  {&_swigt__p_ampl__Variant, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__VariantRef[] = {  {&_swigt__p_ampl__VariantRef, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t[] = {  {&_swigt__p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t[] = {  {&_swigt__p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t[] = {  {&_swigt__p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__TableInstance_t_t[] = {  {&_swigt__p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__TableInstance_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t[] = {  {&_swigt__p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t[] = {  {&_swigt__p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t[] = {  {&_swigt__p_ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t[] = {  {&_swigt__p_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t[] = {  {&_swigt__p_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__internal__EntityWrapperT_ampl__SetInstance_t[] = {  {&_swigt__p_ampl__internal__EntityWrapperT_ampl__SetInstance_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__internal__EntityWrapperT_ampl__TableInstance_t[] = {  {&_swigt__p_ampl__internal__EntityWrapperT_ampl__TableInstance_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__internal__EntityWrapperT_ampl__VariableInstance_t[] = {  {&_swigt__p_ampl__internal__EntityWrapperT_ampl__VariableInstance_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__internal__EntityWrapperT_ampl__VariantRef_t[] = {  {&_swigt__p_ampl__internal__EntityWrapperT_ampl__VariantRef_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__internal__EnvironmentIterator[] = {  {&_swigt__p_ampl__internal__EnvironmentIterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__internal__SliceT_false_t[] = {  {&_swigt__p_ampl__internal__SliceT_false_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__internal__SliceT_false_t__iterator[] = {  {&_swigt__p_ampl__internal__SliceT_false_t__iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__internal__SliceT_true_t[] = {  {&_swigt__p_ampl__internal__SliceT_true_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__internal__SliceT_true_t__iterator[] = {  {&_swigt__p_ampl__internal__SliceT_true_t__iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_char[] = {  {&_swigt__p_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_double[] = {  {&_swigt__p_double, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_iterator[] = {  {&_swigt__p_iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_char[] = {  {&_swigt__p_p_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__runtime_error[] = {  {&_swigt__p_std__runtime_error, 0, 0, 0},  {&_swigt__p_ampl__AMPLException, _p_ampl__AMPLExceptionTo_p_std__runtime_error, 0, 0},  {&_swigt__p_ampl__InvalidSubscriptException, _p_ampl__InvalidSubscriptExceptionTo_p_std__runtime_error, 0, 0},  {&_swigt__p_ampl__SyntaxErrorException, _p_ampl__SyntaxErrorExceptionTo_p_std__runtime_error, 0, 0},  {&_swigt__p_ampl__LicenseException, _p_ampl__LicenseExceptionTo_p_std__runtime_error, 0, 0},  {&_swigt__p_ampl__FileIOException, _p_ampl__FileIOExceptionTo_p_std__runtime_error, 0, 0},  {&_swigt__p_ampl__UnsupportedOperationException, _p_ampl__UnsupportedOperationExceptionTo_p_std__runtime_error, 0, 0},  {&_swigt__p_ampl__NoDataException, _p_ampl__NoDataExceptionTo_p_std__runtime_error, 0, 0},{0, 0, 0, 0}};

static swig_cast_info *swig_cast_initial[] = {
  _swigc__p_Column,
  _swigc__p_EntityArray,
  _swigc__p_InstanceType,
  _swigc__p_KeyType,
  _swigc__p_Row,
  _swigc__p_SwigPyObject,
  _swigc__p_TupleArray,
  _swigc__p_ValueType,
  _swigc__p_VariantArray,
  _swigc__p_ampl__AMPL,
  _swigc__p_ampl__AMPLException,
  _swigc__p_ampl__BasicEntityT_ampl__ConstraintInstance_t,
  _swigc__p_ampl__BasicEntityT_ampl__ObjectiveInstance_t,
  _swigc__p_ampl__BasicEntityT_ampl__SetInstance_t,
  _swigc__p_ampl__BasicEntityT_ampl__TableInstance_t,
  _swigc__p_ampl__BasicEntityT_ampl__VariableInstance_t,
  _swigc__p_ampl__BasicEntityT_ampl__VariantRef_t,
  _swigc__p_ampl__Constraint,
  _swigc__p_ampl__ConstraintInstance,
  _swigc__p_ampl__DataFrame,
  _swigc__p_ampl__Entity,
  _swigc__p_ampl__EntityArgs,
  _swigc__p_ampl__EntityMapT_ampl__Constraint_t,
  _swigc__p_ampl__EntityMapT_ampl__Constraint_t__iterator,
  _swigc__p_ampl__EntityMapT_ampl__Objective_t,
  _swigc__p_ampl__EntityMapT_ampl__Objective_t__iterator,
  _swigc__p_ampl__EntityMapT_ampl__Parameter_t,
  _swigc__p_ampl__EntityMapT_ampl__Parameter_t__iterator,
  _swigc__p_ampl__EntityMapT_ampl__Set_t,
  _swigc__p_ampl__EntityMapT_ampl__Set_t__iterator,
  _swigc__p_ampl__EntityMapT_ampl__Table_t,
  _swigc__p_ampl__EntityMapT_ampl__Table_t__iterator,
  _swigc__p_ampl__EntityMapT_ampl__Variable_t,
  _swigc__p_ampl__EntityMapT_ampl__Variable_t__iterator,
  _swigc__p_ampl__Environment,
  _swigc__p_ampl__ErrorHandler,
  _swigc__p_ampl__FileIOException,
  _swigc__p_ampl__Instance,
  _swigc__p_ampl__InvalidSubscriptException,
  _swigc__p_ampl__LicenseException,
  _swigc__p_ampl__NoDataException,
  _swigc__p_ampl__Objective,
  _swigc__p_ampl__ObjectiveInstance,
  _swigc__p_ampl__OptionalT_bool_t,
  _swigc__p_ampl__OptionalT_double_t,
  _swigc__p_ampl__OptionalT_int_t,
  _swigc__p_ampl__OptionalT_std__string_t,
  _swigc__p_ampl__OutputHandler,
  _swigc__p_ampl__Parameter,
  _swigc__p_ampl__Runnable,
  _swigc__p_ampl__Set,
  _swigc__p_ampl__SetInstance,
  _swigc__p_ampl__SetInstance__MemberRange,
  _swigc__p_ampl__SetInstance__MemberRange__iterator,
  _swigc__p_ampl__StringArray,
  _swigc__p_ampl__StringRefArray,
  _swigc__p_ampl__SyntaxErrorException,
  _swigc__p_ampl__Table,
  _swigc__p_ampl__TableInstance,
  _swigc__p_ampl__Tuple,
  _swigc__p_ampl__TupleRef,
  _swigc__p_ampl__UnsupportedOperationException,
  _swigc__p_ampl__Variable,
  _swigc__p_ampl__VariableInstance,
  _swigc__p_ampl__Variant,
  _swigc__p_ampl__VariantRef,
  _swigc__p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t,
  _swigc__p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t,
  _swigc__p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t,
  _swigc__p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__TableInstance_t_t,
  _swigc__p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t,
  _swigc__p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t,
  _swigc__p_ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t,
  _swigc__p_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t,
  _swigc__p_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t,
  _swigc__p_ampl__internal__EntityWrapperT_ampl__SetInstance_t,
  _swigc__p_ampl__internal__EntityWrapperT_ampl__TableInstance_t,
  _swigc__p_ampl__internal__EntityWrapperT_ampl__VariableInstance_t,
  _swigc__p_ampl__internal__EntityWrapperT_ampl__VariantRef_t,
  _swigc__p_ampl__internal__EnvironmentIterator,
  _swigc__p_ampl__internal__SliceT_false_t,
  _swigc__p_ampl__internal__SliceT_false_t__iterator,
  _swigc__p_ampl__internal__SliceT_true_t,
  _swigc__p_ampl__internal__SliceT_true_t__iterator,
  _swigc__p_char,
  _swigc__p_double,
  _swigc__p_iterator,
  _swigc__p_p_char,
  _swigc__p_std__runtime_error,
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */

static swig_const_info swig_const_table[] = {
{0, 0, 0, 0.0, 0, 0}};

#ifdef __cplusplus
}
#endif
static PyTypeObject *builtin_bases[3];

/* -----------------------------------------------------------------------------
 * Type initialization:
 * This problem is tough by the requirement that no dynamic
 * memory is used. Also, since swig_type_info structures store pointers to
 * swig_cast_info structures and swig_cast_info structures store pointers back
 * to swig_type_info structures, we need some lookup code at initialization.
 * The idea is that swig generates all the structures that are needed.
 * The runtime then collects these partially filled structures.
 * The SWIG_InitializeModule function takes these initial arrays out of
 * swig_module, and does all the lookup, filling in the swig_module.types
 * array with the correct data and linking the correct swig_cast_info
 * structures together.
 *
 * The generated swig_type_info structures are assigned statically to an initial
 * array. We just loop through that array, and handle each type individually.
 * First we lookup if this type has been already loaded, and if so, use the
 * loaded structure instead of the generated one. Then we have to fill in the
 * cast linked list. The cast data is initially stored in something like a
 * two-dimensional array. Each row corresponds to a type (there are the same
 * number of rows as there are in the swig_type_initial array). Each entry in
 * a column is one of the swig_cast_info structures for that type.
 * The cast_initial array is actually an array of arrays, because each row has
 * a variable number of columns. So to actually build the cast linked list,
 * we find the array of casts associated with the type, and loop through it
 * adding the casts to the list. The one last trick we need to do is making
 * sure the type pointer in the swig_cast_info struct is correct.
 *
 * First off, we lookup the cast->type name to see if it is already loaded.
 * There are three cases to handle:
 *  1) If the cast->type has already been loaded AND the type we are adding
 *     casting info to has not been loaded (it is in this module), THEN we
 *     replace the cast->type pointer with the type pointer that has already
 *     been loaded.
 *  2) If BOTH types (the one we are adding casting info to, and the
 *     cast->type) are loaded, THEN the cast info has already been loaded by
 *     the previous module so we just ignore it.
 *  3) Finally, if cast->type has not already been loaded, then we add that
 *     swig_cast_info to the linked list (because the cast->type) pointer will
 *     be correct.
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#if 0
} /* c-mode */
#endif
#endif

#if 0
#define SWIGRUNTIME_DEBUG
#endif


SWIGRUNTIME void
SWIG_InitializeModule(void *clientdata) {
  size_t i;
  swig_module_info *module_head, *iter;
  int init;
  
  /* check to see if the circular list has been setup, if not, set it up */
  if (swig_module.next==0) {
    /* Initialize the swig_module */
    swig_module.type_initial = swig_type_initial;
    swig_module.cast_initial = swig_cast_initial;
    swig_module.next = &swig_module;
    init = 1;
  } else {
    init = 0;
  }
  
  /* Try and load any already created modules */
  module_head = SWIG_GetModule(clientdata);
  if (!module_head) {
    /* This is the first module loaded for this interpreter */
    /* so set the swig module into the interpreter */
    SWIG_SetModule(clientdata, &swig_module);
  } else {
    /* the interpreter has loaded a SWIG module, but has it loaded this one? */
    iter=module_head;
    do {
      if (iter==&swig_module) {
        /* Our module is already in the list, so there's nothing more to do. */
        return;
      }
      iter=iter->next;
    } while (iter!= module_head);
    
    /* otherwise we must add our module into the list */
    swig_module.next = module_head->next;
    module_head->next = &swig_module;
  }
  
  /* When multiple interpreters are used, a module could have already been initialized in
       a different interpreter, but not yet have a pointer in this interpreter.
       In this case, we do not want to continue adding types... everything should be
       set up already */
  if (init == 0) return;
  
  /* Now work on filling in swig_module.types */
#ifdef SWIGRUNTIME_DEBUG
  printf("SWIG_InitializeModule: size %lu\n", (unsigned long)swig_module.size);
#endif
  for (i = 0; i < swig_module.size; ++i) {
    swig_type_info *type = 0;
    swig_type_info *ret;
    swig_cast_info *cast;
    
#ifdef SWIGRUNTIME_DEBUG
    printf("SWIG_InitializeModule: type %lu %s\n", (unsigned long)i, swig_module.type_initial[i]->name);
#endif
    
    /* if there is another module already loaded */
    if (swig_module.next != &swig_module) {
      type = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, swig_module.type_initial[i]->name);
    }
    if (type) {
      /* Overwrite clientdata field */
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: found type %s\n", type->name);
#endif
      if (swig_module.type_initial[i]->clientdata) {
        type->clientdata = swig_module.type_initial[i]->clientdata;
#ifdef SWIGRUNTIME_DEBUG
        printf("SWIG_InitializeModule: found and overwrite type %s \n", type->name);
#endif
      }
    } else {
      type = swig_module.type_initial[i];
    }
    
    /* Insert casting types */
    cast = swig_module.cast_initial[i];
    while (cast->type) {
      /* Don't need to add information already in the list */
      ret = 0;
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: look cast %s\n", cast->type->name);
#endif
      if (swig_module.next != &swig_module) {
        ret = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, cast->type->name);
#ifdef SWIGRUNTIME_DEBUG
        if (ret) printf("SWIG_InitializeModule: found cast %s\n", ret->name);
#endif
      }
      if (ret) {
        if (type == swig_module.type_initial[i]) {
#ifdef SWIGRUNTIME_DEBUG
          printf("SWIG_InitializeModule: skip old type %s\n", ret->name);
#endif
          cast->type = ret;
          ret = 0;
        } else {
          /* Check for casting already in the list */
          swig_cast_info *ocast = SWIG_TypeCheck(ret->name, type);
#ifdef SWIGRUNTIME_DEBUG
          if (ocast) printf("SWIG_InitializeModule: skip old cast %s\n", ret->name);
#endif
          if (!ocast) ret = 0;
        }
      }
      
      if (!ret) {
#ifdef SWIGRUNTIME_DEBUG
        printf("SWIG_InitializeModule: adding cast %s\n", cast->type->name);
#endif
        if (type->cast) {
          type->cast->prev = cast;
          cast->next = type->cast;
        }
        type->cast = cast;
      }
      cast++;
    }
    /* Set entry in modules->types array equal to the type */
    swig_module.types[i] = type;
  }
  swig_module.types[i] = 0;
  
#ifdef SWIGRUNTIME_DEBUG
  printf("**** SWIG_InitializeModule: Cast List ******\n");
  for (i = 0; i < swig_module.size; ++i) {
    int j = 0;
    swig_cast_info *cast = swig_module.cast_initial[i];
    printf("SWIG_InitializeModule: type %lu %s\n", (unsigned long)i, swig_module.type_initial[i]->name);
    while (cast->type) {
      printf("SWIG_InitializeModule: cast type %s\n", cast->type->name);
      cast++;
      ++j;
    }
    printf("---- Total casts: %d\n",j);
  }
  printf("**** SWIG_InitializeModule: Cast List ******\n");
#endif
}

/* This function will propagate the clientdata field of type to
* any new swig_type_info structures that have been added into the list
* of equivalent types.  It is like calling
* SWIG_TypeClientData(type, clientdata) a second time.
*/
SWIGRUNTIME void
SWIG_PropagateClientData(void) {
  size_t i;
  swig_cast_info *equiv;
  static int init_run = 0;
  
  if (init_run) return;
  init_run = 1;
  
  for (i = 0; i < swig_module.size; i++) {
    if (swig_module.types[i]->clientdata) {
      equiv = swig_module.types[i]->cast;
      while (equiv) {
        if (!equiv->converter) {
          if (equiv->type && !equiv->type->clientdata)
          SWIG_TypeClientData(equiv->type, swig_module.types[i]->clientdata);
        }
        equiv = equiv->next;
      }
    }
  }
}

#ifdef __cplusplus
#if 0
{
  /* c-mode */
#endif
}
#endif



#ifdef __cplusplus
extern "C" {
#endif
  
  /* Python-specific SWIG API */
#define SWIG_newvarlink()                             SWIG_Python_newvarlink()
#define SWIG_addvarlink(p, name, get_attr, set_attr)  SWIG_Python_addvarlink(p, name, get_attr, set_attr)
#define SWIG_InstallConstants(d, constants)           SWIG_Python_InstallConstants(d, constants)
  
  /* -----------------------------------------------------------------------------
   * global variable support code.
   * ----------------------------------------------------------------------------- */
  
  typedef struct swig_globalvar {
    char       *name;                  /* Name of global variable */
    PyObject *(*get_attr)(void);       /* Return the current value */
    int       (*set_attr)(PyObject *); /* Set the value */
    struct swig_globalvar *next;
  } swig_globalvar;
  
  typedef struct swig_varlinkobject {
    PyObject_HEAD
    swig_globalvar *vars;
  } swig_varlinkobject;
  
  SWIGINTERN PyObject *
  swig_varlink_repr(swig_varlinkobject *SWIGUNUSEDPARM(v)) {
#if PY_VERSION_HEX >= 0x03000000
    return PyUnicode_InternFromString("<Swig global variables>");
#else
    return PyString_FromString("<Swig global variables>");
#endif
  }
  
  SWIGINTERN PyObject *
  swig_varlink_str(swig_varlinkobject *v) {
#if PY_VERSION_HEX >= 0x03000000
    PyObject *str = PyUnicode_InternFromString("(");
    PyObject *tail;
    PyObject *joined;
    swig_globalvar *var;
    for (var = v->vars; var; var=var->next) {
      tail = PyUnicode_FromString(var->name);
      joined = PyUnicode_Concat(str, tail);
      Py_DecRef(str);
      Py_DecRef(tail);
      str = joined;
      if (var->next) {
        tail = PyUnicode_InternFromString(", ");
        joined = PyUnicode_Concat(str, tail);
        Py_DecRef(str);
        Py_DecRef(tail);
        str = joined;
      }
    }
    tail = PyUnicode_InternFromString(")");
    joined = PyUnicode_Concat(str, tail);
    Py_DecRef(str);
    Py_DecRef(tail);
    str = joined;
#else
    PyObject *str = PyString_FromString("(");
    swig_globalvar *var;
    for (var = v->vars; var; var=var->next) {
      PyString_ConcatAndDel(&str,PyString_FromString(var->name));
      if (var->next) PyString_ConcatAndDel(&str,PyString_FromString(", "));
    }
    PyString_ConcatAndDel(&str,PyString_FromString(")"));
#endif
    return str;
  }
  
  SWIGINTERN void
  swig_varlink_dealloc(swig_varlinkobject *v) {
    swig_globalvar *var = v->vars;
    while (var) {
      swig_globalvar *n = var->next;
      free(var->name);
      free(var);
      var = n;
    }
  }
  
  SWIGINTERN PyObject *
  swig_varlink_getattr(swig_varlinkobject *v, char *n) {
    PyObject *res = NULL;
    swig_globalvar *var = v->vars;
    while (var) {
      if (strcmp(var->name,n) == 0) {
        res = (*var->get_attr)();
        break;
      }
      var = var->next;
    }
    if (res == NULL && !PyErr_Occurred()) {
      PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
    }
    return res;
  }
  
  SWIGINTERN int
  swig_varlink_setattr(swig_varlinkobject *v, char *n, PyObject *p) {
    int res = 1;
    swig_globalvar *var = v->vars;
    while (var) {
      if (strcmp(var->name,n) == 0) {
        res = (*var->set_attr)(p);
        break;
      }
      var = var->next;
    }
    if (res == 1 && !PyErr_Occurred()) {
      PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
    }
    return res;
  }
  
  SWIGINTERN PyTypeObject*
  swig_varlink_type(void) {
    static char varlink__doc__[] = "Swig var link object";
    static PyTypeObject varlink_type;
    static int type_init = 0;
    if (!type_init) {
      const PyTypeObject tmp = {
#if PY_VERSION_HEX >= 0x03000000
        PyVarObject_HEAD_INIT(NULL, 0)
#else
        PyObject_HEAD_INIT(NULL)
        0,                                  /* ob_size */
#endif
        "swigvarlink",                      /* tp_name */
        sizeof(swig_varlinkobject),         /* tp_basicsize */
        0,                                  /* tp_itemsize */
        (destructor) swig_varlink_dealloc,  /* tp_dealloc */
        0,                                  /* tp_print */
        (getattrfunc) swig_varlink_getattr, /* tp_getattr */
        (setattrfunc) swig_varlink_setattr, /* tp_setattr */
        0,                                  /* tp_compare */
        (reprfunc) swig_varlink_repr,       /* tp_repr */
        0,                                  /* tp_as_number */
        0,                                  /* tp_as_sequence */
        0,                                  /* tp_as_mapping */
        0,                                  /* tp_hash */
        0,                                  /* tp_call */
        (reprfunc) swig_varlink_str,        /* tp_str */
        0,                                  /* tp_getattro */
        0,                                  /* tp_setattro */
        0,                                  /* tp_as_buffer */
        0,                                  /* tp_flags */
        varlink__doc__,                     /* tp_doc */
        0,                                  /* tp_traverse */
        0,                                  /* tp_clear */
        0,                                  /* tp_richcompare */
        0,                                  /* tp_weaklistoffset */
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* tp_iter -> tp_weaklist */
        0,                                  /* tp_del */
        0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
        0,                                  /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
        0,                                  /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
        0,                                  /* tp_print */
#endif
#ifdef COUNT_ALLOCS
        0,                                  /* tp_allocs */
        0,                                  /* tp_frees */
        0,                                  /* tp_maxalloc */
        0,                                  /* tp_prev */
        0                                   /* tp_next */
#endif
      };
      varlink_type = tmp;
      type_init = 1;
      if (PyType_Ready(&varlink_type) < 0)
      return NULL;
    }
    return &varlink_type;
  }
  
  /* Create a variable linking object for use later */
  SWIGINTERN PyObject *
  SWIG_Python_newvarlink(void) {
    swig_varlinkobject *result = PyObject_NEW(swig_varlinkobject, swig_varlink_type());
    if (result) {
      result->vars = 0;
    }
    return ((PyObject*) result);
  }
  
  SWIGINTERN void 
  SWIG_Python_addvarlink(PyObject *p, const char *name, PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p)) {
    swig_varlinkobject *v = (swig_varlinkobject *) p;
    swig_globalvar *gv = (swig_globalvar *) malloc(sizeof(swig_globalvar));
    if (gv) {
      size_t size = strlen(name)+1;
      gv->name = (char *)malloc(size);
      if (gv->name) {
        memcpy(gv->name, name, size);
        gv->get_attr = get_attr;
        gv->set_attr = set_attr;
        gv->next = v->vars;
      }
    }
    v->vars = gv;
  }
  
  SWIGINTERN PyObject *
  SWIG_globals(void) {
    static PyObject *globals = 0;
    if (!globals) {
      globals = SWIG_newvarlink();
    }
    return globals;
  }
  
  /* -----------------------------------------------------------------------------
   * constants/methods manipulation
   * ----------------------------------------------------------------------------- */
  
  /* Install Constants */
  SWIGINTERN void
  SWIG_Python_InstallConstants(PyObject *d, swig_const_info constants[]) {
    PyObject *obj = 0;
    size_t i;
    for (i = 0; constants[i].type; ++i) {
      switch(constants[i].type) {
      case SWIG_PY_POINTER:
        obj = SWIG_InternalNewPointerObj(constants[i].pvalue, *(constants[i]).ptype,0);
        break;
      case SWIG_PY_BINARY:
        obj = SWIG_NewPackedObj(constants[i].pvalue, constants[i].lvalue, *(constants[i].ptype));
        break;
      default:
        obj = 0;
        break;
      }
      if (obj) {
        PyDict_SetItemString(d, constants[i].name, obj);
        Py_DECREF(obj);
      }
    }
  }
  
  /* -----------------------------------------------------------------------------*/
  /* Fix SwigMethods to carry the callback ptrs when needed */
  /* -----------------------------------------------------------------------------*/
  
  SWIGINTERN void
  SWIG_Python_FixMethods(PyMethodDef *methods,
    swig_const_info *const_table,
    swig_type_info **types,
    swig_type_info **types_initial) {
    size_t i;
    for (i = 0; methods[i].ml_name; ++i) {
      const char *c = methods[i].ml_doc;
      if (!c) continue;
      c = strstr(c, "swig_ptr: ");
      if (c) {
        int j;
        swig_const_info *ci = 0;
        const char *name = c + 10;
        for (j = 0; const_table[j].type; ++j) {
          if (strncmp(const_table[j].name, name, 
              strlen(const_table[j].name)) == 0) {
            ci = &(const_table[j]);
            break;
          }
        }
        if (ci) {
          void *ptr = (ci->type == SWIG_PY_POINTER) ? ci->pvalue : 0;
          if (ptr) {
            size_t shift = (ci->ptype) - types;
            swig_type_info *ty = types_initial[shift];
            size_t ldoc = (c - methods[i].ml_doc);
            size_t lptr = strlen(ty->name)+2*sizeof(void*)+2;
            char *ndoc = (char*)malloc(ldoc + lptr + 10);
            if (ndoc) {
              char *buff = ndoc;
              memcpy(buff, methods[i].ml_doc, ldoc);
              buff += ldoc;
              memcpy(buff, "swig_ptr: ", 10);
              buff += 10;
              SWIG_PackVoidPtr(buff, ptr, ty->name, lptr);
              methods[i].ml_doc = ndoc;
            }
          }
        }
      }
    }
  } 
  
  /* -----------------------------------------------------------------------------
   * Method creation and docstring support functions
   * ----------------------------------------------------------------------------- */
  
  /* -----------------------------------------------------------------------------
   * Function to find the method definition with the correct docstring for the
   * proxy module as opposed to the low-level API
   * ----------------------------------------------------------------------------- */
  
  SWIGINTERN PyMethodDef *SWIG_PythonGetProxyDoc(const char *name) {
    /* Find the function in the modified method table */
    size_t offset = 0;
    int found = 0;
    while (SwigMethods_proxydocs[offset].ml_meth != NULL) {
      if (strcmp(SwigMethods_proxydocs[offset].ml_name, name) == 0) {
        found = 1;
        break;
      }
      offset++;
    }
    /* Use the copy with the modified docstring if available */
    return found ? &SwigMethods_proxydocs[offset] : NULL;
  }
  
  /* -----------------------------------------------------------------------------
   * Wrapper of PyInstanceMethod_New() used in Python 3
   * It is exported to the generated module, used for -fastproxy
   * ----------------------------------------------------------------------------- */
  
  SWIGINTERN PyObject *SWIG_PyInstanceMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *func) {
    if (PyCFunction_Check(func)) {
      PyCFunctionObject *funcobj = (PyCFunctionObject *)func;
      PyMethodDef *ml = SWIG_PythonGetProxyDoc(funcobj->m_ml->ml_name);
      if (ml)
      func = PyCFunction_NewEx(ml, funcobj->m_self, funcobj->m_module);
    }
#if PY_VERSION_HEX >= 0x03000000
    return PyInstanceMethod_New(func);
#else
    return PyMethod_New(func, NULL, NULL);
#endif
  }
  
  /* -----------------------------------------------------------------------------
   * Wrapper of PyStaticMethod_New()
   * It is exported to the generated module, used for -fastproxy
   * ----------------------------------------------------------------------------- */
  
  SWIGINTERN PyObject *SWIG_PyStaticMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *func) {
    if (PyCFunction_Check(func)) {
      PyCFunctionObject *funcobj = (PyCFunctionObject *)func;
      PyMethodDef *ml = SWIG_PythonGetProxyDoc(funcobj->m_ml->ml_name);
      if (ml)
      func = PyCFunction_NewEx(ml, funcobj->m_self, funcobj->m_module);
    }
    return PyStaticMethod_New(func);
  }
  
#ifdef __cplusplus
}
#endif

/* -----------------------------------------------------------------------------*
 *  Partial Init method
 * -----------------------------------------------------------------------------*/

#ifdef __cplusplus
extern "C"
#endif

SWIGEXPORT 
#if PY_VERSION_HEX >= 0x03000000
PyObject*
#else
void
#endif
SWIG_init(void) {
  PyObject *m, *d, *md, *globals;
  
#if PY_VERSION_HEX >= 0x03000000
  static struct PyModuleDef SWIG_module = {
    PyModuleDef_HEAD_INIT,
    SWIG_name,
    NULL,
    -1,
    SwigMethods,
    NULL,
    NULL,
    NULL,
    NULL
  };
#endif
  
#if defined(SWIGPYTHON_BUILTIN)
  static SwigPyClientData SwigPyObject_clientdata = {
    0, 0, 0, 0, 0, 0, 0
  };
  static PyGetSetDef this_getset_def = {
    (char *)"this", &SwigPyBuiltin_ThisClosure, NULL, NULL, NULL
  };
  static SwigPyGetSet thisown_getset_closure = {
    SwigPyObject_own,
    SwigPyObject_own
  };
  static PyGetSetDef thisown_getset_def = {
    (char *)"thisown", SwigPyBuiltin_GetterClosure, SwigPyBuiltin_SetterClosure, NULL, &thisown_getset_closure
  };
  PyTypeObject *builtin_pytype;
  int builtin_base_count;
  swig_type_info *builtin_basetype;
  PyObject *tuple;
  PyGetSetDescrObject *static_getset;
  PyTypeObject *metatype;
  PyTypeObject *swigpyobject;
  SwigPyClientData *cd;
  PyObject *public_interface, *public_symbol;
  PyObject *this_descr;
  PyObject *thisown_descr;
  PyObject *self = 0;
  int i;
  
  (void)builtin_pytype;
  (void)builtin_base_count;
  (void)builtin_basetype;
  (void)tuple;
  (void)static_getset;
  (void)self;
  
  /* Metaclass is used to implement static member variables */
  metatype = SwigPyObjectType();
  assert(metatype);
#endif
  
  (void)globals;
  
  /* Create singletons now to avoid potential deadlocks with multi-threaded usage after module initialization */
  SWIG_This();
  SWIG_Python_TypeCache();
  SwigPyPacked_type();
#ifndef SWIGPYTHON_BUILTIN
  SwigPyObject_type();
#endif
  
  /* Fix SwigMethods to carry the callback ptrs when needed */
  SWIG_Python_FixMethods(SwigMethods, swig_const_table, swig_types, swig_type_initial);
  
#if PY_VERSION_HEX >= 0x03000000
  m = PyModule_Create(&SWIG_module);
#else
  m = Py_InitModule(SWIG_name, SwigMethods);
#endif
  
  md = d = PyModule_GetDict(m);
  (void)md;
  
  SWIG_InitializeModule(0);
  
#ifdef SWIGPYTHON_BUILTIN
  swigpyobject = SwigPyObject_TypeOnce();
  
  SwigPyObject_stype = SWIG_MangledTypeQuery("_p_SwigPyObject");
  assert(SwigPyObject_stype);
  cd = (SwigPyClientData*) SwigPyObject_stype->clientdata;
  if (!cd) {
    SwigPyObject_stype->clientdata = &SwigPyObject_clientdata;
    SwigPyObject_clientdata.pytype = swigpyobject;
  } else if (swigpyobject->tp_basicsize != cd->pytype->tp_basicsize) {
    PyErr_SetString(PyExc_RuntimeError, "Import error: attempted to load two incompatible swig-generated modules.");
# if PY_VERSION_HEX >= 0x03000000
    return NULL;
# else
    return;
# endif
  }
  
  /* All objects have a 'this' attribute */
  this_descr = PyDescr_NewGetSet(SwigPyObject_type(), &this_getset_def);
  (void)this_descr;
  
  /* All objects have a 'thisown' attribute */
  thisown_descr = PyDescr_NewGetSet(SwigPyObject_type(), &thisown_getset_def);
  (void)thisown_descr;
  
  public_interface = PyList_New(0);
  public_symbol = 0;
  (void)public_symbol;
  
  PyDict_SetItemString(md, "__all__", public_interface);
  Py_DECREF(public_interface);
  for (i = 0; SwigMethods[i].ml_name != NULL; ++i)
  SwigPyBuiltin_AddPublicSymbol(public_interface, SwigMethods[i].ml_name);
  for (i = 0; swig_const_table[i].name != 0; ++i)
  SwigPyBuiltin_AddPublicSymbol(public_interface, swig_const_table[i].name);
#endif
  
  SWIG_InstallConstants(d,swig_const_table);
  
  
  /* type 'ampl::StringArray' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__StringArray_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'StringArray'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "StringArray", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "StringArray");
  d = md;
  
  /* type 'ampl::StringRefArray' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__StringRefArray_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'StringRefArray'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "StringRefArray", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "StringRefArray");
  d = md;
  
  /* type 'std::runtime_error' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__std__runtime_error_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'runtime_error'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "runtime_error", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "runtime_error");
  d = md;
  
  /* type '::VariantArray' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__VariantArray_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'VariantArray'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "VariantArray", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "VariantArray");
  d = md;
  
  /* type '::TupleArray' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__TupleArray_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'TupleArray'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "TupleArray", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "TupleArray");
  d = md;
  
  /* type 'ampl::Optional< int >' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__OptionalT_int_t_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'OptionalInt'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "OptionalInt", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "OptionalInt");
  d = md;
  
  /* type 'ampl::Optional< std::string >' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__OptionalT_std__string_t_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'OptionalString'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "OptionalString", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "OptionalString");
  d = md;
  
  /* type 'ampl::Optional< bool >' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__OptionalT_bool_t_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'OptionalBool'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "OptionalBool", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "OptionalBool");
  d = md;
  
  /* type 'ampl::Optional< double >' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__OptionalT_double_t_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'OptionalDouble'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "OptionalDouble", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "OptionalDouble");
  d = md;
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "EMPTY",SWIG_From_int(static_cast< int >(ampl::EMPTY)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "NUMERIC",SWIG_From_int(static_cast< int >(ampl::NUMERIC)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "STRING",SWIG_From_int(static_cast< int >(ampl::STRING)));
  
  /* type 'ampl::Variant' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__Variant_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'Variant'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "Variant", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "Variant");
  d = md;
  
  /* type 'ampl::VariantRef' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__VariantRef_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'VariantRef'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "VariantRef", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "VariantRef");
  d = md;
  
  /* type 'ampl::TupleRef' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__TupleRef_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'TupleRef'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "TupleRef", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "TupleRef");
  d = md;
  
  /* type 'ampl::Tuple' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__Tuple_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'Tuple'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "Tuple", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "Tuple");
  d = md;
  
  /* type 'ampl::DataFrame' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__DataFrame_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'DataFrame'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "DataFrame", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "DataFrame");
  d = md;
  
  /* type 'ampl::internal::Slice< false >' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__internal__SliceT_false_t_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'DataFrameColumn'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "DataFrameColumn", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "DataFrameColumn");
  d = md;
  
  /* type 'ampl::internal::Slice< false >::iterator' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__internal__SliceT_false_t__iterator_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'ColIterator'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "ColIterator", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "ColIterator");
  d = md;
  
  /* type 'ampl::internal::Slice< true >' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__internal__SliceT_true_t_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'DataFrameRow'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "DataFrameRow", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "DataFrameRow");
  d = md;
  
  /* type 'ampl::internal::Slice< true >::iterator' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__internal__SliceT_true_t__iterator_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'RowIterator'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "RowIterator", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "RowIterator");
  d = md;
  
  /* type 'ampl::Instance' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__Instance_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'Instance'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "Instance", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "Instance");
  d = md;
  
  /* type 'ampl::SetInstance' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__SetInstance_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_basetype = SWIG_MangledTypeQuery("_p_ampl__Instance");
  if (builtin_basetype && builtin_basetype->clientdata && ((SwigPyClientData *) builtin_basetype->clientdata)->pytype) {
    builtin_bases[builtin_base_count++] = ((SwigPyClientData *) builtin_basetype->clientdata)->pytype;
  } else {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'SetInstance' as base 'ampl::Instance' has not been initialized.\n");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'SetInstance'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "SetInstance", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "SetInstance");
  d = md;
  
  /* type 'ampl::SetInstance::MemberRange' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__SetInstance__MemberRange_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'MemberRange'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "MemberRange", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "MemberRange");
  d = md;
  
  /* type 'ampl::SetInstance::MemberRange::iterator' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__SetInstance__MemberRange__iterator_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'iterator'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "iterator", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "iterator");
  d = md;
  
  /* type 'ampl::ObjectiveInstance' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__ObjectiveInstance_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_basetype = SWIG_MangledTypeQuery("_p_ampl__Instance");
  if (builtin_basetype && builtin_basetype->clientdata && ((SwigPyClientData *) builtin_basetype->clientdata)->pytype) {
    builtin_bases[builtin_base_count++] = ((SwigPyClientData *) builtin_basetype->clientdata)->pytype;
  } else {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'ObjectiveInstance' as base 'ampl::Instance' has not been initialized.\n");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'ObjectiveInstance'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "ObjectiveInstance", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "ObjectiveInstance");
  d = md;
  
  /* type 'ampl::VariableInstance' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__VariableInstance_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_basetype = SWIG_MangledTypeQuery("_p_ampl__Instance");
  if (builtin_basetype && builtin_basetype->clientdata && ((SwigPyClientData *) builtin_basetype->clientdata)->pytype) {
    builtin_bases[builtin_base_count++] = ((SwigPyClientData *) builtin_basetype->clientdata)->pytype;
  } else {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'VariableInstance' as base 'ampl::Instance' has not been initialized.\n");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'VariableInstance'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "VariableInstance", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "VariableInstance");
  d = md;
  
  /* type 'ampl::ConstraintInstance' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__ConstraintInstance_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_basetype = SWIG_MangledTypeQuery("_p_ampl__Instance");
  if (builtin_basetype && builtin_basetype->clientdata && ((SwigPyClientData *) builtin_basetype->clientdata)->pytype) {
    builtin_bases[builtin_base_count++] = ((SwigPyClientData *) builtin_basetype->clientdata)->pytype;
  } else {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'ConstraintInstance' as base 'ampl::Instance' has not been initialized.\n");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'ConstraintInstance'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "ConstraintInstance", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "ConstraintInstance");
  d = md;
  
  /* type 'ampl::TableInstance' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__TableInstance_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_basetype = SWIG_MangledTypeQuery("_p_ampl__Instance");
  if (builtin_basetype && builtin_basetype->clientdata && ((SwigPyClientData *) builtin_basetype->clientdata)->pytype) {
    builtin_bases[builtin_base_count++] = ((SwigPyClientData *) builtin_basetype->clientdata)->pytype;
  } else {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'TableInstance' as base 'ampl::Instance' has not been initialized.\n");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'TableInstance'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "TableInstance", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "TableInstance");
  d = md;
  
  /* type '::EntityArray' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__EntityArray_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'EntityArray'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "EntityArray", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "EntityArray");
  d = md;
  
  /* type 'ampl::Entity' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__Entity_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'Entity'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "Entity", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "Entity");
  d = md;
  
  /* type 'ampl::EntityArgs' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__EntityArgs_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'EntityArgs'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "EntityArgs", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "EntityArgs");
  d = md;
  
  /* type 'ampl::BasicEntity< ampl::VariableInstance >' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__BasicEntityT_ampl__VariableInstance_t_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_basetype = SWIG_MangledTypeQuery("_p_ampl__Entity");
  if (builtin_basetype && builtin_basetype->clientdata && ((SwigPyClientData *) builtin_basetype->clientdata)->pytype) {
    builtin_bases[builtin_base_count++] = ((SwigPyClientData *) builtin_basetype->clientdata)->pytype;
  } else {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'BasicEntityVariable' as base 'ampl::Entity' has not been initialized.\n");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'BasicEntityVariable'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "BasicEntityVariable", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "BasicEntityVariable");
  d = md;
  
  /* type 'ampl::BasicEntity< ampl::ConstraintInstance >' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__BasicEntityT_ampl__ConstraintInstance_t_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_basetype = SWIG_MangledTypeQuery("_p_ampl__Entity");
  if (builtin_basetype && builtin_basetype->clientdata && ((SwigPyClientData *) builtin_basetype->clientdata)->pytype) {
    builtin_bases[builtin_base_count++] = ((SwigPyClientData *) builtin_basetype->clientdata)->pytype;
  } else {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'BasicEntityConstraint' as base 'ampl::Entity' has not been initialized.\n");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'BasicEntityConstraint'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "BasicEntityConstraint", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "BasicEntityConstraint");
  d = md;
  
  /* type 'ampl::BasicEntity< ampl::SetInstance >' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__BasicEntityT_ampl__SetInstance_t_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_basetype = SWIG_MangledTypeQuery("_p_ampl__Entity");
  if (builtin_basetype && builtin_basetype->clientdata && ((SwigPyClientData *) builtin_basetype->clientdata)->pytype) {
    builtin_bases[builtin_base_count++] = ((SwigPyClientData *) builtin_basetype->clientdata)->pytype;
  } else {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'BasicEntitySet' as base 'ampl::Entity' has not been initialized.\n");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'BasicEntitySet'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "BasicEntitySet", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "BasicEntitySet");
  d = md;
  
  /* type 'ampl::BasicEntity< ampl::ObjectiveInstance >' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__BasicEntityT_ampl__ObjectiveInstance_t_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_basetype = SWIG_MangledTypeQuery("_p_ampl__Entity");
  if (builtin_basetype && builtin_basetype->clientdata && ((SwigPyClientData *) builtin_basetype->clientdata)->pytype) {
    builtin_bases[builtin_base_count++] = ((SwigPyClientData *) builtin_basetype->clientdata)->pytype;
  } else {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'BasicEntityObjective' as base 'ampl::Entity' has not been initialized.\n");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'BasicEntityObjective'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "BasicEntityObjective", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "BasicEntityObjective");
  d = md;
  
  /* type 'ampl::BasicEntity< ampl::VariantRef >' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__BasicEntityT_ampl__VariantRef_t_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_basetype = SWIG_MangledTypeQuery("_p_ampl__Entity");
  if (builtin_basetype && builtin_basetype->clientdata && ((SwigPyClientData *) builtin_basetype->clientdata)->pytype) {
    builtin_bases[builtin_base_count++] = ((SwigPyClientData *) builtin_basetype->clientdata)->pytype;
  } else {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'BasicEntityParameter' as base 'ampl::Entity' has not been initialized.\n");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'BasicEntityParameter'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "BasicEntityParameter", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "BasicEntityParameter");
  d = md;
  
  /* type 'ampl::BasicEntity< ampl::TableInstance >' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__BasicEntityT_ampl__TableInstance_t_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_basetype = SWIG_MangledTypeQuery("_p_ampl__Entity");
  if (builtin_basetype && builtin_basetype->clientdata && ((SwigPyClientData *) builtin_basetype->clientdata)->pytype) {
    builtin_bases[builtin_base_count++] = ((SwigPyClientData *) builtin_basetype->clientdata)->pytype;
  } else {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'BasicEntityTable' as base 'ampl::Entity' has not been initialized.\n");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'BasicEntityTable'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "BasicEntityTable", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "BasicEntityTable");
  d = md;
  
  /* type 'ampl::Constraint' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__Constraint_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_basetype = SWIG_MangledTypeQuery("_p_ampl__BasicEntityT_ampl__ConstraintInstance_t");
  if (builtin_basetype && builtin_basetype->clientdata && ((SwigPyClientData *) builtin_basetype->clientdata)->pytype) {
    builtin_bases[builtin_base_count++] = ((SwigPyClientData *) builtin_basetype->clientdata)->pytype;
  } else {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'Constraint' as base 'ampl::BasicEntity<(ampl::ConstraintInstance)>' has not been initialized.\n");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'Constraint'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "Constraint", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "Constraint");
  d = md;
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "CONTINUOUS",SWIG_From_int(static_cast< int >(ampl::var::CONTINUOUS)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "BINARY",SWIG_From_int(static_cast< int >(ampl::var::BINARY)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "INTEGER",SWIG_From_int(static_cast< int >(ampl::var::INTEGER)));
  
  /* type 'ampl::Variable' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__Variable_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_basetype = SWIG_MangledTypeQuery("_p_ampl__BasicEntityT_ampl__VariableInstance_t");
  if (builtin_basetype && builtin_basetype->clientdata && ((SwigPyClientData *) builtin_basetype->clientdata)->pytype) {
    builtin_bases[builtin_base_count++] = ((SwigPyClientData *) builtin_basetype->clientdata)->pytype;
  } else {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'Variable' as base 'ampl::BasicEntity<(ampl::VariableInstance)>' has not been initialized.\n");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'Variable'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "Variable", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "Variable");
  d = md;
  
  /* type 'ampl::Objective' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__Objective_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_basetype = SWIG_MangledTypeQuery("_p_ampl__BasicEntityT_ampl__ObjectiveInstance_t");
  if (builtin_basetype && builtin_basetype->clientdata && ((SwigPyClientData *) builtin_basetype->clientdata)->pytype) {
    builtin_bases[builtin_base_count++] = ((SwigPyClientData *) builtin_basetype->clientdata)->pytype;
  } else {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'Objective' as base 'ampl::BasicEntity<(ampl::ObjectiveInstance)>' has not been initialized.\n");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'Objective'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "Objective", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "Objective");
  d = md;
  
  /* type 'ampl::Set' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__Set_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_basetype = SWIG_MangledTypeQuery("_p_ampl__BasicEntityT_ampl__SetInstance_t");
  if (builtin_basetype && builtin_basetype->clientdata && ((SwigPyClientData *) builtin_basetype->clientdata)->pytype) {
    builtin_bases[builtin_base_count++] = ((SwigPyClientData *) builtin_basetype->clientdata)->pytype;
  } else {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'Set' as base 'ampl::BasicEntity<(ampl::SetInstance)>' has not been initialized.\n");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'Set'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "Set", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "Set");
  d = md;
  
  /* type 'ampl::Table' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__Table_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_basetype = SWIG_MangledTypeQuery("_p_ampl__BasicEntityT_ampl__TableInstance_t");
  if (builtin_basetype && builtin_basetype->clientdata && ((SwigPyClientData *) builtin_basetype->clientdata)->pytype) {
    builtin_bases[builtin_base_count++] = ((SwigPyClientData *) builtin_basetype->clientdata)->pytype;
  } else {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'Table' as base 'ampl::BasicEntity<(ampl::TableInstance)>' has not been initialized.\n");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'Table'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "Table", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "Table");
  d = md;
  
  /* type 'ampl::Parameter' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__Parameter_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_basetype = SWIG_MangledTypeQuery("_p_ampl__BasicEntityT_ampl__VariantRef_t");
  if (builtin_basetype && builtin_basetype->clientdata && ((SwigPyClientData *) builtin_basetype->clientdata)->pytype) {
    builtin_bases[builtin_base_count++] = ((SwigPyClientData *) builtin_basetype->clientdata)->pytype;
  } else {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'Parameter' as base 'ampl::BasicEntity<(ampl::VariantRef)>' has not been initialized.\n");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'Parameter'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "Parameter", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "Parameter");
  d = md;
  
  /* type 'ampl::internal::EntityWrapper< ampl::VariableInstance >' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__VariableInstance_t_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'VariableIteratorWrapper'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "VariableIteratorWrapper", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "VariableIteratorWrapper");
  d = md;
  
  /* type 'ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > >' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'VariableIterator'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "VariableIterator", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "VariableIterator");
  d = md;
  
  /* type 'ampl::internal::EntityWrapper< ampl::ConstraintInstance >' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'ConstraintIteratorWrapper'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "ConstraintIteratorWrapper", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "ConstraintIteratorWrapper");
  d = md;
  
  /* type 'ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > >' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'ConstraintIterator'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "ConstraintIterator", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "ConstraintIterator");
  d = md;
  
  /* type 'ampl::internal::EntityWrapper< ampl::ObjectiveInstance >' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'ObjectiveIteratorWrapper'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "ObjectiveIteratorWrapper", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "ObjectiveIteratorWrapper");
  d = md;
  
  /* type 'ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > >' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'ObjectiveIterator'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "ObjectiveIterator", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "ObjectiveIterator");
  d = md;
  
  /* type 'ampl::internal::EntityWrapper< ampl::SetInstance >' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__SetInstance_t_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'SetIteratorWrapper'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "SetIteratorWrapper", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "SetIteratorWrapper");
  d = md;
  
  /* type 'ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > >' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'SetIterator'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "SetIterator", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "SetIterator");
  d = md;
  
  /* type 'ampl::internal::EntityWrapper< ampl::TableInstance >' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__TableInstance_t_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'TableIteratorWrapper'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "TableIteratorWrapper", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "TableIteratorWrapper");
  d = md;
  
  /* type 'ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::TableInstance > >' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__TableInstance_t_t_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'TableIterator'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "TableIterator", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "TableIterator");
  d = md;
  
  /* type 'ampl::internal::EntityWrapper< ampl::VariantRef >' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__VariantRef_t_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'ParameterIteratorWrapper'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "ParameterIteratorWrapper", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "ParameterIteratorWrapper");
  d = md;
  
  /* type 'ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > >' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'ParameterIterator'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "ParameterIterator", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "ParameterIterator");
  d = md;
  
  /* type 'ampl::EntityMap< ampl::Variable >' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__EntityMapT_ampl__Variable_t_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'EntityMapVariable'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "EntityMapVariable", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "EntityMapVariable");
  d = md;
  
  /* type 'ampl::EntityMap< ampl::Variable >::iterator' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__EntityMapT_ampl__Variable_t__iterator_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'EntityMapVariableIterator'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "EntityMapVariableIterator", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "EntityMapVariableIterator");
  d = md;
  
  /* type 'ampl::EntityMap< ampl::Constraint >' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__EntityMapT_ampl__Constraint_t_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'EntityMapConstraint'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "EntityMapConstraint", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "EntityMapConstraint");
  d = md;
  
  /* type 'ampl::EntityMap< ampl::Constraint >::iterator' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__EntityMapT_ampl__Constraint_t__iterator_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'EntityMapConstraintIterator'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "EntityMapConstraintIterator", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "EntityMapConstraintIterator");
  d = md;
  
  /* type 'ampl::EntityMap< ampl::Objective >' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__EntityMapT_ampl__Objective_t_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'EntityMapObjective'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "EntityMapObjective", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "EntityMapObjective");
  d = md;
  
  /* type 'ampl::EntityMap< ampl::Objective >::iterator' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__EntityMapT_ampl__Objective_t__iterator_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'EntityMapObjectiveIterator'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "EntityMapObjectiveIterator", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "EntityMapObjectiveIterator");
  d = md;
  
  /* type 'ampl::EntityMap< ampl::Set >' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__EntityMapT_ampl__Set_t_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'EntityMapSet'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "EntityMapSet", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "EntityMapSet");
  d = md;
  
  /* type 'ampl::EntityMap< ampl::Set >::iterator' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__EntityMapT_ampl__Set_t__iterator_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'EntityMapSetIterator'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "EntityMapSetIterator", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "EntityMapSetIterator");
  d = md;
  
  /* type 'ampl::EntityMap< ampl::Table >' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__EntityMapT_ampl__Table_t_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'EntityMapTable'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "EntityMapTable", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "EntityMapTable");
  d = md;
  
  /* type 'ampl::EntityMap< ampl::Table >::iterator' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__EntityMapT_ampl__Table_t__iterator_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'EntityMapTableIterator'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "EntityMapTableIterator", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "EntityMapTableIterator");
  d = md;
  
  /* type 'ampl::EntityMap< ampl::Parameter >' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__EntityMapT_ampl__Parameter_t_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'EntityMapParameter'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "EntityMapParameter", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "EntityMapParameter");
  d = md;
  
  /* type 'ampl::EntityMap< ampl::Parameter >::iterator' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__EntityMapT_ampl__Parameter_t__iterator_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'EntityMapParameterIterator'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "EntityMapParameterIterator", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "EntityMapParameterIterator");
  d = md;
  
  /* type 'ampl::AMPLException' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__AMPLException_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_basetype = SWIG_MangledTypeQuery("_p_std__runtime_error");
  if (builtin_basetype && builtin_basetype->clientdata && ((SwigPyClientData *) builtin_basetype->clientdata)->pytype) {
    builtin_bases[builtin_base_count++] = ((SwigPyClientData *) builtin_basetype->clientdata)->pytype;
  } else {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'AMPLException' as base 'std::runtime_error' has not been initialized.\n");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'AMPLException'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "AMPLException", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "AMPLException");
  d = md;
  
  /* type 'ampl::LicenseException' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__LicenseException_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_basetype = SWIG_MangledTypeQuery("_p_std__runtime_error");
  if (builtin_basetype && builtin_basetype->clientdata && ((SwigPyClientData *) builtin_basetype->clientdata)->pytype) {
    builtin_bases[builtin_base_count++] = ((SwigPyClientData *) builtin_basetype->clientdata)->pytype;
  } else {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'LicenseException' as base 'std::runtime_error' has not been initialized.\n");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'LicenseException'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "LicenseException", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "LicenseException");
  d = md;
  
  /* type 'ampl::FileIOException' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__FileIOException_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_basetype = SWIG_MangledTypeQuery("_p_std__runtime_error");
  if (builtin_basetype && builtin_basetype->clientdata && ((SwigPyClientData *) builtin_basetype->clientdata)->pytype) {
    builtin_bases[builtin_base_count++] = ((SwigPyClientData *) builtin_basetype->clientdata)->pytype;
  } else {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'FileIOException' as base 'std::runtime_error' has not been initialized.\n");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'FileIOException'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "FileIOException", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "FileIOException");
  d = md;
  
  /* type 'ampl::UnsupportedOperationException' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__UnsupportedOperationException_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_basetype = SWIG_MangledTypeQuery("_p_std__runtime_error");
  if (builtin_basetype && builtin_basetype->clientdata && ((SwigPyClientData *) builtin_basetype->clientdata)->pytype) {
    builtin_bases[builtin_base_count++] = ((SwigPyClientData *) builtin_basetype->clientdata)->pytype;
  } else {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'UnsupportedOperationException' as base 'std::runtime_error' has not been initialized.\n");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'UnsupportedOperationException'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "UnsupportedOperationException", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "UnsupportedOperationException");
  d = md;
  
  /* type 'ampl::InvalidSubscriptException' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__InvalidSubscriptException_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_basetype = SWIG_MangledTypeQuery("_p_ampl__AMPLException");
  if (builtin_basetype && builtin_basetype->clientdata && ((SwigPyClientData *) builtin_basetype->clientdata)->pytype) {
    builtin_bases[builtin_base_count++] = ((SwigPyClientData *) builtin_basetype->clientdata)->pytype;
  } else {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'InvalidSubscriptException' as base 'ampl::AMPLException' has not been initialized.\n");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'InvalidSubscriptException'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "InvalidSubscriptException", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "InvalidSubscriptException");
  d = md;
  
  /* type 'ampl::SyntaxErrorException' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__SyntaxErrorException_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_basetype = SWIG_MangledTypeQuery("_p_ampl__AMPLException");
  if (builtin_basetype && builtin_basetype->clientdata && ((SwigPyClientData *) builtin_basetype->clientdata)->pytype) {
    builtin_bases[builtin_base_count++] = ((SwigPyClientData *) builtin_basetype->clientdata)->pytype;
  } else {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'SyntaxErrorException' as base 'ampl::AMPLException' has not been initialized.\n");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'SyntaxErrorException'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "SyntaxErrorException", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "SyntaxErrorException");
  d = md;
  
  /* type 'ampl::NoDataException' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__NoDataException_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_basetype = SWIG_MangledTypeQuery("_p_std__runtime_error");
  if (builtin_basetype && builtin_basetype->clientdata && ((SwigPyClientData *) builtin_basetype->clientdata)->pytype) {
    builtin_bases[builtin_base_count++] = ((SwigPyClientData *) builtin_basetype->clientdata)->pytype;
  } else {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'NoDataException' as base 'std::runtime_error' has not been initialized.\n");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'NoDataException'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "NoDataException", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "NoDataException");
  d = md;
  
  /* type 'ampl::ErrorHandler' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__ErrorHandler_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'ErrorHandler'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "ErrorHandler", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "ErrorHandler");
  d = md;
  
  /* type 'ampl::Runnable' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__Runnable_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'Runnable'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "Runnable", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "Runnable");
  d = md;
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "WAITING",SWIG_From_int(static_cast< int >(ampl::output::WAITING)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "BREAK",SWIG_From_int(static_cast< int >(ampl::output::BREAK)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "CD",SWIG_From_int(static_cast< int >(ampl::output::CD)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "DISPLAY",SWIG_From_int(static_cast< int >(ampl::output::DISPLAY)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "EXIT",SWIG_From_int(static_cast< int >(ampl::output::EXIT)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "EXPAND",SWIG_From_int(static_cast< int >(ampl::output::EXPAND)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "LOAD",SWIG_From_int(static_cast< int >(ampl::output::LOAD)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "OPTION",SWIG_From_int(static_cast< int >(ampl::output::OPTION)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "PRINT",SWIG_From_int(static_cast< int >(ampl::output::PRINT)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "PROMPT",SWIG_From_int(static_cast< int >(ampl::output::PROMPT)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "SOLUTION",SWIG_From_int(static_cast< int >(ampl::output::SOLUTION)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "SOLVE",SWIG_From_int(static_cast< int >(ampl::output::SOLVE)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "SHOW",SWIG_From_int(static_cast< int >(ampl::output::SHOW)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "XREF",SWIG_From_int(static_cast< int >(ampl::output::XREF)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "SHELL_OUTPUT",SWIG_From_int(static_cast< int >(ampl::output::SHELL_OUTPUT)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "SHELL_MESSAGE",SWIG_From_int(static_cast< int >(ampl::output::SHELL_MESSAGE)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "MISC",SWIG_From_int(static_cast< int >(ampl::output::MISC)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "WRITE_TABLE",SWIG_From_int(static_cast< int >(ampl::output::WRITE_TABLE)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "READ_TABLE",SWIG_From_int(static_cast< int >(ampl::output::READ_TABLE)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "_READTABLE",SWIG_From_int(static_cast< int >(ampl::output::_READTABLE)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "_WRITETABLE",SWIG_From_int(static_cast< int >(ampl::output::_WRITETABLE)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "BREAKPOINT",SWIG_From_int(static_cast< int >(ampl::output::BREAKPOINT)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "CALL",SWIG_From_int(static_cast< int >(ampl::output::CALL)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "CHECK",SWIG_From_int(static_cast< int >(ampl::output::CHECK)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "CLOSE",SWIG_From_int(static_cast< int >(ampl::output::CLOSE)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "COMMANDS",SWIG_From_int(static_cast< int >(ampl::output::COMMANDS)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "CONTINUE",SWIG_From_int(static_cast< int >(ampl::output::CONTINUE)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "DATA",SWIG_From_int(static_cast< int >(ampl::output::DATA)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "DELETECMD",SWIG_From_int(static_cast< int >(ampl::output::DELETECMD)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "DROP",SWIG_From_int(static_cast< int >(ampl::output::DROP)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "DROP_OR_RESTORE_ALL",SWIG_From_int(static_cast< int >(ampl::output::DROP_OR_RESTORE_ALL)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "ELSE",SWIG_From_int(static_cast< int >(ampl::output::ELSE)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "ELSE_CHECK",SWIG_From_int(static_cast< int >(ampl::output::ELSE_CHECK)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "ENDIF",SWIG_From_int(static_cast< int >(ampl::output::ENDIF)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "ENVIRON",SWIG_From_int(static_cast< int >(ampl::output::ENVIRON)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "FIX",SWIG_From_int(static_cast< int >(ampl::output::FIX)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "FOR",SWIG_From_int(static_cast< int >(ampl::output::FOR)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "IF",SWIG_From_int(static_cast< int >(ampl::output::IF)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "LET",SWIG_From_int(static_cast< int >(ampl::output::LET)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "LOOPEND",SWIG_From_int(static_cast< int >(ampl::output::LOOPEND)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "OBJECTIVE",SWIG_From_int(static_cast< int >(ampl::output::OBJECTIVE)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "OPTION_RESET",SWIG_From_int(static_cast< int >(ampl::output::OPTION_RESET)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "PRINTF",SWIG_From_int(static_cast< int >(ampl::output::PRINTF)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "PROBLEM",SWIG_From_int(static_cast< int >(ampl::output::PROBLEM)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "PURGE",SWIG_From_int(static_cast< int >(ampl::output::PURGE)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "RBRACE",SWIG_From_int(static_cast< int >(ampl::output::RBRACE)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "READ",SWIG_From_int(static_cast< int >(ampl::output::READ)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "RELOAD",SWIG_From_int(static_cast< int >(ampl::output::RELOAD)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "REMOVE",SWIG_From_int(static_cast< int >(ampl::output::REMOVE)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "REPEAT",SWIG_From_int(static_cast< int >(ampl::output::REPEAT)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "REPEAT_END",SWIG_From_int(static_cast< int >(ampl::output::REPEAT_END)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "RESET",SWIG_From_int(static_cast< int >(ampl::output::RESET)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "RESTORE",SWIG_From_int(static_cast< int >(ampl::output::RESTORE)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "RUN_ARGS",SWIG_From_int(static_cast< int >(ampl::output::RUN_ARGS)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "SEMICOLON",SWIG_From_int(static_cast< int >(ampl::output::SEMICOLON)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "SSTEP",SWIG_From_int(static_cast< int >(ampl::output::SSTEP)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "THEN",SWIG_From_int(static_cast< int >(ampl::output::THEN)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "UNFIX",SWIG_From_int(static_cast< int >(ampl::output::UNFIX)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "UNLOAD",SWIG_From_int(static_cast< int >(ampl::output::UNLOAD)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "UPDATE",SWIG_From_int(static_cast< int >(ampl::output::UPDATE)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "WRITE",SWIG_From_int(static_cast< int >(ampl::output::WRITE)));
  
  /* type 'ampl::OutputHandler' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__OutputHandler_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'OutputHandler'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "OutputHandler", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "OutputHandler");
  d = md;
  
  /* type 'ampl::internal::EnvironmentIterator' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__internal__EnvironmentIterator_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'EnvironmentIterator'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "EnvironmentIterator", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "EnvironmentIterator");
  d = md;
  
  /* type 'ampl::Environment' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__Environment_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'Environment'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "Environment", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "Environment");
  d = md;
  
  /* type 'ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator >' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'EnvironmentIteratorTemplate'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "EnvironmentIteratorTemplate", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "EnvironmentIteratorTemplate");
  d = md;
  
  /* type 'ampl::AMPL' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__AMPL_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'AMPL'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "AMPL", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "AMPL");
  d = md;
#if PY_VERSION_HEX >= 0x03000000
  return m;
#else
  return;
#endif
}

