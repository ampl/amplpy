/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 3.0.8
 *
 * This file is not intended to be easily readable and contains a number of
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG
 * interface file instead.
 * ----------------------------------------------------------------------------- */

#ifdef _MSC_VER
#define SWIG_PYTHON_INTERPRETER_NO_DEBUG
#endif



#ifndef SWIGPYTHON
#define SWIGPYTHON
#endif

#define SWIG_DIRECTORS
#define SWIG_PYTHON_DIRECTOR_NO_VTABLE
#define SWIGPYTHON_BUILTIN


#ifdef __cplusplus
/* SwigValueWrapper is described in swig.swg */
template<typename T> class SwigValueWrapper {
  struct SwigMovePointer {
    T *ptr;
    SwigMovePointer(T *p) : ptr(p) { }
    ~SwigMovePointer() { delete ptr; }
    SwigMovePointer& operator=(SwigMovePointer& rhs) { T* oldptr = ptr; ptr = 0; delete oldptr; ptr = rhs.ptr; rhs.ptr = 0; return *this; }
  } pointer;
  SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
  SwigValueWrapper(const SwigValueWrapper<T>& rhs);
public:
  SwigValueWrapper() : pointer(0) { }
  SwigValueWrapper& operator=(const T& t) { SwigMovePointer tmp(new T(t)); pointer = tmp; return *this; }
  operator T&() const { return *pointer.ptr; }
  T *operator&() { return pointer.ptr; }
};

template <typename T> T SwigValueInit() {
  return T();
}
#endif

/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#  define SWIGTEMPLATEDISAMBIGUATOR template
# elif defined(__HP_aCC)
/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
#  define SWIGTEMPLATEDISAMBIGUATOR template
# else
#  define SWIGTEMPLATEDISAMBIGUATOR
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__))
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__))
# else
#   define SWIGUNUSED
# endif
#endif

#ifndef SWIG_MSC_UNSUPPRESS_4505
# if defined(_MSC_VER)
#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
# endif
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#  ifndef GCC_HASCLASSVISIBILITY
#    define GCC_HASCLASSVISIBILITY
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
# define _SCL_SECURE_NO_DEPRECATE
#endif

/* Deal with Apple's deprecated 'AssertMacros.h' from Carbon-framework */
#if defined(__APPLE__) && !defined(__ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES)
# define __ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES 0
#endif

/* Intel's compiler complains if a variable which was never initialised is
 * cast to void, which is a common idiom which we use to indicate that we
 * are aware a variable isn't used.  So we just silence that warning.
 * See: https://github.com/swig/swig/issues/192 for more discussion.
 */
#ifdef __INTEL_COMPILER
# pragma warning disable 592
#endif


#if defined(_DEBUG) && defined(SWIG_PYTHON_INTERPRETER_NO_DEBUG)
/* Use debug wrappers with the Python release dll */
# undef _DEBUG
# include <Python.h>
# define _DEBUG
#else
# include <Python.h>
#endif

/* -----------------------------------------------------------------------------
 * swigrun.swg
 *
 * This file contains generic C API SWIG runtime support for pointer
 * type checking.
 * ----------------------------------------------------------------------------- */

/* This should only be incremented when either the layout of swig_type_info changes,
   or for whatever reason, the runtime changes incompatibly */
#define SWIG_RUNTIME_VERSION "4"

/* define SWIG_TYPE_TABLE_NAME as "SWIG_TYPE_TABLE" */
#ifdef SWIG_TYPE_TABLE
# define SWIG_QUOTE_STRING(x) #x
# define SWIG_EXPAND_AND_QUOTE_STRING(x) SWIG_QUOTE_STRING(x)
# define SWIG_TYPE_TABLE_NAME SWIG_EXPAND_AND_QUOTE_STRING(SWIG_TYPE_TABLE)
#else
# define SWIG_TYPE_TABLE_NAME
#endif

/*
  You can use the SWIGRUNTIME and SWIGRUNTIMEINLINE macros for
  creating a static or dynamic library from the SWIG runtime code.
  In 99.9% of the cases, SWIG just needs to declare them as 'static'.

  But only do this if strictly necessary, ie, if you have problems
  with your compiler or suchlike.
*/

#ifndef SWIGRUNTIME
# define SWIGRUNTIME SWIGINTERN
#endif

#ifndef SWIGRUNTIMEINLINE
# define SWIGRUNTIMEINLINE SWIGRUNTIME SWIGINLINE
#endif

/*  Generic buffer size */
#ifndef SWIG_BUFFER_SIZE
# define SWIG_BUFFER_SIZE 1024
#endif

/* Flags for pointer conversions */
#define SWIG_POINTER_DISOWN        0x1
#define SWIG_CAST_NEW_MEMORY       0x2

/* Flags for new pointer objects */
#define SWIG_POINTER_OWN           0x1


/*
   Flags/methods for returning states.

   The SWIG conversion methods, as ConvertPtr, return an integer
   that tells if the conversion was successful or not. And if not,
   an error code can be returned (see swigerrors.swg for the codes).

   Use the following macros/flags to set or process the returning
   states.

   In old versions of SWIG, code such as the following was usually written:

     if (SWIG_ConvertPtr(obj,vptr,ty.flags) != -1) {
       // success code
     } else {
       //fail code
     }

   Now you can be more explicit:

    int res = SWIG_ConvertPtr(obj,vptr,ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
    } else {
      // fail code
    }

   which is the same really, but now you can also do

    Type *ptr;
    int res = SWIG_ConvertPtr(obj,(void **)(&ptr),ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
      if (SWIG_IsNewObj(res) {
        ...
	delete *ptr;
      } else {
        ...
      }
    } else {
      // fail code
    }

   I.e., now SWIG_ConvertPtr can return new objects and you can
   identify the case and take care of the deallocation. Of course that
   also requires SWIG_ConvertPtr to return new result values, such as

      int SWIG_ConvertPtr(obj, ptr,...) {
        if (<obj is ok>) {
          if (<need new object>) {
            *ptr = <ptr to new allocated object>;
            return SWIG_NEWOBJ;
          } else {
            *ptr = <ptr to old object>;
            return SWIG_OLDOBJ;
          }
        } else {
          return SWIG_BADOBJ;
        }
      }

   Of course, returning the plain '0(success)/-1(fail)' still works, but you can be
   more explicit by returning SWIG_BADOBJ, SWIG_ERROR or any of the
   SWIG errors code.

   Finally, if the SWIG_CASTRANK_MODE is enabled, the result code
   allows to return the 'cast rank', for example, if you have this

       int food(double)
       int fooi(int);

   and you call

      food(1)   // cast rank '1'  (1 -> 1.0)
      fooi(1)   // cast rank '0'

   just use the SWIG_AddCast()/SWIG_CheckState()
*/

#define SWIG_OK                    (0)
#define SWIG_ERROR                 (-1)
#define SWIG_IsOK(r)               (r >= 0)
#define SWIG_ArgError(r)           ((r != SWIG_ERROR) ? r : SWIG_TypeError)

/* The CastRankLimit says how many bits are used for the cast rank */
#define SWIG_CASTRANKLIMIT         (1 << 8)
/* The NewMask denotes the object was created (using new/malloc) */
#define SWIG_NEWOBJMASK            (SWIG_CASTRANKLIMIT  << 1)
/* The TmpMask is for in/out typemaps that use temporal objects */
#define SWIG_TMPOBJMASK            (SWIG_NEWOBJMASK << 1)
/* Simple returning values */
#define SWIG_BADOBJ                (SWIG_ERROR)
#define SWIG_OLDOBJ                (SWIG_OK)
#define SWIG_NEWOBJ                (SWIG_OK | SWIG_NEWOBJMASK)
#define SWIG_TMPOBJ                (SWIG_OK | SWIG_TMPOBJMASK)
/* Check, add and del mask methods */
#define SWIG_AddNewMask(r)         (SWIG_IsOK(r) ? (r | SWIG_NEWOBJMASK) : r)
#define SWIG_DelNewMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_NEWOBJMASK) : r)
#define SWIG_IsNewObj(r)           (SWIG_IsOK(r) && (r & SWIG_NEWOBJMASK))
#define SWIG_AddTmpMask(r)         (SWIG_IsOK(r) ? (r | SWIG_TMPOBJMASK) : r)
#define SWIG_DelTmpMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_TMPOBJMASK) : r)
#define SWIG_IsTmpObj(r)           (SWIG_IsOK(r) && (r & SWIG_TMPOBJMASK))

/* Cast-Rank Mode */
#if defined(SWIG_CASTRANK_MODE)
#  ifndef SWIG_TypeRank
#    define SWIG_TypeRank             unsigned long
#  endif
#  ifndef SWIG_MAXCASTRANK            /* Default cast allowed */
#    define SWIG_MAXCASTRANK          (2)
#  endif
#  define SWIG_CASTRANKMASK          ((SWIG_CASTRANKLIMIT) -1)
#  define SWIG_CastRank(r)           (r & SWIG_CASTRANKMASK)
SWIGINTERNINLINE int SWIG_AddCast(int r) {
  return SWIG_IsOK(r) ? ((SWIG_CastRank(r) < SWIG_MAXCASTRANK) ? (r + 1) : SWIG_ERROR) : r;
}
SWIGINTERNINLINE int SWIG_CheckState(int r) {
  return SWIG_IsOK(r) ? SWIG_CastRank(r) + 1 : 0;
}
#else /* no cast-rank mode */
#  define SWIG_AddCast(r) (r)
#  define SWIG_CheckState(r) (SWIG_IsOK(r) ? 1 : 0)
#endif


#include <string.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef void *(*swig_converter_func)(void *, int *);
typedef struct swig_type_info *(*swig_dycast_func)(void **);

/* Structure to store information on one type */
typedef struct swig_type_info {
  const char             *name;			/* mangled name of this type */
  const char             *str;			/* human readable name of this type */
  swig_dycast_func        dcast;		/* dynamic cast function down a hierarchy */
  struct swig_cast_info  *cast;			/* linked list of types that can cast into this type */
  void                   *clientdata;		/* language specific type data */
  int                    owndata;		/* flag if the structure owns the clientdata */
} swig_type_info;

/* Structure to store a type and conversion function used for casting */
typedef struct swig_cast_info {
  swig_type_info         *type;			/* pointer to type that is equivalent to this type */
  swig_converter_func     converter;		/* function to cast the void pointers */
  struct swig_cast_info  *next;			/* pointer to next cast in linked list */
  struct swig_cast_info  *prev;			/* pointer to the previous cast */
} swig_cast_info;

/* Structure used to store module information
 * Each module generates one structure like this, and the runtime collects
 * all of these structures and stores them in a circularly linked list.*/
typedef struct swig_module_info {
  swig_type_info         **types;		/* Array of pointers to swig_type_info structures that are in this module */
  size_t                 size;		        /* Number of types in this module */
  struct swig_module_info *next;		/* Pointer to next element in circularly linked list */
  swig_type_info         **type_initial;	/* Array of initially generated type structures */
  swig_cast_info         **cast_initial;	/* Array of initially generated casting structures */
  void                    *clientdata;		/* Language specific module data */
} swig_module_info;

/*
  Compare two type names skipping the space characters, therefore
  "char*" == "char *" and "Class<int>" == "Class<int >", etc.

  Return 0 when the two name types are equivalent, as in
  strncmp, but skipping ' '.
*/
SWIGRUNTIME int
SWIG_TypeNameComp(const char *f1, const char *l1,
		  const char *f2, const char *l2) {
  for (;(f1 != l1) && (f2 != l2); ++f1, ++f2) {
    while ((*f1 == ' ') && (f1 != l1)) ++f1;
    while ((*f2 == ' ') && (f2 != l2)) ++f2;
    if (*f1 != *f2) return (*f1 > *f2) ? 1 : -1;
  }
  return (int)((l1 - f1) - (l2 - f2));
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if equal, -1 if nb < tb, 1 if nb > tb
*/
SWIGRUNTIME int
SWIG_TypeCmp(const char *nb, const char *tb) {
  int equiv = 1;
  const char* te = tb + strlen(tb);
  const char* ne = nb;
  while (equiv != 0 && *ne) {
    for (nb = ne; *ne; ++ne) {
      if (*ne == '|') break;
    }
    equiv = SWIG_TypeNameComp(nb, ne, tb, te);
    if (*ne) ++ne;
  }
  return equiv;
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if not equal, 1 if equal
*/
SWIGRUNTIME int
SWIG_TypeEquiv(const char *nb, const char *tb) {
  return SWIG_TypeCmp(nb, tb) == 0 ? 1 : 0;
}

/*
  Check the typename
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheck(const char *c, swig_type_info *ty) {
  if (ty) {
    swig_cast_info *iter = ty->cast;
    while (iter) {
      if (strcmp(iter->type->name, c) == 0) {
        if (iter == ty->cast)
          return iter;
        /* Move iter to the top of the linked list */
        iter->prev->next = iter->next;
        if (iter->next)
          iter->next->prev = iter->prev;
        iter->next = ty->cast;
        iter->prev = 0;
        if (ty->cast) ty->cast->prev = iter;
        ty->cast = iter;
        return iter;
      }
      iter = iter->next;
    }
  }
  return 0;
}

/*
  Identical to SWIG_TypeCheck, except strcmp is replaced with a pointer comparison
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheckStruct(swig_type_info *from, swig_type_info *ty) {
  if (ty) {
    swig_cast_info *iter = ty->cast;
    while (iter) {
      if (iter->type == from) {
        if (iter == ty->cast)
          return iter;
        /* Move iter to the top of the linked list */
        iter->prev->next = iter->next;
        if (iter->next)
          iter->next->prev = iter->prev;
        iter->next = ty->cast;
        iter->prev = 0;
        if (ty->cast) ty->cast->prev = iter;
        ty->cast = iter;
        return iter;
      }
      iter = iter->next;
    }
  }
  return 0;
}

/*
  Cast a pointer up an inheritance hierarchy
*/
SWIGRUNTIMEINLINE void *
SWIG_TypeCast(swig_cast_info *ty, void *ptr, int *newmemory) {
  return ((!ty) || (!ty->converter)) ? ptr : (*ty->converter)(ptr, newmemory);
}

/*
   Dynamic pointer casting. Down an inheritance hierarchy
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
  swig_type_info *lastty = ty;
  if (!ty || !ty->dcast) return ty;
  while (ty && (ty->dcast)) {
    ty = (*ty->dcast)(ptr);
    if (ty) lastty = ty;
  }
  return lastty;
}

/*
  Return the name associated with this type
*/
SWIGRUNTIMEINLINE const char *
SWIG_TypeName(const swig_type_info *ty) {
  return ty->name;
}

/*
  Return the pretty name associated with this type,
  that is an unmangled type name in a form presentable to the user.
*/
SWIGRUNTIME const char *
SWIG_TypePrettyName(const swig_type_info *type) {
  /* The "str" field contains the equivalent pretty names of the
     type, separated by vertical-bar characters.  We choose
     to print the last name, as it is often (?) the most
     specific. */
  if (!type) return NULL;
  if (type->str != NULL) {
    const char *last_name = type->str;
    const char *s;
    for (s = type->str; *s; s++)
      if (*s == '|') last_name = s+1;
    return last_name;
  }
  else
    return type->name;
}

/*
   Set the clientdata field for a type
*/
SWIGRUNTIME void
SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
  swig_cast_info *cast = ti->cast;
  /* if (ti->clientdata == clientdata) return; */
  ti->clientdata = clientdata;

  while (cast) {
    if (!cast->converter) {
      swig_type_info *tc = cast->type;
      if (!tc->clientdata) {
	SWIG_TypeClientData(tc, clientdata);
      }
    }
    cast = cast->next;
  }
}
SWIGRUNTIME void
SWIG_TypeNewClientData(swig_type_info *ti, void *clientdata) {
  SWIG_TypeClientData(ti, clientdata);
  ti->owndata = 1;
}

/*
  Search for a swig_type_info structure only by mangled name
  Search is a O(log #types)

  We start searching at module start, and finish searching when start == end.
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_MangledTypeQueryModule(swig_module_info *start,
                            swig_module_info *end,
		            const char *name) {
  swig_module_info *iter = start;
  do {
    if (iter->size) {
      size_t l = 0;
      size_t r = iter->size - 1;
      do {
	/* since l+r >= 0, we can (>> 1) instead (/ 2) */
	size_t i = (l + r) >> 1;
	const char *iname = iter->types[i]->name;
	if (iname) {
	  int compare = strcmp(name, iname);
	  if (compare == 0) {
	    return iter->types[i];
	  } else if (compare < 0) {
	    if (i) {
	      r = i - 1;
	    } else {
	      break;
	    }
	  } else if (compare > 0) {
	    l = i + 1;
	  }
	} else {
	  break; /* should never happen */
	}
      } while (l <= r);
    }
    iter = iter->next;
  } while (iter != end);
  return 0;
}

/*
  Search for a swig_type_info structure for either a mangled name or a human readable name.
  It first searches the mangled names of the types, which is a O(log #types)
  If a type is not found it then searches the human readable names, which is O(#types).

  We start searching at module start, and finish searching when start == end.
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeQueryModule(swig_module_info *start,
                     swig_module_info *end,
		     const char *name) {
  /* STEP 1: Search the name field using binary search */
  swig_type_info *ret = SWIG_MangledTypeQueryModule(start, end, name);
  if (ret) {
    return ret;
  } else {
    /* STEP 2: If the type hasn't been found, do a complete search
       of the str field (the human readable name) */
    swig_module_info *iter = start;
    do {
      size_t i = 0;
      for (; i < iter->size; ++i) {
	if (iter->types[i]->str && (SWIG_TypeEquiv(iter->types[i]->str, name)))
	  return iter->types[i];
      }
      iter = iter->next;
    } while (iter != end);
  }

  /* neither found a match */
  return 0;
}

/*
   Pack binary data into a string
*/
SWIGRUNTIME char *
SWIG_PackData(char *c, void *ptr, size_t sz) {
  static const char hex[17] = "0123456789abcdef";
  const unsigned char *u = (unsigned char *) ptr;
  const unsigned char *eu =  u + sz;
  for (; u != eu; ++u) {
    unsigned char uu = *u;
    *(c++) = hex[(uu & 0xf0) >> 4];
    *(c++) = hex[uu & 0xf];
  }
  return c;
}

/*
   Unpack binary data from a string
*/
SWIGRUNTIME const char *
SWIG_UnpackData(const char *c, void *ptr, size_t sz) {
  unsigned char *u = (unsigned char *) ptr;
  const unsigned char *eu = u + sz;
  for (; u != eu; ++u) {
    char d = *(c++);
    unsigned char uu;
    if ((d >= '0') && (d <= '9'))
      uu = ((d - '0') << 4);
    else if ((d >= 'a') && (d <= 'f'))
      uu = ((d - ('a'-10)) << 4);
    else
      return (char *) 0;
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu |= (d - '0');
    else if ((d >= 'a') && (d <= 'f'))
      uu |= (d - ('a'-10));
    else
      return (char *) 0;
    *u = uu;
  }
  return c;
}

/*
   Pack 'void *' into a string buffer.
*/
SWIGRUNTIME char *
SWIG_PackVoidPtr(char *buff, void *ptr, const char *name, size_t bsz) {
  char *r = buff;
  if ((2*sizeof(void *) + 2) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,&ptr,sizeof(void *));
  if (strlen(name) + 1 > (bsz - (r - buff))) return 0;
  strcpy(r,name);
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackVoidPtr(const char *c, void **ptr, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      *ptr = (void *) 0;
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sizeof(void *));
}

SWIGRUNTIME char *
SWIG_PackDataName(char *buff, void *ptr, size_t sz, const char *name, size_t bsz) {
  char *r = buff;
  size_t lname = (name ? strlen(name) : 0);
  if ((2*sz + 2 + lname) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,ptr,sz);
  if (lname) {
    strncpy(r,name,lname+1);
  } else {
    *r = 0;
  }
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackDataName(const char *c, void *ptr, size_t sz, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      memset(ptr,0,sz);
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sz);
}

#ifdef __cplusplus
}
#endif

/*  Errors in SWIG */
#define  SWIG_UnknownError    	   -1
#define  SWIG_IOError        	   -2
#define  SWIG_RuntimeError   	   -3
#define  SWIG_IndexError     	   -4
#define  SWIG_TypeError      	   -5
#define  SWIG_DivisionByZero 	   -6
#define  SWIG_OverflowError  	   -7
#define  SWIG_SyntaxError    	   -8
#define  SWIG_ValueError     	   -9
#define  SWIG_SystemError    	   -10
#define  SWIG_AttributeError 	   -11
#define  SWIG_MemoryError    	   -12
#define  SWIG_NullReferenceError   -13



/* Compatibility macros for Python 3 */
#if PY_VERSION_HEX >= 0x03000000

#define PyClass_Check(obj) PyObject_IsInstance(obj, (PyObject *)&PyType_Type)
#define PyInt_Check(x) PyLong_Check(x)
#define PyInt_AsLong(x) PyLong_AsLong(x)
#define PyInt_FromLong(x) PyLong_FromLong(x)
#define PyInt_FromSize_t(x) PyLong_FromSize_t(x)
#define PyString_Check(name) PyBytes_Check(name)
#define PyString_FromString(x) PyUnicode_FromString(x)
#define PyString_Format(fmt, args)  PyUnicode_Format(fmt, args)
#define PyString_AsString(str) PyBytes_AsString(str)
#define PyString_Size(str) PyBytes_Size(str)	
#define PyString_InternFromString(key) PyUnicode_InternFromString(key)
#define Py_TPFLAGS_HAVE_CLASS Py_TPFLAGS_BASETYPE
#define PyString_AS_STRING(x) PyUnicode_AS_STRING(x)
#define _PyLong_FromSsize_t(x) PyLong_FromSsize_t(x)

#endif

#ifndef Py_TYPE
#  define Py_TYPE(op) ((op)->ob_type)
#endif

/* SWIG APIs for compatibility of both Python 2 & 3 */

#if PY_VERSION_HEX >= 0x03000000
#  define SWIG_Python_str_FromFormat PyUnicode_FromFormat
#else
#  define SWIG_Python_str_FromFormat PyString_FromFormat
#endif


/* Warning: This function will allocate a new string in Python 3,
 * so please call SWIG_Python_str_DelForPy3(x) to free the space.
 */
SWIGINTERN char*
SWIG_Python_str_AsChar(PyObject *str)
{
#if PY_VERSION_HEX >= 0x03000000
  char *cstr;
  char *newstr;
  Py_ssize_t len;
  str = PyUnicode_AsUTF8String(str);
  PyBytes_AsStringAndSize(str, &cstr, &len);
  newstr = (char *) malloc(len+1);
  memcpy(newstr, cstr, len+1);
  Py_XDECREF(str);
  return newstr;
#else
  return PyString_AsString(str);
#endif
}

#if PY_VERSION_HEX >= 0x03000000
#  define SWIG_Python_str_DelForPy3(x) free( (void*) (x) )
#else
#  define SWIG_Python_str_DelForPy3(x) 
#endif


SWIGINTERN PyObject*
SWIG_Python_str_FromChar(const char *c)
{
#if PY_VERSION_HEX >= 0x03000000
  return PyUnicode_FromString(c); 
#else
  return PyString_FromString(c);
#endif
}

/* Add PyOS_snprintf for old Pythons */
#if PY_VERSION_HEX < 0x02020000
# if defined(_MSC_VER) || defined(__BORLANDC__) || defined(_WATCOM)
#  define PyOS_snprintf _snprintf
# else
#  define PyOS_snprintf snprintf
# endif
#endif

/* A crude PyString_FromFormat implementation for old Pythons */
#if PY_VERSION_HEX < 0x02020000

#ifndef SWIG_PYBUFFER_SIZE
# define SWIG_PYBUFFER_SIZE 1024
#endif

static PyObject *
PyString_FromFormat(const char *fmt, ...) {
  va_list ap;
  char buf[SWIG_PYBUFFER_SIZE * 2];
  int res;
  va_start(ap, fmt);
  res = vsnprintf(buf, sizeof(buf), fmt, ap);
  va_end(ap);
  return (res < 0 || res >= (int)sizeof(buf)) ? 0 : PyString_FromString(buf);
}
#endif

/* Add PyObject_Del for old Pythons */
#if PY_VERSION_HEX < 0x01060000
# define PyObject_Del(op) PyMem_DEL((op))
#endif
#ifndef PyObject_DEL
# define PyObject_DEL PyObject_Del
#endif

/* A crude PyExc_StopIteration exception for old Pythons */
#if PY_VERSION_HEX < 0x02020000
# ifndef PyExc_StopIteration
#  define PyExc_StopIteration PyExc_RuntimeError
# endif
# ifndef PyObject_GenericGetAttr
#  define PyObject_GenericGetAttr 0
# endif
#endif

/* Py_NotImplemented is defined in 2.1 and up. */
#if PY_VERSION_HEX < 0x02010000
# ifndef Py_NotImplemented
#  define Py_NotImplemented PyExc_RuntimeError
# endif
#endif

/* A crude PyString_AsStringAndSize implementation for old Pythons */
#if PY_VERSION_HEX < 0x02010000
# ifndef PyString_AsStringAndSize
#  define PyString_AsStringAndSize(obj, s, len) {*s = PyString_AsString(obj); *len = *s ? strlen(*s) : 0;}
# endif
#endif

/* PySequence_Size for old Pythons */
#if PY_VERSION_HEX < 0x02000000
# ifndef PySequence_Size
#  define PySequence_Size PySequence_Length
# endif
#endif

/* PyBool_FromLong for old Pythons */
#if PY_VERSION_HEX < 0x02030000
static
PyObject *PyBool_FromLong(long ok)
{
  PyObject *result = ok ? Py_True : Py_False;
  Py_INCREF(result);
  return result;
}
#endif

/* Py_ssize_t for old Pythons */
/* This code is as recommended by: */
/* http://www.python.org/dev/peps/pep-0353/#conversion-guidelines */
#if PY_VERSION_HEX < 0x02050000 && !defined(PY_SSIZE_T_MIN)
typedef int Py_ssize_t;
# define PY_SSIZE_T_MAX INT_MAX
# define PY_SSIZE_T_MIN INT_MIN
typedef inquiry lenfunc;
typedef intargfunc ssizeargfunc;
typedef intintargfunc ssizessizeargfunc;
typedef intobjargproc ssizeobjargproc;
typedef intintobjargproc ssizessizeobjargproc;
typedef getreadbufferproc readbufferproc;
typedef getwritebufferproc writebufferproc;
typedef getsegcountproc segcountproc;
typedef getcharbufferproc charbufferproc;
static long PyNumber_AsSsize_t (PyObject *x, void *SWIGUNUSEDPARM(exc))
{
  long result = 0;
  PyObject *i = PyNumber_Int(x);
  if (i) {
    result = PyInt_AsLong(i);
    Py_DECREF(i);
  }
  return result;
}
#endif

#if PY_VERSION_HEX < 0x02050000
#define PyInt_FromSize_t(x) PyInt_FromLong((long)x)
#endif

#if PY_VERSION_HEX < 0x02040000
#define Py_VISIT(op)				\
  do { 						\
    if (op) {					\
      int vret = visit((op), arg);		\
      if (vret)					\
        return vret;				\
    }						\
  } while (0)
#endif

#if PY_VERSION_HEX < 0x02030000
typedef struct {
  PyTypeObject type;
  PyNumberMethods as_number;
  PyMappingMethods as_mapping;
  PySequenceMethods as_sequence;
  PyBufferProcs as_buffer;
  PyObject *name, *slots;
} PyHeapTypeObject;
#endif

#if PY_VERSION_HEX < 0x02030000
typedef destructor freefunc;
#endif

#if ((PY_MAJOR_VERSION == 2 && PY_MINOR_VERSION > 6) || \
     (PY_MAJOR_VERSION == 3 && PY_MINOR_VERSION > 0) || \
     (PY_MAJOR_VERSION > 3))
# define SWIGPY_USE_CAPSULE
# define SWIGPY_CAPSULE_NAME ((char*)"swig_runtime_data" SWIG_RUNTIME_VERSION ".type_pointer_capsule" SWIG_TYPE_TABLE_NAME)
#endif

#if PY_VERSION_HEX < 0x03020000
#define PyDescr_TYPE(x) (((PyDescrObject *)(x))->d_type)
#define PyDescr_NAME(x) (((PyDescrObject *)(x))->d_name)
#endif

/* -----------------------------------------------------------------------------
 * error manipulation
 * ----------------------------------------------------------------------------- */

SWIGRUNTIME PyObject*
SWIG_Python_ErrorType(int code) {
  PyObject* type = 0;
  switch(code) {
  case SWIG_MemoryError:
    type = PyExc_MemoryError;
    break;
  case SWIG_IOError:
    type = PyExc_IOError;
    break;
  case SWIG_RuntimeError:
    type = PyExc_RuntimeError;
    break;
  case SWIG_IndexError:
    type = PyExc_IndexError;
    break;
  case SWIG_TypeError:
    type = PyExc_TypeError;
    break;
  case SWIG_DivisionByZero:
    type = PyExc_ZeroDivisionError;
    break;
  case SWIG_OverflowError:
    type = PyExc_OverflowError;
    break;
  case SWIG_SyntaxError:
    type = PyExc_SyntaxError;
    break;
  case SWIG_ValueError:
    type = PyExc_ValueError;
    break;
  case SWIG_SystemError:
    type = PyExc_SystemError;
    break;
  case SWIG_AttributeError:
    type = PyExc_AttributeError;
    break;
  default:
    type = PyExc_RuntimeError;
  }
  return type;
}


SWIGRUNTIME void
SWIG_Python_AddErrorMsg(const char* mesg)
{
  PyObject *type = 0;
  PyObject *value = 0;
  PyObject *traceback = 0;

  if (PyErr_Occurred()) PyErr_Fetch(&type, &value, &traceback);
  if (value) {
    char *tmp;
    PyObject *old_str = PyObject_Str(value);
    PyErr_Clear();
    Py_XINCREF(type);

    PyErr_Format(type, "%s %s", tmp = SWIG_Python_str_AsChar(old_str), mesg);
    SWIG_Python_str_DelForPy3(tmp);
    Py_DECREF(old_str);
    Py_DECREF(value);
  } else {
    PyErr_SetString(PyExc_RuntimeError, mesg);
  }
}

#if defined(SWIG_PYTHON_NO_THREADS)
#  if defined(SWIG_PYTHON_THREADS)
#    undef SWIG_PYTHON_THREADS
#  endif
#endif
#if defined(SWIG_PYTHON_THREADS) /* Threading support is enabled */
#  if !defined(SWIG_PYTHON_USE_GIL) && !defined(SWIG_PYTHON_NO_USE_GIL)
#    if (PY_VERSION_HEX >= 0x02030000) /* For 2.3 or later, use the PyGILState calls */
#      define SWIG_PYTHON_USE_GIL
#    endif
#  endif
#  if defined(SWIG_PYTHON_USE_GIL) /* Use PyGILState threads calls */
#    ifndef SWIG_PYTHON_INITIALIZE_THREADS
#     define SWIG_PYTHON_INITIALIZE_THREADS  PyEval_InitThreads() 
#    endif
#    ifdef __cplusplus /* C++ code */
       class SWIG_Python_Thread_Block {
         bool status;
         PyGILState_STATE state;
       public:
         void end() { if (status) { PyGILState_Release(state); status = false;} }
         SWIG_Python_Thread_Block() : status(true), state(PyGILState_Ensure()) {}
         ~SWIG_Python_Thread_Block() { end(); }
       };
       class SWIG_Python_Thread_Allow {
         bool status;
         PyThreadState *save;
       public:
         void end() { if (status) { PyEval_RestoreThread(save); status = false; }}
         SWIG_Python_Thread_Allow() : status(true), save(PyEval_SaveThread()) {}
         ~SWIG_Python_Thread_Allow() { end(); }
       };
#      define SWIG_PYTHON_THREAD_BEGIN_BLOCK   SWIG_Python_Thread_Block _swig_thread_block
#      define SWIG_PYTHON_THREAD_END_BLOCK     _swig_thread_block.end()
#      define SWIG_PYTHON_THREAD_BEGIN_ALLOW   SWIG_Python_Thread_Allow _swig_thread_allow
#      define SWIG_PYTHON_THREAD_END_ALLOW     _swig_thread_allow.end()
#    else /* C code */
#      define SWIG_PYTHON_THREAD_BEGIN_BLOCK   PyGILState_STATE _swig_thread_block = PyGILState_Ensure()
#      define SWIG_PYTHON_THREAD_END_BLOCK     PyGILState_Release(_swig_thread_block)
#      define SWIG_PYTHON_THREAD_BEGIN_ALLOW   PyThreadState *_swig_thread_allow = PyEval_SaveThread()
#      define SWIG_PYTHON_THREAD_END_ALLOW     PyEval_RestoreThread(_swig_thread_allow)
#    endif
#  else /* Old thread way, not implemented, user must provide it */
#    if !defined(SWIG_PYTHON_INITIALIZE_THREADS)
#      define SWIG_PYTHON_INITIALIZE_THREADS
#    endif
#    if !defined(SWIG_PYTHON_THREAD_BEGIN_BLOCK)
#      define SWIG_PYTHON_THREAD_BEGIN_BLOCK
#    endif
#    if !defined(SWIG_PYTHON_THREAD_END_BLOCK)
#      define SWIG_PYTHON_THREAD_END_BLOCK
#    endif
#    if !defined(SWIG_PYTHON_THREAD_BEGIN_ALLOW)
#      define SWIG_PYTHON_THREAD_BEGIN_ALLOW
#    endif
#    if !defined(SWIG_PYTHON_THREAD_END_ALLOW)
#      define SWIG_PYTHON_THREAD_END_ALLOW
#    endif
#  endif
#else /* No thread support */
#  define SWIG_PYTHON_INITIALIZE_THREADS
#  define SWIG_PYTHON_THREAD_BEGIN_BLOCK
#  define SWIG_PYTHON_THREAD_END_BLOCK
#  define SWIG_PYTHON_THREAD_BEGIN_ALLOW
#  define SWIG_PYTHON_THREAD_END_ALLOW
#endif

/* -----------------------------------------------------------------------------
 * Python API portion that goes into the runtime
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#endif

/* -----------------------------------------------------------------------------
 * Constant declarations
 * ----------------------------------------------------------------------------- */

/* Constant Types */
#define SWIG_PY_POINTER 4
#define SWIG_PY_BINARY  5

/* Constant information structure */
typedef struct swig_const_info {
  int type;
  char *name;
  long lvalue;
  double dvalue;
  void   *pvalue;
  swig_type_info **ptype;
} swig_const_info;


/* -----------------------------------------------------------------------------
 * Wrapper of PyInstanceMethod_New() used in Python 3
 * It is exported to the generated module, used for -fastproxy
 * ----------------------------------------------------------------------------- */
#if PY_VERSION_HEX >= 0x03000000
SWIGRUNTIME PyObject* SWIG_PyInstanceMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *func)
{
  return PyInstanceMethod_New(func);
}
#else
SWIGRUNTIME PyObject* SWIG_PyInstanceMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *SWIGUNUSEDPARM(func))
{
  return NULL;
}
#endif

#ifdef __cplusplus
}
#endif


/* -----------------------------------------------------------------------------
 * pyrun.swg
 *
 * This file contains the runtime support for Python modules
 * and includes code for managing global variables and pointer
 * type checking.
 *
 * ----------------------------------------------------------------------------- */

/* Common SWIG API */

/* for raw pointers */
#define SWIG_Python_ConvertPtr(obj, pptr, type, flags)  SWIG_Python_ConvertPtrAndOwn(obj, pptr, type, flags, 0)
#define SWIG_ConvertPtr(obj, pptr, type, flags)         SWIG_Python_ConvertPtr(obj, pptr, type, flags)
#define SWIG_ConvertPtrAndOwn(obj,pptr,type,flags,own)  SWIG_Python_ConvertPtrAndOwn(obj, pptr, type, flags, own)

#ifdef SWIGPYTHON_BUILTIN
#define SWIG_NewPointerObj(ptr, type, flags)            SWIG_Python_NewPointerObj(self, ptr, type, flags)
#else
#define SWIG_NewPointerObj(ptr, type, flags)            SWIG_Python_NewPointerObj(NULL, ptr, type, flags)
#endif

#define SWIG_InternalNewPointerObj(ptr, type, flags)	SWIG_Python_NewPointerObj(NULL, ptr, type, flags)

#define SWIG_CheckImplicit(ty)                          SWIG_Python_CheckImplicit(ty) 
#define SWIG_AcquirePtr(ptr, src)                       SWIG_Python_AcquirePtr(ptr, src)
#define swig_owntype                                    int

/* for raw packed data */
#define SWIG_ConvertPacked(obj, ptr, sz, ty)            SWIG_Python_ConvertPacked(obj, ptr, sz, ty)
#define SWIG_NewPackedObj(ptr, sz, type)                SWIG_Python_NewPackedObj(ptr, sz, type)

/* for class or struct pointers */
#define SWIG_ConvertInstance(obj, pptr, type, flags)    SWIG_ConvertPtr(obj, pptr, type, flags)
#define SWIG_NewInstanceObj(ptr, type, flags)           SWIG_NewPointerObj(ptr, type, flags)

/* for C or C++ function pointers */
#define SWIG_ConvertFunctionPtr(obj, pptr, type)        SWIG_Python_ConvertFunctionPtr(obj, pptr, type)
#define SWIG_NewFunctionPtrObj(ptr, type)               SWIG_Python_NewPointerObj(NULL, ptr, type, 0)

/* for C++ member pointers, ie, member methods */
#define SWIG_ConvertMember(obj, ptr, sz, ty)            SWIG_Python_ConvertPacked(obj, ptr, sz, ty)
#define SWIG_NewMemberObj(ptr, sz, type)                SWIG_Python_NewPackedObj(ptr, sz, type)


/* Runtime API */

#define SWIG_GetModule(clientdata)                      SWIG_Python_GetModule(clientdata)
#define SWIG_SetModule(clientdata, pointer)             SWIG_Python_SetModule(pointer)
#define SWIG_NewClientData(obj)                         SwigPyClientData_New(obj)

#define SWIG_SetErrorObj                                SWIG_Python_SetErrorObj                            
#define SWIG_SetErrorMsg                        	SWIG_Python_SetErrorMsg				   
#define SWIG_ErrorType(code)                    	SWIG_Python_ErrorType(code)                        
#define SWIG_Error(code, msg)            		SWIG_Python_SetErrorMsg(SWIG_ErrorType(code), msg) 
#define SWIG_fail                        		goto fail					   


/* Runtime API implementation */

/* Error manipulation */

SWIGINTERN void 
SWIG_Python_SetErrorObj(PyObject *errtype, PyObject *obj) {
  SWIG_PYTHON_THREAD_BEGIN_BLOCK; 
  PyErr_SetObject(errtype, obj);
  Py_DECREF(obj);
  SWIG_PYTHON_THREAD_END_BLOCK;
}

SWIGINTERN void 
SWIG_Python_SetErrorMsg(PyObject *errtype, const char *msg) {
  SWIG_PYTHON_THREAD_BEGIN_BLOCK;
  PyErr_SetString(errtype, msg);
  SWIG_PYTHON_THREAD_END_BLOCK;
}

#define SWIG_Python_Raise(obj, type, desc)  SWIG_Python_SetErrorObj(SWIG_Python_ExceptionType(desc), obj)

/* Set a constant value */

#if defined(SWIGPYTHON_BUILTIN)

SWIGINTERN void
SwigPyBuiltin_AddPublicSymbol(PyObject *seq, const char *key) {
  PyObject *s = PyString_InternFromString(key);
  PyList_Append(seq, s);
  Py_DECREF(s);
}

SWIGINTERN void
SWIG_Python_SetConstant(PyObject *d, PyObject *public_interface, const char *name, PyObject *obj) {   
#if PY_VERSION_HEX < 0x02030000
  PyDict_SetItemString(d, (char *)name, obj);
#else
  PyDict_SetItemString(d, name, obj);
#endif
  Py_DECREF(obj);
  if (public_interface)
    SwigPyBuiltin_AddPublicSymbol(public_interface, name);
}

#else

SWIGINTERN void
SWIG_Python_SetConstant(PyObject *d, const char *name, PyObject *obj) {   
#if PY_VERSION_HEX < 0x02030000
  PyDict_SetItemString(d, (char *)name, obj);
#else
  PyDict_SetItemString(d, name, obj);
#endif
  Py_DECREF(obj);                            
}

#endif

/* Append a value to the result obj */

SWIGINTERN PyObject*
SWIG_Python_AppendOutput(PyObject* result, PyObject* obj) {
#if !defined(SWIG_PYTHON_OUTPUT_TUPLE)
  if (!result) {
    result = obj;
  } else if (result == Py_None) {
    Py_DECREF(result);
    result = obj;
  } else {
    if (!PyList_Check(result)) {
      PyObject *o2 = result;
      result = PyList_New(1);
      PyList_SetItem(result, 0, o2);
    }
    PyList_Append(result,obj);
    Py_DECREF(obj);
  }
  return result;
#else
  PyObject*   o2;
  PyObject*   o3;
  if (!result) {
    result = obj;
  } else if (result == Py_None) {
    Py_DECREF(result);
    result = obj;
  } else {
    if (!PyTuple_Check(result)) {
      o2 = result;
      result = PyTuple_New(1);
      PyTuple_SET_ITEM(result, 0, o2);
    }
    o3 = PyTuple_New(1);
    PyTuple_SET_ITEM(o3, 0, obj);
    o2 = result;
    result = PySequence_Concat(o2, o3);
    Py_DECREF(o2);
    Py_DECREF(o3);
  }
  return result;
#endif
}

/* Unpack the argument tuple */

SWIGINTERN Py_ssize_t
SWIG_Python_UnpackTuple(PyObject *args, const char *name, Py_ssize_t min, Py_ssize_t max, PyObject **objs)
{
  if (!args) {
    if (!min && !max) {
      return 1;
    } else {
      PyErr_Format(PyExc_TypeError, "%s expected %s%d arguments, got none", 
		   name, (min == max ? "" : "at least "), (int)min);
      return 0;
    }
  }  
  if (!PyTuple_Check(args)) {
    if (min <= 1 && max >= 1) {
      Py_ssize_t i;
      objs[0] = args;
      for (i = 1; i < max; ++i) {
	objs[i] = 0;
      }
      return 2;
    }
    PyErr_SetString(PyExc_SystemError, "UnpackTuple() argument list is not a tuple");
    return 0;
  } else {
    Py_ssize_t l = PyTuple_GET_SIZE(args);
    if (l < min) {
      PyErr_Format(PyExc_TypeError, "%s expected %s%d arguments, got %d", 
		   name, (min == max ? "" : "at least "), (int)min, (int)l);
      return 0;
    } else if (l > max) {
      PyErr_Format(PyExc_TypeError, "%s expected %s%d arguments, got %d", 
		   name, (min == max ? "" : "at most "), (int)max, (int)l);
      return 0;
    } else {
      Py_ssize_t i;
      for (i = 0; i < l; ++i) {
	objs[i] = PyTuple_GET_ITEM(args, i);
      }
      for (; l < max; ++l) {
	objs[l] = 0;
      }
      return i + 1;
    }    
  }
}

/* A functor is a function object with one single object argument */
#if PY_VERSION_HEX >= 0x02020000
#define SWIG_Python_CallFunctor(functor, obj)	        PyObject_CallFunctionObjArgs(functor, obj, NULL);
#else
#define SWIG_Python_CallFunctor(functor, obj)	        PyObject_CallFunction(functor, "O", obj);
#endif

/*
  Helper for static pointer initialization for both C and C++ code, for example
  static PyObject *SWIG_STATIC_POINTER(MyVar) = NewSomething(...);
*/
#ifdef __cplusplus
#define SWIG_STATIC_POINTER(var)  var
#else
#define SWIG_STATIC_POINTER(var)  var = 0; if (!var) var
#endif

/* -----------------------------------------------------------------------------
 * Pointer declarations
 * ----------------------------------------------------------------------------- */

/* Flags for new pointer objects */
#define SWIG_POINTER_NOSHADOW       (SWIG_POINTER_OWN      << 1)
#define SWIG_POINTER_NEW            (SWIG_POINTER_NOSHADOW | SWIG_POINTER_OWN)

#define SWIG_POINTER_IMPLICIT_CONV  (SWIG_POINTER_DISOWN   << 1)

#define SWIG_BUILTIN_TP_INIT	    (SWIG_POINTER_OWN << 2)
#define SWIG_BUILTIN_INIT	    (SWIG_BUILTIN_TP_INIT | SWIG_POINTER_OWN)

#ifdef __cplusplus
extern "C" {
#endif

/*  How to access Py_None */
#if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#  ifndef SWIG_PYTHON_NO_BUILD_NONE
#    ifndef SWIG_PYTHON_BUILD_NONE
#      define SWIG_PYTHON_BUILD_NONE
#    endif
#  endif
#endif

#ifdef SWIG_PYTHON_BUILD_NONE
#  ifdef Py_None
#   undef Py_None
#   define Py_None SWIG_Py_None()
#  endif
SWIGRUNTIMEINLINE PyObject * 
_SWIG_Py_None(void)
{
  PyObject *none = Py_BuildValue((char*)"");
  Py_DECREF(none);
  return none;
}
SWIGRUNTIME PyObject * 
SWIG_Py_None(void)
{
  static PyObject *SWIG_STATIC_POINTER(none) = _SWIG_Py_None();
  return none;
}
#endif

/* The python void return value */

SWIGRUNTIMEINLINE PyObject * 
SWIG_Py_Void(void)
{
  PyObject *none = Py_None;
  Py_INCREF(none);
  return none;
}

/* SwigPyClientData */

typedef struct {
  PyObject *klass;
  PyObject *newraw;
  PyObject *newargs;
  PyObject *destroy;
  int delargs;
  int implicitconv;
  PyTypeObject *pytype;
} SwigPyClientData;

SWIGRUNTIMEINLINE int 
SWIG_Python_CheckImplicit(swig_type_info *ty)
{
  SwigPyClientData *data = (SwigPyClientData *)ty->clientdata;
  return data ? data->implicitconv : 0;
}

SWIGRUNTIMEINLINE PyObject *
SWIG_Python_ExceptionType(swig_type_info *desc) {
  SwigPyClientData *data = desc ? (SwigPyClientData *) desc->clientdata : 0;
  PyObject *klass = data ? data->klass : 0;
  return (klass ? klass : PyExc_RuntimeError);
}


SWIGRUNTIME SwigPyClientData * 
SwigPyClientData_New(PyObject* obj)
{
  if (!obj) {
    return 0;
  } else {
    SwigPyClientData *data = (SwigPyClientData *)malloc(sizeof(SwigPyClientData));
    /* the klass element */
    data->klass = obj;
    Py_INCREF(data->klass);
    /* the newraw method and newargs arguments used to create a new raw instance */
    if (PyClass_Check(obj)) {
      data->newraw = 0;
      data->newargs = obj;
      Py_INCREF(obj);
    } else {
#if (PY_VERSION_HEX < 0x02020000)
      data->newraw = 0;
#else
      data->newraw = PyObject_GetAttrString(data->klass, (char *)"__new__");
#endif
      if (data->newraw) {
	Py_INCREF(data->newraw);
	data->newargs = PyTuple_New(1);
	PyTuple_SetItem(data->newargs, 0, obj);
      } else {
	data->newargs = obj;
      }
      Py_INCREF(data->newargs);
    }
    /* the destroy method, aka as the C++ delete method */
    data->destroy = PyObject_GetAttrString(data->klass, (char *)"__swig_destroy__");
    if (PyErr_Occurred()) {
      PyErr_Clear();
      data->destroy = 0;
    }
    if (data->destroy) {
      int flags;
      Py_INCREF(data->destroy);
      flags = PyCFunction_GET_FLAGS(data->destroy);
#ifdef METH_O
      data->delargs = !(flags & (METH_O));
#else
      data->delargs = 0;
#endif
    } else {
      data->delargs = 0;
    }
    data->implicitconv = 0;
    data->pytype = 0;
    return data;
  }
}

SWIGRUNTIME void 
SwigPyClientData_Del(SwigPyClientData *data) {
  Py_XDECREF(data->newraw);
  Py_XDECREF(data->newargs);
  Py_XDECREF(data->destroy);
}

/* =============== SwigPyObject =====================*/

typedef struct {
  PyObject_HEAD
  void *ptr;
  swig_type_info *ty;
  int own;
  PyObject *next;
#ifdef SWIGPYTHON_BUILTIN
  PyObject *dict;
#endif
} SwigPyObject;


#ifdef SWIGPYTHON_BUILTIN

SWIGRUNTIME PyObject *
SwigPyObject_get___dict__(PyObject *v, PyObject *SWIGUNUSEDPARM(args))
{
  SwigPyObject *sobj = (SwigPyObject *)v;

  if (!sobj->dict)
    sobj->dict = PyDict_New();

  Py_INCREF(sobj->dict);
  return sobj->dict;
}

#endif

SWIGRUNTIME PyObject *
SwigPyObject_long(SwigPyObject *v)
{
  return PyLong_FromVoidPtr(v->ptr);
}

SWIGRUNTIME PyObject *
SwigPyObject_format(const char* fmt, SwigPyObject *v)
{
  PyObject *res = NULL;
  PyObject *args = PyTuple_New(1);
  if (args) {
    if (PyTuple_SetItem(args, 0, SwigPyObject_long(v)) == 0) {
      PyObject *ofmt = SWIG_Python_str_FromChar(fmt);
      if (ofmt) {
#if PY_VERSION_HEX >= 0x03000000
	res = PyUnicode_Format(ofmt,args);
#else
	res = PyString_Format(ofmt,args);
#endif
	Py_DECREF(ofmt);
      }
      Py_DECREF(args);
    }
  }
  return res;
}

SWIGRUNTIME PyObject *
SwigPyObject_oct(SwigPyObject *v)
{
  return SwigPyObject_format("%o",v);
}

SWIGRUNTIME PyObject *
SwigPyObject_hex(SwigPyObject *v)
{
  return SwigPyObject_format("%x",v);
}

SWIGRUNTIME PyObject *
#ifdef METH_NOARGS
SwigPyObject_repr(SwigPyObject *v)
#else
SwigPyObject_repr(SwigPyObject *v, PyObject *args)
#endif
{
  const char *name = SWIG_TypePrettyName(v->ty);
  PyObject *repr = SWIG_Python_str_FromFormat("<Swig Object of type '%s' at %p>", (name ? name : "unknown"), (void *)v);
  if (v->next) {
# ifdef METH_NOARGS
    PyObject *nrep = SwigPyObject_repr((SwigPyObject *)v->next);
# else
    PyObject *nrep = SwigPyObject_repr((SwigPyObject *)v->next, args);
# endif
# if PY_VERSION_HEX >= 0x03000000
    PyObject *joined = PyUnicode_Concat(repr, nrep);
    Py_DecRef(repr);
    Py_DecRef(nrep);
    repr = joined;
# else
    PyString_ConcatAndDel(&repr,nrep);
# endif
  }
  return repr;  
}

SWIGRUNTIME int
SwigPyObject_compare(SwigPyObject *v, SwigPyObject *w)
{
  void *i = v->ptr;
  void *j = w->ptr;
  return (i < j) ? -1 : ((i > j) ? 1 : 0);
}

/* Added for Python 3.x, would it also be useful for Python 2.x? */
SWIGRUNTIME PyObject*
SwigPyObject_richcompare(SwigPyObject *v, SwigPyObject *w, int op)
{
  PyObject* res;
  if( op != Py_EQ && op != Py_NE ) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  res = PyBool_FromLong( (SwigPyObject_compare(v, w)==0) == (op == Py_EQ) ? 1 : 0);
  return res;  
}


SWIGRUNTIME PyTypeObject* SwigPyObject_TypeOnce(void);

#ifdef SWIGPYTHON_BUILTIN
static swig_type_info *SwigPyObject_stype = 0;
SWIGRUNTIME PyTypeObject*
SwigPyObject_type(void) {
    SwigPyClientData *cd;
    assert(SwigPyObject_stype);
    cd = (SwigPyClientData*) SwigPyObject_stype->clientdata;
    assert(cd);
    assert(cd->pytype);
    return cd->pytype;
}
#else
SWIGRUNTIME PyTypeObject*
SwigPyObject_type(void) {
  static PyTypeObject *SWIG_STATIC_POINTER(type) = SwigPyObject_TypeOnce();
  return type;
}
#endif

SWIGRUNTIMEINLINE int
SwigPyObject_Check(PyObject *op) {
#ifdef SWIGPYTHON_BUILTIN
  PyTypeObject *target_tp = SwigPyObject_type();
  if (PyType_IsSubtype(op->ob_type, target_tp))
    return 1;
  return (strcmp(op->ob_type->tp_name, "SwigPyObject") == 0);
#else
  return (Py_TYPE(op) == SwigPyObject_type())
    || (strcmp(Py_TYPE(op)->tp_name,"SwigPyObject") == 0);
#endif
}

SWIGRUNTIME PyObject *
SwigPyObject_New(void *ptr, swig_type_info *ty, int own);

SWIGRUNTIME void
SwigPyObject_dealloc(PyObject *v)
{
  SwigPyObject *sobj = (SwigPyObject *) v;
  PyObject *next = sobj->next;
  if (sobj->own == SWIG_POINTER_OWN) {
    swig_type_info *ty = sobj->ty;
    SwigPyClientData *data = ty ? (SwigPyClientData *) ty->clientdata : 0;
    PyObject *destroy = data ? data->destroy : 0;
    if (destroy) {
      /* destroy is always a VARARGS method */
      PyObject *res;

      /* PyObject_CallFunction() has the potential to silently drop
         the active active exception.  In cases of unnamed temporary
         variable or where we just finished iterating over a generator
         StopIteration will be active right now, and this needs to
         remain true upon return from SwigPyObject_dealloc.  So save
         and restore. */
      
      PyObject *val = NULL, *type = NULL, *tb = NULL;
      PyErr_Fetch(&val, &type, &tb);

      if (data->delargs) {
        /* we need to create a temporary object to carry the destroy operation */
        PyObject *tmp = SwigPyObject_New(sobj->ptr, ty, 0);
        res = SWIG_Python_CallFunctor(destroy, tmp);
        Py_DECREF(tmp);
      } else {
        PyCFunction meth = PyCFunction_GET_FUNCTION(destroy);
        PyObject *mself = PyCFunction_GET_SELF(destroy);
        res = ((*meth)(mself, v));
      }
      if (!res)
        PyErr_WriteUnraisable(destroy);

      PyErr_Restore(val, type, tb);

      Py_XDECREF(res);
    } 
#if !defined(SWIG_PYTHON_SILENT_MEMLEAK)
    else {
      const char *name = SWIG_TypePrettyName(ty);
      printf("swig/python detected a memory leak of type '%s', no destructor found.\n", (name ? name : "unknown"));
    }
#endif
  } 
  Py_XDECREF(next);
  PyObject_DEL(v);
}

SWIGRUNTIME PyObject* 
SwigPyObject_append(PyObject* v, PyObject* next)
{
  SwigPyObject *sobj = (SwigPyObject *) v;
#ifndef METH_O
  PyObject *tmp = 0;
  if (!PyArg_ParseTuple(next,(char *)"O:append", &tmp)) return NULL;
  next = tmp;
#endif
  if (!SwigPyObject_Check(next)) {
    PyErr_SetString(PyExc_TypeError, "Attempt to append a non SwigPyObject");
    return NULL;
  }
  sobj->next = next;
  Py_INCREF(next);
  return SWIG_Py_Void();
}

SWIGRUNTIME PyObject* 
#ifdef METH_NOARGS
SwigPyObject_next(PyObject* v)
#else
SwigPyObject_next(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
#endif
{
  SwigPyObject *sobj = (SwigPyObject *) v;
  if (sobj->next) {    
    Py_INCREF(sobj->next);
    return sobj->next;
  } else {
    return SWIG_Py_Void();
  }
}

SWIGINTERN PyObject*
#ifdef METH_NOARGS
SwigPyObject_disown(PyObject *v)
#else
SwigPyObject_disown(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
#endif
{
  SwigPyObject *sobj = (SwigPyObject *)v;
  sobj->own = 0;
  return SWIG_Py_Void();
}

SWIGINTERN PyObject*
#ifdef METH_NOARGS
SwigPyObject_acquire(PyObject *v)
#else
SwigPyObject_acquire(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
#endif
{
  SwigPyObject *sobj = (SwigPyObject *)v;
  sobj->own = SWIG_POINTER_OWN;
  return SWIG_Py_Void();
}

SWIGINTERN PyObject*
SwigPyObject_own(PyObject *v, PyObject *args)
{
  PyObject *val = 0;
#if (PY_VERSION_HEX < 0x02020000)
  if (!PyArg_ParseTuple(args,(char *)"|O:own",&val))
#elif (PY_VERSION_HEX < 0x02050000)
  if (!PyArg_UnpackTuple(args, (char *)"own", 0, 1, &val)) 
#else
  if (!PyArg_UnpackTuple(args, "own", 0, 1, &val)) 
#endif
    {
      return NULL;
    } 
  else
    {
      SwigPyObject *sobj = (SwigPyObject *)v;
      PyObject *obj = PyBool_FromLong(sobj->own);
      if (val) {
#ifdef METH_NOARGS
	if (PyObject_IsTrue(val)) {
	  SwigPyObject_acquire(v);
	} else {
	  SwigPyObject_disown(v);
	}
#else
	if (PyObject_IsTrue(val)) {
	  SwigPyObject_acquire(v,args);
	} else {
	  SwigPyObject_disown(v,args);
	}
#endif
      } 
      return obj;
    }
}

#ifdef METH_O
static PyMethodDef
swigobject_methods[] = {
  {(char *)"disown",  (PyCFunction)SwigPyObject_disown,  METH_NOARGS,  (char *)"releases ownership of the pointer"},
  {(char *)"acquire", (PyCFunction)SwigPyObject_acquire, METH_NOARGS,  (char *)"acquires ownership of the pointer"},
  {(char *)"own",     (PyCFunction)SwigPyObject_own,     METH_VARARGS, (char *)"returns/sets ownership of the pointer"},
  {(char *)"append",  (PyCFunction)SwigPyObject_append,  METH_O,       (char *)"appends another 'this' object"},
  {(char *)"next",    (PyCFunction)SwigPyObject_next,    METH_NOARGS,  (char *)"returns the next 'this' object"},
  {(char *)"__repr__",(PyCFunction)SwigPyObject_repr,    METH_NOARGS,  (char *)"returns object representation"},
  {0, 0, 0, 0}  
};
#else
static PyMethodDef
swigobject_methods[] = {
  {(char *)"disown",  (PyCFunction)SwigPyObject_disown,  METH_VARARGS,  (char *)"releases ownership of the pointer"},
  {(char *)"acquire", (PyCFunction)SwigPyObject_acquire, METH_VARARGS,  (char *)"acquires ownership of the pointer"},
  {(char *)"own",     (PyCFunction)SwigPyObject_own,     METH_VARARGS,  (char *)"returns/sets ownership of the pointer"},
  {(char *)"append",  (PyCFunction)SwigPyObject_append,  METH_VARARGS,  (char *)"appends another 'this' object"},
  {(char *)"next",    (PyCFunction)SwigPyObject_next,    METH_VARARGS,  (char *)"returns the next 'this' object"},
  {(char *)"__repr__",(PyCFunction)SwigPyObject_repr,   METH_VARARGS,  (char *)"returns object representation"},
  {0, 0, 0, 0}  
};
#endif

#if PY_VERSION_HEX < 0x02020000
SWIGINTERN PyObject *
SwigPyObject_getattr(SwigPyObject *sobj,char *name)
{
  return Py_FindMethod(swigobject_methods, (PyObject *)sobj, name);
}
#endif

SWIGRUNTIME PyTypeObject*
SwigPyObject_TypeOnce(void) {
  static char swigobject_doc[] = "Swig object carries a C/C++ instance pointer";

  static PyNumberMethods SwigPyObject_as_number = {
    (binaryfunc)0, /*nb_add*/
    (binaryfunc)0, /*nb_subtract*/
    (binaryfunc)0, /*nb_multiply*/
    /* nb_divide removed in Python 3 */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc)0, /*nb_divide*/
#endif
    (binaryfunc)0, /*nb_remainder*/
    (binaryfunc)0, /*nb_divmod*/
    (ternaryfunc)0,/*nb_power*/
    (unaryfunc)0,  /*nb_negative*/
    (unaryfunc)0,  /*nb_positive*/
    (unaryfunc)0,  /*nb_absolute*/
    (inquiry)0,    /*nb_nonzero*/
    0,		   /*nb_invert*/
    0,		   /*nb_lshift*/
    0,		   /*nb_rshift*/
    0,		   /*nb_and*/
    0,		   /*nb_xor*/
    0,		   /*nb_or*/
#if PY_VERSION_HEX < 0x03000000
    0,   /*nb_coerce*/
#endif
    (unaryfunc)SwigPyObject_long, /*nb_int*/
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc)SwigPyObject_long, /*nb_long*/
#else
    0, /*nb_reserved*/
#endif
    (unaryfunc)0,                 /*nb_float*/
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc)SwigPyObject_oct,  /*nb_oct*/
    (unaryfunc)SwigPyObject_hex,  /*nb_hex*/
#endif
#if PY_VERSION_HEX >= 0x03050000 /* 3.5 */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_inplace_matrix_multiply */
#elif PY_VERSION_HEX >= 0x03000000 /* 3.0 */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_index, nb_inplace_divide removed */
#elif PY_VERSION_HEX >= 0x02050000 /* 2.5.0 */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_index */
#elif PY_VERSION_HEX >= 0x02020000 /* 2.2.0 */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_inplace_true_divide */
#elif PY_VERSION_HEX >= 0x02000000 /* 2.0.0 */
    0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_inplace_or */
#endif
  };

  static PyTypeObject swigpyobject_type;
  static int type_init = 0;
  if (!type_init) {
    const PyTypeObject tmp = {
      /* PyObject header changed in Python 3 */
#if PY_VERSION_HEX >= 0x03000000
      PyVarObject_HEAD_INIT(NULL, 0)
#else
      PyObject_HEAD_INIT(NULL)
      0,                                    /* ob_size */
#endif
      (char *)"SwigPyObject",               /* tp_name */
      sizeof(SwigPyObject),                 /* tp_basicsize */
      0,                                    /* tp_itemsize */
      (destructor)SwigPyObject_dealloc,     /* tp_dealloc */
      0,				    /* tp_print */
#if PY_VERSION_HEX < 0x02020000
      (getattrfunc)SwigPyObject_getattr,    /* tp_getattr */
#else
      (getattrfunc)0,                       /* tp_getattr */
#endif
      (setattrfunc)0,                       /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0, /* tp_reserved in 3.0.1, tp_compare in 3.0.0 but not used */
#else
      (cmpfunc)SwigPyObject_compare,        /* tp_compare */
#endif
      (reprfunc)SwigPyObject_repr,          /* tp_repr */
      &SwigPyObject_as_number,              /* tp_as_number */
      0,                                    /* tp_as_sequence */
      0,                                    /* tp_as_mapping */
      (hashfunc)0,                          /* tp_hash */
      (ternaryfunc)0,                       /* tp_call */
      0,				    /* tp_str */
      PyObject_GenericGetAttr,              /* tp_getattro */
      0,                                    /* tp_setattro */
      0,                                    /* tp_as_buffer */
      Py_TPFLAGS_DEFAULT,                   /* tp_flags */
      swigobject_doc,                       /* tp_doc */
      0,                                    /* tp_traverse */
      0,                                    /* tp_clear */
      (richcmpfunc)SwigPyObject_richcompare,/* tp_richcompare */
      0,                                    /* tp_weaklistoffset */
#if PY_VERSION_HEX >= 0x02020000
      0,                                    /* tp_iter */
      0,                                    /* tp_iternext */
      swigobject_methods,                   /* tp_methods */
      0,                                    /* tp_members */
      0,                                    /* tp_getset */
      0,                                    /* tp_base */
      0,                                    /* tp_dict */
      0,                                    /* tp_descr_get */
      0,                                    /* tp_descr_set */
      0,                                    /* tp_dictoffset */
      0,                                    /* tp_init */
      0,                                    /* tp_alloc */
      0,                                    /* tp_new */
      0,                                    /* tp_free */
      0,                                    /* tp_is_gc */
      0,                                    /* tp_bases */
      0,                                    /* tp_mro */
      0,                                    /* tp_cache */
      0,                                    /* tp_subclasses */
      0,                                    /* tp_weaklist */
#endif
#if PY_VERSION_HEX >= 0x02030000
      0,                                    /* tp_del */
#endif
#if PY_VERSION_HEX >= 0x02060000
      0,                                    /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
      0,                                    /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
      0,                                    /* tp_allocs */
      0,                                    /* tp_frees */
      0,                                    /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
      0,                                    /* tp_prev */
#endif
      0                                     /* tp_next */
#endif
    };
    swigpyobject_type = tmp;
    type_init = 1;
#if PY_VERSION_HEX < 0x02020000
    swigpyobject_type.ob_type = &PyType_Type;
#else
    if (PyType_Ready(&swigpyobject_type) < 0)
      return NULL;
#endif
  }
  return &swigpyobject_type;
}

SWIGRUNTIME PyObject *
SwigPyObject_New(void *ptr, swig_type_info *ty, int own)
{
  SwigPyObject *sobj = PyObject_NEW(SwigPyObject, SwigPyObject_type());
  if (sobj) {
    sobj->ptr  = ptr;
    sobj->ty   = ty;
    sobj->own  = own;
    sobj->next = 0;
  }
  return (PyObject *)sobj;
}

/* -----------------------------------------------------------------------------
 * Implements a simple Swig Packed type, and use it instead of string
 * ----------------------------------------------------------------------------- */

typedef struct {
  PyObject_HEAD
  void *pack;
  swig_type_info *ty;
  size_t size;
} SwigPyPacked;

SWIGRUNTIME int
SwigPyPacked_print(SwigPyPacked *v, FILE *fp, int SWIGUNUSEDPARM(flags))
{
  char result[SWIG_BUFFER_SIZE];
  fputs("<Swig Packed ", fp); 
  if (SWIG_PackDataName(result, v->pack, v->size, 0, sizeof(result))) {
    fputs("at ", fp); 
    fputs(result, fp); 
  }
  fputs(v->ty->name,fp); 
  fputs(">", fp);
  return 0; 
}
  
SWIGRUNTIME PyObject *
SwigPyPacked_repr(SwigPyPacked *v)
{
  char result[SWIG_BUFFER_SIZE];
  if (SWIG_PackDataName(result, v->pack, v->size, 0, sizeof(result))) {
    return SWIG_Python_str_FromFormat("<Swig Packed at %s%s>", result, v->ty->name);
  } else {
    return SWIG_Python_str_FromFormat("<Swig Packed %s>", v->ty->name);
  }  
}

SWIGRUNTIME PyObject *
SwigPyPacked_str(SwigPyPacked *v)
{
  char result[SWIG_BUFFER_SIZE];
  if (SWIG_PackDataName(result, v->pack, v->size, 0, sizeof(result))){
    return SWIG_Python_str_FromFormat("%s%s", result, v->ty->name);
  } else {
    return SWIG_Python_str_FromChar(v->ty->name);
  }  
}

SWIGRUNTIME int
SwigPyPacked_compare(SwigPyPacked *v, SwigPyPacked *w)
{
  size_t i = v->size;
  size_t j = w->size;
  int s = (i < j) ? -1 : ((i > j) ? 1 : 0);
  return s ? s : strncmp((char *)v->pack, (char *)w->pack, 2*v->size);
}

SWIGRUNTIME PyTypeObject* SwigPyPacked_TypeOnce(void);

SWIGRUNTIME PyTypeObject*
SwigPyPacked_type(void) {
  static PyTypeObject *SWIG_STATIC_POINTER(type) = SwigPyPacked_TypeOnce();
  return type;
}

SWIGRUNTIMEINLINE int
SwigPyPacked_Check(PyObject *op) {
  return ((op)->ob_type == SwigPyPacked_TypeOnce()) 
    || (strcmp((op)->ob_type->tp_name,"SwigPyPacked") == 0);
}

SWIGRUNTIME void
SwigPyPacked_dealloc(PyObject *v)
{
  if (SwigPyPacked_Check(v)) {
    SwigPyPacked *sobj = (SwigPyPacked *) v;
    free(sobj->pack);
  }
  PyObject_DEL(v);
}

SWIGRUNTIME PyTypeObject*
SwigPyPacked_TypeOnce(void) {
  static char swigpacked_doc[] = "Swig object carries a C/C++ instance pointer";
  static PyTypeObject swigpypacked_type;
  static int type_init = 0;
  if (!type_init) {
    const PyTypeObject tmp = {
      /* PyObject header changed in Python 3 */
#if PY_VERSION_HEX>=0x03000000
      PyVarObject_HEAD_INIT(NULL, 0)
#else
      PyObject_HEAD_INIT(NULL)
      0,                                    /* ob_size */
#endif
      (char *)"SwigPyPacked",               /* tp_name */
      sizeof(SwigPyPacked),                 /* tp_basicsize */
      0,                                    /* tp_itemsize */
      (destructor)SwigPyPacked_dealloc,     /* tp_dealloc */
      (printfunc)SwigPyPacked_print,        /* tp_print */
      (getattrfunc)0,                       /* tp_getattr */
      (setattrfunc)0,                       /* tp_setattr */
#if PY_VERSION_HEX>=0x03000000
      0, /* tp_reserved in 3.0.1 */
#else
      (cmpfunc)SwigPyPacked_compare,        /* tp_compare */
#endif
      (reprfunc)SwigPyPacked_repr,          /* tp_repr */
      0,                                    /* tp_as_number */
      0,                                    /* tp_as_sequence */
      0,                                    /* tp_as_mapping */
      (hashfunc)0,                          /* tp_hash */
      (ternaryfunc)0,                       /* tp_call */
      (reprfunc)SwigPyPacked_str,           /* tp_str */
      PyObject_GenericGetAttr,              /* tp_getattro */
      0,                                    /* tp_setattro */
      0,                                    /* tp_as_buffer */
      Py_TPFLAGS_DEFAULT,                   /* tp_flags */
      swigpacked_doc,                       /* tp_doc */
      0,                                    /* tp_traverse */
      0,                                    /* tp_clear */
      0,                                    /* tp_richcompare */
      0,                                    /* tp_weaklistoffset */
#if PY_VERSION_HEX >= 0x02020000
      0,                                    /* tp_iter */
      0,                                    /* tp_iternext */
      0,                                    /* tp_methods */
      0,                                    /* tp_members */
      0,                                    /* tp_getset */
      0,                                    /* tp_base */
      0,                                    /* tp_dict */
      0,                                    /* tp_descr_get */
      0,                                    /* tp_descr_set */
      0,                                    /* tp_dictoffset */
      0,                                    /* tp_init */
      0,                                    /* tp_alloc */
      0,                                    /* tp_new */
      0,                                    /* tp_free */
      0,                                    /* tp_is_gc */
      0,                                    /* tp_bases */
      0,                                    /* tp_mro */
      0,                                    /* tp_cache */
      0,                                    /* tp_subclasses */
      0,                                    /* tp_weaklist */
#endif
#if PY_VERSION_HEX >= 0x02030000
      0,                                    /* tp_del */
#endif
#if PY_VERSION_HEX >= 0x02060000
      0,                                    /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
      0,                                    /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
      0,                                    /* tp_allocs */
      0,                                    /* tp_frees */
      0,                                    /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
      0,                                    /* tp_prev */
#endif
      0                                     /* tp_next */
#endif
    };
    swigpypacked_type = tmp;
    type_init = 1;
#if PY_VERSION_HEX < 0x02020000
    swigpypacked_type.ob_type = &PyType_Type;
#else
    if (PyType_Ready(&swigpypacked_type) < 0)
      return NULL;
#endif
  }
  return &swigpypacked_type;
}

SWIGRUNTIME PyObject *
SwigPyPacked_New(void *ptr, size_t size, swig_type_info *ty)
{
  SwigPyPacked *sobj = PyObject_NEW(SwigPyPacked, SwigPyPacked_type());
  if (sobj) {
    void *pack = malloc(size);
    if (pack) {
      memcpy(pack, ptr, size);
      sobj->pack = pack;
      sobj->ty   = ty;
      sobj->size = size;
    } else {
      PyObject_DEL((PyObject *) sobj);
      sobj = 0;
    }
  }
  return (PyObject *) sobj;
}

SWIGRUNTIME swig_type_info *
SwigPyPacked_UnpackData(PyObject *obj, void *ptr, size_t size)
{
  if (SwigPyPacked_Check(obj)) {
    SwigPyPacked *sobj = (SwigPyPacked *)obj;
    if (sobj->size != size) return 0;
    memcpy(ptr, sobj->pack, size);
    return sobj->ty;
  } else {
    return 0;
  }
}

/* -----------------------------------------------------------------------------
 * pointers/data manipulation
 * ----------------------------------------------------------------------------- */

SWIGRUNTIMEINLINE PyObject *
_SWIG_This(void)
{
    return SWIG_Python_str_FromChar("this");
}

static PyObject *swig_this = NULL;

SWIGRUNTIME PyObject *
SWIG_This(void)
{
  if (swig_this == NULL)
    swig_this = _SWIG_This();
  return swig_this;
}

/* #define SWIG_PYTHON_SLOW_GETSET_THIS */

/* TODO: I don't know how to implement the fast getset in Python 3 right now */
#if PY_VERSION_HEX>=0x03000000
#define SWIG_PYTHON_SLOW_GETSET_THIS 
#endif

SWIGRUNTIME SwigPyObject *
SWIG_Python_GetSwigThis(PyObject *pyobj) 
{
  PyObject *obj;

  if (SwigPyObject_Check(pyobj))
    return (SwigPyObject *) pyobj;

#ifdef SWIGPYTHON_BUILTIN
  (void)obj;
# ifdef PyWeakref_CheckProxy
  if (PyWeakref_CheckProxy(pyobj)) {
    pyobj = PyWeakref_GET_OBJECT(pyobj);
    if (pyobj && SwigPyObject_Check(pyobj))
      return (SwigPyObject*) pyobj;
  }
# endif
  return NULL;
#else

  obj = 0;

#if (!defined(SWIG_PYTHON_SLOW_GETSET_THIS) && (PY_VERSION_HEX >= 0x02030000))
  if (PyInstance_Check(pyobj)) {
    obj = _PyInstance_Lookup(pyobj, SWIG_This());      
  } else {
    PyObject **dictptr = _PyObject_GetDictPtr(pyobj);
    if (dictptr != NULL) {
      PyObject *dict = *dictptr;
      obj = dict ? PyDict_GetItem(dict, SWIG_This()) : 0;
    } else {
#ifdef PyWeakref_CheckProxy
      if (PyWeakref_CheckProxy(pyobj)) {
	PyObject *wobj = PyWeakref_GET_OBJECT(pyobj);
	return wobj ? SWIG_Python_GetSwigThis(wobj) : 0;
      }
#endif
      obj = PyObject_GetAttr(pyobj,SWIG_This());
      if (obj) {
	Py_DECREF(obj);
      } else {
	if (PyErr_Occurred()) PyErr_Clear();
	return 0;
      }
    }
  }
#else
  obj = PyObject_GetAttr(pyobj,SWIG_This());
  if (obj) {
    Py_DECREF(obj);
  } else {
    if (PyErr_Occurred()) PyErr_Clear();
    return 0;
  }
#endif
  if (obj && !SwigPyObject_Check(obj)) {
    /* a PyObject is called 'this', try to get the 'real this'
       SwigPyObject from it */ 
    return SWIG_Python_GetSwigThis(obj);
  }
  return (SwigPyObject *)obj;
#endif
}

/* Acquire a pointer value */

SWIGRUNTIME int
SWIG_Python_AcquirePtr(PyObject *obj, int own) {
  if (own == SWIG_POINTER_OWN) {
    SwigPyObject *sobj = SWIG_Python_GetSwigThis(obj);
    if (sobj) {
      int oldown = sobj->own;
      sobj->own = own;
      return oldown;
    }
  }
  return 0;
}

/* Convert a pointer value */

SWIGRUNTIME int
SWIG_Python_ConvertPtrAndOwn(PyObject *obj, void **ptr, swig_type_info *ty, int flags, int *own) {
  int res;
  SwigPyObject *sobj;
  int implicit_conv = (flags & SWIG_POINTER_IMPLICIT_CONV) != 0;

  if (!obj)
    return SWIG_ERROR;
  if (obj == Py_None && !implicit_conv) {
    if (ptr)
      *ptr = 0;
    return SWIG_OK;
  }

  res = SWIG_ERROR;

  sobj = SWIG_Python_GetSwigThis(obj);
  if (own)
    *own = 0;
  while (sobj) {
    void *vptr = sobj->ptr;
    if (ty) {
      swig_type_info *to = sobj->ty;
      if (to == ty) {
        /* no type cast needed */
        if (ptr) *ptr = vptr;
        break;
      } else {
        swig_cast_info *tc = SWIG_TypeCheck(to->name,ty);
        if (!tc) {
          sobj = (SwigPyObject *)sobj->next;
        } else {
          if (ptr) {
            int newmemory = 0;
            *ptr = SWIG_TypeCast(tc,vptr,&newmemory);
            if (newmemory == SWIG_CAST_NEW_MEMORY) {
              assert(own); /* badly formed typemap which will lead to a memory leak - it must set and use own to delete *ptr */
              if (own)
                *own = *own | SWIG_CAST_NEW_MEMORY;
            }
          }
          break;
        }
      }
    } else {
      if (ptr) *ptr = vptr;
      break;
    }
  }
  if (sobj) {
    if (own)
      *own = *own | sobj->own;
    if (flags & SWIG_POINTER_DISOWN) {
      sobj->own = 0;
    }
    res = SWIG_OK;
  } else {
    if (implicit_conv) {
      SwigPyClientData *data = ty ? (SwigPyClientData *) ty->clientdata : 0;
      if (data && !data->implicitconv) {
        PyObject *klass = data->klass;
        if (klass) {
          PyObject *impconv;
          data->implicitconv = 1; /* avoid recursion and call 'explicit' constructors*/
          impconv = SWIG_Python_CallFunctor(klass, obj);
          data->implicitconv = 0;
          if (PyErr_Occurred()) {
            PyErr_Clear();
            impconv = 0;
          }
          if (impconv) {
            SwigPyObject *iobj = SWIG_Python_GetSwigThis(impconv);
            if (iobj) {
              void *vptr;
              res = SWIG_Python_ConvertPtrAndOwn((PyObject*)iobj, &vptr, ty, 0, 0);
              if (SWIG_IsOK(res)) {
                if (ptr) {
                  *ptr = vptr;
                  /* transfer the ownership to 'ptr' */
                  iobj->own = 0;
                  res = SWIG_AddCast(res);
                  res = SWIG_AddNewMask(res);
                } else {
                  res = SWIG_AddCast(res);		    
                }
              }
            }
            Py_DECREF(impconv);
          }
        }
      }
    }
    if (!SWIG_IsOK(res) && obj == Py_None) {
      if (ptr)
        *ptr = 0;
      if (PyErr_Occurred())
        PyErr_Clear();
      res = SWIG_OK;
    }
  }
  return res;
}

/* Convert a function ptr value */

SWIGRUNTIME int
SWIG_Python_ConvertFunctionPtr(PyObject *obj, void **ptr, swig_type_info *ty) {
  if (!PyCFunction_Check(obj)) {
    return SWIG_ConvertPtr(obj, ptr, ty, 0);
  } else {
    void *vptr = 0;
    
    /* here we get the method pointer for callbacks */
    const char *doc = (((PyCFunctionObject *)obj) -> m_ml -> ml_doc);
    const char *desc = doc ? strstr(doc, "swig_ptr: ") : 0;
    if (desc)
      desc = ty ? SWIG_UnpackVoidPtr(desc + 10, &vptr, ty->name) : 0;
    if (!desc) 
      return SWIG_ERROR;
    if (ty) {
      swig_cast_info *tc = SWIG_TypeCheck(desc,ty);
      if (tc) {
        int newmemory = 0;
        *ptr = SWIG_TypeCast(tc,vptr,&newmemory);
        assert(!newmemory); /* newmemory handling not yet implemented */
      } else {
        return SWIG_ERROR;
      }
    } else {
      *ptr = vptr;
    }
    return SWIG_OK;
  }
}

/* Convert a packed value value */

SWIGRUNTIME int
SWIG_Python_ConvertPacked(PyObject *obj, void *ptr, size_t sz, swig_type_info *ty) {
  swig_type_info *to = SwigPyPacked_UnpackData(obj, ptr, sz);
  if (!to) return SWIG_ERROR;
  if (ty) {
    if (to != ty) {
      /* check type cast? */
      swig_cast_info *tc = SWIG_TypeCheck(to->name,ty);
      if (!tc) return SWIG_ERROR;
    }
  }
  return SWIG_OK;
}  

/* -----------------------------------------------------------------------------
 * Create a new pointer object
 * ----------------------------------------------------------------------------- */

/*
  Create a new instance object, without calling __init__, and set the
  'this' attribute.
*/

SWIGRUNTIME PyObject* 
SWIG_Python_NewShadowInstance(SwigPyClientData *data, PyObject *swig_this)
{
#if (PY_VERSION_HEX >= 0x02020000)
  PyObject *inst = 0;
  PyObject *newraw = data->newraw;
  if (newraw) {
    inst = PyObject_Call(newraw, data->newargs, NULL);
    if (inst) {
#if !defined(SWIG_PYTHON_SLOW_GETSET_THIS)
      PyObject **dictptr = _PyObject_GetDictPtr(inst);
      if (dictptr != NULL) {
	PyObject *dict = *dictptr;
	if (dict == NULL) {
	  dict = PyDict_New();
	  *dictptr = dict;
	  PyDict_SetItem(dict, SWIG_This(), swig_this);
	}
      }
#else
      PyObject *key = SWIG_This();
      PyObject_SetAttr(inst, key, swig_this);
#endif
    }
  } else {
#if PY_VERSION_HEX >= 0x03000000
    inst = ((PyTypeObject*) data->newargs)->tp_new((PyTypeObject*) data->newargs, Py_None, Py_None);
    if (inst) {
      PyObject_SetAttr(inst, SWIG_This(), swig_this);
      Py_TYPE(inst)->tp_flags &= ~Py_TPFLAGS_VALID_VERSION_TAG;
    }
#else
    PyObject *dict = PyDict_New();
    if (dict) {
      PyDict_SetItem(dict, SWIG_This(), swig_this);
      inst = PyInstance_NewRaw(data->newargs, dict);
      Py_DECREF(dict);
    }
#endif
  }
  return inst;
#else
#if (PY_VERSION_HEX >= 0x02010000)
  PyObject *inst = 0;
  PyObject *dict = PyDict_New();
  if (dict) {
    PyDict_SetItem(dict, SWIG_This(), swig_this);
    inst = PyInstance_NewRaw(data->newargs, dict);
    Py_DECREF(dict);
  }
  return (PyObject *) inst;
#else
  PyInstanceObject *inst = PyObject_NEW(PyInstanceObject, &PyInstance_Type);
  if (inst == NULL) {
    return NULL;
  }
  inst->in_class = (PyClassObject *)data->newargs;
  Py_INCREF(inst->in_class);
  inst->in_dict = PyDict_New();
  if (inst->in_dict == NULL) {
    Py_DECREF(inst);
    return NULL;
  }
#ifdef Py_TPFLAGS_HAVE_WEAKREFS
  inst->in_weakreflist = NULL;
#endif
#ifdef Py_TPFLAGS_GC
  PyObject_GC_Init(inst);
#endif
  PyDict_SetItem(inst->in_dict, SWIG_This(), swig_this);
  return (PyObject *) inst;
#endif
#endif
}

SWIGRUNTIME void
SWIG_Python_SetSwigThis(PyObject *inst, PyObject *swig_this)
{
 PyObject *dict;
#if (PY_VERSION_HEX >= 0x02020000) && !defined(SWIG_PYTHON_SLOW_GETSET_THIS)
 PyObject **dictptr = _PyObject_GetDictPtr(inst);
 if (dictptr != NULL) {
   dict = *dictptr;
   if (dict == NULL) {
     dict = PyDict_New();
     *dictptr = dict;
   }
   PyDict_SetItem(dict, SWIG_This(), swig_this);
   return;
 }
#endif
 dict = PyObject_GetAttrString(inst, (char*)"__dict__");
 PyDict_SetItem(dict, SWIG_This(), swig_this);
 Py_DECREF(dict);
} 


SWIGINTERN PyObject *
SWIG_Python_InitShadowInstance(PyObject *args) {
  PyObject *obj[2];
  if (!SWIG_Python_UnpackTuple(args, "swiginit", 2, 2, obj)) {
    return NULL;
  } else {
    SwigPyObject *sthis = SWIG_Python_GetSwigThis(obj[0]);
    if (sthis) {
      SwigPyObject_append((PyObject*) sthis, obj[1]);
    } else {
      SWIG_Python_SetSwigThis(obj[0], obj[1]);
    }
    return SWIG_Py_Void();
  }
}

/* Create a new pointer object */

SWIGRUNTIME PyObject *
SWIG_Python_NewPointerObj(PyObject *self, void *ptr, swig_type_info *type, int flags) {
  SwigPyClientData *clientdata;
  PyObject * robj;
  int own;

  if (!ptr)
    return SWIG_Py_Void();

  clientdata = type ? (SwigPyClientData *)(type->clientdata) : 0;
  own = (flags & SWIG_POINTER_OWN) ? SWIG_POINTER_OWN : 0;
  if (clientdata && clientdata->pytype) {
    SwigPyObject *newobj;
    if (flags & SWIG_BUILTIN_TP_INIT) {
      newobj = (SwigPyObject*) self;
      if (newobj->ptr) {
        PyObject *next_self = clientdata->pytype->tp_alloc(clientdata->pytype, 0);
        while (newobj->next)
	  newobj = (SwigPyObject *) newobj->next;
        newobj->next = next_self;
        newobj = (SwigPyObject *)next_self;
#ifdef SWIGPYTHON_BUILTIN
        newobj->dict = 0;
#endif
      }
    } else {
      newobj = PyObject_New(SwigPyObject, clientdata->pytype);
#ifdef SWIGPYTHON_BUILTIN
      newobj->dict = 0;
#endif
    }
    if (newobj) {
      newobj->ptr = ptr;
      newobj->ty = type;
      newobj->own = own;
      newobj->next = 0;
      return (PyObject*) newobj;
    }
    return SWIG_Py_Void();
  }

  assert(!(flags & SWIG_BUILTIN_TP_INIT));

  robj = SwigPyObject_New(ptr, type, own);
  if (robj && clientdata && !(flags & SWIG_POINTER_NOSHADOW)) {
    PyObject *inst = SWIG_Python_NewShadowInstance(clientdata, robj);
    Py_DECREF(robj);
    robj = inst;
  }
  return robj;
}

/* Create a new packed object */

SWIGRUNTIMEINLINE PyObject *
SWIG_Python_NewPackedObj(void *ptr, size_t sz, swig_type_info *type) {
  return ptr ? SwigPyPacked_New((void *) ptr, sz, type) : SWIG_Py_Void();
}

/* -----------------------------------------------------------------------------*
 *  Get type list 
 * -----------------------------------------------------------------------------*/

#ifdef SWIG_LINK_RUNTIME
void *SWIG_ReturnGlobalTypeList(void *);
#endif

SWIGRUNTIME swig_module_info *
SWIG_Python_GetModule(void *SWIGUNUSEDPARM(clientdata)) {
  static void *type_pointer = (void *)0;
  /* first check if module already created */
  if (!type_pointer) {
#ifdef SWIG_LINK_RUNTIME
    type_pointer = SWIG_ReturnGlobalTypeList((void *)0);
#else
# ifdef SWIGPY_USE_CAPSULE
    type_pointer = PyCapsule_Import(SWIGPY_CAPSULE_NAME, 0);
# else
    type_pointer = PyCObject_Import((char*)"swig_runtime_data" SWIG_RUNTIME_VERSION,
				    (char*)"type_pointer" SWIG_TYPE_TABLE_NAME);
# endif
    if (PyErr_Occurred()) {
      PyErr_Clear();
      type_pointer = (void *)0;
    }
#endif
  }
  return (swig_module_info *) type_pointer;
}

#if PY_MAJOR_VERSION < 2
/* PyModule_AddObject function was introduced in Python 2.0.  The following function
   is copied out of Python/modsupport.c in python version 2.3.4 */
SWIGINTERN int
PyModule_AddObject(PyObject *m, char *name, PyObject *o)
{
  PyObject *dict;
  if (!PyModule_Check(m)) {
    PyErr_SetString(PyExc_TypeError, "PyModule_AddObject() needs module as first arg");
    return SWIG_ERROR;
  }
  if (!o) {
    PyErr_SetString(PyExc_TypeError, "PyModule_AddObject() needs non-NULL value");
    return SWIG_ERROR;
  }
  
  dict = PyModule_GetDict(m);
  if (dict == NULL) {
    /* Internal error -- modules must have a dict! */
    PyErr_Format(PyExc_SystemError, "module '%s' has no __dict__",
		 PyModule_GetName(m));
    return SWIG_ERROR;
  }
  if (PyDict_SetItemString(dict, name, o))
    return SWIG_ERROR;
  Py_DECREF(o);
  return SWIG_OK;
}
#endif

SWIGRUNTIME void
#ifdef SWIGPY_USE_CAPSULE
SWIG_Python_DestroyModule(PyObject *obj)
#else
SWIG_Python_DestroyModule(void *vptr)
#endif
{
#ifdef SWIGPY_USE_CAPSULE
  swig_module_info *swig_module = (swig_module_info *) PyCapsule_GetPointer(obj, SWIGPY_CAPSULE_NAME);
#else
  swig_module_info *swig_module = (swig_module_info *) vptr;
#endif
  swig_type_info **types = swig_module->types;
  size_t i;
  for (i =0; i < swig_module->size; ++i) {
    swig_type_info *ty = types[i];
    if (ty->owndata) {
      SwigPyClientData *data = (SwigPyClientData *) ty->clientdata;
      if (data) SwigPyClientData_Del(data);
    }
  }
  Py_DECREF(SWIG_This());
  swig_this = NULL;
}

SWIGRUNTIME void
SWIG_Python_SetModule(swig_module_info *swig_module) {
#if PY_VERSION_HEX >= 0x03000000
 /* Add a dummy module object into sys.modules */
  PyObject *module = PyImport_AddModule((char*)"swig_runtime_data" SWIG_RUNTIME_VERSION);
#else
  static PyMethodDef swig_empty_runtime_method_table[] = { {NULL, NULL, 0, NULL} }; /* Sentinel */
  PyObject *module = Py_InitModule((char*)"swig_runtime_data" SWIG_RUNTIME_VERSION, swig_empty_runtime_method_table);
#endif
#ifdef SWIGPY_USE_CAPSULE
  PyObject *pointer = PyCapsule_New((void *) swig_module, SWIGPY_CAPSULE_NAME, SWIG_Python_DestroyModule);
  if (pointer && module) {
    PyModule_AddObject(module, (char*)"type_pointer_capsule" SWIG_TYPE_TABLE_NAME, pointer);
  } else {
    Py_XDECREF(pointer);
  }
#else
  PyObject *pointer = PyCObject_FromVoidPtr((void *) swig_module, SWIG_Python_DestroyModule);
  if (pointer && module) {
    PyModule_AddObject(module, (char*)"type_pointer" SWIG_TYPE_TABLE_NAME, pointer);
  } else {
    Py_XDECREF(pointer);
  }
#endif
}

/* The python cached type query */
SWIGRUNTIME PyObject *
SWIG_Python_TypeCache(void) {
  static PyObject *SWIG_STATIC_POINTER(cache) = PyDict_New();
  return cache;
}

SWIGRUNTIME swig_type_info *
SWIG_Python_TypeQuery(const char *type)
{
  PyObject *cache = SWIG_Python_TypeCache();
  PyObject *key = SWIG_Python_str_FromChar(type); 
  PyObject *obj = PyDict_GetItem(cache, key);
  swig_type_info *descriptor;
  if (obj) {
#ifdef SWIGPY_USE_CAPSULE
    descriptor = (swig_type_info *) PyCapsule_GetPointer(obj, NULL);
#else
    descriptor = (swig_type_info *) PyCObject_AsVoidPtr(obj);
#endif
  } else {
    swig_module_info *swig_module = SWIG_GetModule(0);
    descriptor = SWIG_TypeQueryModule(swig_module, swig_module, type);
    if (descriptor) {
#ifdef SWIGPY_USE_CAPSULE
      obj = PyCapsule_New((void*) descriptor, NULL, NULL);
#else
      obj = PyCObject_FromVoidPtr(descriptor, NULL);
#endif
      PyDict_SetItem(cache, key, obj);
      Py_DECREF(obj);
    }
  }
  Py_DECREF(key);
  return descriptor;
}

/* 
   For backward compatibility only
*/
#define SWIG_POINTER_EXCEPTION  0
#define SWIG_arg_fail(arg)      SWIG_Python_ArgFail(arg)
#define SWIG_MustGetPtr(p, type, argnum, flags)  SWIG_Python_MustGetPtr(p, type, argnum, flags)

SWIGRUNTIME int
SWIG_Python_AddErrMesg(const char* mesg, int infront)
{  
  if (PyErr_Occurred()) {
    PyObject *type = 0;
    PyObject *value = 0;
    PyObject *traceback = 0;
    PyErr_Fetch(&type, &value, &traceback);
    if (value) {
      char *tmp;
      PyObject *old_str = PyObject_Str(value);
      Py_XINCREF(type);
      PyErr_Clear();
      if (infront) {
	PyErr_Format(type, "%s %s", mesg, tmp = SWIG_Python_str_AsChar(old_str));
      } else {
	PyErr_Format(type, "%s %s", tmp = SWIG_Python_str_AsChar(old_str), mesg);
      }
      SWIG_Python_str_DelForPy3(tmp);
      Py_DECREF(old_str);
    }
    return 1;
  } else {
    return 0;
  }
}
  
SWIGRUNTIME int
SWIG_Python_ArgFail(int argnum)
{
  if (PyErr_Occurred()) {
    /* add information about failing argument */
    char mesg[256];
    PyOS_snprintf(mesg, sizeof(mesg), "argument number %d:", argnum);
    return SWIG_Python_AddErrMesg(mesg, 1);
  } else {
    return 0;
  }
}

SWIGRUNTIMEINLINE const char *
SwigPyObject_GetDesc(PyObject *self)
{
  SwigPyObject *v = (SwigPyObject *)self;
  swig_type_info *ty = v ? v->ty : 0;
  return ty ? ty->str : "";
}

SWIGRUNTIME void
SWIG_Python_TypeError(const char *type, PyObject *obj)
{
  if (type) {
#if defined(SWIG_COBJECT_TYPES)
    if (obj && SwigPyObject_Check(obj)) {
      const char *otype = (const char *) SwigPyObject_GetDesc(obj);
      if (otype) {
	PyErr_Format(PyExc_TypeError, "a '%s' is expected, 'SwigPyObject(%s)' is received",
		     type, otype);
	return;
      }
    } else 
#endif      
    {
      const char *otype = (obj ? obj->ob_type->tp_name : 0); 
      if (otype) {
	PyObject *str = PyObject_Str(obj);
	const char *cstr = str ? SWIG_Python_str_AsChar(str) : 0;
	if (cstr) {
	  PyErr_Format(PyExc_TypeError, "a '%s' is expected, '%s(%s)' is received",
		       type, otype, cstr);
          SWIG_Python_str_DelForPy3(cstr);
	} else {
	  PyErr_Format(PyExc_TypeError, "a '%s' is expected, '%s' is received",
		       type, otype);
	}
	Py_XDECREF(str);
	return;
      }
    }   
    PyErr_Format(PyExc_TypeError, "a '%s' is expected", type);
  } else {
    PyErr_Format(PyExc_TypeError, "unexpected type is received");
  }
}


/* Convert a pointer value, signal an exception on a type mismatch */
SWIGRUNTIME void *
SWIG_Python_MustGetPtr(PyObject *obj, swig_type_info *ty, int SWIGUNUSEDPARM(argnum), int flags) {
  void *result;
  if (SWIG_Python_ConvertPtr(obj, &result, ty, flags) == -1) {
    PyErr_Clear();
#if SWIG_POINTER_EXCEPTION
    if (flags) {
      SWIG_Python_TypeError(SWIG_TypePrettyName(ty), obj);
      SWIG_Python_ArgFail(argnum);
    }
#endif
  }
  return result;
}

#ifdef SWIGPYTHON_BUILTIN
SWIGRUNTIME int
SWIG_Python_NonDynamicSetAttr(PyObject *obj, PyObject *name, PyObject *value) {
  PyTypeObject *tp = obj->ob_type;
  PyObject *descr;
  PyObject *encoded_name;
  descrsetfunc f;
  int res = -1;

# ifdef Py_USING_UNICODE
  if (PyString_Check(name)) {
    name = PyUnicode_Decode(PyString_AsString(name), PyString_Size(name), NULL, NULL);
    if (!name)
      return -1;
  } else if (!PyUnicode_Check(name))
# else
  if (!PyString_Check(name))
# endif
  {
    PyErr_Format(PyExc_TypeError, "attribute name must be string, not '%.200s'", name->ob_type->tp_name);
    return -1;
  } else {
    Py_INCREF(name);
  }

  if (!tp->tp_dict) {
    if (PyType_Ready(tp) < 0)
      goto done;
  }

  descr = _PyType_Lookup(tp, name);
  f = NULL;
  if (descr != NULL)
    f = descr->ob_type->tp_descr_set;
  if (!f) {
    if (PyString_Check(name)) {
      encoded_name = name;
      Py_INCREF(name);
    } else {
      encoded_name = PyUnicode_AsUTF8String(name);
    }
    PyErr_Format(PyExc_AttributeError, "'%.100s' object has no attribute '%.200s'", tp->tp_name, PyString_AsString(encoded_name));
    Py_DECREF(encoded_name);
  } else {
    res = f(descr, obj, value);
  }
  
  done:
  Py_DECREF(name);
  return res;
}
#endif


#ifdef __cplusplus
}
#endif

#define SWIGPY_UNARYFUNC_CLOSURE(wrapper)	\
SWIGINTERN PyObject *				\
wrapper##_closure(PyObject *a) {		\
  return wrapper(a, NULL);			\
}

#define SWIGPY_DESTRUCTOR_CLOSURE(wrapper)	\
SWIGINTERN void					\
wrapper##_closure(PyObject *a) {		\
    SwigPyObject *sobj;				\
    sobj = (SwigPyObject *)a;			\
    Py_XDECREF(sobj->dict);			\
    if (sobj->own) {				\
	PyObject *o;				\
	PyObject *val = 0, *type = 0, *tb = 0;	\
	PyErr_Fetch(&val, &type, &tb);		\
	o = wrapper(a, NULL);			\
	if (!o) {				\
	    PyObject *deallocname = PyString_FromString(#wrapper); \
	    PyErr_WriteUnraisable(deallocname);	\
	    Py_DECREF(deallocname);		\
	}					\
	PyErr_Restore(val, type, tb);		\
	Py_XDECREF(o);				\
    }						\
    if (PyType_IS_GC(a->ob_type)) {		\
	PyObject_GC_Del(a);			\
    } else {					\
	PyObject_Del(a);			\
    }						\
}

#define SWIGPY_INQUIRY_CLOSURE(wrapper)				\
SWIGINTERN int							\
wrapper##_closure(PyObject *a) {				\
    PyObject *pyresult;						\
    int result;							\
    pyresult = wrapper(a, NULL);				\
    result = pyresult && PyObject_IsTrue(pyresult) ? 1 : 0;	\
    Py_XDECREF(pyresult);					\
    return result;						\
}

#define SWIGPY_BINARYFUNC_CLOSURE(wrapper)	\
SWIGINTERN PyObject *				\
wrapper##_closure(PyObject *a, PyObject *b) {	\
    PyObject *tuple, *result;			\
    tuple = PyTuple_New(1);			\
    assert(tuple);				\
    PyTuple_SET_ITEM(tuple, 0, b);		\
    Py_XINCREF(b);				\
    result = wrapper(a, tuple);			\
    Py_DECREF(tuple);				\
    return result;				\
}

typedef ternaryfunc ternarycallfunc;

#define SWIGPY_TERNARYFUNC_CLOSURE(wrapper)			\
SWIGINTERN PyObject *						\
wrapper##_closure(PyObject *a, PyObject *b, PyObject *c) {	\
    PyObject *tuple, *result;					\
    tuple = PyTuple_New(2);					\
    assert(tuple);						\
    PyTuple_SET_ITEM(tuple, 0, b);				\
    PyTuple_SET_ITEM(tuple, 1, c);				\
    Py_XINCREF(b);						\
    Py_XINCREF(c);						\
    result = wrapper(a, tuple);					\
    Py_DECREF(tuple);						\
    return result;						\
}

#define SWIGPY_TERNARYCALLFUNC_CLOSURE(wrapper)			\
SWIGINTERN PyObject *						\
wrapper##_closure(PyObject *callable_object, PyObject *args, PyObject *) { \
    return wrapper(callable_object, args);			\
}

#define SWIGPY_LENFUNC_CLOSURE(wrapper)			\
SWIGINTERN Py_ssize_t					\
wrapper##_closure(PyObject *a) {			\
    PyObject *resultobj;				\
    Py_ssize_t result;					\
    resultobj = wrapper(a, NULL);			\
    result = PyNumber_AsSsize_t(resultobj, NULL);	\
    Py_DECREF(resultobj);				\
    return result;					\
}

#define SWIGPY_SSIZESSIZEARGFUNC_CLOSURE(wrapper)		\
SWIGINTERN PyObject *						\
wrapper##_closure(PyObject *a, Py_ssize_t b, Py_ssize_t c) {	\
    PyObject *tuple, *result;					\
    tuple = PyTuple_New(2);					\
    assert(tuple);						\
    PyTuple_SET_ITEM(tuple, 0, _PyLong_FromSsize_t(b));		\
    PyTuple_SET_ITEM(tuple, 1, _PyLong_FromSsize_t(c));		\
    result = wrapper(a, tuple);					\
    Py_DECREF(tuple);						\
    return result;						\
}

#define SWIGPY_SSIZESSIZEOBJARGPROC_CLOSURE(wrapper)			\
SWIGINTERN int								\
wrapper##_closure(PyObject *a, Py_ssize_t b, Py_ssize_t c, PyObject *d) { \
    PyObject *tuple, *resultobj;					\
    int result;								\
    tuple = PyTuple_New(d ? 3 : 2);					\
    assert(tuple);							\
    PyTuple_SET_ITEM(tuple, 0, _PyLong_FromSsize_t(b));			\
    PyTuple_SET_ITEM(tuple, 1, _PyLong_FromSsize_t(c));			\
    if (d) {								\
        PyTuple_SET_ITEM(tuple, 2, d);					\
        Py_INCREF(d);							\
    }									\
    resultobj = wrapper(a, tuple);					\
    result = resultobj ? 0 : -1;					\
    Py_DECREF(tuple);							\
    Py_XDECREF(resultobj);						\
    return result;							\
}

#define SWIGPY_SSIZEARGFUNC_CLOSURE(wrapper)		\
SWIGINTERN PyObject *					\
wrapper##_closure(PyObject *a, Py_ssize_t b) {		\
    PyObject *tuple, *result;				\
    tuple = PyTuple_New(1);				\
    assert(tuple);					\
    PyTuple_SET_ITEM(tuple, 0, _PyLong_FromSsize_t(b));	\
    result = wrapper(a, tuple);				\
    Py_DECREF(tuple);					\
    return result;					\
}

#define SWIGPY_FUNPACK_SSIZEARGFUNC_CLOSURE(wrapper)	\
SWIGINTERN PyObject *					\
wrapper##_closure(PyObject *a, Py_ssize_t b) {		\
    PyObject *arg, *result;				\
    arg = _PyLong_FromSsize_t(b);			\
    result = wrapper(a, arg);				\
    Py_DECREF(arg);					\
    return result;					\
}

#define SWIGPY_SSIZEOBJARGPROC_CLOSURE(wrapper)			\
SWIGINTERN int							\
wrapper##_closure(PyObject *a, Py_ssize_t b, PyObject *c) {	\
    PyObject *tuple, *resultobj;				\
    int result;							\
    tuple = PyTuple_New(2);					\
    assert(tuple);						\
    PyTuple_SET_ITEM(tuple, 0, _PyLong_FromSsize_t(b));		\
    PyTuple_SET_ITEM(tuple, 1, c);				\
    Py_XINCREF(c);						\
    resultobj = wrapper(a, tuple);				\
    result = resultobj ? 0 : -1;				\
    Py_XDECREF(resultobj);					\
    Py_DECREF(tuple);						\
    return result;						\
}

#define SWIGPY_OBJOBJARGPROC_CLOSURE(wrapper)			\
SWIGINTERN int							\
wrapper##_closure(PyObject *a, PyObject *b, PyObject *c) {	\
    PyObject *tuple, *resultobj;				\
    int result;							\
    tuple = PyTuple_New(c ? 2 : 1);				\
    assert(tuple);						\
    PyTuple_SET_ITEM(tuple, 0, b);				\
    Py_XINCREF(b);						\
    if (c) {							\
        PyTuple_SET_ITEM(tuple, 1, c);				\
        Py_XINCREF(c);						\
    }								\
    resultobj = wrapper(a, tuple);				\
    result = resultobj ? 0 : -1;				\
    Py_XDECREF(resultobj);					\
    Py_DECREF(tuple);						\
    return result;						\
}

#define SWIGPY_REPRFUNC_CLOSURE(wrapper)	\
SWIGINTERN PyObject *				\
wrapper##_closure(PyObject *a) {		\
    return wrapper(a, NULL);			\
}

#define SWIGPY_HASHFUNC_CLOSURE(wrapper)	\
SWIGINTERN long					\
wrapper##_closure(PyObject *a) {		\
    PyObject *pyresult;				\
    long result;				\
    pyresult = wrapper(a, NULL);		\
    if (!pyresult || !PyLong_Check(pyresult))	\
	return -1;				\
    result = PyLong_AsLong(pyresult);		\
    Py_DECREF(pyresult);			\
    return result;				\
}

#define SWIGPY_ITERNEXT_CLOSURE(wrapper)	\
SWIGINTERN PyObject *				\
wrapper##_closure(PyObject *a) {		\
    PyObject *result;				\
    result = wrapper(a, NULL);			\
    if (result && result == Py_None) {		\
	Py_DECREF(result);			\
	result = NULL;				\
    }						\
    return result;				\
}

#ifdef __cplusplus
extern "C" {
#endif

SWIGINTERN int
SwigPyBuiltin_BadInit(PyObject *self, PyObject *SWIGUNUSEDPARM(args), PyObject *SWIGUNUSEDPARM(kwds)) {
  PyErr_Format(PyExc_TypeError, "Cannot create new instances of type '%.300s'", self->ob_type->tp_name);
  return -1;
}

SWIGINTERN void
SwigPyBuiltin_BadDealloc(PyObject *pyobj) {
  SwigPyObject *sobj;
  sobj = (SwigPyObject *)pyobj;
  if (sobj->own) {
    PyErr_Format(PyExc_TypeError, "Swig detected a memory leak in type '%.300s': no callable destructor found.", pyobj->ob_type->tp_name);
  }
}

typedef struct {
  PyCFunction get;
  PyCFunction set;
} SwigPyGetSet;

SWIGINTERN PyObject *
SwigPyBuiltin_GetterClosure (PyObject *obj, void *closure) {
  SwigPyGetSet *getset;
  PyObject *tuple, *result;
  if (!closure)
    return SWIG_Py_Void();
  getset = (SwigPyGetSet *)closure;
  if (!getset->get)
    return SWIG_Py_Void();
  tuple = PyTuple_New(0);
  assert(tuple);
  result = (*getset->get)(obj, tuple);
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyObject *
SwigPyBuiltin_FunpackGetterClosure (PyObject *obj, void *closure) {
  SwigPyGetSet *getset;
  PyObject *result;
  if (!closure)
    return SWIG_Py_Void();
  getset = (SwigPyGetSet *)closure;
  if (!getset->get)
    return SWIG_Py_Void();
  result = (*getset->get)(obj, NULL);
  return result;
}

SWIGINTERN int
SwigPyBuiltin_SetterClosure (PyObject *obj, PyObject *val, void *closure) {
  SwigPyGetSet *getset;
  PyObject *tuple, *result;
  if (!closure) {
    PyErr_Format(PyExc_TypeError, "Missing getset closure");
    return -1;
  }
  getset = (SwigPyGetSet *)closure;
  if (!getset->set) {
    PyErr_Format(PyExc_TypeError, "Illegal member variable assignment in type '%.300s'", obj->ob_type->tp_name);
    return -1;
  }
  tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, val);
  Py_XINCREF(val);
  result = (*getset->set)(obj, tuple);
  Py_DECREF(tuple);
  Py_XDECREF(result);
  return result ? 0 : -1;
}

SWIGINTERN int
SwigPyBuiltin_FunpackSetterClosure (PyObject *obj, PyObject *val, void *closure) {
  SwigPyGetSet *getset;
  PyObject *result;
  if (!closure) {
    PyErr_Format(PyExc_TypeError, "Missing getset closure");
    return -1;
  }
  getset = (SwigPyGetSet *)closure;
  if (!getset->set) {
    PyErr_Format(PyExc_TypeError, "Illegal member variable assignment in type '%.300s'", obj->ob_type->tp_name);
    return -1;
  }
  result = (*getset->set)(obj, val);
  Py_XDECREF(result);
  return result ? 0 : -1;
}

SWIGINTERN void
SwigPyStaticVar_dealloc(PyDescrObject *descr) {
  _PyObject_GC_UNTRACK(descr);
  Py_XDECREF(PyDescr_TYPE(descr));
  Py_XDECREF(PyDescr_NAME(descr));
  PyObject_GC_Del(descr);
}

SWIGINTERN PyObject *
SwigPyStaticVar_repr(PyGetSetDescrObject *descr) {
#if PY_VERSION_HEX >= 0x03000000

  return PyUnicode_FromFormat("<class attribute '%S' of type '%s'>", PyDescr_NAME(descr), PyDescr_TYPE(descr)->tp_name);
#else
  return PyString_FromFormat("<class attribute '%s' of type '%s'>", PyString_AsString(PyDescr_NAME(descr)), PyDescr_TYPE(descr)->tp_name);
#endif
}

SWIGINTERN int
SwigPyStaticVar_traverse(PyObject *self, visitproc visit, void *arg) {
  PyDescrObject *descr;
  descr = (PyDescrObject *)self;
  Py_VISIT((PyObject*) PyDescr_TYPE(descr));
  return 0;
}

SWIGINTERN PyObject *
SwigPyStaticVar_get(PyGetSetDescrObject *descr, PyObject *obj, PyObject *SWIGUNUSEDPARM(type)) {
  if (descr->d_getset->get != NULL)
    return descr->d_getset->get(obj, descr->d_getset->closure);
#if PY_VERSION_HEX >= 0x03000000
  PyErr_Format(PyExc_AttributeError, "attribute '%.300S' of '%.100s' objects is not readable", PyDescr_NAME(descr), PyDescr_TYPE(descr)->tp_name);
#else
  PyErr_Format(PyExc_AttributeError, "attribute '%.300s' of '%.100s' objects is not readable", PyString_AsString(PyDescr_NAME(descr)), PyDescr_TYPE(descr)->tp_name);
#endif
  return NULL;
}

SWIGINTERN int
SwigPyStaticVar_set(PyGetSetDescrObject *descr, PyObject *obj, PyObject *value) {
  if (descr->d_getset->set != NULL)
    return descr->d_getset->set(obj, value, descr->d_getset->closure);
#if PY_VERSION_HEX >= 0x03000000
  PyErr_Format(PyExc_AttributeError, "attribute '%.300S' of '%.100s' objects is not writable", PyDescr_NAME(descr), PyDescr_TYPE(descr)->tp_name);
#else
  PyErr_Format(PyExc_AttributeError, "attribute '%.300s' of '%.100s' objects is not writable", PyString_AsString(PyDescr_NAME(descr)), PyDescr_TYPE(descr)->tp_name);
#endif
  return -1;
}

SWIGINTERN int
SwigPyObjectType_setattro(PyTypeObject *type, PyObject *name, PyObject *value) {
  PyObject *attribute;
  descrsetfunc local_set;
  attribute = _PyType_Lookup(type, name);
  if (attribute != NULL) {
    /* Implement descriptor functionality, if any */
    local_set = attribute->ob_type->tp_descr_set;
    if (local_set != NULL)
      return local_set(attribute, (PyObject *)type, value);
#if PY_VERSION_HEX >= 0x03000000
    PyErr_Format(PyExc_AttributeError, "cannot modify read-only attribute '%.50s.%.400S'", type->tp_name, name);
#else 
    PyErr_Format(PyExc_AttributeError, "cannot modify read-only attribute '%.50s.%.400s'", type->tp_name, PyString_AS_STRING(name));
#endif
  } else {
#if PY_VERSION_HEX >= 0x03000000
    PyErr_Format(PyExc_AttributeError, "type '%.50s' has no attribute '%.400S'", type->tp_name, name);
#else
    PyErr_Format(PyExc_AttributeError, "type '%.50s' has no attribute '%.400s'", type->tp_name, PyString_AS_STRING(name));
#endif
  }

  return -1;
}

SWIGINTERN PyTypeObject*
SwigPyStaticVar_Type(void) {
  static PyTypeObject staticvar_type;
  static int type_init = 0;
  if (!type_init) {
    const PyTypeObject tmp = {
      /* PyObject header changed in Python 3 */
#if PY_VERSION_HEX >= 0x03000000
      PyVarObject_HEAD_INIT(&PyType_Type, 0)
#else
      PyObject_HEAD_INIT(&PyType_Type)
      0,
#endif
      "swig_static_var_getset_descriptor",
      sizeof(PyGetSetDescrObject),
      0,
      (destructor)SwigPyStaticVar_dealloc,      /* tp_dealloc */
      0,                                        /* tp_print */
      0,                                        /* tp_getattr */
      0,                                        /* tp_setattr */
      0,                                        /* tp_compare */
      (reprfunc)SwigPyStaticVar_repr,           /* tp_repr */
      0,                                        /* tp_as_number */
      0,                                        /* tp_as_sequence */
      0,                                        /* tp_as_mapping */
      0,                                        /* tp_hash */
      0,                                        /* tp_call */
      0,                                        /* tp_str */
      PyObject_GenericGetAttr,                  /* tp_getattro */
      0,                                        /* tp_setattro */
      0,                                        /* tp_as_buffer */
      Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC|Py_TPFLAGS_HAVE_CLASS, /* tp_flags */
      0,                                        /* tp_doc */
      SwigPyStaticVar_traverse,                 /* tp_traverse */
      0,                                        /* tp_clear */
      0,                                        /* tp_richcompare */
      0,                                        /* tp_weaklistoffset */
      0,                                        /* tp_iter */
      0,                                        /* tp_iternext */
      0,                                        /* tp_methods */
      0,                                        /* tp_members */
      0,                                        /* tp_getset */
      0,                                        /* tp_base */
      0,                                        /* tp_dict */
      (descrgetfunc)SwigPyStaticVar_get,        /* tp_descr_get */
      (descrsetfunc)SwigPyStaticVar_set,        /* tp_descr_set */
      0,                                        /* tp_dictoffset */
      0,                                        /* tp_init */
      0,                                        /* tp_alloc */
      0,                                        /* tp_new */
      0,                                        /* tp_free */
      0,                                        /* tp_is_gc */
      0,                                        /* tp_bases */
      0,                                        /* tp_mro */
      0,                                        /* tp_cache */
      0,                                        /* tp_subclasses */
      0,                                        /* tp_weaklist */
#if PY_VERSION_HEX >= 0x02030000
      0,                                        /* tp_del */
#endif
#if PY_VERSION_HEX >= 0x02060000
      0,                                        /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
      0,                                        /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
      0,                                        /* tp_allocs */
      0,                                        /* tp_frees */
      0,                                        /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
      0,                                        /* tp_prev */
#endif
      0                                         /* tp_next */
#endif
    };
    staticvar_type = tmp;
    type_init = 1;
#if PY_VERSION_HEX < 0x02020000
    staticvar_type.ob_type = &PyType_Type;
#else
    if (PyType_Ready(&staticvar_type) < 0)
      return NULL;
#endif
  }
  return &staticvar_type;
}

SWIGINTERN PyGetSetDescrObject *
SwigPyStaticVar_new_getset(PyTypeObject *type, PyGetSetDef *getset) {

  PyGetSetDescrObject *descr;
  descr = (PyGetSetDescrObject *)PyType_GenericAlloc(SwigPyStaticVar_Type(), 0);
  assert(descr);
  Py_XINCREF(type);
  PyDescr_TYPE(descr) = type;
  PyDescr_NAME(descr) = PyString_InternFromString(getset->name);
  descr->d_getset = getset;
  if (PyDescr_NAME(descr) == NULL) {
    Py_DECREF(descr);
    descr = NULL;
  }
  return descr;
}

SWIGINTERN void
SwigPyBuiltin_InitBases (PyTypeObject *type, PyTypeObject **bases) {
  int base_count = 0;
  PyTypeObject **b;
  PyObject *tuple;
  int i;

  if (!bases[0]) {
    bases[0] = SwigPyObject_type();
    bases[1] = NULL;
  }
  type->tp_base = bases[0];
  Py_INCREF((PyObject *)bases[0]);
  for (b = bases; *b != NULL; ++b)
    ++base_count;
  tuple = PyTuple_New(base_count);
  for (i = 0; i < base_count; ++i) {
    PyTuple_SET_ITEM(tuple, i, (PyObject *)bases[i]);
    Py_INCREF((PyObject *)bases[i]);
  }
  type->tp_bases = tuple;
}

SWIGINTERN PyObject *
SwigPyBuiltin_ThisClosure (PyObject *self, void *SWIGUNUSEDPARM(closure)) {
  PyObject *result;
  result = (PyObject *)SWIG_Python_GetSwigThis(self);
  Py_XINCREF(result);
  return result;
}

SWIGINTERN void
SwigPyBuiltin_SetMetaType (PyTypeObject *type, PyTypeObject *metatype)
{
#if PY_VERSION_HEX >= 0x03000000
    type->ob_base.ob_base.ob_type = metatype;
#else
    type->ob_type = metatype;
#endif
}

#ifdef __cplusplus
}
#endif




#define SWIG_exception_fail(code, msg) do { SWIG_Error(code, msg); SWIG_fail; } while(0) 

#define SWIG_contract_assert(expr, msg) if (!(expr)) { SWIG_Error(SWIG_RuntimeError, msg); SWIG_fail; } else 



  #define SWIG_exception(code, msg) do { SWIG_Error(code, msg); SWIG_fail;; } while(0) 

/* -----------------------------------------------------------------------------
 * director_common.swg
 *
 * This file contains support for director classes which is common between
 * languages.
 * ----------------------------------------------------------------------------- */

/*
  Use -DSWIG_DIRECTOR_STATIC if you prefer to avoid the use of the
  'Swig' namespace. This could be useful for multi-modules projects.
*/
#ifdef SWIG_DIRECTOR_STATIC
/* Force anonymous (static) namespace */
#define Swig
#endif
/* -----------------------------------------------------------------------------
 * director.swg
 *
 * This file contains support for director classes so that Python proxy
 * methods can be called from C++.
 * ----------------------------------------------------------------------------- */

#ifndef SWIG_DIRECTOR_PYTHON_HEADER_
#define SWIG_DIRECTOR_PYTHON_HEADER_

#include <string>
#include <iostream>
#include <exception>
#include <vector>
#include <map>


/*
  Use -DSWIG_PYTHON_DIRECTOR_NO_VTABLE if you don't want to generate a 'virtual
  table', and avoid multiple GetAttr calls to retrieve the python
  methods.
*/

#ifndef SWIG_PYTHON_DIRECTOR_NO_VTABLE
#ifndef SWIG_PYTHON_DIRECTOR_VTABLE
#define SWIG_PYTHON_DIRECTOR_VTABLE
#endif
#endif



/*
  Use -DSWIG_DIRECTOR_NO_UEH if you prefer to avoid the use of the
  Undefined Exception Handler provided by swig.
*/
#ifndef SWIG_DIRECTOR_NO_UEH
#ifndef SWIG_DIRECTOR_UEH
#define SWIG_DIRECTOR_UEH
#endif
#endif


/*
  Use -DSWIG_DIRECTOR_NORTTI if you prefer to avoid the use of the
  native C++ RTTI and dynamic_cast<>. But be aware that directors
  could stop working when using this option.
*/
#ifdef SWIG_DIRECTOR_NORTTI
/*
   When we don't use the native C++ RTTI, we implement a minimal one
   only for Directors.
*/
# ifndef SWIG_DIRECTOR_RTDIR
# define SWIG_DIRECTOR_RTDIR

namespace Swig {
  class Director;
  SWIGINTERN std::map<void *, Director *>& get_rtdir_map() {
    static std::map<void *, Director *> rtdir_map;
    return rtdir_map;
  }

  SWIGINTERNINLINE void set_rtdir(void *vptr, Director *rtdir) {
    get_rtdir_map()[vptr] = rtdir;
  }

  SWIGINTERNINLINE Director *get_rtdir(void *vptr) {
    std::map<void *, Director *>::const_iterator pos = get_rtdir_map().find(vptr);
    Director *rtdir = (pos != get_rtdir_map().end()) ? pos->second : 0;
    return rtdir;
  }
}
# endif /* SWIG_DIRECTOR_RTDIR */

# define SWIG_DIRECTOR_CAST(ARG) Swig::get_rtdir(static_cast<void *>(ARG))
# define SWIG_DIRECTOR_RGTR(ARG1, ARG2) Swig::set_rtdir(static_cast<void *>(ARG1), ARG2)

#else

# define SWIG_DIRECTOR_CAST(ARG) dynamic_cast<Swig::Director *>(ARG)
# define SWIG_DIRECTOR_RGTR(ARG1, ARG2)

#endif /* SWIG_DIRECTOR_NORTTI */

extern "C" {
  struct swig_type_info;
}

namespace Swig {

  /* memory handler */
  struct GCItem {
    virtual ~GCItem() {}

    virtual int get_own() const {
      return 0;
    }
  };

  struct GCItem_var {
    GCItem_var(GCItem *item = 0) : _item(item) {
    }

    GCItem_var& operator=(GCItem *item) {
      GCItem *tmp = _item;
      _item = item;
      delete tmp;
      return *this;
    }

    ~GCItem_var() {
      delete _item;
    }

    GCItem * operator->() const {
      return _item;
    }

  private:
    GCItem *_item;
  };

  struct GCItem_Object : GCItem {
    GCItem_Object(int own) : _own(own) {
    }

    virtual ~GCItem_Object() {
    }

    int get_own() const {
      return _own;
    }

  private:
    int _own;
  };

  template <typename Type>
  struct GCItem_T : GCItem {
    GCItem_T(Type *ptr) : _ptr(ptr) {
    }

    virtual ~GCItem_T() {
      delete _ptr;
    }

  private:
    Type *_ptr;
  };

  template <typename Type>
  struct GCArray_T : GCItem {
    GCArray_T(Type *ptr) : _ptr(ptr) {
    }

    virtual ~GCArray_T() {
      delete[] _ptr;
    }

  private:
    Type *_ptr;
  };

  /* base class for director exceptions */
  class DirectorException : public std::exception {
  protected:
    std::string swig_msg;
  public:
    DirectorException(PyObject *error, const char *hdr ="", const char *msg ="") : swig_msg(hdr) {
      SWIG_PYTHON_THREAD_BEGIN_BLOCK;
      if (msg[0]) {
        swig_msg += " ";
        swig_msg += msg;
      }
      if (!PyErr_Occurred()) {
        PyErr_SetString(error, what());
      }
      SWIG_PYTHON_THREAD_END_BLOCK;
    }

    virtual ~DirectorException() throw() {
    }

    /* Deprecated, use what() instead */
    const char *getMessage() const {
      return what();
    }

    const char *what() const throw() {
      return swig_msg.c_str();
    }

    static void raise(PyObject *error, const char *msg) {
      throw DirectorException(error, msg);
    }

    static void raise(const char *msg) {
      raise(PyExc_RuntimeError, msg);
    }
  };

  /* unknown exception handler  */
  class UnknownExceptionHandler {
#ifdef SWIG_DIRECTOR_UEH
    static void handler() {
      try {
        throw;
      } catch (DirectorException& e) {
        std::cerr << "SWIG Director exception caught:" << std::endl
                  << e.what() << std::endl;
      } catch (std::exception& e) {
        std::cerr << "std::exception caught: "<< e.what() << std::endl;
      } catch (...) {
        std::cerr << "Unknown exception caught." << std::endl;
      }

      std::cerr << std::endl
                << "Python interpreter traceback:" << std::endl;
      PyErr_Print();
      std::cerr << std::endl;

      std::cerr << "This exception was caught by the SWIG unexpected exception handler." << std::endl
                << "Try using %feature(\"director:except\") to avoid reaching this point." << std::endl
                << std::endl
                << "Exception is being re-thrown, program will likely abort/terminate." << std::endl;
      throw;
    }

  public:

    std::unexpected_handler old;
    UnknownExceptionHandler(std::unexpected_handler nh = handler) {
      old = std::set_unexpected(nh);
    }

    ~UnknownExceptionHandler() {
      std::set_unexpected(old);
    }
#endif
  };

  /* type mismatch in the return value from a python method call */
  class DirectorTypeMismatchException : public DirectorException {
  public:
    DirectorTypeMismatchException(PyObject *error, const char *msg="")
      : DirectorException(error, "SWIG director type mismatch", msg) {
    }

    DirectorTypeMismatchException(const char *msg="")
      : DirectorException(PyExc_TypeError, "SWIG director type mismatch", msg) {
    }

    static void raise(PyObject *error, const char *msg) {
      throw DirectorTypeMismatchException(error, msg);
    }

    static void raise(const char *msg) {
      throw DirectorTypeMismatchException(msg);
    }
  };

  /* any python exception that occurs during a director method call */
  class DirectorMethodException : public DirectorException {
  public:
    DirectorMethodException(const char *msg = "")
      : DirectorException(PyExc_RuntimeError, "SWIG director method error.", msg) {
    }

    static void raise(const char *msg) {
      throw DirectorMethodException(msg);
    }
  };

  /* attempt to call a pure virtual method via a director method */
  class DirectorPureVirtualException : public DirectorException {
  public:
    DirectorPureVirtualException(const char *msg = "")
      : DirectorException(PyExc_RuntimeError, "SWIG director pure virtual method called", msg) {
    }

    static void raise(const char *msg) {
      throw DirectorPureVirtualException(msg);
    }
  };


#if defined(SWIG_PYTHON_THREADS)
/*  __THREAD__ is the old macro to activate some thread support */
# if !defined(__THREAD__)
#   define __THREAD__ 1
# endif
#endif

#ifdef __THREAD__
# include "pythread.h"
  class Guard {
    PyThread_type_lock &mutex_;

  public:
    Guard(PyThread_type_lock & mutex) : mutex_(mutex) {
      PyThread_acquire_lock(mutex_, WAIT_LOCK);
    }

    ~Guard() {
      PyThread_release_lock(mutex_);
    }
  };
# define SWIG_GUARD(mutex) Guard _guard(mutex)
#else
# define SWIG_GUARD(mutex)
#endif

  /* director base class */
  class Director {
  private:
    /* pointer to the wrapped python object */
    PyObject *swig_self;
    /* flag indicating whether the object is owned by python or c++ */
    mutable bool swig_disown_flag;

    /* decrement the reference count of the wrapped python object */
    void swig_decref() const {
      if (swig_disown_flag) {
        SWIG_PYTHON_THREAD_BEGIN_BLOCK;
        Py_DECREF(swig_self);
        SWIG_PYTHON_THREAD_END_BLOCK;
      }
    }

  public:
    /* wrap a python object. */
    Director(PyObject *self) : swig_self(self), swig_disown_flag(false) {
    }

    /* discard our reference at destruction */
    virtual ~Director() {
      swig_decref();
    }

    /* return a pointer to the wrapped python object */
    PyObject *swig_get_self() const {
      return swig_self;
    }

    /* acquire ownership of the wrapped python object (the sense of "disown" is from python) */
    void swig_disown() const {
      if (!swig_disown_flag) {
        swig_disown_flag=true;
        swig_incref();
      }
    }

    /* increase the reference count of the wrapped python object */
    void swig_incref() const {
      if (swig_disown_flag) {
        Py_INCREF(swig_self);
      }
    }

    /* methods to implement pseudo protected director members */
    virtual bool swig_get_inner(const char * /* swig_protected_method_name */) const {
      return true;
    }

    virtual void swig_set_inner(const char * /* swig_protected_method_name */, bool /* swig_val */) const {
    }

  /* ownership management */
  private:
    typedef std::map<void *, GCItem_var> swig_ownership_map;
    mutable swig_ownership_map swig_owner;
#ifdef __THREAD__
    static PyThread_type_lock swig_mutex_own;
#endif

  public:
    template <typename Type>
    void swig_acquire_ownership_array(Type *vptr) const {
      if (vptr) {
        SWIG_GUARD(swig_mutex_own);
        swig_owner[vptr] = new GCArray_T<Type>(vptr);
      }
    }

    template <typename Type>
    void swig_acquire_ownership(Type *vptr) const {
      if (vptr) {
        SWIG_GUARD(swig_mutex_own);
        swig_owner[vptr] = new GCItem_T<Type>(vptr);
      }
    }

    void swig_acquire_ownership_obj(void *vptr, int own) const {
      if (vptr && own) {
        SWIG_GUARD(swig_mutex_own);
        swig_owner[vptr] = new GCItem_Object(own);
      }
    }

    int swig_release_ownership(void *vptr) const {
      int own = 0;
      if (vptr) {
        SWIG_GUARD(swig_mutex_own);
        swig_ownership_map::iterator iter = swig_owner.find(vptr);
        if (iter != swig_owner.end()) {
          own = iter->second->get_own();
          swig_owner.erase(iter);
        }
      }
      return own;
    }

    template <typename Type>
    static PyObject *swig_pyobj_disown(PyObject *pyobj, PyObject *SWIGUNUSEDPARM(args)) {
      SwigPyObject *sobj = (SwigPyObject *)pyobj;
      sobj->own = 0;
      Director *d = SWIG_DIRECTOR_CAST(reinterpret_cast<Type *>(sobj->ptr));
      if (d)
        d->swig_disown();
      return PyWeakref_NewProxy(pyobj, NULL);
    }
  };

#ifdef __THREAD__
  PyThread_type_lock Director::swig_mutex_own = PyThread_allocate_lock();
#endif
}

#endif

/* -------- TYPES TABLE (BEGIN) -------- */

#define SWIGTYPE_p_Column swig_types[0]
#define SWIGTYPE_p_EntityArray swig_types[1]
#define SWIGTYPE_p_InstanceType swig_types[2]
#define SWIGTYPE_p_KeyType swig_types[3]
#define SWIGTYPE_p_Row swig_types[4]
#define SWIGTYPE_p_SwigPyObject swig_types[5]
#define SWIGTYPE_p_TupleArray swig_types[6]
#define SWIGTYPE_p_ValueType swig_types[7]
#define SWIGTYPE_p_VariantArray swig_types[8]
#define SWIGTYPE_p_ampl__AMPL swig_types[9]
#define SWIGTYPE_p_ampl__AMPLException swig_types[10]
#define SWIGTYPE_p_ampl__BasicEntityT_ampl__ConstraintInstance_t swig_types[11]
#define SWIGTYPE_p_ampl__BasicEntityT_ampl__ObjectiveInstance_t swig_types[12]
#define SWIGTYPE_p_ampl__BasicEntityT_ampl__SetInstance_t swig_types[13]
#define SWIGTYPE_p_ampl__BasicEntityT_ampl__VariableInstance_t swig_types[14]
#define SWIGTYPE_p_ampl__BasicEntityT_ampl__VariantRef_t swig_types[15]
#define SWIGTYPE_p_ampl__Constraint swig_types[16]
#define SWIGTYPE_p_ampl__ConstraintInstance swig_types[17]
#define SWIGTYPE_p_ampl__DataFrame swig_types[18]
#define SWIGTYPE_p_ampl__Entity swig_types[19]
#define SWIGTYPE_p_ampl__EntityArgs swig_types[20]
#define SWIGTYPE_p_ampl__EntityMapT_ampl__Constraint_t swig_types[21]
#define SWIGTYPE_p_ampl__EntityMapT_ampl__Constraint_t__iterator swig_types[22]
#define SWIGTYPE_p_ampl__EntityMapT_ampl__Objective_t swig_types[23]
#define SWIGTYPE_p_ampl__EntityMapT_ampl__Objective_t__iterator swig_types[24]
#define SWIGTYPE_p_ampl__EntityMapT_ampl__Parameter_t swig_types[25]
#define SWIGTYPE_p_ampl__EntityMapT_ampl__Parameter_t__iterator swig_types[26]
#define SWIGTYPE_p_ampl__EntityMapT_ampl__Set_t swig_types[27]
#define SWIGTYPE_p_ampl__EntityMapT_ampl__Set_t__iterator swig_types[28]
#define SWIGTYPE_p_ampl__EntityMapT_ampl__Variable_t swig_types[29]
#define SWIGTYPE_p_ampl__EntityMapT_ampl__Variable_t__iterator swig_types[30]
#define SWIGTYPE_p_ampl__Environment swig_types[31]
#define SWIGTYPE_p_ampl__ErrorHandler swig_types[32]
#define SWIGTYPE_p_ampl__FileIOException swig_types[33]
#define SWIGTYPE_p_ampl__Instance swig_types[34]
#define SWIGTYPE_p_ampl__InvalidSubscriptException swig_types[35]
#define SWIGTYPE_p_ampl__LicenseException swig_types[36]
#define SWIGTYPE_p_ampl__NoDataException swig_types[37]
#define SWIGTYPE_p_ampl__Objective swig_types[38]
#define SWIGTYPE_p_ampl__ObjectiveInstance swig_types[39]
#define SWIGTYPE_p_ampl__OptionalT_bool_t swig_types[40]
#define SWIGTYPE_p_ampl__OptionalT_double_t swig_types[41]
#define SWIGTYPE_p_ampl__OptionalT_int_t swig_types[42]
#define SWIGTYPE_p_ampl__OptionalT_std__string_t swig_types[43]
#define SWIGTYPE_p_ampl__OutputHandler swig_types[44]
#define SWIGTYPE_p_ampl__Parameter swig_types[45]
#define SWIGTYPE_p_ampl__Runnable swig_types[46]
#define SWIGTYPE_p_ampl__Set swig_types[47]
#define SWIGTYPE_p_ampl__SetInstance swig_types[48]
#define SWIGTYPE_p_ampl__SetInstance__MemberRange swig_types[49]
#define SWIGTYPE_p_ampl__SetInstance__MemberRange__iterator swig_types[50]
#define SWIGTYPE_p_ampl__StringArray swig_types[51]
#define SWIGTYPE_p_ampl__StringRefArray swig_types[52]
#define SWIGTYPE_p_ampl__SyntaxErrorException swig_types[53]
#define SWIGTYPE_p_ampl__Tuple swig_types[54]
#define SWIGTYPE_p_ampl__TupleRef swig_types[55]
#define SWIGTYPE_p_ampl__UnsupportedOperationException swig_types[56]
#define SWIGTYPE_p_ampl__Variable swig_types[57]
#define SWIGTYPE_p_ampl__VariableInstance swig_types[58]
#define SWIGTYPE_p_ampl__Variant swig_types[59]
#define SWIGTYPE_p_ampl__VariantRef swig_types[60]
#define SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t swig_types[61]
#define SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t swig_types[62]
#define SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t swig_types[63]
#define SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t swig_types[64]
#define SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t swig_types[65]
#define SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t swig_types[66]
#define SWIGTYPE_p_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t swig_types[67]
#define SWIGTYPE_p_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t swig_types[68]
#define SWIGTYPE_p_ampl__internal__EntityWrapperT_ampl__SetInstance_t swig_types[69]
#define SWIGTYPE_p_ampl__internal__EntityWrapperT_ampl__VariableInstance_t swig_types[70]
#define SWIGTYPE_p_ampl__internal__EntityWrapperT_ampl__VariantRef_t swig_types[71]
#define SWIGTYPE_p_ampl__internal__EnvironmentIterator swig_types[72]
#define SWIGTYPE_p_ampl__internal__SliceT_false_t swig_types[73]
#define SWIGTYPE_p_ampl__internal__SliceT_false_t__iterator swig_types[74]
#define SWIGTYPE_p_ampl__internal__SliceT_true_t swig_types[75]
#define SWIGTYPE_p_ampl__internal__SliceT_true_t__iterator swig_types[76]
#define SWIGTYPE_p_char swig_types[77]
#define SWIGTYPE_p_double swig_types[78]
#define SWIGTYPE_p_iterator swig_types[79]
#define SWIGTYPE_p_p_char swig_types[80]
#define SWIGTYPE_p_std__runtime_error swig_types[81]
#define SWIGTYPE_p_unsigned_int swig_types[82]
static swig_type_info *swig_types[84];
static swig_module_info swig_module = {swig_types, 83, 0, 0, 0, 0};
#define SWIG_TypeQuery(name) SWIG_TypeQueryModule(&swig_module, &swig_module, name)
#define SWIG_MangledTypeQuery(name) SWIG_MangledTypeQueryModule(&swig_module, &swig_module, name)

/* -------- TYPES TABLE (END) -------- */

#if (PY_VERSION_HEX <= 0x02000000)
# if !defined(SWIG_PYTHON_CLASSIC)
#  error "This python version requires swig to be run with the '-classic' option"
# endif
#endif

/*-----------------------------------------------
              @(target):= _amplpython.so
  ------------------------------------------------*/
#if PY_VERSION_HEX >= 0x03000000
#  define SWIG_init    PyInit__amplpython

#else
#  define SWIG_init    init_amplpython

#endif
#define SWIG_name    "_amplpython"

#define SWIGVERSION 0x030008 
#define SWIG_VERSION SWIGVERSION


#define SWIG_as_voidptr(a) const_cast< void * >(static_cast< const void * >(a)) 
#define SWIG_as_voidptrptr(a) ((void)SWIG_as_voidptr(*a),reinterpret_cast< void** >(a)) 


#include <stdexcept>


namespace swig {
  class SwigPtr_PyObject {
  protected:
    PyObject *_obj;

  public:
    SwigPtr_PyObject() :_obj(0)
    {
    }

    SwigPtr_PyObject(const SwigPtr_PyObject& item) : _obj(item._obj)
    {
      SWIG_PYTHON_THREAD_BEGIN_BLOCK;
      Py_XINCREF(_obj);      
      SWIG_PYTHON_THREAD_END_BLOCK;
    }
    
    SwigPtr_PyObject(PyObject *obj, bool initial_ref = true) :_obj(obj)
    {
      if (initial_ref) {
        SWIG_PYTHON_THREAD_BEGIN_BLOCK;
        Py_XINCREF(_obj);
        SWIG_PYTHON_THREAD_END_BLOCK;
      }
    }
    
    SwigPtr_PyObject & operator=(const SwigPtr_PyObject& item) 
    {
      SWIG_PYTHON_THREAD_BEGIN_BLOCK;
      Py_XINCREF(item._obj);
      Py_XDECREF(_obj);
      _obj = item._obj;
      SWIG_PYTHON_THREAD_END_BLOCK;
      return *this;      
    }
    
    ~SwigPtr_PyObject() 
    {
      SWIG_PYTHON_THREAD_BEGIN_BLOCK;
      Py_XDECREF(_obj);
      SWIG_PYTHON_THREAD_END_BLOCK;
    }
    
    operator PyObject *() const
    {
      return _obj;
    }

    PyObject *operator->() const
    {
      return _obj;
    }
  };
}


namespace swig {
  struct SwigVar_PyObject : SwigPtr_PyObject {
    SwigVar_PyObject(PyObject* obj = 0) : SwigPtr_PyObject(obj, false) { }
    
    SwigVar_PyObject & operator = (PyObject* obj)
    {
      Py_XDECREF(_obj);
      _obj = obj;
      return *this;      
    }
  };
}


#include <stddef.h>


#if PY_VERSION_HEX>=0x03000000
  #define _PyString_AsString(str) PyUnicode_AsUTF8(str)
  #define _PyString_Check(obj) PyUnicode_Check(obj)
#else
  #define _PyString_AsString(str) PyString_AsString(str)
  #define _PyString_Check(obj) PyString_Check(obj)
#endif


  namespace std {
#if _WIN64
    typedef unsigned __int64 size_t;
#elif __clang__
    //
#elif __amd64__
    typedef unsigned long size_t;
#else
    typedef unsigned int size_t;
#endif
 }


  #include "ampl/ampl.h"


#include <string>


  #define SWIG_From_long   PyLong_FromLong 


SWIGINTERNINLINE PyObject* 
SWIG_From_unsigned_SS_long  (unsigned long value)
{
  return (value > LONG_MAX) ?
    PyLong_FromUnsignedLong(value) : PyLong_FromLong(static_cast< long >(value)); 
}


SWIGINTERNINLINE PyObject *
SWIG_From_size_t  (size_t value)
{    
  return SWIG_From_unsigned_SS_long  (static_cast< unsigned long >(value));
}


SWIGINTERN int
SWIG_AsVal_double (PyObject *obj, double *val)
{
  int res = SWIG_TypeError;
  if (PyFloat_Check(obj)) {
    if (val) *val = PyFloat_AsDouble(obj);
    return SWIG_OK;
#if PY_VERSION_HEX < 0x03000000
  } else if (PyInt_Check(obj)) {
    if (val) *val = PyInt_AsLong(obj);
    return SWIG_OK;
#endif
  } else if (PyLong_Check(obj)) {
    double v = PyLong_AsDouble(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      PyErr_Clear();
    }
  }
#ifdef SWIG_PYTHON_CAST_MODE
  {
    int dispatch = 0;
    double d = PyFloat_AsDouble(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = d;
      return SWIG_AddCast(SWIG_OK);
    } else {
      PyErr_Clear();
    }
    if (!dispatch) {
      long v = PyLong_AsLong(obj);
      if (!PyErr_Occurred()) {
	if (val) *val = v;
	return SWIG_AddCast(SWIG_AddCast(SWIG_OK));
      } else {
	PyErr_Clear();
      }
    }
  }
#endif
  return res;
}


#include <float.h>


#include <math.h>


SWIGINTERNINLINE int
SWIG_CanCastAsInteger(double *d, double min, double max) {
  double x = *d;
  if ((min <= x && x <= max)) {
   double fx = floor(x);
   double cx = ceil(x);
   double rd =  ((x - fx) < 0.5) ? fx : cx; /* simple rint */
   if ((errno == EDOM) || (errno == ERANGE)) {
     errno = 0;
   } else {
     double summ, reps, diff;
     if (rd < x) {
       diff = x - rd;
     } else if (rd > x) {
       diff = rd - x;
     } else {
       return 1;
     }
     summ = rd + x;
     reps = diff/summ;
     if (reps < 8*DBL_EPSILON) {
       *d = rd;
       return 1;
     }
   }
  }
  return 0;
}


SWIGINTERN int
SWIG_AsVal_unsigned_SS_long (PyObject *obj, unsigned long *val) 
{
#if PY_VERSION_HEX < 0x03000000
  if (PyInt_Check(obj)) {
    long v = PyInt_AsLong(obj);
    if (v >= 0) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      return SWIG_OverflowError;
    }
  } else
#endif
  if (PyLong_Check(obj)) {
    unsigned long v = PyLong_AsUnsignedLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      PyErr_Clear();
      return SWIG_OverflowError;
    }
  }
#ifdef SWIG_PYTHON_CAST_MODE
  {
    int dispatch = 0;
    unsigned long v = PyLong_AsUnsignedLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_AddCast(SWIG_OK);
    } else {
      PyErr_Clear();
    }
    if (!dispatch) {
      double d;
      int res = SWIG_AddCast(SWIG_AsVal_double (obj,&d));
      if (SWIG_IsOK(res) && SWIG_CanCastAsInteger(&d, 0, ULONG_MAX)) {
	if (val) *val = (unsigned long)(d);
	return res;
      }
    }
  }
#endif
  return SWIG_TypeError;
}


SWIGINTERNINLINE int
SWIG_AsVal_size_t (PyObject * obj, size_t *val)
{
  unsigned long v;
  int res = SWIG_AsVal_unsigned_SS_long (obj, val ? &v : 0);
  if (SWIG_IsOK(res) && val) *val = static_cast< size_t >(v);
  return res;
}


SWIGINTERN swig_type_info*
SWIG_pchar_descriptor(void)
{
  static int init = 0;
  static swig_type_info* info = 0;
  if (!init) {
    info = SWIG_TypeQuery("_p_char");
    init = 1;
  }
  return info;
}


SWIGINTERNINLINE PyObject *
SWIG_FromCharPtrAndSize(const char* carray, size_t size)
{
  if (carray) {
    if (size > INT_MAX) {
      swig_type_info* pchar_descriptor = SWIG_pchar_descriptor();
      return pchar_descriptor ? 
	SWIG_InternalNewPointerObj(const_cast< char * >(carray), pchar_descriptor, 0) : SWIG_Py_Void();
    } else {
#if PY_VERSION_HEX >= 0x03000000
#if PY_VERSION_HEX >= 0x03010000
      return PyUnicode_DecodeUTF8(carray, static_cast< Py_ssize_t >(size), "surrogateescape");
#else
      return PyUnicode_FromStringAndSize(carray, static_cast< Py_ssize_t >(size));
#endif
#else
      return PyString_FromStringAndSize(carray, static_cast< Py_ssize_t >(size));
#endif
    }
  } else {
    return SWIG_Py_Void();
  }
}


SWIGINTERNINLINE PyObject * 
SWIG_FromCharPtr(const char *cptr)
{ 
  return SWIG_FromCharPtrAndSize(cptr, (cptr ? strlen(cptr) : 0));
}


#include <stdexcept>


typedef struct {
    ampl::Variant *el;
} VariantArray;

SWIGINTERN VariantArray *new_VariantArray(size_t nelements){
      VariantArray *arr = (new VariantArray);
      arr->el = (new ampl::Variant[nelements]);
      return arr;
  }
SWIGINTERN void delete_VariantArray(VariantArray *self){
      delete[] self->el;
      delete self;
  }
SWIGINTERN ampl::Variant VariantArray___getitem__(VariantArray *self,size_t index){
      return self->el[index];
  }
SWIGINTERN void VariantArray___setitem__(VariantArray *self,size_t index,ampl::Variant value){
      self->el[index] = value;
  }
SWIGINTERN ampl::Variant *VariantArray_cast(VariantArray *self){
      return self->el;
  }
SWIGINTERN VariantArray *VariantArray_frompointer(ampl::Variant *t){
      return reinterpret_cast< VariantArray * >(t);
  }

typedef struct {
    ampl::Tuple *el;
} TupleArray;

SWIGINTERN TupleArray *new_TupleArray(size_t nelements){
      TupleArray *arr = (new TupleArray);
      arr->el = (new ampl::Tuple[nelements]);
      return arr;
  }
SWIGINTERN void delete_TupleArray(TupleArray *self){
      delete[] self->el;
      delete self;
  }
SWIGINTERN ampl::Tuple TupleArray___getitem__(TupleArray *self,size_t index){
      return self->el[index];
  }
SWIGINTERN void TupleArray___setitem__(TupleArray *self,size_t index,ampl::Tuple value){
      self->el[index] = value;
  }
SWIGINTERN ampl::Tuple *TupleArray_cast(TupleArray *self){
      return self->el;
  }
SWIGINTERN TupleArray *TupleArray_frompointer(ampl::Tuple *t){
      return reinterpret_cast< TupleArray * >(t);
  }

#include <limits.h>
#if !defined(SWIG_NO_LLONG_MAX)
# if !defined(LLONG_MAX) && defined(__GNUC__) && defined (__LONG_LONG_MAX__)
#   define LLONG_MAX __LONG_LONG_MAX__
#   define LLONG_MIN (-LLONG_MAX - 1LL)
#   define ULLONG_MAX (LLONG_MAX * 2ULL + 1ULL)
# endif
#endif


SWIGINTERN int
SWIG_AsVal_long (PyObject *obj, long* val)
{
#if PY_VERSION_HEX < 0x03000000
  if (PyInt_Check(obj)) {
    if (val) *val = PyInt_AsLong(obj);
    return SWIG_OK;
  } else
#endif
  if (PyLong_Check(obj)) {
    long v = PyLong_AsLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      PyErr_Clear();
      return SWIG_OverflowError;
    }
  }
#ifdef SWIG_PYTHON_CAST_MODE
  {
    int dispatch = 0;
    long v = PyInt_AsLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_AddCast(SWIG_OK);
    } else {
      PyErr_Clear();
    }
    if (!dispatch) {
      double d;
      int res = SWIG_AddCast(SWIG_AsVal_double (obj,&d));
      if (SWIG_IsOK(res) && SWIG_CanCastAsInteger(&d, LONG_MIN, LONG_MAX)) {
	if (val) *val = (long)(d);
	return res;
      }
    }
  }
#endif
  return SWIG_TypeError;
}


SWIGINTERN int
SWIG_AsVal_int (PyObject * obj, int *val)
{
  long v;
  int res = SWIG_AsVal_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v < INT_MIN || v > INT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = static_cast< int >(v);
    }
  }  
  return res;
}


SWIGINTERNINLINE PyObject*
  SWIG_From_bool  (bool value)
{
  return PyBool_FromLong(value ? 1 : 0);
}


SWIGINTERNINLINE PyObject*
  SWIG_From_int  (int value)
{
  return PyInt_FromLong((long) value);
}


SWIGINTERN int
SWIG_AsCharPtrAndSize(PyObject *obj, char** cptr, size_t* psize, int *alloc)
{
#if PY_VERSION_HEX>=0x03000000
  if (PyUnicode_Check(obj))
#else  
  if (PyString_Check(obj))
#endif
  {
    char *cstr; Py_ssize_t len;
#if PY_VERSION_HEX>=0x03000000
    if (!alloc && cptr) {
        /* We can't allow converting without allocation, since the internal
           representation of string in Python 3 is UCS-2/UCS-4 but we require
           a UTF-8 representation.
           TODO(bhy) More detailed explanation */
        return SWIG_RuntimeError;
    }
    obj = PyUnicode_AsUTF8String(obj);
    PyBytes_AsStringAndSize(obj, &cstr, &len);
    if(alloc) *alloc = SWIG_NEWOBJ;
#else
    PyString_AsStringAndSize(obj, &cstr, &len);
#endif
    if (cptr) {
      if (alloc) {
	/* 
	   In python the user should not be able to modify the inner
	   string representation. To warranty that, if you define
	   SWIG_PYTHON_SAFE_CSTRINGS, a new/copy of the python string
	   buffer is always returned.

	   The default behavior is just to return the pointer value,
	   so, be careful.
	*/ 
#if defined(SWIG_PYTHON_SAFE_CSTRINGS)
	if (*alloc != SWIG_OLDOBJ) 
#else
	if (*alloc == SWIG_NEWOBJ) 
#endif
	{
	  *cptr = reinterpret_cast< char* >(memcpy((new char[len + 1]), cstr, sizeof(char)*(len + 1)));
	  *alloc = SWIG_NEWOBJ;
	} else {
	  *cptr = cstr;
	  *alloc = SWIG_OLDOBJ;
	}
      } else {
	#if PY_VERSION_HEX>=0x03000000
	assert(0); /* Should never reach here in Python 3 */
	#endif
	*cptr = SWIG_Python_str_AsChar(obj);
      }
    }
    if (psize) *psize = len + 1;
#if PY_VERSION_HEX>=0x03000000
    Py_XDECREF(obj);
#endif
    return SWIG_OK;
  } else {
#if defined(SWIG_PYTHON_2_UNICODE)
#if PY_VERSION_HEX<0x03000000
    if (PyUnicode_Check(obj)) {
      char *cstr; Py_ssize_t len;
      if (!alloc && cptr) {
        return SWIG_RuntimeError;
      }
      obj = PyUnicode_AsUTF8String(obj);
      if (PyString_AsStringAndSize(obj, &cstr, &len) != -1) {
        if (cptr) {
          if (alloc) *alloc = SWIG_NEWOBJ;
          *cptr = reinterpret_cast< char* >(memcpy((new char[len + 1]), cstr, sizeof(char)*(len + 1)));
        }
        if (psize) *psize = len + 1;

        Py_XDECREF(obj);
        return SWIG_OK;
      } else {
        Py_XDECREF(obj);
      }
    }
#endif
#endif

    swig_type_info* pchar_descriptor = SWIG_pchar_descriptor();
    if (pchar_descriptor) {
      void* vptr = 0;
      if (SWIG_ConvertPtr(obj, &vptr, pchar_descriptor, 0) == SWIG_OK) {
	if (cptr) *cptr = (char *) vptr;
	if (psize) *psize = vptr ? (strlen((char *)vptr) + 1) : 0;
	if (alloc) *alloc = SWIG_OLDOBJ;
	return SWIG_OK;
      }
    }
  }
  return SWIG_TypeError;
}


SWIGINTERN int
SWIG_AsPtr_std_string (PyObject * obj, std::string **val) 
{
  char* buf = 0 ; size_t size = 0; int alloc = SWIG_OLDOBJ;
  if (SWIG_IsOK((SWIG_AsCharPtrAndSize(obj, &buf, &size, &alloc)))) {
    if (buf) {
      if (val) *val = new std::string(buf, size - 1);
      if (alloc == SWIG_NEWOBJ) delete[] buf;
      return SWIG_NEWOBJ;
    } else {
      if (val) *val = 0;
      return SWIG_OLDOBJ;
    }
  } else {
    static int init = 0;
    static swig_type_info* descriptor = 0;
    if (!init) {
      descriptor = SWIG_TypeQuery("std::string" " *");
      init = 1;
    }
    if (descriptor) {
      std::string *vptr;
      int res = SWIG_ConvertPtr(obj, (void**)&vptr, descriptor, 0);
      if (SWIG_IsOK(res) && val) *val = vptr;
      return res;
    }
  }
  return SWIG_ERROR;
}


SWIGINTERNINLINE PyObject *
SWIG_From_std_string  (const std::string& s)
{
  return SWIG_FromCharPtrAndSize(s.data(), s.size());
}


SWIGINTERN int
SWIG_AsVal_bool (PyObject *obj, bool *val)
{
  int r;
  if (!PyBool_Check(obj))
    return SWIG_ERROR;
  r = PyObject_IsTrue(obj);
  if (r == -1)
    return SWIG_ERROR;
  if (val) *val = r ? true : false;
  return SWIG_OK;
}


  #define SWIG_From_double   PyFloat_FromDouble 

SWIGINTERN bool ampl_Variant_equals(ampl::Variant *self,ampl::Variant &b){
      return ampl::internal::compare(*self, b)==0;
    }
SWIGINTERN int ampl_Variant_compare(ampl::Variant *self,ampl::Variant &b){
      return ampl::internal::compare(*self, b);
    }
SWIGINTERN bool ampl_VariantRef_equals(ampl::VariantRef *self,ampl::VariantRef &b){
      return ampl::internal::compare(*self, b) == 0;
    }
SWIGINTERN int ampl_VariantRef_compare(ampl::VariantRef *self,ampl::VariantRef &b){
      return ampl::internal::compare(*self, b);
    }



SWIGINTERN bool ampl_Tuple_operator_Se__Se_(ampl::Tuple *self,ampl::Tuple &other){
  return (other == *self);
  }
SWIGINTERN ampl::Tuple ampl_Tuple_Factory__SWIG_0(VariantArray &args,std::size_t count){
    return ampl::Tuple(VariantArray_cast(&args), count);
  }
SWIGINTERN ampl::Tuple ampl_Tuple_Factory__SWIG_1(ampl::TupleRef t){
    return ampl::Tuple(t);
  }
SWIGINTERN void ampl_DataFrame_addColumnSWIG(ampl::DataFrame *self,fmt::CStringRef header){
  return self->addColumn(header);
}
SWIGINTERN void ampl_DataFrame_addColumnSWIG(ampl::DataFrame *self,fmt::CStringRef header,char const *args[]){
  return self->addColumn(header, ampl::internal::Args(args));
}
SWIGINTERN void ampl_DataFrame_addColumnSWIG(ampl::DataFrame *self,fmt::CStringRef header,double *args){
  return self->addColumn(header, ampl::internal::Args(args));
}
SWIGINTERN void ampl_DataFrame_addRow__SWIG_5(ampl::DataFrame *self,ampl::Tuple tuple){
  return self->addRow(ampl::TupleRef(tuple));
  }
SWIGINTERN ampl::internal::Slice< true > ampl_DataFrame_getRow__SWIG_3(ampl::DataFrame *self,ampl::Tuple tuple){
  return self->getRow(ampl::TupleRef(tuple));
  }
SWIGINTERN void ampl_DataFrame_setColumnSWIG(ampl::DataFrame *self,fmt::CStringRef header,char const *args[],std::size_t n){
    self->setColumn(header, ampl::internal::Args(args), n);
  }
SWIGINTERN void ampl_DataFrame_setColumnSWIG(ampl::DataFrame *self,fmt::CStringRef header,double *values,std::size_t n){
    self->setColumn(header, ampl::internal::Args(values), n);
  }
SWIGINTERN void ampl_DataFrame_setArraySWIG(ampl::DataFrame *self,double *args,double *values,std::size_t n){
    self->setArray(n, ampl::internal::Args(args), values);
  }
SWIGINTERN void ampl_DataFrame_setArraySWIG(ampl::DataFrame *self,char const *args[],double *values,std::size_t n){
    self->setArray(n, ampl::internal::Args(args), values);
  }
SWIGINTERN void ampl_DataFrame_setArraySWIG(ampl::DataFrame *self,double *args,char const *const *values,std::size_t n){
    self->setArray(n, ampl::internal::Args(args), values);
  }
SWIGINTERN void ampl_DataFrame_setArraySWIG(ampl::DataFrame *self,char const *args[],char const *const *values,std::size_t n){
    self->setArray(n, ampl::internal::Args(args), values);
  }
SWIGINTERN void ampl_DataFrame_setMatrixSWIG(ampl::DataFrame *self,double *row_indices,std::size_t rown,double *col_indices,std::size_t coln,double const *values){
    self->setMatrix(rown, ampl::internal::Args(row_indices), coln,
      ampl::internal::Args(col_indices), values);
  }
SWIGINTERN void ampl_DataFrame_setMatrixSWIG(ampl::DataFrame *self,char const *row_indices[],std::size_t rown,char const *col_indices[],std::size_t coln,double const *values){
    self->setMatrix(rown, ampl::internal::Args(row_indices), coln,
      ampl::internal::Args(col_indices), values);
  }
SWIGINTERN void ampl_DataFrame_setMatrixSWIG(ampl::DataFrame *self,double *row_indices,std::size_t rown,char const *col_indices[],std::size_t coln,double const *values){
    self->setMatrix(rown, ampl::internal::Args(row_indices), coln,
      ampl::internal::Args(col_indices), values);
  }
SWIGINTERN void ampl_DataFrame_setMatrixSWIG(ampl::DataFrame *self,char const *row_indices[],std::size_t rown,double *col_indices,std::size_t coln,double const *values){
    self->setMatrix(rown, ampl::internal::Args(row_indices), coln,
      ampl::internal::Args(col_indices), values);
  }
SWIGINTERN void ampl_DataFrame_setMatrixSWIG(ampl::DataFrame *self,double *row_indices,std::size_t rown,double *col_indices,std::size_t coln,char const *args[]){
    self->setMatrix(rown, ampl::internal::Args(row_indices), coln,
      ampl::internal::Args(col_indices), args);
  }
SWIGINTERN void ampl_DataFrame_setMatrixSWIG(ampl::DataFrame *self,double *row_indices,std::size_t rown,char const *col_indices[],std::size_t coln,char const *args[]){
    self->setMatrix(rown, ampl::internal::Args(row_indices), coln,
      ampl::internal::Args(col_indices), args);
  }
SWIGINTERN void ampl_DataFrame_setMatrixSWIG(ampl::DataFrame *self,char const *row_indices[],std::size_t rown,double *col_indices,std::size_t coln,char const *args[]){
    self->setMatrix(rown, ampl::internal::Args(row_indices), coln,
      ampl::internal::Args(col_indices), args);
  }
SWIGINTERN void ampl_DataFrame_setMatrixSWIG(ampl::DataFrame *self,char const *row_indices[],std::size_t rown,char const *col_indices[],std::size_t coln,char const *args[]){
    self->setMatrix(rown, ampl::internal::Args(row_indices), coln,
      ampl::internal::Args(col_indices), args);
  }
SWIGINTERN ampl::DataFrame ampl_DataFrame_factory(int numberOfIndexColumns,char const *args[],int count){
    ampl::StringArgs s(args, count);
    return ampl::DataFrame(numberOfIndexColumns, s);
  }
SWIGINTERN bool ampl_SetInstance_Contains(ampl::SetInstance const *self,ampl::Tuple t){
    return self->contains(ampl::TupleRef(t));
  }
SWIGINTERN void ampl_SetInstance_setValues(ampl::SetInstance *self,TupleArray &t,std::size_t n){
    return self->setValues(TupleArray_cast(&t), n);
  }
SWIGINTERN void ampl_SetInstance_setValues(ampl::SetInstance *self,double *values,std::size_t n){
    return self->setValues(ampl::internal::Args(values), n);
  }
SWIGINTERN void ampl_SetInstance_setValues(ampl::SetInstance *self,char const *args[],std::size_t n){
    return self->setValues(ampl::internal::Args(args), n);
  }

typedef struct {
    ampl::Entity *el;
} EntityArray;

SWIGINTERN EntityArray *new_EntityArray(size_t nelements){
      EntityArray *arr = (new EntityArray);
      arr->el = (new ampl::Entity[nelements]);
      return arr;
  }
SWIGINTERN void delete_EntityArray(EntityArray *self){
      delete[] self->el;
      delete self;
  }
SWIGINTERN ampl::Entity EntityArray___getitem__(EntityArray *self,size_t index){
      return self->el[index];
  }
SWIGINTERN void EntityArray___setitem__(EntityArray *self,size_t index,ampl::Entity value){
      self->el[index] = value;
  }
SWIGINTERN ampl::Entity *EntityArray_cast(EntityArray *self){
      return self->el;
  }
SWIGINTERN EntityArray *EntityArray_frompointer(ampl::Entity *t){
      return reinterpret_cast< EntityArray * >(t);
  }
SWIGINTERN ampl::DataFrame ampl_Entity_getValues(ampl::Entity *self,char const *args[],int count){
      ampl::StringArgs s(args, count);
      return self->getValues(s);
    }
SWIGINTERN ampl::EntityArgs ampl_EntityArgs_Factory(EntityArray &args,std::size_t count){
    return ampl::EntityArgs(EntityArray_cast(&args), count);
  }
SWIGINTERN bool ampl_Set_contains(ampl::Set const *self,ampl::Tuple t){
        return self->contains(ampl::TupleRef(t));
      }
SWIGINTERN void ampl_Set_setValues(ampl::Set *self,TupleArray &t,std::size_t n){
        return self->setValues(TupleArray_cast(&t), n);
      }
SWIGINTERN void ampl_Set_setValues(ampl::Set *self,double *values,std::size_t n){
        return self->setValues(ampl::internal::Args(values), n);
      }
SWIGINTERN void ampl_Set_setValues(ampl::Set *self,char const *args[],std::size_t n){
        return self->setValues(ampl::internal::Args(args), n);
      }
SWIGINTERN void ampl_Parameter_set__SWIG_0(ampl::Parameter *self,ampl::Variant value){
      self->set(ampl::VariantRef(value));
    }
SWIGINTERN void ampl_Parameter_set__SWIG_1(ampl::Parameter *self,double value){
        self->set(ampl::VariantRef(value));
      }
SWIGINTERN void ampl_Parameter_set__SWIG_2(ampl::Parameter *self,char const *value){
      self->set(ampl::VariantRef(value));
    }
SWIGINTERN void ampl_Parameter_set__SWIG_3(ampl::Parameter *self,ampl::Tuple index,ampl::Variant value){
      self->set(ampl::TupleRef(index), ampl::VariantRef(value));
    }
SWIGINTERN void ampl_Parameter_set(ampl::Parameter *self,ampl::Tuple index,double value){
        self->set(ampl::TupleRef(index), ampl::VariantRef(value));
      }
SWIGINTERN void ampl_Parameter_set(ampl::Parameter *self,ampl::Tuple index,char const *value){
      self->set(ampl::TupleRef(index), ampl::VariantRef(value));
    }
SWIGINTERN void ampl_Parameter_setValues(ampl::Parameter *self,TupleArray &indices,double *values,std::size_t nvalues){
        self->setValues(TupleArray_cast(&indices), ampl::internal::Args(values), nvalues);
      }
SWIGINTERN void ampl_Parameter_setValues(ampl::Parameter *self,TupleArray &indices,char const *args[],std::size_t nvalues){
        self->setValues(TupleArray_cast(&indices), ampl::internal::Args(args), nvalues);
      }
SWIGINTERN void ampl_Parameter_setValues(ampl::Parameter *self,double *values,std::size_t n){
        self->setValues(ampl::internal::Args(values), n);
      }
SWIGINTERN void ampl_Parameter_setValues(ampl::Parameter *self,char const *args[],std::size_t n){
        self->setValues(ampl::internal::Args(args), n);
      }
SWIGINTERN void ampl_Parameter_setValues__SWIG_0(ampl::Parameter *self,std::size_t num_rows,char const *row_indices[],std::size_t num_cols,char const *col_indices[],double const *values,bool transpose){
        self->setValues(num_rows, ampl::internal::Args(row_indices),
          num_cols,ampl::internal::Args(col_indices), values, transpose);
      }
SWIGINTERN void ampl_Parameter_setValues__SWIG_1(ampl::Parameter *self,std::size_t num_rows,double *row_indices,std::size_t num_cols,double *col_indices,double const *values,bool transpose){
        self->setValues(num_rows, ampl::internal::Args(row_indices),
          num_cols,ampl::internal::Args(col_indices), values, transpose);
      }
SWIGINTERN ampl::internal::EntityWrapper< ampl::VariableInstance >::KeyType ampl_internal_CountedIterator_Sl_ampl_internal_EntityWrapper_Sl_ampl_VariableInstance_Sg__Sg__first(ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > *self){
        return self->operator*().first;
        }
SWIGINTERN ampl::internal::EntityWrapper< ampl::VariableInstance >::InstanceType ampl_internal_CountedIterator_Sl_ampl_internal_EntityWrapper_Sl_ampl_VariableInstance_Sg__Sg__second(ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > *self){
        return self->operator*().second;
      }
SWIGINTERN ampl::internal::EntityWrapper< ampl::ConstraintInstance >::KeyType ampl_internal_CountedIterator_Sl_ampl_internal_EntityWrapper_Sl_ampl_ConstraintInstance_Sg__Sg__first(ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > *self){
        return self->operator*().first;
        }
SWIGINTERN ampl::internal::EntityWrapper< ampl::ConstraintInstance >::InstanceType ampl_internal_CountedIterator_Sl_ampl_internal_EntityWrapper_Sl_ampl_ConstraintInstance_Sg__Sg__second(ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > *self){
        return self->operator*().second;
      }
SWIGINTERN ampl::internal::EntityWrapper< ampl::ObjectiveInstance >::KeyType ampl_internal_CountedIterator_Sl_ampl_internal_EntityWrapper_Sl_ampl_ObjectiveInstance_Sg__Sg__first(ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > *self){
        return self->operator*().first;
        }
SWIGINTERN ampl::internal::EntityWrapper< ampl::ObjectiveInstance >::InstanceType ampl_internal_CountedIterator_Sl_ampl_internal_EntityWrapper_Sl_ampl_ObjectiveInstance_Sg__Sg__second(ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > *self){
        return self->operator*().second;
      }
SWIGINTERN ampl::internal::EntityWrapper< ampl::SetInstance >::KeyType ampl_internal_CountedIterator_Sl_ampl_internal_EntityWrapper_Sl_ampl_SetInstance_Sg__Sg__first(ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > *self){
        return self->operator*().first;
        }
SWIGINTERN ampl::internal::EntityWrapper< ampl::SetInstance >::InstanceType ampl_internal_CountedIterator_Sl_ampl_internal_EntityWrapper_Sl_ampl_SetInstance_Sg__Sg__second(ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > *self){
        return self->operator*().second;
      }
SWIGINTERN ampl::internal::EntityWrapper< ampl::VariantRef >::KeyType ampl_internal_CountedIterator_Sl_ampl_internal_EntityWrapper_Sl_ampl_VariantRef_Sg__Sg__first(ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > *self){
        return self->operator*().first;
        }
SWIGINTERN ampl::internal::EntityWrapper< ampl::VariantRef >::InstanceType ampl_internal_CountedIterator_Sl_ampl_internal_EntityWrapper_Sl_ampl_VariantRef_Sg__Sg__second(ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > *self){
        return self->operator*().second;
      }

#if defined(__GNUC__)
#  if __GNUC__ == 2 && __GNUC_MINOR <= 96
#     define SWIG_STD_NOMODERN_STL
#  endif
#endif


#include <utility>


	#include "ampl/environment.h"

SWIGINTERN ampl::internal::EnvironmentIterator::KeyType ampl_internal_CountedIterator_Sl_ampl_internal_EnvironmentIterator_Sg__first(ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > *self){
        return self->operator*().first;
        }
SWIGINTERN ampl::internal::EnvironmentIterator::InstanceType ampl_internal_CountedIterator_Sl_ampl_internal_EnvironmentIterator_Sg__second(ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > *self){
        return self->operator*().second;
      }
SWIGINTERN void ampl_AMPL_display(ampl::AMPL *self,char const *args[],int count){
  ampl::StringArgs s(args, count);
  self->display(s);
}
SWIGINTERN ampl::DataFrame ampl_AMPL_getData(ampl::AMPL *self,char const *args[],int count){
  ampl::StringArgs s(args, count);
  return self->getData(s);
}


/* ---------------------------------------------------
 * C++ director class methods
 * --------------------------------------------------- */

#include "amplpythonPYTHON_wrap.h"

SwigDirector_ErrorHandler::SwigDirector_ErrorHandler(PyObject *self): ampl::ErrorHandler(), Swig::Director(self) {
  SWIG_DIRECTOR_RGTR((ampl::ErrorHandler *)this, this); 
}




SwigDirector_ErrorHandler::~SwigDirector_ErrorHandler() {
}

void SwigDirector_ErrorHandler::error(ampl::AMPLException const &arg0) {
  PyObject *self = NULL;
  (void)self;
  swig::SwigVar_PyObject obj0;
  obj0 = SWIG_NewPointerObj(SWIG_as_voidptr(&arg0), SWIGTYPE_p_ampl__AMPLException,  0 );
  if (!swig_get_self()) {
    Swig::DirectorException::raise("'self' uninitialized, maybe you forgot to call ErrorHandler.__init__.");
  }
#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
  const size_t swig_method_index = 0;
  const char * const swig_method_name = "error";
  PyObject* method = swig_get_method(swig_method_index, swig_method_name);
  swig::SwigVar_PyObject result = PyObject_CallFunction(method, (char *)"(O)" ,(PyObject *)obj0);
#else
  swig::SwigVar_PyObject result = PyObject_CallMethod(swig_get_self(), (char *)"error", (char *)"(O)" ,(PyObject *)obj0);
#endif
  if (!result) {
    PyObject *error = PyErr_Occurred();
    if (error) {
      Swig::DirectorMethodException::raise("Error detected when calling 'ErrorHandler.error'");
    }
  }
}


void SwigDirector_ErrorHandler::warning(ampl::AMPLException const &arg0) {
  PyObject *self = NULL;
  (void)self;
  swig::SwigVar_PyObject obj0;
  obj0 = SWIG_NewPointerObj(SWIG_as_voidptr(&arg0), SWIGTYPE_p_ampl__AMPLException,  0 );
  if (!swig_get_self()) {
    Swig::DirectorException::raise("'self' uninitialized, maybe you forgot to call ErrorHandler.__init__.");
  }
#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
  const size_t swig_method_index = 1;
  const char * const swig_method_name = "warning";
  PyObject* method = swig_get_method(swig_method_index, swig_method_name);
  swig::SwigVar_PyObject result = PyObject_CallFunction(method, (char *)"(O)" ,(PyObject *)obj0);
#else
  swig::SwigVar_PyObject result = PyObject_CallMethod(swig_get_self(), (char *)"warning", (char *)"(O)" ,(PyObject *)obj0);
#endif
  if (!result) {
    PyObject *error = PyErr_Occurred();
    if (error) {
      Swig::DirectorMethodException::raise("Error detected when calling 'ErrorHandler.warning'");
    }
  }
}


SwigDirector_Runnable::SwigDirector_Runnable(PyObject *self): ampl::Runnable(), Swig::Director(self) {
  SWIG_DIRECTOR_RGTR((ampl::Runnable *)this, this); 
}




SwigDirector_Runnable::~SwigDirector_Runnable() {
}

void SwigDirector_Runnable::run() {
  PyObject *self = NULL;
  (void)self;
  if (!swig_get_self()) {
    Swig::DirectorException::raise("'self' uninitialized, maybe you forgot to call Runnable.__init__.");
  }
#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
  const size_t swig_method_index = 0;
  const char * const swig_method_name = "run";
  PyObject* method = swig_get_method(swig_method_index, swig_method_name);
  swig::SwigVar_PyObject result = PyObject_CallFunction(method, NULL, NULL);
#else
  swig::SwigVar_PyObject result = PyObject_CallMethod(swig_get_self(), (char *) "run", NULL);
#endif
  if (!result) {
    PyObject *error = PyErr_Occurred();
    if (error) {
      Swig::DirectorMethodException::raise("Error detected when calling 'Runnable.run'");
    }
  }
}


SwigDirector_OutputHandler::SwigDirector_OutputHandler(PyObject *self): ampl::OutputHandler(), Swig::Director(self) {
  SWIG_DIRECTOR_RGTR((ampl::OutputHandler *)this, this); 
}




SwigDirector_OutputHandler::~SwigDirector_OutputHandler() {
}

void SwigDirector_OutputHandler::output(ampl::output::Kind kind, char const *msg) {
  PyObject *self = NULL;
  (void)self;
  swig::SwigVar_PyObject obj0;
  obj0 = SWIG_From_int(static_cast< int >(kind));
  swig::SwigVar_PyObject obj1;
  obj1 = SWIG_FromCharPtr((const char *)msg);
  if (!swig_get_self()) {
    Swig::DirectorException::raise("'self' uninitialized, maybe you forgot to call OutputHandler.__init__.");
  }
#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
  const size_t swig_method_index = 0;
  const char * const swig_method_name = "output";
  PyObject* method = swig_get_method(swig_method_index, swig_method_name);
  swig::SwigVar_PyObject result = PyObject_CallFunction(method, (char *)"(OO)" ,(PyObject *)obj0,(PyObject *)obj1);
#else
  swig::SwigVar_PyObject result = PyObject_CallMethod(swig_get_self(), (char *)"output", (char *)"(OO)" ,(PyObject *)obj0,(PyObject *)obj1);
#endif
  if (!result) {
    PyObject *error = PyErr_Occurred();
    if (error) {
      Swig::DirectorMethodException::raise("Error detected when calling 'OutputHandler.output'");
    }
  }
}


#ifdef __cplusplus
extern "C" {
#endif
SWIGINTERN PyObject *_wrap_StringArray_size(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::StringArray *arg1 = (ampl::StringArray *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::size_t result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "StringArray_size takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__StringArray, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StringArray_size" "', argument " "1"" of type '" "ampl::StringArray const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::StringArray * >(argp1);
  result = (std::size_t)((ampl::StringArray const *)arg1)->size();
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_StringArray_getIndex(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::StringArray *arg1 = (ampl::StringArray *) 0 ;
  std::size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj1 = 0 ;
  char *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:StringArray_getIndex",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__StringArray, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StringArray_getIndex" "', argument " "1"" of type '" "ampl::StringArray const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::StringArray * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "StringArray_getIndex" "', argument " "2"" of type '" "std::size_t""'");
  } 
  arg2 = static_cast< std::size_t >(val2);
  result = (char *)((ampl::StringArray const *)arg1)->operator [](arg2);
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_StringArray(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::StringArray *arg1 = (ampl::StringArray *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_StringArray takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__StringArray, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_StringArray" "', argument " "1"" of type '" "ampl::StringArray *""'"); 
  }
  arg1 = reinterpret_cast< ampl::StringArray * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_StringRefArray_size(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::StringRefArray *arg1 = (ampl::StringRefArray *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::size_t result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "StringRefArray_size takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__StringRefArray, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StringRefArray_size" "', argument " "1"" of type '" "ampl::StringRefArray const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::StringRefArray * >(argp1);
  result = (std::size_t)((ampl::StringRefArray const *)arg1)->size();
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_StringRefArray_getIndex(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::StringRefArray *arg1 = (ampl::StringRefArray *) 0 ;
  std::size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj1 = 0 ;
  char *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:StringRefArray_getIndex",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__StringRefArray, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StringRefArray_getIndex" "', argument " "1"" of type '" "ampl::StringRefArray const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::StringRefArray * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "StringRefArray_getIndex" "', argument " "2"" of type '" "std::size_t""'");
  } 
  arg2 = static_cast< std::size_t >(val2);
  result = (char *)((ampl::StringRefArray const *)arg1)->operator [](arg2);
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_StringRefArray(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::StringRefArray *arg1 = (ampl::StringRefArray *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_StringRefArray takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__StringRefArray, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_StringRefArray" "', argument " "1"" of type '" "ampl::StringRefArray *""'"); 
  }
  arg1 = reinterpret_cast< ampl::StringRefArray * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_runtime_error_what(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  std::runtime_error *arg1 = (std::runtime_error *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "runtime_error_what takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__runtime_error, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "runtime_error_what" "', argument " "1"" of type '" "std::runtime_error const *""'"); 
  }
  arg1 = reinterpret_cast< std::runtime_error * >(argp1);
  result = (char *)((std::runtime_error const *)arg1)->what();
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_runtime_error(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  std::runtime_error *arg1 = (std::runtime_error *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_runtime_error takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__runtime_error, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_runtime_error" "', argument " "1"" of type '" "std::runtime_error *""'"); 
  }
  arg1 = reinterpret_cast< std::runtime_error * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariantArray_el_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  VariantArray *arg1 = (VariantArray *) 0 ;
  ampl::Variant *arg2 = (ampl::Variant *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:VariantArray_el_set",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_VariantArray, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariantArray_el_set" "', argument " "1"" of type '" "VariantArray *""'"); 
  }
  arg1 = reinterpret_cast< VariantArray * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_ampl__Variant, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VariantArray_el_set" "', argument " "2"" of type '" "ampl::Variant *""'"); 
  }
  arg2 = reinterpret_cast< ampl::Variant * >(argp2);
  if (arg1) (arg1)->el = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariantArray_el_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  VariantArray *arg1 = (VariantArray *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ampl::Variant *result = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "VariantArray_el_get takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_VariantArray, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariantArray_el_get" "', argument " "1"" of type '" "VariantArray *""'"); 
  }
  arg1 = reinterpret_cast< VariantArray * >(argp1);
  result = (ampl::Variant *) ((arg1)->el);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__Variant, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN int _wrap_new_VariantArray(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  size_t arg1 ;
  size_t val1 ;
  int ecode1 = 0 ;
  PyObject * obj1 = 0 ;
  VariantArray *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_VariantArray",&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_size_t(obj1, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_VariantArray" "', argument " "1"" of type '" "size_t""'");
  } 
  arg1 = static_cast< size_t >(val1);
  {
    try {
      result = (VariantArray *)new_VariantArray(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_VariantArray, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN PyObject *_wrap_delete_VariantArray(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  VariantArray *arg1 = (VariantArray *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_VariantArray takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_VariantArray, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_VariantArray" "', argument " "1"" of type '" "VariantArray *""'"); 
  }
  arg1 = reinterpret_cast< VariantArray * >(argp1);
  {
    try {
      delete_VariantArray(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariantArray___getitem__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  VariantArray *arg1 = (VariantArray *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj1 = 0 ;
  SwigValueWrapper< ampl::Variant > result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:VariantArray___getitem__",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_VariantArray, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariantArray___getitem__" "', argument " "1"" of type '" "VariantArray *""'"); 
  }
  arg1 = reinterpret_cast< VariantArray * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VariantArray___getitem__" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    try {
      result = VariantArray___getitem__(arg1,arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::Variant(static_cast< const ampl::Variant& >(result))), SWIGTYPE_p_ampl__Variant, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGPY_SSIZEARGFUNC_CLOSURE(_wrap_VariantArray___getitem__)

SWIGINTERN PyObject *_wrap_VariantArray___setitem__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  VariantArray *arg1 = (VariantArray *) 0 ;
  size_t arg2 ;
  SwigValueWrapper< ampl::Variant > arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:VariantArray___setitem__",&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_VariantArray, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariantArray___setitem__" "', argument " "1"" of type '" "VariantArray *""'"); 
  }
  arg1 = reinterpret_cast< VariantArray * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VariantArray___setitem__" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_ampl__Variant,  0  | 0);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "VariantArray___setitem__" "', argument " "3"" of type '" "ampl::Variant""'"); 
    }  
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VariantArray___setitem__" "', argument " "3"" of type '" "ampl::Variant""'");
    } else {
      ampl::Variant * temp = reinterpret_cast< ampl::Variant * >(argp3);
      arg3 = *temp;
      if (SWIG_IsNewObj(res3)) delete temp;
    }
  }
  {
    try {
      VariantArray___setitem__(arg1,arg2,arg3);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_SSIZEOBJARGPROC_CLOSURE(_wrap_VariantArray___setitem__)

SWIGINTERN PyObject *_wrap_VariantArray_cast(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  VariantArray *arg1 = (VariantArray *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ampl::Variant *result = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "VariantArray_cast takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_VariantArray, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariantArray_cast" "', argument " "1"" of type '" "VariantArray *""'"); 
  }
  arg1 = reinterpret_cast< VariantArray * >(argp1);
  {
    try {
      result = (ampl::Variant *)VariantArray_cast(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__Variant, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariantArray_frompointer(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Variant *arg1 = (ampl::Variant *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  VariantArray *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:VariantArray_frompointer",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ampl__Variant, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariantArray_frompointer" "', argument " "1"" of type '" "ampl::Variant *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Variant * >(argp1);
  {
    try {
      result = (VariantArray *)VariantArray_frompointer(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_VariantArray, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_TupleArray_el_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  TupleArray *arg1 = (TupleArray *) 0 ;
  ampl::Tuple *arg2 = (ampl::Tuple *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:TupleArray_el_set",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_TupleArray, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TupleArray_el_set" "', argument " "1"" of type '" "TupleArray *""'"); 
  }
  arg1 = reinterpret_cast< TupleArray * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_ampl__Tuple, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "TupleArray_el_set" "', argument " "2"" of type '" "ampl::Tuple *""'"); 
  }
  arg2 = reinterpret_cast< ampl::Tuple * >(argp2);
  if (arg1) (arg1)->el = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_TupleArray_el_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  TupleArray *arg1 = (TupleArray *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ampl::Tuple *result = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "TupleArray_el_get takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_TupleArray, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TupleArray_el_get" "', argument " "1"" of type '" "TupleArray *""'"); 
  }
  arg1 = reinterpret_cast< TupleArray * >(argp1);
  result = (ampl::Tuple *) ((arg1)->el);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__Tuple, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN int _wrap_new_TupleArray(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  size_t arg1 ;
  size_t val1 ;
  int ecode1 = 0 ;
  PyObject * obj1 = 0 ;
  TupleArray *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_TupleArray",&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_size_t(obj1, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_TupleArray" "', argument " "1"" of type '" "size_t""'");
  } 
  arg1 = static_cast< size_t >(val1);
  {
    try {
      result = (TupleArray *)new_TupleArray(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_TupleArray, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN PyObject *_wrap_delete_TupleArray(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  TupleArray *arg1 = (TupleArray *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_TupleArray takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_TupleArray, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_TupleArray" "', argument " "1"" of type '" "TupleArray *""'"); 
  }
  arg1 = reinterpret_cast< TupleArray * >(argp1);
  {
    try {
      delete_TupleArray(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_TupleArray___getitem__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  TupleArray *arg1 = (TupleArray *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj1 = 0 ;
  ampl::Tuple result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:TupleArray___getitem__",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_TupleArray, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TupleArray___getitem__" "', argument " "1"" of type '" "TupleArray *""'"); 
  }
  arg1 = reinterpret_cast< TupleArray * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "TupleArray___getitem__" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    try {
      result = TupleArray___getitem__(arg1,arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::Tuple(static_cast< const ampl::Tuple& >(result))), SWIGTYPE_p_ampl__Tuple, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGPY_SSIZEARGFUNC_CLOSURE(_wrap_TupleArray___getitem__)

SWIGINTERN PyObject *_wrap_TupleArray___setitem__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  TupleArray *arg1 = (TupleArray *) 0 ;
  size_t arg2 ;
  ampl::Tuple arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:TupleArray___setitem__",&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_TupleArray, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TupleArray___setitem__" "', argument " "1"" of type '" "TupleArray *""'"); 
  }
  arg1 = reinterpret_cast< TupleArray * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "TupleArray___setitem__" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_ampl__Tuple,  0  | 0);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "TupleArray___setitem__" "', argument " "3"" of type '" "ampl::Tuple""'"); 
    }  
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "TupleArray___setitem__" "', argument " "3"" of type '" "ampl::Tuple""'");
    } else {
      ampl::Tuple * temp = reinterpret_cast< ampl::Tuple * >(argp3);
      arg3 = *temp;
      if (SWIG_IsNewObj(res3)) delete temp;
    }
  }
  {
    try {
      TupleArray___setitem__(arg1,arg2,arg3);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_SSIZEOBJARGPROC_CLOSURE(_wrap_TupleArray___setitem__)

SWIGINTERN PyObject *_wrap_TupleArray_cast(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  TupleArray *arg1 = (TupleArray *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ampl::Tuple *result = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "TupleArray_cast takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_TupleArray, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TupleArray_cast" "', argument " "1"" of type '" "TupleArray *""'"); 
  }
  arg1 = reinterpret_cast< TupleArray * >(argp1);
  {
    try {
      result = (ampl::Tuple *)TupleArray_cast(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__Tuple, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_TupleArray_frompointer(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Tuple *arg1 = (ampl::Tuple *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  TupleArray *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:TupleArray_frompointer",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ampl__Tuple, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TupleArray_frompointer" "', argument " "1"" of type '" "ampl::Tuple *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Tuple * >(argp1);
  {
    try {
      result = (TupleArray *)TupleArray_frompointer(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_TupleArray, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN int _wrap_new_OptionalInt__SWIG_0(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Optional< int > *result = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "new_OptionalInt takes no arguments");
  {
    try {
      result = (ampl::Optional< int > *)new ampl::Optional< int >();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__OptionalT_int_t, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN int _wrap_new_OptionalInt__SWIG_1(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  int *arg1 = 0 ;
  int temp1 ;
  int val1 ;
  int ecode1 = 0 ;
  PyObject * obj1 = 0 ;
  ampl::Optional< int > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_OptionalInt",&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_int(obj1, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_OptionalInt" "', argument " "1"" of type '" "int""'");
  } 
  temp1 = static_cast< int >(val1);
  arg1 = &temp1;
  {
    try {
      result = (ampl::Optional< int > *)new ampl::Optional< int >((int const &)*arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__OptionalT_int_t, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN int _wrap_new_OptionalInt(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  Py_ssize_t ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = args ? PyObject_Length(args) : 0;
  for (ii = 0; (ii < 1) && (ii < argc); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 0) {
    return _wrap_new_OptionalInt__SWIG_0(self, args);
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_OptionalInt__SWIG_1(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'new_OptionalInt'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    ampl::Optional< int >::Optional()\n"
    "    ampl::Optional< int >::Optional(int const &)\n");
  return -1;
}


SWIGINTERN PyObject *_wrap_OptionalInt___nonzero__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Optional< int > *arg1 = (ampl::Optional< int > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "OptionalInt___nonzero__ takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__OptionalT_int_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OptionalInt___nonzero__" "', argument " "1"" of type '" "ampl::Optional< int > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Optional< int > * >(argp1);
  {
    try {
      result = (bool)((ampl::Optional< int > const *)arg1)->operator bool();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGPY_INQUIRY_CLOSURE(_wrap_OptionalInt___nonzero__)

SWIGINTERN PyObject *_wrap_OptionalInt_value(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Optional< int > *arg1 = (ampl::Optional< int > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int *result = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "OptionalInt_value takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__OptionalT_int_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OptionalInt_value" "', argument " "1"" of type '" "ampl::Optional< int > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Optional< int > * >(argp1);
  {
    try {
      result = (int *) &((ampl::Optional< int > const *)arg1)->value();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_int(static_cast< int >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_OptionalInt(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Optional< int > *arg1 = (ampl::Optional< int > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_OptionalInt takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__OptionalT_int_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_OptionalInt" "', argument " "1"" of type '" "ampl::Optional< int > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Optional< int > * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN int _wrap_new_OptionalString__SWIG_0(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Optional< std::string > *result = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "new_OptionalString takes no arguments");
  {
    try {
      result = (ampl::Optional< std::string > *)new ampl::Optional< std::string >();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__OptionalT_std__string_t, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN int _wrap_new_OptionalString__SWIG_1(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  PyObject * obj1 = 0 ;
  ampl::Optional< std::string > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_OptionalString",&obj1)) SWIG_fail;
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(obj1, &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_OptionalString" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_OptionalString" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (ampl::Optional< std::string > *)new ampl::Optional< std::string >((std::string const &)*arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__OptionalT_std__string_t, SWIG_BUILTIN_INIT |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  return resultobj == Py_None ? -1 : 0;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return -1;
}


SWIGINTERN int _wrap_new_OptionalString(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  Py_ssize_t ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = args ? PyObject_Length(args) : 0;
  for (ii = 0; (ii < 1) && (ii < argc); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 0) {
    return _wrap_new_OptionalString__SWIG_0(self, args);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OptionalString__SWIG_1(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'new_OptionalString'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    ampl::Optional< std::string >::Optional()\n"
    "    ampl::Optional< std::string >::Optional(std::string const &)\n");
  return -1;
}


SWIGINTERN PyObject *_wrap_OptionalString___nonzero__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Optional< std::string > *arg1 = (ampl::Optional< std::string > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "OptionalString___nonzero__ takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__OptionalT_std__string_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OptionalString___nonzero__" "', argument " "1"" of type '" "ampl::Optional< std::string > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Optional< std::string > * >(argp1);
  {
    try {
      result = (bool)((ampl::Optional< std::string > const *)arg1)->operator bool();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGPY_INQUIRY_CLOSURE(_wrap_OptionalString___nonzero__)

SWIGINTERN PyObject *_wrap_OptionalString_value(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Optional< std::string > *arg1 = (ampl::Optional< std::string > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "OptionalString_value takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__OptionalT_std__string_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OptionalString_value" "', argument " "1"" of type '" "ampl::Optional< std::string > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Optional< std::string > * >(argp1);
  {
    try {
      result = (std::string *) &((ampl::Optional< std::string > const *)arg1)->value();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_OptionalString(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Optional< std::string > *arg1 = (ampl::Optional< std::string > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_OptionalString takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__OptionalT_std__string_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_OptionalString" "', argument " "1"" of type '" "ampl::Optional< std::string > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Optional< std::string > * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN int _wrap_new_OptionalBool__SWIG_0(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Optional< bool > *result = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "new_OptionalBool takes no arguments");
  {
    try {
      result = (ampl::Optional< bool > *)new ampl::Optional< bool >();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__OptionalT_bool_t, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN int _wrap_new_OptionalBool__SWIG_1(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  bool *arg1 = 0 ;
  bool temp1 ;
  bool val1 ;
  int ecode1 = 0 ;
  PyObject * obj1 = 0 ;
  ampl::Optional< bool > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_OptionalBool",&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_bool(obj1, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_OptionalBool" "', argument " "1"" of type '" "bool""'");
  } 
  temp1 = static_cast< bool >(val1);
  arg1 = &temp1;
  {
    try {
      result = (ampl::Optional< bool > *)new ampl::Optional< bool >((bool const &)*arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__OptionalT_bool_t, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN int _wrap_new_OptionalBool(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  Py_ssize_t ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = args ? PyObject_Length(args) : 0;
  for (ii = 0; (ii < 1) && (ii < argc); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 0) {
    return _wrap_new_OptionalBool__SWIG_0(self, args);
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_bool(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_OptionalBool__SWIG_1(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'new_OptionalBool'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    ampl::Optional< bool >::Optional()\n"
    "    ampl::Optional< bool >::Optional(bool const &)\n");
  return -1;
}


SWIGINTERN PyObject *_wrap_OptionalBool___nonzero__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Optional< bool > *arg1 = (ampl::Optional< bool > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "OptionalBool___nonzero__ takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__OptionalT_bool_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OptionalBool___nonzero__" "', argument " "1"" of type '" "ampl::Optional< bool > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Optional< bool > * >(argp1);
  {
    try {
      result = (bool)((ampl::Optional< bool > const *)arg1)->operator bool();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGPY_INQUIRY_CLOSURE(_wrap_OptionalBool___nonzero__)

SWIGINTERN PyObject *_wrap_OptionalBool_value(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Optional< bool > *arg1 = (ampl::Optional< bool > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool *result = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "OptionalBool_value takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__OptionalT_bool_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OptionalBool_value" "', argument " "1"" of type '" "ampl::Optional< bool > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Optional< bool > * >(argp1);
  {
    try {
      result = (bool *) &((ampl::Optional< bool > const *)arg1)->value();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_OptionalBool(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Optional< bool > *arg1 = (ampl::Optional< bool > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_OptionalBool takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__OptionalT_bool_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_OptionalBool" "', argument " "1"" of type '" "ampl::Optional< bool > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Optional< bool > * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN int _wrap_new_OptionalDouble__SWIG_0(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Optional< double > *result = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "new_OptionalDouble takes no arguments");
  {
    try {
      result = (ampl::Optional< double > *)new ampl::Optional< double >();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__OptionalT_double_t, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN int _wrap_new_OptionalDouble__SWIG_1(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  double *arg1 = 0 ;
  double temp1 ;
  double val1 ;
  int ecode1 = 0 ;
  PyObject * obj1 = 0 ;
  ampl::Optional< double > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_OptionalDouble",&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_double(obj1, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_OptionalDouble" "', argument " "1"" of type '" "double""'");
  } 
  temp1 = static_cast< double >(val1);
  arg1 = &temp1;
  {
    try {
      result = (ampl::Optional< double > *)new ampl::Optional< double >((double const &)*arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__OptionalT_double_t, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN int _wrap_new_OptionalDouble(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  Py_ssize_t ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = args ? PyObject_Length(args) : 0;
  for (ii = 0; (ii < 1) && (ii < argc); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 0) {
    return _wrap_new_OptionalDouble__SWIG_0(self, args);
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_double(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_OptionalDouble__SWIG_1(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'new_OptionalDouble'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    ampl::Optional< double >::Optional()\n"
    "    ampl::Optional< double >::Optional(double const &)\n");
  return -1;
}


SWIGINTERN PyObject *_wrap_OptionalDouble___nonzero__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Optional< double > *arg1 = (ampl::Optional< double > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "OptionalDouble___nonzero__ takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__OptionalT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OptionalDouble___nonzero__" "', argument " "1"" of type '" "ampl::Optional< double > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Optional< double > * >(argp1);
  {
    try {
      result = (bool)((ampl::Optional< double > const *)arg1)->operator bool();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGPY_INQUIRY_CLOSURE(_wrap_OptionalDouble___nonzero__)

SWIGINTERN PyObject *_wrap_OptionalDouble_value(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Optional< double > *arg1 = (ampl::Optional< double > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double *result = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "OptionalDouble_value takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__OptionalT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OptionalDouble_value" "', argument " "1"" of type '" "ampl::Optional< double > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Optional< double > * >(argp1);
  {
    try {
      result = (double *) &((ampl::Optional< double > const *)arg1)->value();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_OptionalDouble(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Optional< double > *arg1 = (ampl::Optional< double > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_OptionalDouble takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__OptionalT_double_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_OptionalDouble" "', argument " "1"" of type '" "ampl::Optional< double > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Optional< double > * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN int _wrap_new_Variant__SWIG_0(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  std::string arg1 ;
  PyObject * obj1 = 0 ;
  ampl::Variant *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_Variant",&obj1)) SWIG_fail;
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(obj1, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "new_Variant" "', argument " "1"" of type '" "std::string""'"); 
    }
    arg1 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    try {
      result = (ampl::Variant *)new ampl::Variant(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__Variant, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN int _wrap_new_Variant__SWIG_1(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  PyObject * obj1 = 0 ;
  ampl::Variant *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_Variant",&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_double(obj1, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_Variant" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  {
    try {
      result = (ampl::Variant *)new ampl::Variant(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__Variant, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN int _wrap_new_Variant__SWIG_2(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::VariantRef *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj1 = 0 ;
  ampl::Variant *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_Variant",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj1, &argp1, SWIGTYPE_p_ampl__VariantRef,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Variant" "', argument " "1"" of type '" "ampl::VariantRef const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Variant" "', argument " "1"" of type '" "ampl::VariantRef const &""'"); 
  }
  arg1 = reinterpret_cast< ampl::VariantRef * >(argp1);
  {
    try {
      result = (ampl::Variant *)new ampl::Variant((ampl::VariantRef const &)*arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__Variant, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN int _wrap_new_Variant(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  Py_ssize_t ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = args ? PyObject_Length(args) : 0;
  for (ii = 0; (ii < 1) && (ii < argc); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_ampl__VariantRef, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Variant__SWIG_2(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_double(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_Variant__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Variant__SWIG_0(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'new_Variant'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    ampl::Variant::Variant(std::string)\n"
    "    ampl::Variant::Variant(double)\n"
    "    ampl::Variant::Variant(ampl::VariantRef const &)\n");
  return -1;
}


SWIGINTERN PyObject *_wrap_Variant_str(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Variant *arg1 = (ampl::Variant *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Variant_str takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Variant, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variant_str" "', argument " "1"" of type '" "ampl::Variant const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Variant * >(argp1);
  {
    try {
      result = ((ampl::Variant const *)arg1)->str();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variant_dbl(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Variant *arg1 = (ampl::Variant *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Variant_dbl takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Variant, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variant_dbl" "', argument " "1"" of type '" "ampl::Variant const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Variant * >(argp1);
  {
    try {
      result = (double)((ampl::Variant const *)arg1)->dbl();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variant_type(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Variant *arg1 = (ampl::Variant *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ampl::Type result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Variant_type takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Variant, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variant_type" "', argument " "1"" of type '" "ampl::Variant const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Variant * >(argp1);
  {
    try {
      result = (ampl::Type)((ampl::Variant const *)arg1)->type();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variant_toString(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Variant *arg1 = (ampl::Variant *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Variant_toString takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Variant, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variant_toString" "', argument " "1"" of type '" "ampl::Variant *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Variant * >(argp1);
  {
    try {
      result = (arg1)->toString();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variant_equals(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Variant *arg1 = (ampl::Variant *) 0 ;
  ampl::Variant *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Variant_equals",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Variant, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variant_equals" "', argument " "1"" of type '" "ampl::Variant *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Variant * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__Variant,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Variant_equals" "', argument " "2"" of type '" "ampl::Variant &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Variant_equals" "', argument " "2"" of type '" "ampl::Variant &""'"); 
  }
  arg2 = reinterpret_cast< ampl::Variant * >(argp2);
  {
    try {
      result = (bool)ampl_Variant_equals(arg1,*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variant_compare(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Variant *arg1 = (ampl::Variant *) 0 ;
  ampl::Variant *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Variant_compare",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Variant, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variant_compare" "', argument " "1"" of type '" "ampl::Variant *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Variant * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__Variant,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Variant_compare" "', argument " "2"" of type '" "ampl::Variant &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Variant_compare" "', argument " "2"" of type '" "ampl::Variant &""'"); 
  }
  arg2 = reinterpret_cast< ampl::Variant * >(argp2);
  {
    try {
      result = (int)ampl_Variant_compare(arg1,*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_Variant(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Variant *arg1 = (ampl::Variant *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_Variant takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Variant, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Variant" "', argument " "1"" of type '" "ampl::Variant *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Variant * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN int _wrap_new_VariantRef__SWIG_0(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  std::string arg1 ;
  PyObject * obj1 = 0 ;
  ampl::VariantRef *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_VariantRef",&obj1)) SWIG_fail;
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(obj1, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "new_VariantRef" "', argument " "1"" of type '" "std::string""'"); 
    }
    arg1 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    try {
      result = (ampl::VariantRef *)new ampl::VariantRef(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__VariantRef, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN int _wrap_new_VariantRef__SWIG_1(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  PyObject * obj1 = 0 ;
  ampl::VariantRef *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_VariantRef",&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_double(obj1, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_VariantRef" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  {
    try {
      result = (ampl::VariantRef *)new ampl::VariantRef(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__VariantRef, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN int _wrap_new_VariantRef__SWIG_2(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Variant *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj1 = 0 ;
  ampl::VariantRef *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_VariantRef",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj1, &argp1, SWIGTYPE_p_ampl__Variant,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_VariantRef" "', argument " "1"" of type '" "ampl::Variant const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_VariantRef" "', argument " "1"" of type '" "ampl::Variant const &""'"); 
  }
  arg1 = reinterpret_cast< ampl::Variant * >(argp1);
  {
    try {
      result = (ampl::VariantRef *)new ampl::VariantRef((ampl::Variant const &)*arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__VariantRef, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN int _wrap_new_VariantRef(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  Py_ssize_t ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = args ? PyObject_Length(args) : 0;
  for (ii = 0; (ii < 1) && (ii < argc); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_ampl__Variant, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_VariantRef__SWIG_2(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_double(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_VariantRef__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_VariantRef__SWIG_0(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'new_VariantRef'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    ampl::VariantRef::VariantRef(std::string)\n"
    "    ampl::VariantRef::VariantRef(double)\n"
    "    ampl::VariantRef::VariantRef(ampl::Variant const &)\n");
  return -1;
}


SWIGINTERN PyObject *_wrap_VariantRef_str(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::VariantRef *arg1 = (ampl::VariantRef *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "VariantRef_str takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__VariantRef, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariantRef_str" "', argument " "1"" of type '" "ampl::VariantRef const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::VariantRef * >(argp1);
  {
    try {
      result = ((ampl::VariantRef const *)arg1)->str();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariantRef_dbl(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::VariantRef *arg1 = (ampl::VariantRef *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "VariantRef_dbl takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__VariantRef, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariantRef_dbl" "', argument " "1"" of type '" "ampl::VariantRef const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::VariantRef * >(argp1);
  {
    try {
      result = (double)((ampl::VariantRef const *)arg1)->dbl();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariantRef_type(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::VariantRef *arg1 = (ampl::VariantRef *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ampl::Type result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "VariantRef_type takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__VariantRef, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariantRef_type" "', argument " "1"" of type '" "ampl::VariantRef const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::VariantRef * >(argp1);
  {
    try {
      result = (ampl::Type)((ampl::VariantRef const *)arg1)->type();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariantRef_toString(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::VariantRef *arg1 = (ampl::VariantRef *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "VariantRef_toString takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__VariantRef, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariantRef_toString" "', argument " "1"" of type '" "ampl::VariantRef *""'"); 
  }
  arg1 = reinterpret_cast< ampl::VariantRef * >(argp1);
  {
    try {
      result = (arg1)->toString();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariantRef_equals(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::VariantRef *arg1 = (ampl::VariantRef *) 0 ;
  ampl::VariantRef *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:VariantRef_equals",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__VariantRef, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariantRef_equals" "', argument " "1"" of type '" "ampl::VariantRef *""'"); 
  }
  arg1 = reinterpret_cast< ampl::VariantRef * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__VariantRef,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VariantRef_equals" "', argument " "2"" of type '" "ampl::VariantRef &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VariantRef_equals" "', argument " "2"" of type '" "ampl::VariantRef &""'"); 
  }
  arg2 = reinterpret_cast< ampl::VariantRef * >(argp2);
  {
    try {
      result = (bool)ampl_VariantRef_equals(arg1,*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariantRef_compare(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::VariantRef *arg1 = (ampl::VariantRef *) 0 ;
  ampl::VariantRef *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:VariantRef_compare",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__VariantRef, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariantRef_compare" "', argument " "1"" of type '" "ampl::VariantRef *""'"); 
  }
  arg1 = reinterpret_cast< ampl::VariantRef * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__VariantRef,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VariantRef_compare" "', argument " "2"" of type '" "ampl::VariantRef &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VariantRef_compare" "', argument " "2"" of type '" "ampl::VariantRef &""'"); 
  }
  arg2 = reinterpret_cast< ampl::VariantRef * >(argp2);
  {
    try {
      result = (int)ampl_VariantRef_compare(arg1,*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_VariantRef(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::VariantRef *arg1 = (ampl::VariantRef *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_VariantRef takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__VariantRef, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_VariantRef" "', argument " "1"" of type '" "ampl::VariantRef *""'"); 
  }
  arg1 = reinterpret_cast< ampl::VariantRef * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN int _wrap_new_TupleRef(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Tuple arg1 ;
  void *argp1 ;
  int res1 = 0 ;
  PyObject * obj1 = 0 ;
  ampl::TupleRef *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_TupleRef",&obj1)) SWIG_fail;
  {
    res1 = SWIG_ConvertPtr(obj1, &argp1, SWIGTYPE_p_ampl__Tuple,  0  | 0);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_TupleRef" "', argument " "1"" of type '" "ampl::Tuple""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_TupleRef" "', argument " "1"" of type '" "ampl::Tuple""'");
    } else {
      ampl::Tuple * temp = reinterpret_cast< ampl::Tuple * >(argp1);
      arg1 = *temp;
      if (SWIG_IsNewObj(res1)) delete temp;
    }
  }
  {
    try {
      result = (ampl::TupleRef *)new ampl::TupleRef(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__TupleRef, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN PyObject *_wrap_TupleRef_size(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::TupleRef *arg1 = (ampl::TupleRef *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::size_t result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "TupleRef_size takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__TupleRef, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TupleRef_size" "', argument " "1"" of type '" "ampl::TupleRef *""'"); 
  }
  arg1 = reinterpret_cast< ampl::TupleRef * >(argp1);
  {
    try {
      result = (std::size_t)(arg1)->size();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_TupleRef_toString(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::TupleRef *arg1 = (ampl::TupleRef *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "TupleRef_toString takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__TupleRef, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TupleRef_toString" "', argument " "1"" of type '" "ampl::TupleRef *""'"); 
  }
  arg1 = reinterpret_cast< ampl::TupleRef * >(argp1);
  {
    try {
      result = (arg1)->toString();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_TupleRef_getIndex(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::TupleRef *arg1 = (ampl::TupleRef *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj1 = 0 ;
  SwigValueWrapper< ampl::Variant > result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:TupleRef_getIndex",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__TupleRef, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TupleRef_getIndex" "', argument " "1"" of type '" "ampl::TupleRef *""'"); 
  }
  arg1 = reinterpret_cast< ampl::TupleRef * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "TupleRef_getIndex" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  {
    try {
      result = (arg1)->operator [](arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::Variant(static_cast< const ampl::Variant& >(result))), SWIGTYPE_p_ampl__Variant, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_TupleRef(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::TupleRef *arg1 = (ampl::TupleRef *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_TupleRef takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__TupleRef, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_TupleRef" "', argument " "1"" of type '" "ampl::TupleRef *""'"); 
  }
  arg1 = reinterpret_cast< ampl::TupleRef * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN int _wrap_new_Tuple__SWIG_0(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Tuple *result = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "new_Tuple takes no arguments");
  {
    try {
      result = (ampl::Tuple *)new ampl::Tuple();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__Tuple, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN int _wrap_new_Tuple__SWIG_1(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  PyObject * obj1 = 0 ;
  ampl::Tuple *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_Tuple",&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_double(obj1, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_Tuple" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  {
    try {
      result = (ampl::Tuple *)new ampl::Tuple(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__Tuple, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN int _wrap_new_Tuple__SWIG_2(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  PyObject * obj1 = 0 ;
  ampl::Tuple *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_Tuple",&obj1)) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(obj1, &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Tuple" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  {
    try {
      result = (ampl::Tuple *)new ampl::Tuple((char const *)arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__Tuple, SWIG_BUILTIN_INIT |  0 );
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return resultobj == Py_None ? -1 : 0;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return -1;
}


SWIGINTERN int _wrap_new_Tuple(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  Py_ssize_t ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = args ? PyObject_Length(args) : 0;
  for (ii = 0; (ii < 1) && (ii < argc); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 0) {
    return _wrap_new_Tuple__SWIG_0(self, args);
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_double(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_Tuple__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Tuple__SWIG_2(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'new_Tuple'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    ampl::Tuple::Tuple()\n"
    "    ampl::Tuple::Tuple(double)\n"
    "    ampl::Tuple::Tuple(char const *)\n");
  return -1;
}


SWIGINTERN PyObject *_wrap_Tuple_size(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Tuple *arg1 = (ampl::Tuple *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::size_t result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Tuple_size takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Tuple, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tuple_size" "', argument " "1"" of type '" "ampl::Tuple *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Tuple * >(argp1);
  {
    try {
      result = (std::size_t)(arg1)->size();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tuple_toString(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Tuple *arg1 = (ampl::Tuple *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Tuple_toString takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Tuple, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tuple_toString" "', argument " "1"" of type '" "ampl::Tuple *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Tuple * >(argp1);
  {
    try {
      result = (arg1)->toString();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tuple_getIndex(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Tuple *arg1 = (ampl::Tuple *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj1 = 0 ;
  SwigValueWrapper< ampl::Variant > result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Tuple_getIndex",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Tuple, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tuple_getIndex" "', argument " "1"" of type '" "ampl::Tuple *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Tuple * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Tuple_getIndex" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  {
    try {
      result = (arg1)->operator [](arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::Variant(static_cast< const ampl::Variant& >(result))), SWIGTYPE_p_ampl__Variant, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tuple_equals(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Tuple *arg1 = (ampl::Tuple *) 0 ;
  ampl::Tuple *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Tuple_equals",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Tuple, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tuple_equals" "', argument " "1"" of type '" "ampl::Tuple *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Tuple * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__Tuple,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Tuple_equals" "', argument " "2"" of type '" "ampl::Tuple &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Tuple_equals" "', argument " "2"" of type '" "ampl::Tuple &""'"); 
  }
  arg2 = reinterpret_cast< ampl::Tuple * >(argp2);
  {
    try {
      result = (bool)ampl_Tuple_operator_Se__Se_(arg1,*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tuple_Factory__SWIG_0(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  VariantArray *arg1 = 0 ;
  std::size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  ampl::Tuple result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Tuple_Factory",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_VariantArray,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tuple_Factory" "', argument " "1"" of type '" "VariantArray &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Tuple_Factory" "', argument " "1"" of type '" "VariantArray &""'"); 
  }
  arg1 = reinterpret_cast< VariantArray * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Tuple_Factory" "', argument " "2"" of type '" "std::size_t""'");
  } 
  arg2 = static_cast< std::size_t >(val2);
  {
    try {
      result = ampl_Tuple_Factory__SWIG_0(*arg1,arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::Tuple(static_cast< const ampl::Tuple& >(result))), SWIGTYPE_p_ampl__Tuple, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tuple_Factory__SWIG_1(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  SwigValueWrapper< ampl::TupleRef > arg1 ;
  void *argp1 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ampl::Tuple result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Tuple_Factory",&obj0)) SWIG_fail;
  {
    res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_ampl__TupleRef,  0  | 0);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tuple_Factory" "', argument " "1"" of type '" "ampl::TupleRef""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Tuple_Factory" "', argument " "1"" of type '" "ampl::TupleRef""'");
    } else {
      ampl::TupleRef * temp = reinterpret_cast< ampl::TupleRef * >(argp1);
      arg1 = *temp;
      if (SWIG_IsNewObj(res1)) delete temp;
    }
  }
  {
    try {
      result = ampl_Tuple_Factory__SWIG_1(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::Tuple(static_cast< const ampl::Tuple& >(result))), SWIGTYPE_p_ampl__Tuple, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tuple_Factory(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  Py_ssize_t ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = args ? PyObject_Length(args) : 0;
  for (ii = 0; (ii < 2) && (ii < argc); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_ampl__TupleRef, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Tuple_Factory__SWIG_1(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_VariantArray, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Tuple_Factory__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'Tuple_Factory'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    ampl::Tuple::Factory(VariantArray &,std::size_t)\n"
    "    ampl::Tuple::ampl_Tuple_Factory__SWIG_1(ampl::TupleRef)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_delete_Tuple(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Tuple *arg1 = (ampl::Tuple *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_Tuple takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Tuple, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Tuple" "', argument " "1"" of type '" "ampl::Tuple *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Tuple * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN int _wrap_new_DataFrame__SWIG_0(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  std::size_t arg1 ;
  size_t val1 ;
  int ecode1 = 0 ;
  PyObject * obj1 = 0 ;
  ampl::DataFrame *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_DataFrame",&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_size_t(obj1, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_DataFrame" "', argument " "1"" of type '" "std::size_t""'");
  } 
  arg1 = static_cast< std::size_t >(val1);
  {
    try {
      result = (ampl::DataFrame *)new ampl::DataFrame(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__DataFrame, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN PyObject *_wrap_delete_DataFrame(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_DataFrame takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_DataFrame" "', argument " "1"" of type '" "ampl::DataFrame *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN int _wrap_new_DataFrame__SWIG_1(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityArgs *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj1 = 0 ;
  ampl::DataFrame *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_DataFrame",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj1, &argp1, SWIGTYPE_p_ampl__EntityArgs,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_DataFrame" "', argument " "1"" of type '" "ampl::EntityArgs const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_DataFrame" "', argument " "1"" of type '" "ampl::EntityArgs const &""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityArgs * >(argp1);
  {
    try {
      result = (ampl::DataFrame *)new ampl::DataFrame((ampl::EntityArgs const &)*arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__DataFrame, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN int _wrap_new_DataFrame__SWIG_2(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj1 = 0 ;
  ampl::DataFrame *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_DataFrame",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj1, &argp1, SWIGTYPE_p_ampl__DataFrame,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_DataFrame" "', argument " "1"" of type '" "ampl::DataFrame const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_DataFrame" "', argument " "1"" of type '" "ampl::DataFrame const &""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  {
    try {
      result = (ampl::DataFrame *)new ampl::DataFrame((ampl::DataFrame const &)*arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__DataFrame, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN int _wrap_new_DataFrame(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  Py_ssize_t ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = args ? PyObject_Length(args) : 0;
  for (ii = 0; (ii < 1) && (ii < argc); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_ampl__EntityArgs, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_DataFrame__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_ampl__DataFrame, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_DataFrame__SWIG_2(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_size_t(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_DataFrame__SWIG_0(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'new_DataFrame'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    ampl::DataFrame::DataFrame(std::size_t)\n"
    "    ampl::DataFrame::DataFrame(ampl::EntityArgs const &)\n"
    "    ampl::DataFrame::DataFrame(ampl::DataFrame const &)\n");
  return -1;
}


SWIGINTERN PyObject *_wrap_DataFrame_clone(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  ampl::DataFrame *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  ampl::DataFrame *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:DataFrame_clone",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_clone" "', argument " "1"" of type '" "ampl::DataFrame *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__DataFrame,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DataFrame_clone" "', argument " "2"" of type '" "ampl::DataFrame const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DataFrame_clone" "', argument " "2"" of type '" "ampl::DataFrame const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::DataFrame * >(argp2);
  {
    try {
      result = (ampl::DataFrame *) &(arg1)->operator =((ampl::DataFrame const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_getNumCols(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::size_t result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "DataFrame_getNumCols takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_getNumCols" "', argument " "1"" of type '" "ampl::DataFrame const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  {
    try {
      result = (std::size_t)((ampl::DataFrame const *)arg1)->getNumCols();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_getNumRows(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::size_t result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "DataFrame_getNumRows takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_getNumRows" "', argument " "1"" of type '" "ampl::DataFrame const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  {
    try {
      result = (std::size_t)((ampl::DataFrame const *)arg1)->getNumRows();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_getNumIndices(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::size_t result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "DataFrame_getNumIndices takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_getNumIndices" "', argument " "1"" of type '" "ampl::DataFrame const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  {
    try {
      result = (std::size_t)((ampl::DataFrame const *)arg1)->getNumIndices();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_addRow__SWIG_0(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  SwigValueWrapper< ampl::TupleRef > arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:DataFrame_addRow",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_addRow" "', argument " "1"" of type '" "ampl::DataFrame *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__TupleRef,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DataFrame_addRow" "', argument " "2"" of type '" "ampl::TupleRef""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DataFrame_addRow" "', argument " "2"" of type '" "ampl::TupleRef""'");
    } else {
      ampl::TupleRef * temp = reinterpret_cast< ampl::TupleRef * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      (arg1)->addRow(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_addRow__SWIG_1(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  SwigValueWrapper< ampl::VariantRef > arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:DataFrame_addRow",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_addRow" "', argument " "1"" of type '" "ampl::DataFrame *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__VariantRef,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DataFrame_addRow" "', argument " "2"" of type '" "ampl::VariantRef""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DataFrame_addRow" "', argument " "2"" of type '" "ampl::VariantRef""'");
    } else {
      ampl::VariantRef * temp = reinterpret_cast< ampl::VariantRef * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      (arg1)->addRow(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_addRow__SWIG_2(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  SwigValueWrapper< ampl::VariantRef > arg2 ;
  SwigValueWrapper< ampl::VariantRef > arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:DataFrame_addRow",&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_addRow" "', argument " "1"" of type '" "ampl::DataFrame *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__VariantRef,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DataFrame_addRow" "', argument " "2"" of type '" "ampl::VariantRef""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DataFrame_addRow" "', argument " "2"" of type '" "ampl::VariantRef""'");
    } else {
      ampl::VariantRef * temp = reinterpret_cast< ampl::VariantRef * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_ampl__VariantRef,  0  | 0);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "DataFrame_addRow" "', argument " "3"" of type '" "ampl::VariantRef""'"); 
    }  
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DataFrame_addRow" "', argument " "3"" of type '" "ampl::VariantRef""'");
    } else {
      ampl::VariantRef * temp = reinterpret_cast< ampl::VariantRef * >(argp3);
      arg3 = *temp;
      if (SWIG_IsNewObj(res3)) delete temp;
    }
  }
  {
    try {
      (arg1)->addRow(arg2,arg3);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_addRow__SWIG_3(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  SwigValueWrapper< ampl::VariantRef > arg2 ;
  SwigValueWrapper< ampl::VariantRef > arg3 ;
  SwigValueWrapper< ampl::VariantRef > arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  void *argp4 ;
  int res4 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:DataFrame_addRow",&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_addRow" "', argument " "1"" of type '" "ampl::DataFrame *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__VariantRef,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DataFrame_addRow" "', argument " "2"" of type '" "ampl::VariantRef""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DataFrame_addRow" "', argument " "2"" of type '" "ampl::VariantRef""'");
    } else {
      ampl::VariantRef * temp = reinterpret_cast< ampl::VariantRef * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_ampl__VariantRef,  0  | 0);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "DataFrame_addRow" "', argument " "3"" of type '" "ampl::VariantRef""'"); 
    }  
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DataFrame_addRow" "', argument " "3"" of type '" "ampl::VariantRef""'");
    } else {
      ampl::VariantRef * temp = reinterpret_cast< ampl::VariantRef * >(argp3);
      arg3 = *temp;
      if (SWIG_IsNewObj(res3)) delete temp;
    }
  }
  {
    res4 = SWIG_ConvertPtr(obj3, &argp4, SWIGTYPE_p_ampl__VariantRef,  0  | 0);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "DataFrame_addRow" "', argument " "4"" of type '" "ampl::VariantRef""'"); 
    }  
    if (!argp4) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DataFrame_addRow" "', argument " "4"" of type '" "ampl::VariantRef""'");
    } else {
      ampl::VariantRef * temp = reinterpret_cast< ampl::VariantRef * >(argp4);
      arg4 = *temp;
      if (SWIG_IsNewObj(res4)) delete temp;
    }
  }
  {
    try {
      (arg1)->addRow(arg2,arg3,arg4);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_addRow__SWIG_4(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  SwigValueWrapper< ampl::VariantRef > arg2 ;
  SwigValueWrapper< ampl::VariantRef > arg3 ;
  SwigValueWrapper< ampl::VariantRef > arg4 ;
  SwigValueWrapper< ampl::VariantRef > arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  void *argp4 ;
  int res4 = 0 ;
  void *argp5 ;
  int res5 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:DataFrame_addRow",&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_addRow" "', argument " "1"" of type '" "ampl::DataFrame *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__VariantRef,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DataFrame_addRow" "', argument " "2"" of type '" "ampl::VariantRef""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DataFrame_addRow" "', argument " "2"" of type '" "ampl::VariantRef""'");
    } else {
      ampl::VariantRef * temp = reinterpret_cast< ampl::VariantRef * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_ampl__VariantRef,  0  | 0);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "DataFrame_addRow" "', argument " "3"" of type '" "ampl::VariantRef""'"); 
    }  
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DataFrame_addRow" "', argument " "3"" of type '" "ampl::VariantRef""'");
    } else {
      ampl::VariantRef * temp = reinterpret_cast< ampl::VariantRef * >(argp3);
      arg3 = *temp;
      if (SWIG_IsNewObj(res3)) delete temp;
    }
  }
  {
    res4 = SWIG_ConvertPtr(obj3, &argp4, SWIGTYPE_p_ampl__VariantRef,  0  | 0);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "DataFrame_addRow" "', argument " "4"" of type '" "ampl::VariantRef""'"); 
    }  
    if (!argp4) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DataFrame_addRow" "', argument " "4"" of type '" "ampl::VariantRef""'");
    } else {
      ampl::VariantRef * temp = reinterpret_cast< ampl::VariantRef * >(argp4);
      arg4 = *temp;
      if (SWIG_IsNewObj(res4)) delete temp;
    }
  }
  {
    res5 = SWIG_ConvertPtr(obj4, &argp5, SWIGTYPE_p_ampl__VariantRef,  0  | 0);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "DataFrame_addRow" "', argument " "5"" of type '" "ampl::VariantRef""'"); 
    }  
    if (!argp5) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DataFrame_addRow" "', argument " "5"" of type '" "ampl::VariantRef""'");
    } else {
      ampl::VariantRef * temp = reinterpret_cast< ampl::VariantRef * >(argp5);
      arg5 = *temp;
      if (SWIG_IsNewObj(res5)) delete temp;
    }
  }
  {
    try {
      (arg1)->addRow(arg2,arg3,arg4,arg5);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_reserve(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  std::size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:DataFrame_reserve",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_reserve" "', argument " "1"" of type '" "ampl::DataFrame *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DataFrame_reserve" "', argument " "2"" of type '" "std::size_t""'");
  } 
  arg2 = static_cast< std::size_t >(val2);
  {
    try {
      (arg1)->reserve(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_toString(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "DataFrame_toString takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_toString" "', argument " "1"" of type '" "ampl::DataFrame const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  {
    try {
      result = ((ampl::DataFrame const *)arg1)->toString();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_getColumn(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  fmt::CStringRef arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj1 = 0 ;
  SwigValueWrapper< ampl::internal::Slice< false > > result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:DataFrame_getColumn",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_getColumn" "', argument " "1"" of type '" "ampl::DataFrame const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  
  arg2 = _PyString_AsString(obj1);
  
  {
    try {
      result = ((ampl::DataFrame const *)arg1)->getColumn(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::DataFrame::Column(static_cast< const ampl::DataFrame::Column& >(result))), SWIGTYPE_p_ampl__internal__SliceT_false_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_getRowByIndex(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  std::size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj1 = 0 ;
  SwigValueWrapper< ampl::internal::Slice< true > > result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:DataFrame_getRowByIndex",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_getRowByIndex" "', argument " "1"" of type '" "ampl::DataFrame const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DataFrame_getRowByIndex" "', argument " "2"" of type '" "std::size_t""'");
  } 
  arg2 = static_cast< std::size_t >(val2);
  {
    try {
      result = ((ampl::DataFrame const *)arg1)->getRowByIndex(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::DataFrame::Row(static_cast< const ampl::DataFrame::Row& >(result))), SWIGTYPE_p_ampl__internal__SliceT_true_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_getRow__SWIG_0(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  SwigValueWrapper< ampl::VariantRef > arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  SwigValueWrapper< ampl::internal::Slice< true > > result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:DataFrame_getRow",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_getRow" "', argument " "1"" of type '" "ampl::DataFrame *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__VariantRef,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DataFrame_getRow" "', argument " "2"" of type '" "ampl::VariantRef""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DataFrame_getRow" "', argument " "2"" of type '" "ampl::VariantRef""'");
    } else {
      ampl::VariantRef * temp = reinterpret_cast< ampl::VariantRef * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (arg1)->getRow(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::DataFrame::Row(static_cast< const ampl::DataFrame::Row& >(result))), SWIGTYPE_p_ampl__internal__SliceT_true_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_getRow__SWIG_1(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  SwigValueWrapper< ampl::TupleRef > arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  SwigValueWrapper< ampl::internal::Slice< true > > result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:DataFrame_getRow",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_getRow" "', argument " "1"" of type '" "ampl::DataFrame const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__TupleRef,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DataFrame_getRow" "', argument " "2"" of type '" "ampl::TupleRef""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DataFrame_getRow" "', argument " "2"" of type '" "ampl::TupleRef""'");
    } else {
      ampl::TupleRef * temp = reinterpret_cast< ampl::TupleRef * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = ((ampl::DataFrame const *)arg1)->getRow(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::DataFrame::Row(static_cast< const ampl::DataFrame::Row& >(result))), SWIGTYPE_p_ampl__internal__SliceT_true_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_getRow__SWIG_2(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< ampl::internal::Slice< true > > result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "DataFrame_getRow takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_getRow" "', argument " "1"" of type '" "ampl::DataFrame const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  {
    try {
      result = ((ampl::DataFrame const *)arg1)->getRow();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::DataFrame::Row(static_cast< const ampl::DataFrame::Row& >(result))), SWIGTYPE_p_ampl__internal__SliceT_true_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_getHeaders(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ampl::StringRefArray result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "DataFrame_getHeaders takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_getHeaders" "', argument " "1"" of type '" "ampl::DataFrame const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  {
    try {
      result = ((ampl::DataFrame const *)arg1)->getHeaders();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::StringRefArray(static_cast< const ampl::StringRefArray& >(result))), SWIGTYPE_p_ampl__StringRefArray, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_impl(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ampl::internal::DataFrame *result = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "DataFrame_impl takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_impl" "', argument " "1"" of type '" "ampl::DataFrame const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  {
    try {
      result = (ampl::internal::DataFrame *)((ampl::DataFrame const *)arg1)->impl();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_addColumn(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  fmt::CStringRef arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:DataFrame_addColumn",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_addColumn" "', argument " "1"" of type '" "ampl::DataFrame *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  
  arg2 = _PyString_AsString(obj1);
  
  {
    try {
      ampl_DataFrame_addColumnSWIG(arg1,arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_addColumnStr(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  fmt::CStringRef arg2 ;
  char **arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  {
    arg3 = NULL;
  }
  if (!PyArg_ParseTuple(args,(char *)"OO:DataFrame_addColumnStr",&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_addColumnStr" "', argument " "1"" of type '" "ampl::DataFrame *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  
  arg2 = _PyString_AsString(obj1);
  
  {
    /* Check if is a list */
    if (PyList_Check(obj2)) {
      int size = PyList_Size(obj2);
      int i = 0;
      arg3 = (char **)malloc((size + 1) * sizeof(char *));
      for (i = 0; i < size; i++) {
        PyObject *obj = PyList_GetItem(obj2,i);
        if (_PyString_Check(obj)) {
          arg3[i] = _PyString_AsString(PyList_GetItem(obj2,i));
        } else {
          PyErr_SetString(PyExc_TypeError,"list must contain strings");
          free(arg3);
          return NULL;
        }
      }
      arg3[i] = 0;
    }
    else {
      PyErr_SetString(PyExc_TypeError,"not a list");
      return NULL;
    }
  }
  {
    try {
      ampl_DataFrame_addColumnSWIG(arg1,arg2,(char const *(*))arg3);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  {
    free((char *)arg3);
  }
  return resultobj;
fail:
  {
    free((char *)arg3);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_addColumnDbl(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  fmt::CStringRef arg2 ;
  double *arg3 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:DataFrame_addColumnDbl",&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_addColumnDbl" "', argument " "1"" of type '" "ampl::DataFrame *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  
  arg2 = _PyString_AsString(obj1);
  
  {
    /* Check if is a list */
    if (PyList_Check(obj2)) {
      int size = PyList_Size(obj2);
      int i = 0;
      arg3 = (double *)malloc(size * sizeof(double));
      for (i = 0; i < size; i++) {
        PyObject *o = PyList_GetItem(obj2,i);
        if (PyFloat_Check(o))
        arg3[i] = PyFloat_AsDouble(PyList_GetItem(obj2,i));
        else {
          PyErr_SetString(PyExc_TypeError, "The input list must contain floating point numbers");
          free(arg3);
          return NULL;
        }
      }
    }
    else {
      PyErr_SetString(PyExc_TypeError,"The input is not a list");
      return NULL;
    }
  }
  {
    try {
      ampl_DataFrame_addColumnSWIG(arg1,arg2,arg3);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  {
    free((double *)arg3);
  }
  return resultobj;
fail:
  {
    free((double *)arg3);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_addRow__SWIG_5(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  ampl::Tuple arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:DataFrame_addRow",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_addRow" "', argument " "1"" of type '" "ampl::DataFrame *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__Tuple,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DataFrame_addRow" "', argument " "2"" of type '" "ampl::Tuple""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DataFrame_addRow" "', argument " "2"" of type '" "ampl::Tuple""'");
    } else {
      ampl::Tuple * temp = reinterpret_cast< ampl::Tuple * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      ampl_DataFrame_addRow__SWIG_5(arg1,arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_addRow(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[6] = {
    0
  };
  Py_ssize_t ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = args ? PyObject_Length(args) : 0;
  argv[0] = self;
  for (ii = 0; (ii < 4) && (ii < argc); ii++) {
    argv[ii + 1] = PyTuple_GET_ITEM(args,ii);
  }
  argc++;
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__DataFrame, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_ampl__TupleRef, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_DataFrame_addRow__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__DataFrame, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_ampl__VariantRef, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_DataFrame_addRow__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__DataFrame, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_ampl__Tuple, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_DataFrame_addRow__SWIG_5(self, args);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__DataFrame, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_ampl__VariantRef, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_ConvertPtr(argv[2], 0, SWIGTYPE_p_ampl__VariantRef, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_DataFrame_addRow__SWIG_2(self, args);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__DataFrame, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_ampl__VariantRef, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_ConvertPtr(argv[2], 0, SWIGTYPE_p_ampl__VariantRef, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          int res = SWIG_ConvertPtr(argv[3], 0, SWIGTYPE_p_ampl__VariantRef, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_DataFrame_addRow__SWIG_3(self, args);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__DataFrame, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_ampl__VariantRef, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_ConvertPtr(argv[2], 0, SWIGTYPE_p_ampl__VariantRef, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          int res = SWIG_ConvertPtr(argv[3], 0, SWIGTYPE_p_ampl__VariantRef, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            int res = SWIG_ConvertPtr(argv[4], 0, SWIGTYPE_p_ampl__VariantRef, 0);
            _v = SWIG_CheckState(res);
            if (_v) {
              return _wrap_DataFrame_addRow__SWIG_4(self, args);
            }
          }
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'DataFrame_addRow'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    ampl::DataFrame::addRow(ampl::TupleRef)\n"
    "    ampl::DataFrame::addRow(ampl::VariantRef)\n"
    "    ampl::DataFrame::addRow(ampl::VariantRef,ampl::VariantRef)\n"
    "    ampl::DataFrame::addRow(ampl::VariantRef,ampl::VariantRef,ampl::VariantRef)\n"
    "    ampl::DataFrame::addRow(ampl::VariantRef,ampl::VariantRef,ampl::VariantRef,ampl::VariantRef)\n"
    "    ampl::DataFrame::addRow(ampl::Tuple)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_DataFrame_getRow__SWIG_3(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  ampl::Tuple arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  SwigValueWrapper< ampl::internal::Slice< true > > result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:DataFrame_getRow",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_getRow" "', argument " "1"" of type '" "ampl::DataFrame *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__Tuple,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DataFrame_getRow" "', argument " "2"" of type '" "ampl::Tuple""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DataFrame_getRow" "', argument " "2"" of type '" "ampl::Tuple""'");
    } else {
      ampl::Tuple * temp = reinterpret_cast< ampl::Tuple * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = ampl_DataFrame_getRow__SWIG_3(arg1,arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::internal::Slice< true >(static_cast< const ampl::internal::Slice< true >& >(result))), SWIGTYPE_p_ampl__internal__SliceT_true_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_getRow(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  Py_ssize_t ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = args ? PyObject_Length(args) : 0;
  argv[0] = self;
  for (ii = 0; (ii < 1) && (ii < argc); ii++) {
    argv[ii + 1] = PyTuple_GET_ITEM(args,ii);
  }
  argc++;
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__DataFrame, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_DataFrame_getRow__SWIG_2(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__DataFrame, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_ampl__TupleRef, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_DataFrame_getRow__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__DataFrame, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_ampl__VariantRef, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_DataFrame_getRow__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__DataFrame, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_ampl__Tuple, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_DataFrame_getRow__SWIG_3(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'DataFrame_getRow'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    ampl::DataFrame::getRow(ampl::VariantRef)\n"
    "    ampl::DataFrame::getRow(ampl::TupleRef) const\n"
    "    ampl::DataFrame::getRow() const\n"
    "    ampl::DataFrame::getRow(ampl::Tuple)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_DataFrame_setColumnStr(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  fmt::CStringRef arg2 ;
  char **arg3 ;
  std::size_t arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val4 ;
  int ecode4 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    arg3 = NULL;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOO:DataFrame_setColumnStr",&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_setColumnStr" "', argument " "1"" of type '" "ampl::DataFrame *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  
  arg2 = _PyString_AsString(obj1);
  
  {
    /* Check if is a list */
    if (PyList_Check(obj2)) {
      int size = PyList_Size(obj2);
      int i = 0;
      arg3 = (char **)malloc((size + 1) * sizeof(char *));
      for (i = 0; i < size; i++) {
        PyObject *obj = PyList_GetItem(obj2,i);
        if (_PyString_Check(obj)) {
          arg3[i] = _PyString_AsString(PyList_GetItem(obj2,i));
        } else {
          PyErr_SetString(PyExc_TypeError,"list must contain strings");
          free(arg3);
          return NULL;
        }
      }
      arg3[i] = 0;
    }
    else {
      PyErr_SetString(PyExc_TypeError,"not a list");
      return NULL;
    }
  }
  ecode4 = SWIG_AsVal_size_t(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "DataFrame_setColumnStr" "', argument " "4"" of type '" "std::size_t""'");
  } 
  arg4 = static_cast< std::size_t >(val4);
  {
    try {
      ampl_DataFrame_setColumnSWIG(arg1,arg2,(char const *(*))arg3,arg4);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  {
    free((char *)arg3);
  }
  return resultobj;
fail:
  {
    free((char *)arg3);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_setColumnDbl(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  fmt::CStringRef arg2 ;
  double *arg3 = (double *) 0 ;
  std::size_t arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val4 ;
  int ecode4 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:DataFrame_setColumnDbl",&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_setColumnDbl" "', argument " "1"" of type '" "ampl::DataFrame *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  
  arg2 = _PyString_AsString(obj1);
  
  {
    /* Check if is a list */
    if (PyList_Check(obj2)) {
      int size = PyList_Size(obj2);
      int i = 0;
      arg3 = (double *)malloc(size * sizeof(double));
      for (i = 0; i < size; i++) {
        PyObject *o = PyList_GetItem(obj2,i);
        if (PyFloat_Check(o))
        arg3[i] = PyFloat_AsDouble(PyList_GetItem(obj2,i));
        else {
          PyErr_SetString(PyExc_TypeError, "The input list must contain floating point numbers");
          free(arg3);
          return NULL;
        }
      }
    }
    else {
      PyErr_SetString(PyExc_TypeError,"The input is not a list");
      return NULL;
    }
  }
  ecode4 = SWIG_AsVal_size_t(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "DataFrame_setColumnDbl" "', argument " "4"" of type '" "std::size_t""'");
  } 
  arg4 = static_cast< std::size_t >(val4);
  {
    try {
      ampl_DataFrame_setColumnSWIG(arg1,arg2,arg3,arg4);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  {
    free((double *)arg3);
  }
  return resultobj;
fail:
  {
    free((double *)arg3);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_setArrayDblDbl(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  std::size_t arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val4 ;
  int ecode4 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:DataFrame_setArrayDblDbl",&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_setArrayDblDbl" "', argument " "1"" of type '" "ampl::DataFrame *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  {
    /* Check if is a list */
    if (PyList_Check(obj1)) {
      int size = PyList_Size(obj1);
      int i = 0;
      arg2 = (double *)malloc(size * sizeof(double));
      for (i = 0; i < size; i++) {
        PyObject *o = PyList_GetItem(obj1,i);
        if (PyFloat_Check(o))
        arg2[i] = PyFloat_AsDouble(PyList_GetItem(obj1,i));
        else {
          PyErr_SetString(PyExc_TypeError, "The input list must contain floating point numbers");
          free(arg2);
          return NULL;
        }
      }
    }
    else {
      PyErr_SetString(PyExc_TypeError,"The input is not a list");
      return NULL;
    }
  }
  {
    /* Check if is a list */
    if (PyList_Check(obj2)) {
      int size = PyList_Size(obj2);
      int i = 0;
      arg3 = (double *)malloc(size * sizeof(double));
      for (i = 0; i < size; i++) {
        PyObject *o = PyList_GetItem(obj2,i);
        if (PyFloat_Check(o))
        arg3[i] = PyFloat_AsDouble(PyList_GetItem(obj2,i));
        else {
          PyErr_SetString(PyExc_TypeError, "The input list must contain floating point numbers");
          free(arg3);
          return NULL;
        }
      }
    }
    else {
      PyErr_SetString(PyExc_TypeError,"The input is not a list");
      return NULL;
    }
  }
  ecode4 = SWIG_AsVal_size_t(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "DataFrame_setArrayDblDbl" "', argument " "4"" of type '" "std::size_t""'");
  } 
  arg4 = static_cast< std::size_t >(val4);
  {
    try {
      ampl_DataFrame_setArraySWIG(arg1,arg2,arg3,arg4);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  {
    free((double *)arg2);
  }
  {
    free((double *)arg3);
  }
  return resultobj;
fail:
  {
    free((double *)arg2);
  }
  {
    free((double *)arg3);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_setArrayStrDbl(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  char **arg2 ;
  double *arg3 = (double *) 0 ;
  std::size_t arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val4 ;
  int ecode4 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    arg2 = NULL;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOO:DataFrame_setArrayStrDbl",&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_setArrayStrDbl" "', argument " "1"" of type '" "ampl::DataFrame *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  {
    /* Check if is a list */
    if (PyList_Check(obj1)) {
      int size = PyList_Size(obj1);
      int i = 0;
      arg2 = (char **)malloc((size + 1) * sizeof(char *));
      for (i = 0; i < size; i++) {
        PyObject *obj = PyList_GetItem(obj1,i);
        if (_PyString_Check(obj)) {
          arg2[i] = _PyString_AsString(PyList_GetItem(obj1,i));
        } else {
          PyErr_SetString(PyExc_TypeError,"list must contain strings");
          free(arg2);
          return NULL;
        }
      }
      arg2[i] = 0;
    }
    else {
      PyErr_SetString(PyExc_TypeError,"not a list");
      return NULL;
    }
  }
  {
    /* Check if is a list */
    if (PyList_Check(obj2)) {
      int size = PyList_Size(obj2);
      int i = 0;
      arg3 = (double *)malloc(size * sizeof(double));
      for (i = 0; i < size; i++) {
        PyObject *o = PyList_GetItem(obj2,i);
        if (PyFloat_Check(o))
        arg3[i] = PyFloat_AsDouble(PyList_GetItem(obj2,i));
        else {
          PyErr_SetString(PyExc_TypeError, "The input list must contain floating point numbers");
          free(arg3);
          return NULL;
        }
      }
    }
    else {
      PyErr_SetString(PyExc_TypeError,"The input is not a list");
      return NULL;
    }
  }
  ecode4 = SWIG_AsVal_size_t(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "DataFrame_setArrayStrDbl" "', argument " "4"" of type '" "std::size_t""'");
  } 
  arg4 = static_cast< std::size_t >(val4);
  {
    try {
      ampl_DataFrame_setArraySWIG(arg1,(char const *(*))arg2,arg3,arg4);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  {
    free((char *)arg2);
  }
  {
    free((double *)arg3);
  }
  return resultobj;
fail:
  {
    free((char *)arg2);
  }
  {
    free((double *)arg3);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_setArrayDblStr(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  double *arg2 = (double *) 0 ;
  char **arg3 = (char **) 0 ;
  std::size_t arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val4 ;
  int ecode4 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    arg3 = NULL;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOO:DataFrame_setArrayDblStr",&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_setArrayDblStr" "', argument " "1"" of type '" "ampl::DataFrame *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  {
    /* Check if is a list */
    if (PyList_Check(obj1)) {
      int size = PyList_Size(obj1);
      int i = 0;
      arg2 = (double *)malloc(size * sizeof(double));
      for (i = 0; i < size; i++) {
        PyObject *o = PyList_GetItem(obj1,i);
        if (PyFloat_Check(o))
        arg2[i] = PyFloat_AsDouble(PyList_GetItem(obj1,i));
        else {
          PyErr_SetString(PyExc_TypeError, "The input list must contain floating point numbers");
          free(arg2);
          return NULL;
        }
      }
    }
    else {
      PyErr_SetString(PyExc_TypeError,"The input is not a list");
      return NULL;
    }
  }
  {
    /* Check if is a list */
    if (PyList_Check(obj2)) {
      int size = PyList_Size(obj2);
      int i = 0;
      arg3 = (char **)malloc((size + 1) * sizeof(char *));
      for (i = 0; i < size; i++) {
        PyObject *obj = PyList_GetItem(obj2,i);
        if (_PyString_Check(obj)) {
          arg3[i] = _PyString_AsString(PyList_GetItem(obj2,i));
        } else {
          PyErr_SetString(PyExc_TypeError,"list must contain strings");
          free(arg3);
          return NULL;
        }
      }
      arg3[i] = 0;
    }
    else {
      PyErr_SetString(PyExc_TypeError,"not a list");
      return NULL;
    }
  }
  ecode4 = SWIG_AsVal_size_t(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "DataFrame_setArrayDblStr" "', argument " "4"" of type '" "std::size_t""'");
  } 
  arg4 = static_cast< std::size_t >(val4);
  {
    try {
      ampl_DataFrame_setArraySWIG(arg1,arg2,(char const *const *)arg3,arg4);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  {
    free((double *)arg2);
  }
  {
    free((char *)arg3);
  }
  return resultobj;
fail:
  {
    free((double *)arg2);
  }
  {
    free((char *)arg3);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_setArrayStrStr(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  char **arg2 ;
  char **arg3 = (char **) 0 ;
  std::size_t arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val4 ;
  int ecode4 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    arg2 = NULL;
  }
  {
    arg3 = NULL;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOO:DataFrame_setArrayStrStr",&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_setArrayStrStr" "', argument " "1"" of type '" "ampl::DataFrame *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  {
    /* Check if is a list */
    if (PyList_Check(obj1)) {
      int size = PyList_Size(obj1);
      int i = 0;
      arg2 = (char **)malloc((size + 1) * sizeof(char *));
      for (i = 0; i < size; i++) {
        PyObject *obj = PyList_GetItem(obj1,i);
        if (_PyString_Check(obj)) {
          arg2[i] = _PyString_AsString(PyList_GetItem(obj1,i));
        } else {
          PyErr_SetString(PyExc_TypeError,"list must contain strings");
          free(arg2);
          return NULL;
        }
      }
      arg2[i] = 0;
    }
    else {
      PyErr_SetString(PyExc_TypeError,"not a list");
      return NULL;
    }
  }
  {
    /* Check if is a list */
    if (PyList_Check(obj2)) {
      int size = PyList_Size(obj2);
      int i = 0;
      arg3 = (char **)malloc((size + 1) * sizeof(char *));
      for (i = 0; i < size; i++) {
        PyObject *obj = PyList_GetItem(obj2,i);
        if (_PyString_Check(obj)) {
          arg3[i] = _PyString_AsString(PyList_GetItem(obj2,i));
        } else {
          PyErr_SetString(PyExc_TypeError,"list must contain strings");
          free(arg3);
          return NULL;
        }
      }
      arg3[i] = 0;
    }
    else {
      PyErr_SetString(PyExc_TypeError,"not a list");
      return NULL;
    }
  }
  ecode4 = SWIG_AsVal_size_t(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "DataFrame_setArrayStrStr" "', argument " "4"" of type '" "std::size_t""'");
  } 
  arg4 = static_cast< std::size_t >(val4);
  {
    try {
      ampl_DataFrame_setArraySWIG(arg1,(char const *(*))arg2,(char const *const *)arg3,arg4);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  {
    free((char *)arg2);
  }
  {
    free((char *)arg3);
  }
  return resultobj;
fail:
  {
    free((char *)arg2);
  }
  {
    free((char *)arg3);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_setMatrixDblDblDbl(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  double *arg2 = (double *) 0 ;
  std::size_t arg3 ;
  double *arg4 = (double *) 0 ;
  std::size_t arg5 ;
  double *arg6 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  size_t val5 ;
  int ecode5 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:DataFrame_setMatrixDblDblDbl",&obj1,&obj2,&obj3,&obj4,&obj5)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_setMatrixDblDblDbl" "', argument " "1"" of type '" "ampl::DataFrame *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  {
    /* Check if is a list */
    if (PyList_Check(obj1)) {
      int size = PyList_Size(obj1);
      int i = 0;
      arg2 = (double *)malloc(size * sizeof(double));
      for (i = 0; i < size; i++) {
        PyObject *o = PyList_GetItem(obj1,i);
        if (PyFloat_Check(o))
        arg2[i] = PyFloat_AsDouble(PyList_GetItem(obj1,i));
        else {
          PyErr_SetString(PyExc_TypeError, "The input list must contain floating point numbers");
          free(arg2);
          return NULL;
        }
      }
    }
    else {
      PyErr_SetString(PyExc_TypeError,"The input is not a list");
      return NULL;
    }
  }
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "DataFrame_setMatrixDblDblDbl" "', argument " "3"" of type '" "std::size_t""'");
  } 
  arg3 = static_cast< std::size_t >(val3);
  {
    /* Check if is a list */
    if (PyList_Check(obj3)) {
      int size = PyList_Size(obj3);
      int i = 0;
      arg4 = (double *)malloc(size * sizeof(double));
      for (i = 0; i < size; i++) {
        PyObject *o = PyList_GetItem(obj3,i);
        if (PyFloat_Check(o))
        arg4[i] = PyFloat_AsDouble(PyList_GetItem(obj3,i));
        else {
          PyErr_SetString(PyExc_TypeError, "The input list must contain floating point numbers");
          free(arg4);
          return NULL;
        }
      }
    }
    else {
      PyErr_SetString(PyExc_TypeError,"The input is not a list");
      return NULL;
    }
  }
  ecode5 = SWIG_AsVal_size_t(obj4, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "DataFrame_setMatrixDblDblDbl" "', argument " "5"" of type '" "std::size_t""'");
  } 
  arg5 = static_cast< std::size_t >(val5);
  {
    /* Check if is a list */
    if (PyList_Check(obj5)) {
      int size = PyList_Size(obj5);
      int i = 0;
      arg6 = (double *)malloc(size * sizeof(double));
      for (i = 0; i < size; i++) {
        PyObject *o = PyList_GetItem(obj5,i);
        if (PyFloat_Check(o))
        arg6[i] = PyFloat_AsDouble(PyList_GetItem(obj5,i));
        else {
          PyErr_SetString(PyExc_TypeError, "The input list must contain floating point numbers");
          free(arg6);
          return NULL;
        }
      }
    }
    else {
      PyErr_SetString(PyExc_TypeError,"The input is not a list");
      return NULL;
    }
  }
  {
    try {
      ampl_DataFrame_setMatrixSWIG(arg1,arg2,arg3,arg4,arg5,(double const *)arg6);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  {
    free((double *)arg2);
  }
  {
    free((double *)arg4);
  }
  {
    free((double *)arg6);
  }
  return resultobj;
fail:
  {
    free((double *)arg2);
  }
  {
    free((double *)arg4);
  }
  {
    free((double *)arg6);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_setMatrixStrStrDbl(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  char **arg2 ;
  std::size_t arg3 ;
  char **arg4 ;
  std::size_t arg5 ;
  double *arg6 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  size_t val5 ;
  int ecode5 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:DataFrame_setMatrixStrStrDbl",&obj1,&obj2,&obj3,&obj4,&obj5)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_setMatrixStrStrDbl" "', argument " "1"" of type '" "ampl::DataFrame *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_p_char, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DataFrame_setMatrixStrStrDbl" "', argument " "2"" of type '" "char const *[]""'"); 
  } 
  arg2 = reinterpret_cast< char ** >(argp2);
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "DataFrame_setMatrixStrStrDbl" "', argument " "3"" of type '" "std::size_t""'");
  } 
  arg3 = static_cast< std::size_t >(val3);
  res4 = SWIG_ConvertPtr(obj3, &argp4,SWIGTYPE_p_p_char, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "DataFrame_setMatrixStrStrDbl" "', argument " "4"" of type '" "char const *[]""'"); 
  } 
  arg4 = reinterpret_cast< char ** >(argp4);
  ecode5 = SWIG_AsVal_size_t(obj4, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "DataFrame_setMatrixStrStrDbl" "', argument " "5"" of type '" "std::size_t""'");
  } 
  arg5 = static_cast< std::size_t >(val5);
  {
    /* Check if is a list */
    if (PyList_Check(obj5)) {
      int size = PyList_Size(obj5);
      int i = 0;
      arg6 = (double *)malloc(size * sizeof(double));
      for (i = 0; i < size; i++) {
        PyObject *o = PyList_GetItem(obj5,i);
        if (PyFloat_Check(o))
        arg6[i] = PyFloat_AsDouble(PyList_GetItem(obj5,i));
        else {
          PyErr_SetString(PyExc_TypeError, "The input list must contain floating point numbers");
          free(arg6);
          return NULL;
        }
      }
    }
    else {
      PyErr_SetString(PyExc_TypeError,"The input is not a list");
      return NULL;
    }
  }
  {
    try {
      ampl_DataFrame_setMatrixSWIG(arg1,(char const *(*))arg2,arg3,(char const *(*))arg4,arg5,(double const *)arg6);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  {
    free((double *)arg6);
  }
  return resultobj;
fail:
  {
    free((double *)arg6);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_setMatrixDblStrDbl(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  double *arg2 = (double *) 0 ;
  std::size_t arg3 ;
  char **arg4 ;
  std::size_t arg5 ;
  double *arg6 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  size_t val5 ;
  int ecode5 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:DataFrame_setMatrixDblStrDbl",&obj1,&obj2,&obj3,&obj4,&obj5)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_setMatrixDblStrDbl" "', argument " "1"" of type '" "ampl::DataFrame *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  {
    /* Check if is a list */
    if (PyList_Check(obj1)) {
      int size = PyList_Size(obj1);
      int i = 0;
      arg2 = (double *)malloc(size * sizeof(double));
      for (i = 0; i < size; i++) {
        PyObject *o = PyList_GetItem(obj1,i);
        if (PyFloat_Check(o))
        arg2[i] = PyFloat_AsDouble(PyList_GetItem(obj1,i));
        else {
          PyErr_SetString(PyExc_TypeError, "The input list must contain floating point numbers");
          free(arg2);
          return NULL;
        }
      }
    }
    else {
      PyErr_SetString(PyExc_TypeError,"The input is not a list");
      return NULL;
    }
  }
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "DataFrame_setMatrixDblStrDbl" "', argument " "3"" of type '" "std::size_t""'");
  } 
  arg3 = static_cast< std::size_t >(val3);
  res4 = SWIG_ConvertPtr(obj3, &argp4,SWIGTYPE_p_p_char, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "DataFrame_setMatrixDblStrDbl" "', argument " "4"" of type '" "char const *[]""'"); 
  } 
  arg4 = reinterpret_cast< char ** >(argp4);
  ecode5 = SWIG_AsVal_size_t(obj4, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "DataFrame_setMatrixDblStrDbl" "', argument " "5"" of type '" "std::size_t""'");
  } 
  arg5 = static_cast< std::size_t >(val5);
  {
    /* Check if is a list */
    if (PyList_Check(obj5)) {
      int size = PyList_Size(obj5);
      int i = 0;
      arg6 = (double *)malloc(size * sizeof(double));
      for (i = 0; i < size; i++) {
        PyObject *o = PyList_GetItem(obj5,i);
        if (PyFloat_Check(o))
        arg6[i] = PyFloat_AsDouble(PyList_GetItem(obj5,i));
        else {
          PyErr_SetString(PyExc_TypeError, "The input list must contain floating point numbers");
          free(arg6);
          return NULL;
        }
      }
    }
    else {
      PyErr_SetString(PyExc_TypeError,"The input is not a list");
      return NULL;
    }
  }
  {
    try {
      ampl_DataFrame_setMatrixSWIG(arg1,arg2,arg3,(char const *(*))arg4,arg5,(double const *)arg6);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  {
    free((double *)arg2);
  }
  {
    free((double *)arg6);
  }
  return resultobj;
fail:
  {
    free((double *)arg2);
  }
  {
    free((double *)arg6);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_setMatrixStrDblDbl(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  char **arg2 ;
  std::size_t arg3 ;
  double *arg4 = (double *) 0 ;
  std::size_t arg5 ;
  double *arg6 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  size_t val5 ;
  int ecode5 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:DataFrame_setMatrixStrDblDbl",&obj1,&obj2,&obj3,&obj4,&obj5)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_setMatrixStrDblDbl" "', argument " "1"" of type '" "ampl::DataFrame *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_p_char, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DataFrame_setMatrixStrDblDbl" "', argument " "2"" of type '" "char const *[]""'"); 
  } 
  arg2 = reinterpret_cast< char ** >(argp2);
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "DataFrame_setMatrixStrDblDbl" "', argument " "3"" of type '" "std::size_t""'");
  } 
  arg3 = static_cast< std::size_t >(val3);
  {
    /* Check if is a list */
    if (PyList_Check(obj3)) {
      int size = PyList_Size(obj3);
      int i = 0;
      arg4 = (double *)malloc(size * sizeof(double));
      for (i = 0; i < size; i++) {
        PyObject *o = PyList_GetItem(obj3,i);
        if (PyFloat_Check(o))
        arg4[i] = PyFloat_AsDouble(PyList_GetItem(obj3,i));
        else {
          PyErr_SetString(PyExc_TypeError, "The input list must contain floating point numbers");
          free(arg4);
          return NULL;
        }
      }
    }
    else {
      PyErr_SetString(PyExc_TypeError,"The input is not a list");
      return NULL;
    }
  }
  ecode5 = SWIG_AsVal_size_t(obj4, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "DataFrame_setMatrixStrDblDbl" "', argument " "5"" of type '" "std::size_t""'");
  } 
  arg5 = static_cast< std::size_t >(val5);
  {
    /* Check if is a list */
    if (PyList_Check(obj5)) {
      int size = PyList_Size(obj5);
      int i = 0;
      arg6 = (double *)malloc(size * sizeof(double));
      for (i = 0; i < size; i++) {
        PyObject *o = PyList_GetItem(obj5,i);
        if (PyFloat_Check(o))
        arg6[i] = PyFloat_AsDouble(PyList_GetItem(obj5,i));
        else {
          PyErr_SetString(PyExc_TypeError, "The input list must contain floating point numbers");
          free(arg6);
          return NULL;
        }
      }
    }
    else {
      PyErr_SetString(PyExc_TypeError,"The input is not a list");
      return NULL;
    }
  }
  {
    try {
      ampl_DataFrame_setMatrixSWIG(arg1,(char const *(*))arg2,arg3,arg4,arg5,(double const *)arg6);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  {
    free((double *)arg4);
  }
  {
    free((double *)arg6);
  }
  return resultobj;
fail:
  {
    free((double *)arg4);
  }
  {
    free((double *)arg6);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_setMatrixDblDblStr(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  double *arg2 = (double *) 0 ;
  std::size_t arg3 ;
  double *arg4 = (double *) 0 ;
  std::size_t arg5 ;
  char **arg6 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  size_t val5 ;
  int ecode5 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  
  {
    arg6 = NULL;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:DataFrame_setMatrixDblDblStr",&obj1,&obj2,&obj3,&obj4,&obj5)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_setMatrixDblDblStr" "', argument " "1"" of type '" "ampl::DataFrame *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  {
    /* Check if is a list */
    if (PyList_Check(obj1)) {
      int size = PyList_Size(obj1);
      int i = 0;
      arg2 = (double *)malloc(size * sizeof(double));
      for (i = 0; i < size; i++) {
        PyObject *o = PyList_GetItem(obj1,i);
        if (PyFloat_Check(o))
        arg2[i] = PyFloat_AsDouble(PyList_GetItem(obj1,i));
        else {
          PyErr_SetString(PyExc_TypeError, "The input list must contain floating point numbers");
          free(arg2);
          return NULL;
        }
      }
    }
    else {
      PyErr_SetString(PyExc_TypeError,"The input is not a list");
      return NULL;
    }
  }
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "DataFrame_setMatrixDblDblStr" "', argument " "3"" of type '" "std::size_t""'");
  } 
  arg3 = static_cast< std::size_t >(val3);
  {
    /* Check if is a list */
    if (PyList_Check(obj3)) {
      int size = PyList_Size(obj3);
      int i = 0;
      arg4 = (double *)malloc(size * sizeof(double));
      for (i = 0; i < size; i++) {
        PyObject *o = PyList_GetItem(obj3,i);
        if (PyFloat_Check(o))
        arg4[i] = PyFloat_AsDouble(PyList_GetItem(obj3,i));
        else {
          PyErr_SetString(PyExc_TypeError, "The input list must contain floating point numbers");
          free(arg4);
          return NULL;
        }
      }
    }
    else {
      PyErr_SetString(PyExc_TypeError,"The input is not a list");
      return NULL;
    }
  }
  ecode5 = SWIG_AsVal_size_t(obj4, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "DataFrame_setMatrixDblDblStr" "', argument " "5"" of type '" "std::size_t""'");
  } 
  arg5 = static_cast< std::size_t >(val5);
  {
    /* Check if is a list */
    if (PyList_Check(obj5)) {
      int size = PyList_Size(obj5);
      int i = 0;
      arg6 = (char **)malloc((size + 1) * sizeof(char *));
      for (i = 0; i < size; i++) {
        PyObject *obj = PyList_GetItem(obj5,i);
        if (_PyString_Check(obj)) {
          arg6[i] = _PyString_AsString(PyList_GetItem(obj5,i));
        } else {
          PyErr_SetString(PyExc_TypeError,"list must contain strings");
          free(arg6);
          return NULL;
        }
      }
      arg6[i] = 0;
    }
    else {
      PyErr_SetString(PyExc_TypeError,"not a list");
      return NULL;
    }
  }
  {
    try {
      ampl_DataFrame_setMatrixSWIG(arg1,arg2,arg3,arg4,arg5,(char const *(*))arg6);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  {
    free((double *)arg2);
  }
  {
    free((double *)arg4);
  }
  {
    free((char *)arg6);
  }
  return resultobj;
fail:
  {
    free((double *)arg2);
  }
  {
    free((double *)arg4);
  }
  {
    free((char *)arg6);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_setMatrixDblStrStr(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  double *arg2 = (double *) 0 ;
  std::size_t arg3 ;
  char **arg4 ;
  std::size_t arg5 ;
  char **arg6 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  size_t val5 ;
  int ecode5 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  
  {
    arg6 = NULL;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:DataFrame_setMatrixDblStrStr",&obj1,&obj2,&obj3,&obj4,&obj5)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_setMatrixDblStrStr" "', argument " "1"" of type '" "ampl::DataFrame *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  {
    /* Check if is a list */
    if (PyList_Check(obj1)) {
      int size = PyList_Size(obj1);
      int i = 0;
      arg2 = (double *)malloc(size * sizeof(double));
      for (i = 0; i < size; i++) {
        PyObject *o = PyList_GetItem(obj1,i);
        if (PyFloat_Check(o))
        arg2[i] = PyFloat_AsDouble(PyList_GetItem(obj1,i));
        else {
          PyErr_SetString(PyExc_TypeError, "The input list must contain floating point numbers");
          free(arg2);
          return NULL;
        }
      }
    }
    else {
      PyErr_SetString(PyExc_TypeError,"The input is not a list");
      return NULL;
    }
  }
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "DataFrame_setMatrixDblStrStr" "', argument " "3"" of type '" "std::size_t""'");
  } 
  arg3 = static_cast< std::size_t >(val3);
  res4 = SWIG_ConvertPtr(obj3, &argp4,SWIGTYPE_p_p_char, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "DataFrame_setMatrixDblStrStr" "', argument " "4"" of type '" "char const *[]""'"); 
  } 
  arg4 = reinterpret_cast< char ** >(argp4);
  ecode5 = SWIG_AsVal_size_t(obj4, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "DataFrame_setMatrixDblStrStr" "', argument " "5"" of type '" "std::size_t""'");
  } 
  arg5 = static_cast< std::size_t >(val5);
  {
    /* Check if is a list */
    if (PyList_Check(obj5)) {
      int size = PyList_Size(obj5);
      int i = 0;
      arg6 = (char **)malloc((size + 1) * sizeof(char *));
      for (i = 0; i < size; i++) {
        PyObject *obj = PyList_GetItem(obj5,i);
        if (_PyString_Check(obj)) {
          arg6[i] = _PyString_AsString(PyList_GetItem(obj5,i));
        } else {
          PyErr_SetString(PyExc_TypeError,"list must contain strings");
          free(arg6);
          return NULL;
        }
      }
      arg6[i] = 0;
    }
    else {
      PyErr_SetString(PyExc_TypeError,"not a list");
      return NULL;
    }
  }
  {
    try {
      ampl_DataFrame_setMatrixSWIG(arg1,arg2,arg3,(char const *(*))arg4,arg5,(char const *(*))arg6);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  {
    free((double *)arg2);
  }
  {
    free((char *)arg6);
  }
  return resultobj;
fail:
  {
    free((double *)arg2);
  }
  {
    free((char *)arg6);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_setMatrixStrDblStr(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  char **arg2 ;
  std::size_t arg3 ;
  double *arg4 = (double *) 0 ;
  std::size_t arg5 ;
  char **arg6 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  size_t val5 ;
  int ecode5 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  
  {
    arg6 = NULL;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:DataFrame_setMatrixStrDblStr",&obj1,&obj2,&obj3,&obj4,&obj5)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_setMatrixStrDblStr" "', argument " "1"" of type '" "ampl::DataFrame *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_p_char, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DataFrame_setMatrixStrDblStr" "', argument " "2"" of type '" "char const *[]""'"); 
  } 
  arg2 = reinterpret_cast< char ** >(argp2);
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "DataFrame_setMatrixStrDblStr" "', argument " "3"" of type '" "std::size_t""'");
  } 
  arg3 = static_cast< std::size_t >(val3);
  {
    /* Check if is a list */
    if (PyList_Check(obj3)) {
      int size = PyList_Size(obj3);
      int i = 0;
      arg4 = (double *)malloc(size * sizeof(double));
      for (i = 0; i < size; i++) {
        PyObject *o = PyList_GetItem(obj3,i);
        if (PyFloat_Check(o))
        arg4[i] = PyFloat_AsDouble(PyList_GetItem(obj3,i));
        else {
          PyErr_SetString(PyExc_TypeError, "The input list must contain floating point numbers");
          free(arg4);
          return NULL;
        }
      }
    }
    else {
      PyErr_SetString(PyExc_TypeError,"The input is not a list");
      return NULL;
    }
  }
  ecode5 = SWIG_AsVal_size_t(obj4, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "DataFrame_setMatrixStrDblStr" "', argument " "5"" of type '" "std::size_t""'");
  } 
  arg5 = static_cast< std::size_t >(val5);
  {
    /* Check if is a list */
    if (PyList_Check(obj5)) {
      int size = PyList_Size(obj5);
      int i = 0;
      arg6 = (char **)malloc((size + 1) * sizeof(char *));
      for (i = 0; i < size; i++) {
        PyObject *obj = PyList_GetItem(obj5,i);
        if (_PyString_Check(obj)) {
          arg6[i] = _PyString_AsString(PyList_GetItem(obj5,i));
        } else {
          PyErr_SetString(PyExc_TypeError,"list must contain strings");
          free(arg6);
          return NULL;
        }
      }
      arg6[i] = 0;
    }
    else {
      PyErr_SetString(PyExc_TypeError,"not a list");
      return NULL;
    }
  }
  {
    try {
      ampl_DataFrame_setMatrixSWIG(arg1,(char const *(*))arg2,arg3,arg4,arg5,(char const *(*))arg6);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  {
    free((double *)arg4);
  }
  {
    free((char *)arg6);
  }
  return resultobj;
fail:
  {
    free((double *)arg4);
  }
  {
    free((char *)arg6);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_setMatrixStrStrStr(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::DataFrame *arg1 = (ampl::DataFrame *) 0 ;
  char **arg2 ;
  std::size_t arg3 ;
  char **arg4 ;
  std::size_t arg5 ;
  char **arg6 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  size_t val5 ;
  int ecode5 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  
  {
    arg6 = NULL;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:DataFrame_setMatrixStrStrStr",&obj1,&obj2,&obj3,&obj4,&obj5)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__DataFrame, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrame_setMatrixStrStrStr" "', argument " "1"" of type '" "ampl::DataFrame *""'"); 
  }
  arg1 = reinterpret_cast< ampl::DataFrame * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_p_char, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DataFrame_setMatrixStrStrStr" "', argument " "2"" of type '" "char const *[]""'"); 
  } 
  arg2 = reinterpret_cast< char ** >(argp2);
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "DataFrame_setMatrixStrStrStr" "', argument " "3"" of type '" "std::size_t""'");
  } 
  arg3 = static_cast< std::size_t >(val3);
  res4 = SWIG_ConvertPtr(obj3, &argp4,SWIGTYPE_p_p_char, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "DataFrame_setMatrixStrStrStr" "', argument " "4"" of type '" "char const *[]""'"); 
  } 
  arg4 = reinterpret_cast< char ** >(argp4);
  ecode5 = SWIG_AsVal_size_t(obj4, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "DataFrame_setMatrixStrStrStr" "', argument " "5"" of type '" "std::size_t""'");
  } 
  arg5 = static_cast< std::size_t >(val5);
  {
    /* Check if is a list */
    if (PyList_Check(obj5)) {
      int size = PyList_Size(obj5);
      int i = 0;
      arg6 = (char **)malloc((size + 1) * sizeof(char *));
      for (i = 0; i < size; i++) {
        PyObject *obj = PyList_GetItem(obj5,i);
        if (_PyString_Check(obj)) {
          arg6[i] = _PyString_AsString(PyList_GetItem(obj5,i));
        } else {
          PyErr_SetString(PyExc_TypeError,"list must contain strings");
          free(arg6);
          return NULL;
        }
      }
      arg6[i] = 0;
    }
    else {
      PyErr_SetString(PyExc_TypeError,"not a list");
      return NULL;
    }
  }
  {
    try {
      ampl_DataFrame_setMatrixSWIG(arg1,(char const *(*))arg2,arg3,(char const *(*))arg4,arg5,(char const *(*))arg6);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  {
    free((char *)arg6);
  }
  return resultobj;
fail:
  {
    free((char *)arg6);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrame_factory(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  int arg1 ;
  char **arg2 ;
  int arg3 ;
  int val1 ;
  int ecode1 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  SwigValueWrapper< ampl::DataFrame > result;
  
  {
    arg2 = NULL;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOO:DataFrame_factory",&obj0,&obj1,&obj2)) SWIG_fail;
  ecode1 = SWIG_AsVal_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "DataFrame_factory" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = static_cast< int >(val1);
  {
    /* Check if is a list */
    if (PyList_Check(obj1)) {
      int size = PyList_Size(obj1);
      int i = 0;
      arg2 = (char **)malloc((size + 1) * sizeof(char *));
      for (i = 0; i < size; i++) {
        PyObject *obj = PyList_GetItem(obj1,i);
        if (_PyString_Check(obj)) {
          arg2[i] = _PyString_AsString(PyList_GetItem(obj1,i));
        } else {
          PyErr_SetString(PyExc_TypeError,"list must contain strings");
          free(arg2);
          return NULL;
        }
      }
      arg2[i] = 0;
    }
    else {
      PyErr_SetString(PyExc_TypeError,"not a list");
      return NULL;
    }
  }
  ecode3 = SWIG_AsVal_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "DataFrame_factory" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  {
    try {
      result = ampl_DataFrame_factory(arg1,(char const *(*))arg2,arg3);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::DataFrame(static_cast< const ampl::DataFrame& >(result))), SWIGTYPE_p_ampl__DataFrame, SWIG_POINTER_OWN |  0 );
  {
    free((char *)arg2);
  }
  return resultobj;
fail:
  {
    free((char *)arg2);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrameColumn_size(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::Slice< false > *arg1 = (ampl::internal::Slice< false > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::size_t result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "DataFrameColumn_size takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__SliceT_false_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrameColumn_size" "', argument " "1"" of type '" "ampl::internal::Slice< false > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::Slice< false > * >(argp1);
  {
    try {
      result = (std::size_t)((ampl::internal::Slice< false > const *)arg1)->size();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrameColumn_begin(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::Slice< false > *arg1 = (ampl::internal::Slice< false > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< ampl::internal::Slice< false >::iterator > result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "DataFrameColumn_begin takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__SliceT_false_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrameColumn_begin" "', argument " "1"" of type '" "ampl::internal::Slice< false > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::Slice< false > * >(argp1);
  {
    try {
      result = ((ampl::internal::Slice< false > const *)arg1)->begin();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::internal::Slice< false >::iterator(static_cast< const ampl::internal::Slice< false >::iterator& >(result))), SWIGTYPE_p_ampl__internal__SliceT_false_t__iterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrameColumn_end(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::Slice< false > *arg1 = (ampl::internal::Slice< false > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< ampl::internal::Slice< false >::iterator > result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "DataFrameColumn_end takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__SliceT_false_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrameColumn_end" "', argument " "1"" of type '" "ampl::internal::Slice< false > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::Slice< false > * >(argp1);
  {
    try {
      result = ((ampl::internal::Slice< false > const *)arg1)->end();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::internal::Slice< false >::iterator(static_cast< const ampl::internal::Slice< false >::iterator& >(result))), SWIGTYPE_p_ampl__internal__SliceT_false_t__iterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrameColumn_getIndex(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::Slice< false > *arg1 = (ampl::internal::Slice< false > *) 0 ;
  std::size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj1 = 0 ;
  SwigValueWrapper< ampl::VariantRef > result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:DataFrameColumn_getIndex",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__SliceT_false_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrameColumn_getIndex" "', argument " "1"" of type '" "ampl::internal::Slice< false > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::Slice< false > * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DataFrameColumn_getIndex" "', argument " "2"" of type '" "std::size_t""'");
  } 
  arg2 = static_cast< std::size_t >(val2);
  {
    try {
      result = ((ampl::internal::Slice< false > const *)arg1)->operator [](arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::VariantRef(static_cast< const ampl::VariantRef& >(result))), SWIGTYPE_p_ampl__VariantRef, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_DataFrameColumn(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::Slice< false > *arg1 = (ampl::internal::Slice< false > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_DataFrameColumn takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__SliceT_false_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_DataFrameColumn" "', argument " "1"" of type '" "ampl::internal::Slice< false > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::Slice< false > * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ColIterator_equals(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::Slice< false >::iterator *arg1 = (ampl::internal::Slice< false >::iterator *) 0 ;
  ampl::internal::Slice< false >::iterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ColIterator_equals",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__SliceT_false_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ColIterator_equals" "', argument " "1"" of type '" "ampl::internal::Slice< false >::iterator const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::Slice< false >::iterator * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__internal__SliceT_false_t__iterator,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ColIterator_equals" "', argument " "2"" of type '" "ampl::internal::Slice< false >::iterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ColIterator_equals" "', argument " "2"" of type '" "ampl::internal::Slice< false >::iterator const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::internal::Slice< false >::iterator * >(argp2);
  {
    try {
      result = (bool)((ampl::internal::Slice< false >::iterator const *)arg1)->operator ==((ampl::internal::Slice< false >::iterator const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ColIterator_differs(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::Slice< false >::iterator *arg1 = (ampl::internal::Slice< false >::iterator *) 0 ;
  ampl::internal::Slice< false >::iterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ColIterator_differs",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__SliceT_false_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ColIterator_differs" "', argument " "1"" of type '" "ampl::internal::Slice< false >::iterator const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::Slice< false >::iterator * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__internal__SliceT_false_t__iterator,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ColIterator_differs" "', argument " "2"" of type '" "ampl::internal::Slice< false >::iterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ColIterator_differs" "', argument " "2"" of type '" "ampl::internal::Slice< false >::iterator const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::internal::Slice< false >::iterator * >(argp2);
  {
    try {
      result = (bool)((ampl::internal::Slice< false >::iterator const *)arg1)->operator !=((ampl::internal::Slice< false >::iterator const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ColIterator___ref__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::Slice< false >::iterator *arg1 = (ampl::internal::Slice< false >::iterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< ampl::VariantRef > result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "ColIterator___ref__ takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__SliceT_false_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ColIterator___ref__" "', argument " "1"" of type '" "ampl::internal::Slice< false >::iterator const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::Slice< false >::iterator * >(argp1);
  {
    try {
      result = ((ampl::internal::Slice< false >::iterator const *)arg1)->operator *();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::VariantRef(static_cast< const ampl::VariantRef& >(result))), SWIGTYPE_p_ampl__VariantRef, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGPY_BINARYFUNC_CLOSURE(_wrap_ColIterator___ref__)

SWIGINTERN PyObject *_wrap_ColIterator_clone(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::Slice< false >::iterator *arg1 = (ampl::internal::Slice< false >::iterator *) 0 ;
  ampl::internal::Slice< false >::iterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  ampl::internal::Slice< false >::iterator *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ColIterator_clone",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__SliceT_false_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ColIterator_clone" "', argument " "1"" of type '" "ampl::internal::Slice< false >::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::Slice< false >::iterator * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__internal__SliceT_false_t__iterator,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ColIterator_clone" "', argument " "2"" of type '" "ampl::internal::Slice< false >::iterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ColIterator_clone" "', argument " "2"" of type '" "ampl::internal::Slice< false >::iterator const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::internal::Slice< false >::iterator * >(argp2);
  {
    try {
      result = (ampl::internal::Slice< false >::iterator *) &(arg1)->operator =((ampl::internal::Slice< false >::iterator const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__internal__SliceT_false_t__iterator, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ColIterator_postIncrement(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::Slice< false >::iterator *arg1 = (ampl::internal::Slice< false >::iterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ampl::internal::Slice< false >::iterator *result = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "ColIterator_postIncrement takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__SliceT_false_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ColIterator_postIncrement" "', argument " "1"" of type '" "ampl::internal::Slice< false >::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::Slice< false >::iterator * >(argp1);
  {
    try {
      result = (ampl::internal::Slice< false >::iterator *) &(arg1)->operator ++();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__internal__SliceT_false_t__iterator, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ColIterator_postIncrementBy(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::Slice< false >::iterator *arg1 = (ampl::internal::Slice< false >::iterator *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj1 = 0 ;
  SwigValueWrapper< ampl::internal::Slice< false >::iterator > result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ColIterator_postIncrementBy",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__SliceT_false_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ColIterator_postIncrementBy" "', argument " "1"" of type '" "ampl::internal::Slice< false >::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::Slice< false >::iterator * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ColIterator_postIncrementBy" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  {
    try {
      result = (arg1)->operator ++(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::internal::Slice< false >::iterator(static_cast< const ampl::internal::Slice< false >::iterator& >(result))), SWIGTYPE_p_ampl__internal__SliceT_false_t__iterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ColIterator(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::Slice< false >::iterator *arg1 = (ampl::internal::Slice< false >::iterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_ColIterator takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__SliceT_false_t__iterator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ColIterator" "', argument " "1"" of type '" "ampl::internal::Slice< false >::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::Slice< false >::iterator * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrameRow_size(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::Slice< true > *arg1 = (ampl::internal::Slice< true > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::size_t result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "DataFrameRow_size takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__SliceT_true_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrameRow_size" "', argument " "1"" of type '" "ampl::internal::Slice< true > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::Slice< true > * >(argp1);
  {
    try {
      result = (std::size_t)((ampl::internal::Slice< true > const *)arg1)->size();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrameRow_begin(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::Slice< true > *arg1 = (ampl::internal::Slice< true > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< ampl::internal::Slice< true >::iterator > result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "DataFrameRow_begin takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__SliceT_true_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrameRow_begin" "', argument " "1"" of type '" "ampl::internal::Slice< true > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::Slice< true > * >(argp1);
  {
    try {
      result = ((ampl::internal::Slice< true > const *)arg1)->begin();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::internal::Slice< true >::iterator(static_cast< const ampl::internal::Slice< true >::iterator& >(result))), SWIGTYPE_p_ampl__internal__SliceT_true_t__iterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrameRow_end(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::Slice< true > *arg1 = (ampl::internal::Slice< true > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< ampl::internal::Slice< true >::iterator > result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "DataFrameRow_end takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__SliceT_true_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrameRow_end" "', argument " "1"" of type '" "ampl::internal::Slice< true > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::Slice< true > * >(argp1);
  {
    try {
      result = ((ampl::internal::Slice< true > const *)arg1)->end();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::internal::Slice< true >::iterator(static_cast< const ampl::internal::Slice< true >::iterator& >(result))), SWIGTYPE_p_ampl__internal__SliceT_true_t__iterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DataFrameRow_getIndex(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::Slice< true > *arg1 = (ampl::internal::Slice< true > *) 0 ;
  std::size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj1 = 0 ;
  SwigValueWrapper< ampl::VariantRef > result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:DataFrameRow_getIndex",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__SliceT_true_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataFrameRow_getIndex" "', argument " "1"" of type '" "ampl::internal::Slice< true > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::Slice< true > * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DataFrameRow_getIndex" "', argument " "2"" of type '" "std::size_t""'");
  } 
  arg2 = static_cast< std::size_t >(val2);
  {
    try {
      result = ((ampl::internal::Slice< true > const *)arg1)->operator [](arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::VariantRef(static_cast< const ampl::VariantRef& >(result))), SWIGTYPE_p_ampl__VariantRef, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_DataFrameRow(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::Slice< true > *arg1 = (ampl::internal::Slice< true > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_DataFrameRow takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__SliceT_true_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_DataFrameRow" "', argument " "1"" of type '" "ampl::internal::Slice< true > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::Slice< true > * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RowIterator_equals(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::Slice< true >::iterator *arg1 = (ampl::internal::Slice< true >::iterator *) 0 ;
  ampl::internal::Slice< true >::iterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:RowIterator_equals",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__SliceT_true_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RowIterator_equals" "', argument " "1"" of type '" "ampl::internal::Slice< true >::iterator const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::Slice< true >::iterator * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__internal__SliceT_true_t__iterator,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "RowIterator_equals" "', argument " "2"" of type '" "ampl::internal::Slice< true >::iterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "RowIterator_equals" "', argument " "2"" of type '" "ampl::internal::Slice< true >::iterator const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::internal::Slice< true >::iterator * >(argp2);
  {
    try {
      result = (bool)((ampl::internal::Slice< true >::iterator const *)arg1)->operator ==((ampl::internal::Slice< true >::iterator const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RowIterator_differs(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::Slice< true >::iterator *arg1 = (ampl::internal::Slice< true >::iterator *) 0 ;
  ampl::internal::Slice< true >::iterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:RowIterator_differs",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__SliceT_true_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RowIterator_differs" "', argument " "1"" of type '" "ampl::internal::Slice< true >::iterator const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::Slice< true >::iterator * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__internal__SliceT_true_t__iterator,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "RowIterator_differs" "', argument " "2"" of type '" "ampl::internal::Slice< true >::iterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "RowIterator_differs" "', argument " "2"" of type '" "ampl::internal::Slice< true >::iterator const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::internal::Slice< true >::iterator * >(argp2);
  {
    try {
      result = (bool)((ampl::internal::Slice< true >::iterator const *)arg1)->operator !=((ampl::internal::Slice< true >::iterator const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RowIterator___ref__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::Slice< true >::iterator *arg1 = (ampl::internal::Slice< true >::iterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< ampl::VariantRef > result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "RowIterator___ref__ takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__SliceT_true_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RowIterator___ref__" "', argument " "1"" of type '" "ampl::internal::Slice< true >::iterator const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::Slice< true >::iterator * >(argp1);
  {
    try {
      result = ((ampl::internal::Slice< true >::iterator const *)arg1)->operator *();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::VariantRef(static_cast< const ampl::VariantRef& >(result))), SWIGTYPE_p_ampl__VariantRef, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGPY_BINARYFUNC_CLOSURE(_wrap_RowIterator___ref__)

SWIGINTERN PyObject *_wrap_RowIterator_clone(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::Slice< true >::iterator *arg1 = (ampl::internal::Slice< true >::iterator *) 0 ;
  ampl::internal::Slice< true >::iterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  ampl::internal::Slice< true >::iterator *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:RowIterator_clone",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__SliceT_true_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RowIterator_clone" "', argument " "1"" of type '" "ampl::internal::Slice< true >::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::Slice< true >::iterator * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__internal__SliceT_true_t__iterator,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "RowIterator_clone" "', argument " "2"" of type '" "ampl::internal::Slice< true >::iterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "RowIterator_clone" "', argument " "2"" of type '" "ampl::internal::Slice< true >::iterator const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::internal::Slice< true >::iterator * >(argp2);
  {
    try {
      result = (ampl::internal::Slice< true >::iterator *) &(arg1)->operator =((ampl::internal::Slice< true >::iterator const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__internal__SliceT_true_t__iterator, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RowIterator_postIncrement(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::Slice< true >::iterator *arg1 = (ampl::internal::Slice< true >::iterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ampl::internal::Slice< true >::iterator *result = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "RowIterator_postIncrement takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__SliceT_true_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RowIterator_postIncrement" "', argument " "1"" of type '" "ampl::internal::Slice< true >::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::Slice< true >::iterator * >(argp1);
  {
    try {
      result = (ampl::internal::Slice< true >::iterator *) &(arg1)->operator ++();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__internal__SliceT_true_t__iterator, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RowIterator_postIncrementBy(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::Slice< true >::iterator *arg1 = (ampl::internal::Slice< true >::iterator *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj1 = 0 ;
  SwigValueWrapper< ampl::internal::Slice< true >::iterator > result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:RowIterator_postIncrementBy",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__SliceT_true_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RowIterator_postIncrementBy" "', argument " "1"" of type '" "ampl::internal::Slice< true >::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::Slice< true >::iterator * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "RowIterator_postIncrementBy" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  {
    try {
      result = (arg1)->operator ++(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::internal::Slice< true >::iterator(static_cast< const ampl::internal::Slice< true >::iterator& >(result))), SWIGTYPE_p_ampl__internal__SliceT_true_t__iterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_RowIterator(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::Slice< true >::iterator *arg1 = (ampl::internal::Slice< true >::iterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_RowIterator takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__SliceT_true_t__iterator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_RowIterator" "', argument " "1"" of type '" "ampl::internal::Slice< true >::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::Slice< true >::iterator * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Instance_toString(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Instance *arg1 = (ampl::Instance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Instance_toString takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Instance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Instance_toString" "', argument " "1"" of type '" "ampl::Instance const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Instance * >(argp1);
  {
    try {
      result = ((ampl::Instance const *)arg1)->toString();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Instance_name(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Instance *arg1 = (ampl::Instance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Instance_name takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Instance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Instance_name" "', argument " "1"" of type '" "ampl::Instance const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Instance * >(argp1);
  {
    try {
      result = ((ampl::Instance const *)arg1)->name();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Instance_entity(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Instance *arg1 = (ampl::Instance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< ampl::Entity > result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Instance_entity takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Instance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Instance_entity" "', argument " "1"" of type '" "ampl::Instance const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Instance * >(argp1);
  {
    try {
      result = ((ampl::Instance const *)arg1)->entity();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::Entity(static_cast< const ampl::Entity& >(result))), SWIGTYPE_p_ampl__Entity, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Instance_key(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Instance *arg1 = (ampl::Instance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ampl::Tuple result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Instance_key takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Instance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Instance_key" "', argument " "1"" of type '" "ampl::Instance const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Instance * >(argp1);
  {
    try {
      result = ((ampl::Instance const *)arg1)->key();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::Tuple(static_cast< const ampl::Tuple& >(result))), SWIGTYPE_p_ampl__Tuple, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_Instance(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Instance *arg1 = (ampl::Instance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_Instance takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Instance, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Instance" "', argument " "1"" of type '" "ampl::Instance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Instance * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SetInstance_size(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::SetInstance *arg1 = (ampl::SetInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::size_t result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "SetInstance_size takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__SetInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetInstance_size" "', argument " "1"" of type '" "ampl::SetInstance const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::SetInstance * >(argp1);
  {
    try {
      result = (std::size_t)((ampl::SetInstance const *)arg1)->size();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SetInstance_contains(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::SetInstance *arg1 = (ampl::SetInstance *) 0 ;
  SwigValueWrapper< ampl::TupleRef > arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SetInstance_contains",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__SetInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetInstance_contains" "', argument " "1"" of type '" "ampl::SetInstance const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::SetInstance * >(argp1);
  {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__TupleRef,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetInstance_contains" "', argument " "2"" of type '" "ampl::TupleRef""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetInstance_contains" "', argument " "2"" of type '" "ampl::TupleRef""'");
    } else {
      ampl::TupleRef * temp = reinterpret_cast< ampl::TupleRef * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)((ampl::SetInstance const *)arg1)->contains(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SetInstance_getValues(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::SetInstance *arg1 = (ampl::SetInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< ampl::DataFrame > result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "SetInstance_getValues takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__SetInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetInstance_getValues" "', argument " "1"" of type '" "ampl::SetInstance const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::SetInstance * >(argp1);
  {
    try {
      result = ((ampl::SetInstance const *)arg1)->getValues();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::DataFrame(static_cast< const ampl::DataFrame& >(result))), SWIGTYPE_p_ampl__DataFrame, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SetInstance_setValuesDf(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::SetInstance *arg1 = (ampl::SetInstance *) 0 ;
  SwigValueWrapper< ampl::DataFrame > arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SetInstance_setValuesDf",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__SetInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetInstance_setValuesDf" "', argument " "1"" of type '" "ampl::SetInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::SetInstance * >(argp1);
  {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__DataFrame,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetInstance_setValuesDf" "', argument " "2"" of type '" "ampl::DataFrame""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetInstance_setValuesDf" "', argument " "2"" of type '" "ampl::DataFrame""'");
    } else {
      ampl::DataFrame * temp = reinterpret_cast< ampl::DataFrame * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      (arg1)->setValues(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SetInstance_members(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::SetInstance *arg1 = (ampl::SetInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< ampl::SetInstance::MemberRange > result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "SetInstance_members takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__SetInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetInstance_members" "', argument " "1"" of type '" "ampl::SetInstance const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::SetInstance * >(argp1);
  {
    try {
      result = ((ampl::SetInstance const *)arg1)->members();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::SetInstance::MemberRange(static_cast< const ampl::SetInstance::MemberRange& >(result))), SWIGTYPE_p_ampl__SetInstance__MemberRange, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SetInstance_Contains(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::SetInstance *arg1 = (ampl::SetInstance *) 0 ;
  ampl::Tuple arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SetInstance_Contains",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__SetInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetInstance_Contains" "', argument " "1"" of type '" "ampl::SetInstance const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::SetInstance * >(argp1);
  {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__Tuple,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetInstance_Contains" "', argument " "2"" of type '" "ampl::Tuple""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetInstance_Contains" "', argument " "2"" of type '" "ampl::Tuple""'");
    } else {
      ampl::Tuple * temp = reinterpret_cast< ampl::Tuple * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)ampl_SetInstance_Contains((ampl::SetInstance const *)arg1,arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SetInstance_setValues(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::SetInstance *arg1 = (ampl::SetInstance *) 0 ;
  TupleArray *arg2 = 0 ;
  std::size_t arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SetInstance_setValues",&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__SetInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetInstance_setValues" "', argument " "1"" of type '" "ampl::SetInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::SetInstance * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_TupleArray,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetInstance_setValues" "', argument " "2"" of type '" "TupleArray &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetInstance_setValues" "', argument " "2"" of type '" "TupleArray &""'"); 
  }
  arg2 = reinterpret_cast< TupleArray * >(argp2);
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SetInstance_setValues" "', argument " "3"" of type '" "std::size_t""'");
  } 
  arg3 = static_cast< std::size_t >(val3);
  {
    try {
      ampl_SetInstance_setValues(arg1,*arg2,arg3);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SetInstance_setValuesDbl(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::SetInstance *arg1 = (ampl::SetInstance *) 0 ;
  double *arg2 = (double *) 0 ;
  std::size_t arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SetInstance_setValuesDbl",&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__SetInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetInstance_setValuesDbl" "', argument " "1"" of type '" "ampl::SetInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::SetInstance * >(argp1);
  {
    /* Check if is a list */
    if (PyList_Check(obj1)) {
      int size = PyList_Size(obj1);
      int i = 0;
      arg2 = (double *)malloc(size * sizeof(double));
      for (i = 0; i < size; i++) {
        PyObject *o = PyList_GetItem(obj1,i);
        if (PyFloat_Check(o))
        arg2[i] = PyFloat_AsDouble(PyList_GetItem(obj1,i));
        else {
          PyErr_SetString(PyExc_TypeError, "The input list must contain floating point numbers");
          free(arg2);
          return NULL;
        }
      }
    }
    else {
      PyErr_SetString(PyExc_TypeError,"The input is not a list");
      return NULL;
    }
  }
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SetInstance_setValuesDbl" "', argument " "3"" of type '" "std::size_t""'");
  } 
  arg3 = static_cast< std::size_t >(val3);
  {
    try {
      ampl_SetInstance_setValues(arg1,arg2,arg3);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  {
    free((double *)arg2);
  }
  return resultobj;
fail:
  {
    free((double *)arg2);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_SetInstance_setValuesStr(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::SetInstance *arg1 = (ampl::SetInstance *) 0 ;
  char **arg2 ;
  std::size_t arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  {
    arg2 = NULL;
  }
  if (!PyArg_ParseTuple(args,(char *)"OO:SetInstance_setValuesStr",&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__SetInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetInstance_setValuesStr" "', argument " "1"" of type '" "ampl::SetInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::SetInstance * >(argp1);
  {
    /* Check if is a list */
    if (PyList_Check(obj1)) {
      int size = PyList_Size(obj1);
      int i = 0;
      arg2 = (char **)malloc((size + 1) * sizeof(char *));
      for (i = 0; i < size; i++) {
        PyObject *obj = PyList_GetItem(obj1,i);
        if (_PyString_Check(obj)) {
          arg2[i] = _PyString_AsString(PyList_GetItem(obj1,i));
        } else {
          PyErr_SetString(PyExc_TypeError,"list must contain strings");
          free(arg2);
          return NULL;
        }
      }
      arg2[i] = 0;
    }
    else {
      PyErr_SetString(PyExc_TypeError,"not a list");
      return NULL;
    }
  }
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SetInstance_setValuesStr" "', argument " "3"" of type '" "std::size_t""'");
  } 
  arg3 = static_cast< std::size_t >(val3);
  {
    try {
      ampl_SetInstance_setValues(arg1,(char const *(*))arg2,arg3);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  {
    free((char *)arg2);
  }
  return resultobj;
fail:
  {
    free((char *)arg2);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_SetInstance(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::SetInstance *arg1 = (ampl::SetInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_SetInstance takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__SetInstance, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SetInstance" "', argument " "1"" of type '" "ampl::SetInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::SetInstance * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN int _wrap_new_MemberRange(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::SetInstance *arg1 = (ampl::internal::SetInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj1 = 0 ;
  ampl::SetInstance::MemberRange *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_MemberRange",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj1, &argp1,SWIGTYPE_p_ampl__SetInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_MemberRange" "', argument " "1"" of type '" "ampl::internal::SetInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::SetInstance * >(argp1);
  {
    try {
      result = (ampl::SetInstance::MemberRange *)new ampl::SetInstance::MemberRange(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__SetInstance__MemberRange, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN PyObject *_wrap_MemberRange_begin(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::SetInstance::MemberRange *arg1 = (ampl::SetInstance::MemberRange *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< ampl::SetInstance::MemberRange::iterator > result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "MemberRange_begin takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__SetInstance__MemberRange, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MemberRange_begin" "', argument " "1"" of type '" "ampl::SetInstance::MemberRange const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::SetInstance::MemberRange * >(argp1);
  {
    try {
      result = ((ampl::SetInstance::MemberRange const *)arg1)->begin();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::SetInstance::MemberRange::iterator(static_cast< const ampl::SetInstance::MemberRange::iterator& >(result))), SWIGTYPE_p_ampl__SetInstance__MemberRange__iterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MemberRange_end(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::SetInstance::MemberRange *arg1 = (ampl::SetInstance::MemberRange *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< ampl::SetInstance::MemberRange::iterator > result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "MemberRange_end takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__SetInstance__MemberRange, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MemberRange_end" "', argument " "1"" of type '" "ampl::SetInstance::MemberRange const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::SetInstance::MemberRange * >(argp1);
  {
    try {
      result = ((ampl::SetInstance::MemberRange const *)arg1)->end();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::SetInstance::MemberRange::iterator(static_cast< const ampl::SetInstance::MemberRange::iterator& >(result))), SWIGTYPE_p_ampl__SetInstance__MemberRange__iterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_MemberRange(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::SetInstance::MemberRange *arg1 = (ampl::SetInstance::MemberRange *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_MemberRange takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__SetInstance__MemberRange, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_MemberRange" "', argument " "1"" of type '" "ampl::SetInstance::MemberRange *""'"); 
  }
  arg1 = reinterpret_cast< ampl::SetInstance::MemberRange * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_iterator___ref__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::SetInstance::MemberRange::iterator *arg1 = (ampl::SetInstance::MemberRange::iterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< ampl::TupleRef > result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "iterator___ref__ takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__SetInstance__MemberRange__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "iterator___ref__" "', argument " "1"" of type '" "ampl::SetInstance::MemberRange::iterator const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::SetInstance::MemberRange::iterator * >(argp1);
  {
    try {
      result = ((ampl::SetInstance::MemberRange::iterator const *)arg1)->operator *();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::TupleRef(static_cast< const ampl::TupleRef& >(result))), SWIGTYPE_p_ampl__TupleRef, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGPY_BINARYFUNC_CLOSURE(_wrap_iterator___ref__)

SWIGINTERN PyObject *_wrap_iterator_postIncrement(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::SetInstance::MemberRange::iterator *arg1 = (ampl::SetInstance::MemberRange::iterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ampl::SetInstance::MemberRange::iterator *result = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "iterator_postIncrement takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__SetInstance__MemberRange__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "iterator_postIncrement" "', argument " "1"" of type '" "ampl::SetInstance::MemberRange::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::SetInstance::MemberRange::iterator * >(argp1);
  {
    try {
      result = (ampl::SetInstance::MemberRange::iterator *) &(arg1)->operator ++();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__SetInstance__MemberRange__iterator, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_iterator_postIncrementBy(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::SetInstance::MemberRange::iterator *arg1 = (ampl::SetInstance::MemberRange::iterator *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj1 = 0 ;
  SwigValueWrapper< ampl::SetInstance::MemberRange::iterator > result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:iterator_postIncrementBy",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__SetInstance__MemberRange__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "iterator_postIncrementBy" "', argument " "1"" of type '" "ampl::SetInstance::MemberRange::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::SetInstance::MemberRange::iterator * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "iterator_postIncrementBy" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  {
    try {
      result = (arg1)->operator ++(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::SetInstance::MemberRange::iterator(static_cast< const ampl::SetInstance::MemberRange::iterator& >(result))), SWIGTYPE_p_ampl__SetInstance__MemberRange__iterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_iterator_equals(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::SetInstance::MemberRange::iterator *arg1 = (ampl::SetInstance::MemberRange::iterator *) 0 ;
  ampl::SetInstance::MemberRange::iterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:iterator_equals",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__SetInstance__MemberRange__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "iterator_equals" "', argument " "1"" of type '" "ampl::SetInstance::MemberRange::iterator const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::SetInstance::MemberRange::iterator * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__SetInstance__MemberRange__iterator,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "iterator_equals" "', argument " "2"" of type '" "ampl::SetInstance::MemberRange::iterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "iterator_equals" "', argument " "2"" of type '" "ampl::SetInstance::MemberRange::iterator const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::SetInstance::MemberRange::iterator * >(argp2);
  {
    try {
      result = (bool)((ampl::SetInstance::MemberRange::iterator const *)arg1)->operator ==((ampl::SetInstance::MemberRange::iterator const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_iterator_differs(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::SetInstance::MemberRange::iterator *arg1 = (ampl::SetInstance::MemberRange::iterator *) 0 ;
  ampl::SetInstance::MemberRange::iterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:iterator_differs",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__SetInstance__MemberRange__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "iterator_differs" "', argument " "1"" of type '" "ampl::SetInstance::MemberRange::iterator const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::SetInstance::MemberRange::iterator * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__SetInstance__MemberRange__iterator,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "iterator_differs" "', argument " "2"" of type '" "ampl::SetInstance::MemberRange::iterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "iterator_differs" "', argument " "2"" of type '" "ampl::SetInstance::MemberRange::iterator const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::SetInstance::MemberRange::iterator * >(argp2);
  {
    try {
      result = (bool)((ampl::SetInstance::MemberRange::iterator const *)arg1)->operator !=((ampl::SetInstance::MemberRange::iterator const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_iterator(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::SetInstance::MemberRange::iterator *arg1 = (ampl::SetInstance::MemberRange::iterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_iterator takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__SetInstance__MemberRange__iterator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_iterator" "', argument " "1"" of type '" "ampl::SetInstance::MemberRange::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::SetInstance::MemberRange::iterator * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ObjectiveInstance_value(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::ObjectiveInstance *arg1 = (ampl::ObjectiveInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "ObjectiveInstance_value takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__ObjectiveInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ObjectiveInstance_value" "', argument " "1"" of type '" "ampl::ObjectiveInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::ObjectiveInstance * >(argp1);
  {
    try {
      result = (double)(arg1)->value();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ObjectiveInstance_astatus(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::ObjectiveInstance *arg1 = (ampl::ObjectiveInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "ObjectiveInstance_astatus takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__ObjectiveInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ObjectiveInstance_astatus" "', argument " "1"" of type '" "ampl::ObjectiveInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::ObjectiveInstance * >(argp1);
  {
    try {
      result = (arg1)->astatus();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ObjectiveInstance_sstatus(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::ObjectiveInstance *arg1 = (ampl::ObjectiveInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "ObjectiveInstance_sstatus takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__ObjectiveInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ObjectiveInstance_sstatus" "', argument " "1"" of type '" "ampl::ObjectiveInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::ObjectiveInstance * >(argp1);
  {
    try {
      result = (arg1)->sstatus();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ObjectiveInstance_exitcode(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::ObjectiveInstance *arg1 = (ampl::ObjectiveInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "ObjectiveInstance_exitcode takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__ObjectiveInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ObjectiveInstance_exitcode" "', argument " "1"" of type '" "ampl::ObjectiveInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::ObjectiveInstance * >(argp1);
  {
    try {
      result = (int)(arg1)->exitcode();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ObjectiveInstance_message(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::ObjectiveInstance *arg1 = (ampl::ObjectiveInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "ObjectiveInstance_message takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__ObjectiveInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ObjectiveInstance_message" "', argument " "1"" of type '" "ampl::ObjectiveInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::ObjectiveInstance * >(argp1);
  {
    try {
      result = (arg1)->message();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ObjectiveInstance_result(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::ObjectiveInstance *arg1 = (ampl::ObjectiveInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "ObjectiveInstance_result takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__ObjectiveInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ObjectiveInstance_result" "', argument " "1"" of type '" "ampl::ObjectiveInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::ObjectiveInstance * >(argp1);
  {
    try {
      result = (arg1)->result();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ObjectiveInstance_drop(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::ObjectiveInstance *arg1 = (ampl::ObjectiveInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "ObjectiveInstance_drop takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__ObjectiveInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ObjectiveInstance_drop" "', argument " "1"" of type '" "ampl::ObjectiveInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::ObjectiveInstance * >(argp1);
  {
    try {
      (arg1)->drop();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ObjectiveInstance_restore(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::ObjectiveInstance *arg1 = (ampl::ObjectiveInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "ObjectiveInstance_restore takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__ObjectiveInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ObjectiveInstance_restore" "', argument " "1"" of type '" "ampl::ObjectiveInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::ObjectiveInstance * >(argp1);
  {
    try {
      (arg1)->restore();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ObjectiveInstance_minimization(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::ObjectiveInstance *arg1 = (ampl::ObjectiveInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "ObjectiveInstance_minimization takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__ObjectiveInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ObjectiveInstance_minimization" "', argument " "1"" of type '" "ampl::ObjectiveInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::ObjectiveInstance * >(argp1);
  {
    try {
      result = (bool)(arg1)->minimization();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ObjectiveInstance(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::ObjectiveInstance *arg1 = (ampl::ObjectiveInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_ObjectiveInstance takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__ObjectiveInstance, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ObjectiveInstance" "', argument " "1"" of type '" "ampl::ObjectiveInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::ObjectiveInstance * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariableInstance_fix__SWIG_0(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::VariableInstance *arg1 = (ampl::VariableInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "VariableInstance_fix takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__VariableInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariableInstance_fix" "', argument " "1"" of type '" "ampl::VariableInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::VariableInstance * >(argp1);
  {
    try {
      (arg1)->fix();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariableInstance_fix__SWIG_1(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::VariableInstance *arg1 = (ampl::VariableInstance *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:VariableInstance_fix",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__VariableInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariableInstance_fix" "', argument " "1"" of type '" "ampl::VariableInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::VariableInstance * >(argp1);
  ecode2 = SWIG_AsVal_double(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VariableInstance_fix" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->fix(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariableInstance_fix(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  Py_ssize_t ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = args ? PyObject_Length(args) : 0;
  argv[0] = self;
  for (ii = 0; (ii < 1) && (ii < argc); ii++) {
    argv[ii + 1] = PyTuple_GET_ITEM(args,ii);
  }
  argc++;
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__VariableInstance, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_VariableInstance_fix__SWIG_0(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__VariableInstance, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_VariableInstance_fix__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'VariableInstance_fix'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    ampl::VariableInstance::fix()\n"
    "    ampl::VariableInstance::fix(double)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_VariableInstance_unfix(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::VariableInstance *arg1 = (ampl::VariableInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "VariableInstance_unfix takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__VariableInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariableInstance_unfix" "', argument " "1"" of type '" "ampl::VariableInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::VariableInstance * >(argp1);
  {
    try {
      (arg1)->unfix();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariableInstance_setValue(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::VariableInstance *arg1 = (ampl::VariableInstance *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:VariableInstance_setValue",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__VariableInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariableInstance_setValue" "', argument " "1"" of type '" "ampl::VariableInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::VariableInstance * >(argp1);
  ecode2 = SWIG_AsVal_double(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VariableInstance_setValue" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->setValue(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariableInstance_value(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::VariableInstance *arg1 = (ampl::VariableInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "VariableInstance_value takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__VariableInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariableInstance_value" "', argument " "1"" of type '" "ampl::VariableInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::VariableInstance * >(argp1);
  {
    try {
      result = (double)(arg1)->value();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariableInstance_defeqn(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::VariableInstance *arg1 = (ampl::VariableInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "VariableInstance_defeqn takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__VariableInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariableInstance_defeqn" "', argument " "1"" of type '" "ampl::VariableInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::VariableInstance * >(argp1);
  {
    try {
      result = (int)(arg1)->defeqn();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariableInstance_dual(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::VariableInstance *arg1 = (ampl::VariableInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "VariableInstance_dual takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__VariableInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariableInstance_dual" "', argument " "1"" of type '" "ampl::VariableInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::VariableInstance * >(argp1);
  {
    try {
      result = (double)(arg1)->dual();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariableInstance_init(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::VariableInstance *arg1 = (ampl::VariableInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "VariableInstance_init takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__VariableInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariableInstance_init" "', argument " "1"" of type '" "ampl::VariableInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::VariableInstance * >(argp1);
  {
    try {
      result = (double)(arg1)->init();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariableInstance_init0(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::VariableInstance *arg1 = (ampl::VariableInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "VariableInstance_init0 takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__VariableInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariableInstance_init0" "', argument " "1"" of type '" "ampl::VariableInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::VariableInstance * >(argp1);
  {
    try {
      result = (double)(arg1)->init0();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariableInstance_lb(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::VariableInstance *arg1 = (ampl::VariableInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "VariableInstance_lb takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__VariableInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariableInstance_lb" "', argument " "1"" of type '" "ampl::VariableInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::VariableInstance * >(argp1);
  {
    try {
      result = (double)(arg1)->lb();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariableInstance_ub(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::VariableInstance *arg1 = (ampl::VariableInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "VariableInstance_ub takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__VariableInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariableInstance_ub" "', argument " "1"" of type '" "ampl::VariableInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::VariableInstance * >(argp1);
  {
    try {
      result = (double)(arg1)->ub();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariableInstance_lb0(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::VariableInstance *arg1 = (ampl::VariableInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "VariableInstance_lb0 takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__VariableInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariableInstance_lb0" "', argument " "1"" of type '" "ampl::VariableInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::VariableInstance * >(argp1);
  {
    try {
      result = (double)(arg1)->lb0();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariableInstance_ub0(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::VariableInstance *arg1 = (ampl::VariableInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "VariableInstance_ub0 takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__VariableInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariableInstance_ub0" "', argument " "1"" of type '" "ampl::VariableInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::VariableInstance * >(argp1);
  {
    try {
      result = (double)(arg1)->ub0();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariableInstance_lb1(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::VariableInstance *arg1 = (ampl::VariableInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "VariableInstance_lb1 takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__VariableInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariableInstance_lb1" "', argument " "1"" of type '" "ampl::VariableInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::VariableInstance * >(argp1);
  {
    try {
      result = (double)(arg1)->lb1();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariableInstance_ub1(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::VariableInstance *arg1 = (ampl::VariableInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "VariableInstance_ub1 takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__VariableInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariableInstance_ub1" "', argument " "1"" of type '" "ampl::VariableInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::VariableInstance * >(argp1);
  {
    try {
      result = (double)(arg1)->ub1();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariableInstance_lb2(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::VariableInstance *arg1 = (ampl::VariableInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "VariableInstance_lb2 takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__VariableInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariableInstance_lb2" "', argument " "1"" of type '" "ampl::VariableInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::VariableInstance * >(argp1);
  {
    try {
      result = (double)(arg1)->lb2();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariableInstance_ub2(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::VariableInstance *arg1 = (ampl::VariableInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "VariableInstance_ub2 takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__VariableInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariableInstance_ub2" "', argument " "1"" of type '" "ampl::VariableInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::VariableInstance * >(argp1);
  {
    try {
      result = (double)(arg1)->ub2();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariableInstance_lrc(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::VariableInstance *arg1 = (ampl::VariableInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "VariableInstance_lrc takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__VariableInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariableInstance_lrc" "', argument " "1"" of type '" "ampl::VariableInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::VariableInstance * >(argp1);
  {
    try {
      result = (double)(arg1)->lrc();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariableInstance_urc(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::VariableInstance *arg1 = (ampl::VariableInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "VariableInstance_urc takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__VariableInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariableInstance_urc" "', argument " "1"" of type '" "ampl::VariableInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::VariableInstance * >(argp1);
  {
    try {
      result = (double)(arg1)->urc();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariableInstance_lslack(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::VariableInstance *arg1 = (ampl::VariableInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "VariableInstance_lslack takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__VariableInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariableInstance_lslack" "', argument " "1"" of type '" "ampl::VariableInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::VariableInstance * >(argp1);
  {
    try {
      result = (double)(arg1)->lslack();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariableInstance_uslack(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::VariableInstance *arg1 = (ampl::VariableInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "VariableInstance_uslack takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__VariableInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariableInstance_uslack" "', argument " "1"" of type '" "ampl::VariableInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::VariableInstance * >(argp1);
  {
    try {
      result = (double)(arg1)->uslack();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariableInstance_rc(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::VariableInstance *arg1 = (ampl::VariableInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "VariableInstance_rc takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__VariableInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariableInstance_rc" "', argument " "1"" of type '" "ampl::VariableInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::VariableInstance * >(argp1);
  {
    try {
      result = (double)(arg1)->rc();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariableInstance_slack(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::VariableInstance *arg1 = (ampl::VariableInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "VariableInstance_slack takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__VariableInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariableInstance_slack" "', argument " "1"" of type '" "ampl::VariableInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::VariableInstance * >(argp1);
  {
    try {
      result = (double)(arg1)->slack();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariableInstance_astatus(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::VariableInstance *arg1 = (ampl::VariableInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "VariableInstance_astatus takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__VariableInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariableInstance_astatus" "', argument " "1"" of type '" "ampl::VariableInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::VariableInstance * >(argp1);
  {
    try {
      result = (arg1)->astatus();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariableInstance_sstatus(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::VariableInstance *arg1 = (ampl::VariableInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "VariableInstance_sstatus takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__VariableInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariableInstance_sstatus" "', argument " "1"" of type '" "ampl::VariableInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::VariableInstance * >(argp1);
  {
    try {
      result = (arg1)->sstatus();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariableInstance_status(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::VariableInstance *arg1 = (ampl::VariableInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "VariableInstance_status takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__VariableInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariableInstance_status" "', argument " "1"" of type '" "ampl::VariableInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::VariableInstance * >(argp1);
  {
    try {
      result = (arg1)->status();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_VariableInstance(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::VariableInstance *arg1 = (ampl::VariableInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_VariableInstance takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__VariableInstance, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_VariableInstance" "', argument " "1"" of type '" "ampl::VariableInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::VariableInstance * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ConstraintInstance_drop(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::ConstraintInstance *arg1 = (ampl::ConstraintInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "ConstraintInstance_drop takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__ConstraintInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConstraintInstance_drop" "', argument " "1"" of type '" "ampl::ConstraintInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::ConstraintInstance * >(argp1);
  {
    try {
      (arg1)->drop();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ConstraintInstance_restore(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::ConstraintInstance *arg1 = (ampl::ConstraintInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "ConstraintInstance_restore takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__ConstraintInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConstraintInstance_restore" "', argument " "1"" of type '" "ampl::ConstraintInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::ConstraintInstance * >(argp1);
  {
    try {
      (arg1)->restore();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ConstraintInstance_body(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::ConstraintInstance *arg1 = (ampl::ConstraintInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "ConstraintInstance_body takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__ConstraintInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConstraintInstance_body" "', argument " "1"" of type '" "ampl::ConstraintInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::ConstraintInstance * >(argp1);
  {
    try {
      result = (double)(arg1)->body();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ConstraintInstance_astatus(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::ConstraintInstance *arg1 = (ampl::ConstraintInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "ConstraintInstance_astatus takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__ConstraintInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConstraintInstance_astatus" "', argument " "1"" of type '" "ampl::ConstraintInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::ConstraintInstance * >(argp1);
  {
    try {
      result = (arg1)->astatus();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ConstraintInstance_defvar(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::ConstraintInstance *arg1 = (ampl::ConstraintInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "ConstraintInstance_defvar takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__ConstraintInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConstraintInstance_defvar" "', argument " "1"" of type '" "ampl::ConstraintInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::ConstraintInstance * >(argp1);
  {
    try {
      result = (int)(arg1)->defvar();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ConstraintInstance_dinit(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::ConstraintInstance *arg1 = (ampl::ConstraintInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "ConstraintInstance_dinit takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__ConstraintInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConstraintInstance_dinit" "', argument " "1"" of type '" "ampl::ConstraintInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::ConstraintInstance * >(argp1);
  {
    try {
      result = (double)(arg1)->dinit();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ConstraintInstance_dinit0(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::ConstraintInstance *arg1 = (ampl::ConstraintInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "ConstraintInstance_dinit0 takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__ConstraintInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConstraintInstance_dinit0" "', argument " "1"" of type '" "ampl::ConstraintInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::ConstraintInstance * >(argp1);
  {
    try {
      result = (double)(arg1)->dinit0();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ConstraintInstance_dual(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::ConstraintInstance *arg1 = (ampl::ConstraintInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "ConstraintInstance_dual takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__ConstraintInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConstraintInstance_dual" "', argument " "1"" of type '" "ampl::ConstraintInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::ConstraintInstance * >(argp1);
  {
    try {
      result = (double)(arg1)->dual();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ConstraintInstance_lb(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::ConstraintInstance *arg1 = (ampl::ConstraintInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "ConstraintInstance_lb takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__ConstraintInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConstraintInstance_lb" "', argument " "1"" of type '" "ampl::ConstraintInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::ConstraintInstance * >(argp1);
  {
    try {
      result = (double)(arg1)->lb();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ConstraintInstance_ub(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::ConstraintInstance *arg1 = (ampl::ConstraintInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "ConstraintInstance_ub takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__ConstraintInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConstraintInstance_ub" "', argument " "1"" of type '" "ampl::ConstraintInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::ConstraintInstance * >(argp1);
  {
    try {
      result = (double)(arg1)->ub();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ConstraintInstance_lbs(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::ConstraintInstance *arg1 = (ampl::ConstraintInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "ConstraintInstance_lbs takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__ConstraintInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConstraintInstance_lbs" "', argument " "1"" of type '" "ampl::ConstraintInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::ConstraintInstance * >(argp1);
  {
    try {
      result = (double)(arg1)->lbs();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ConstraintInstance_ubs(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::ConstraintInstance *arg1 = (ampl::ConstraintInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "ConstraintInstance_ubs takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__ConstraintInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConstraintInstance_ubs" "', argument " "1"" of type '" "ampl::ConstraintInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::ConstraintInstance * >(argp1);
  {
    try {
      result = (double)(arg1)->ubs();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ConstraintInstance_ldual(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::ConstraintInstance *arg1 = (ampl::ConstraintInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "ConstraintInstance_ldual takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__ConstraintInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConstraintInstance_ldual" "', argument " "1"" of type '" "ampl::ConstraintInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::ConstraintInstance * >(argp1);
  {
    try {
      result = (double)(arg1)->ldual();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ConstraintInstance_udual(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::ConstraintInstance *arg1 = (ampl::ConstraintInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "ConstraintInstance_udual takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__ConstraintInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConstraintInstance_udual" "', argument " "1"" of type '" "ampl::ConstraintInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::ConstraintInstance * >(argp1);
  {
    try {
      result = (double)(arg1)->udual();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ConstraintInstance_lslack(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::ConstraintInstance *arg1 = (ampl::ConstraintInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "ConstraintInstance_lslack takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__ConstraintInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConstraintInstance_lslack" "', argument " "1"" of type '" "ampl::ConstraintInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::ConstraintInstance * >(argp1);
  {
    try {
      result = (double)(arg1)->lslack();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ConstraintInstance_uslack(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::ConstraintInstance *arg1 = (ampl::ConstraintInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "ConstraintInstance_uslack takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__ConstraintInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConstraintInstance_uslack" "', argument " "1"" of type '" "ampl::ConstraintInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::ConstraintInstance * >(argp1);
  {
    try {
      result = (double)(arg1)->uslack();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ConstraintInstance_slack(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::ConstraintInstance *arg1 = (ampl::ConstraintInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "ConstraintInstance_slack takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__ConstraintInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConstraintInstance_slack" "', argument " "1"" of type '" "ampl::ConstraintInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::ConstraintInstance * >(argp1);
  {
    try {
      result = (double)(arg1)->slack();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ConstraintInstance_sstatus(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::ConstraintInstance *arg1 = (ampl::ConstraintInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "ConstraintInstance_sstatus takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__ConstraintInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConstraintInstance_sstatus" "', argument " "1"" of type '" "ampl::ConstraintInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::ConstraintInstance * >(argp1);
  {
    try {
      result = (arg1)->sstatus();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ConstraintInstance_status(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::ConstraintInstance *arg1 = (ampl::ConstraintInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "ConstraintInstance_status takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__ConstraintInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConstraintInstance_status" "', argument " "1"" of type '" "ampl::ConstraintInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::ConstraintInstance * >(argp1);
  {
    try {
      result = (arg1)->status();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ConstraintInstance_setDual(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::ConstraintInstance *arg1 = (ampl::ConstraintInstance *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ConstraintInstance_setDual",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__ConstraintInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConstraintInstance_setDual" "', argument " "1"" of type '" "ampl::ConstraintInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::ConstraintInstance * >(argp1);
  ecode2 = SWIG_AsVal_double(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ConstraintInstance_setDual" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->setDual(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ConstraintInstance_val(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::ConstraintInstance *arg1 = (ampl::ConstraintInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "ConstraintInstance_val takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__ConstraintInstance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConstraintInstance_val" "', argument " "1"" of type '" "ampl::ConstraintInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::ConstraintInstance * >(argp1);
  {
    try {
      result = (double)(arg1)->val();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ConstraintInstance(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::ConstraintInstance *arg1 = (ampl::ConstraintInstance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_ConstraintInstance takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__ConstraintInstance, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ConstraintInstance" "', argument " "1"" of type '" "ampl::ConstraintInstance *""'"); 
  }
  arg1 = reinterpret_cast< ampl::ConstraintInstance * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityArray_el_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  EntityArray *arg1 = (EntityArray *) 0 ;
  ampl::Entity *arg2 = (ampl::Entity *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:EntityArray_el_set",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_EntityArray, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityArray_el_set" "', argument " "1"" of type '" "EntityArray *""'"); 
  }
  arg1 = reinterpret_cast< EntityArray * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_ampl__Entity, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "EntityArray_el_set" "', argument " "2"" of type '" "ampl::Entity *""'"); 
  }
  arg2 = reinterpret_cast< ampl::Entity * >(argp2);
  if (arg1) (arg1)->el = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityArray_el_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  EntityArray *arg1 = (EntityArray *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ampl::Entity *result = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "EntityArray_el_get takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_EntityArray, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityArray_el_get" "', argument " "1"" of type '" "EntityArray *""'"); 
  }
  arg1 = reinterpret_cast< EntityArray * >(argp1);
  result = (ampl::Entity *) ((arg1)->el);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__Entity, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN int _wrap_new_EntityArray(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  size_t arg1 ;
  size_t val1 ;
  int ecode1 = 0 ;
  PyObject * obj1 = 0 ;
  EntityArray *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_EntityArray",&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_size_t(obj1, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_EntityArray" "', argument " "1"" of type '" "size_t""'");
  } 
  arg1 = static_cast< size_t >(val1);
  {
    try {
      result = (EntityArray *)new_EntityArray(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_EntityArray, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN PyObject *_wrap_delete_EntityArray(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  EntityArray *arg1 = (EntityArray *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_EntityArray takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_EntityArray, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_EntityArray" "', argument " "1"" of type '" "EntityArray *""'"); 
  }
  arg1 = reinterpret_cast< EntityArray * >(argp1);
  {
    try {
      delete_EntityArray(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityArray___getitem__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  EntityArray *arg1 = (EntityArray *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj1 = 0 ;
  SwigValueWrapper< ampl::Entity > result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:EntityArray___getitem__",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_EntityArray, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityArray___getitem__" "', argument " "1"" of type '" "EntityArray *""'"); 
  }
  arg1 = reinterpret_cast< EntityArray * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "EntityArray___getitem__" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    try {
      result = EntityArray___getitem__(arg1,arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::Entity(static_cast< const ampl::Entity& >(result))), SWIGTYPE_p_ampl__Entity, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGPY_SSIZEARGFUNC_CLOSURE(_wrap_EntityArray___getitem__)

SWIGINTERN PyObject *_wrap_EntityArray___setitem__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  EntityArray *arg1 = (EntityArray *) 0 ;
  size_t arg2 ;
  SwigValueWrapper< ampl::Entity > arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:EntityArray___setitem__",&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_EntityArray, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityArray___setitem__" "', argument " "1"" of type '" "EntityArray *""'"); 
  }
  arg1 = reinterpret_cast< EntityArray * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "EntityArray___setitem__" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_ampl__Entity,  0  | 0);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "EntityArray___setitem__" "', argument " "3"" of type '" "ampl::Entity""'"); 
    }  
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "EntityArray___setitem__" "', argument " "3"" of type '" "ampl::Entity""'");
    } else {
      ampl::Entity * temp = reinterpret_cast< ampl::Entity * >(argp3);
      arg3 = *temp;
      if (SWIG_IsNewObj(res3)) delete temp;
    }
  }
  {
    try {
      EntityArray___setitem__(arg1,arg2,arg3);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_SSIZEOBJARGPROC_CLOSURE(_wrap_EntityArray___setitem__)

SWIGINTERN PyObject *_wrap_EntityArray_cast(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  EntityArray *arg1 = (EntityArray *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ampl::Entity *result = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "EntityArray_cast takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_EntityArray, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityArray_cast" "', argument " "1"" of type '" "EntityArray *""'"); 
  }
  arg1 = reinterpret_cast< EntityArray * >(argp1);
  {
    try {
      result = (ampl::Entity *)EntityArray_cast(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__Entity, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityArray_frompointer(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Entity *arg1 = (ampl::Entity *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  EntityArray *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:EntityArray_frompointer",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ampl__Entity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityArray_frompointer" "', argument " "1"" of type '" "ampl::Entity *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Entity * >(argp1);
  {
    try {
      result = (EntityArray *)EntityArray_frompointer(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_EntityArray, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Entity_toString(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Entity *arg1 = (ampl::Entity *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Entity_toString takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Entity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Entity_toString" "', argument " "1"" of type '" "ampl::Entity *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Entity * >(argp1);
  {
    try {
      result = (arg1)->toString();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Entity_name(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Entity *arg1 = (ampl::Entity *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Entity_name takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Entity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Entity_name" "', argument " "1"" of type '" "ampl::Entity *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Entity * >(argp1);
  {
    try {
      result = (arg1)->name();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Entity_indexarity(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Entity *arg1 = (ampl::Entity *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Entity_indexarity takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Entity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Entity_indexarity" "', argument " "1"" of type '" "ampl::Entity *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Entity * >(argp1);
  {
    try {
      result = (int)(arg1)->indexarity();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Entity_isScalar(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Entity *arg1 = (ampl::Entity *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Entity_isScalar takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Entity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Entity_isScalar" "', argument " "1"" of type '" "ampl::Entity *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Entity * >(argp1);
  {
    try {
      result = (bool)(arg1)->isScalar();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Entity_numInstances(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Entity *arg1 = (ampl::Entity *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Entity_numInstances takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Entity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Entity_numInstances" "', argument " "1"" of type '" "ampl::Entity *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Entity * >(argp1);
  {
    try {
      result = (int)(arg1)->numInstances();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Entity_getIndexingSets(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Entity *arg1 = (ampl::Entity *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ampl::StringArray result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Entity_getIndexingSets takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Entity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Entity_getIndexingSets" "', argument " "1"" of type '" "ampl::Entity const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Entity * >(argp1);
  {
    try {
      result = ((ampl::Entity const *)arg1)->getIndexingSets();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::StringArray(static_cast< const ampl::StringArray& >(result))), SWIGTYPE_p_ampl__StringArray, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Entity_getValues(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Entity *arg1 = (ampl::Entity *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< ampl::DataFrame > result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Entity_getValues takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Entity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Entity_getValues" "', argument " "1"" of type '" "ampl::Entity *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Entity * >(argp1);
  {
    try {
      result = (arg1)->getValues();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::DataFrame(static_cast< const ampl::DataFrame& >(result))), SWIGTYPE_p_ampl__DataFrame, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Entity_setValuesDf(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Entity *arg1 = (ampl::Entity *) 0 ;
  SwigValueWrapper< ampl::DataFrame > arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Entity_setValuesDf",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Entity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Entity_setValuesDf" "', argument " "1"" of type '" "ampl::Entity *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Entity * >(argp1);
  {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__DataFrame,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Entity_setValuesDf" "', argument " "2"" of type '" "ampl::DataFrame""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Entity_setValuesDf" "', argument " "2"" of type '" "ampl::DataFrame""'");
    } else {
      ampl::DataFrame * temp = reinterpret_cast< ampl::DataFrame * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      (arg1)->setValues(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Entity_getValuesLst(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Entity *arg1 = (ampl::Entity *) 0 ;
  char **arg2 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  SwigValueWrapper< ampl::DataFrame > result;
  
  {
    arg2 = NULL;
  }
  if (!PyArg_ParseTuple(args,(char *)"OO:Entity_getValuesLst",&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Entity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Entity_getValuesLst" "', argument " "1"" of type '" "ampl::Entity *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Entity * >(argp1);
  {
    /* Check if is a list */
    if (PyList_Check(obj1)) {
      int size = PyList_Size(obj1);
      int i = 0;
      arg2 = (char **)malloc((size + 1) * sizeof(char *));
      for (i = 0; i < size; i++) {
        PyObject *obj = PyList_GetItem(obj1,i);
        if (_PyString_Check(obj)) {
          arg2[i] = _PyString_AsString(PyList_GetItem(obj1,i));
        } else {
          PyErr_SetString(PyExc_TypeError,"list must contain strings");
          free(arg2);
          return NULL;
        }
      }
      arg2[i] = 0;
    }
    else {
      PyErr_SetString(PyExc_TypeError,"not a list");
      return NULL;
    }
  }
  ecode3 = SWIG_AsVal_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Entity_getValuesLst" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  {
    try {
      result = ampl_Entity_getValues(arg1,(char const *(*))arg2,arg3);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::DataFrame(static_cast< const ampl::DataFrame& >(result))), SWIGTYPE_p_ampl__DataFrame, SWIG_POINTER_OWN |  0 );
  {
    free((char *)arg2);
  }
  return resultobj;
fail:
  {
    free((char *)arg2);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_Entity(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Entity *arg1 = (ampl::Entity *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_Entity takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Entity, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Entity" "', argument " "1"" of type '" "ampl::Entity *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Entity * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityArgs_Factory(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  EntityArray *arg1 = 0 ;
  std::size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SwigValueWrapper< ampl::EntityArgs > result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:EntityArgs_Factory",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_EntityArray,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityArgs_Factory" "', argument " "1"" of type '" "EntityArray &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "EntityArgs_Factory" "', argument " "1"" of type '" "EntityArray &""'"); 
  }
  arg1 = reinterpret_cast< EntityArray * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "EntityArgs_Factory" "', argument " "2"" of type '" "std::size_t""'");
  } 
  arg2 = static_cast< std::size_t >(val2);
  {
    try {
      result = ampl_EntityArgs_Factory(*arg1,arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::EntityArgs(static_cast< const ampl::EntityArgs& >(result))), SWIGTYPE_p_ampl__EntityArgs, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_EntityArgs(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityArgs *arg1 = (ampl::EntityArgs *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_EntityArgs takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityArgs, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_EntityArgs" "', argument " "1"" of type '" "ampl::EntityArgs *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityArgs * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BasicEntityVariable_begin(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::BasicEntity< ampl::VariableInstance > *arg1 = (ampl::BasicEntity< ampl::VariableInstance > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ampl::BasicEntity< ampl::VariableInstance >::iterator result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "BasicEntityVariable_begin takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__BasicEntityT_ampl__VariableInstance_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BasicEntityVariable_begin" "', argument " "1"" of type '" "ampl::BasicEntity< ampl::VariableInstance > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::BasicEntity< ampl::VariableInstance > * >(argp1);
  {
    try {
      result = (arg1)->begin();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::BasicEntity< ampl::VariableInstance >::iterator(static_cast< const ampl::BasicEntity< ampl::VariableInstance >::iterator& >(result))), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BasicEntityVariable_end(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::BasicEntity< ampl::VariableInstance > *arg1 = (ampl::BasicEntity< ampl::VariableInstance > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ampl::BasicEntity< ampl::VariableInstance >::iterator result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "BasicEntityVariable_end takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__BasicEntityT_ampl__VariableInstance_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BasicEntityVariable_end" "', argument " "1"" of type '" "ampl::BasicEntity< ampl::VariableInstance > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::BasicEntity< ampl::VariableInstance > * >(argp1);
  {
    try {
      result = (arg1)->end();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::BasicEntity< ampl::VariableInstance >::iterator(static_cast< const ampl::BasicEntity< ampl::VariableInstance >::iterator& >(result))), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BasicEntityVariable_find(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::BasicEntity< ampl::VariableInstance > *arg1 = (ampl::BasicEntity< ampl::VariableInstance > *) 0 ;
  ampl::Tuple arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  ampl::BasicEntity< ampl::VariableInstance >::iterator result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:BasicEntityVariable_find",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__BasicEntityT_ampl__VariableInstance_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BasicEntityVariable_find" "', argument " "1"" of type '" "ampl::BasicEntity< ampl::VariableInstance > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::BasicEntity< ampl::VariableInstance > * >(argp1);
  {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__Tuple,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "BasicEntityVariable_find" "', argument " "2"" of type '" "ampl::Tuple""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "BasicEntityVariable_find" "', argument " "2"" of type '" "ampl::Tuple""'");
    } else {
      ampl::Tuple * temp = reinterpret_cast< ampl::Tuple * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (arg1)->find(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::BasicEntity< ampl::VariableInstance >::iterator(static_cast< const ampl::BasicEntity< ampl::VariableInstance >::iterator& >(result))), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BasicEntityVariable_get__SWIG_0(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::BasicEntity< ampl::VariableInstance > *arg1 = (ampl::BasicEntity< ampl::VariableInstance > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< ampl::VariableInstance > result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "BasicEntityVariable_get takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__BasicEntityT_ampl__VariableInstance_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BasicEntityVariable_get" "', argument " "1"" of type '" "ampl::BasicEntity< ampl::VariableInstance > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::BasicEntity< ampl::VariableInstance > * >(argp1);
  {
    try {
      result = (arg1)->get();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::VariableInstance(static_cast< const ampl::VariableInstance& >(result))), SWIGTYPE_p_ampl__VariableInstance, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BasicEntityVariable_get__SWIG_1(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::BasicEntity< ampl::VariableInstance > *arg1 = (ampl::BasicEntity< ampl::VariableInstance > *) 0 ;
  ampl::Tuple arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  SwigValueWrapper< ampl::VariableInstance > result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:BasicEntityVariable_get",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__BasicEntityT_ampl__VariableInstance_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BasicEntityVariable_get" "', argument " "1"" of type '" "ampl::BasicEntity< ampl::VariableInstance > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::BasicEntity< ampl::VariableInstance > * >(argp1);
  {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__Tuple,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "BasicEntityVariable_get" "', argument " "2"" of type '" "ampl::Tuple""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "BasicEntityVariable_get" "', argument " "2"" of type '" "ampl::Tuple""'");
    } else {
      ampl::Tuple * temp = reinterpret_cast< ampl::Tuple * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (arg1)->get(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::VariableInstance(static_cast< const ampl::VariableInstance& >(result))), SWIGTYPE_p_ampl__VariableInstance, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BasicEntityVariable_get(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  Py_ssize_t ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = args ? PyObject_Length(args) : 0;
  argv[0] = self;
  for (ii = 0; (ii < 1) && (ii < argc); ii++) {
    argv[ii + 1] = PyTuple_GET_ITEM(args,ii);
  }
  argc++;
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__BasicEntityT_ampl__VariableInstance_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_BasicEntityVariable_get__SWIG_0(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__BasicEntityT_ampl__VariableInstance_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_ampl__Tuple, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_BasicEntityVariable_get__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'BasicEntityVariable_get'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    ampl::BasicEntity< ampl::VariableInstance >::get()\n"
    "    ampl::BasicEntity< ampl::VariableInstance >::get(ampl::Tuple)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_delete_BasicEntityVariable(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::BasicEntity< ampl::VariableInstance > *arg1 = (ampl::BasicEntity< ampl::VariableInstance > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_BasicEntityVariable takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__BasicEntityT_ampl__VariableInstance_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_BasicEntityVariable" "', argument " "1"" of type '" "ampl::BasicEntity< ampl::VariableInstance > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::BasicEntity< ampl::VariableInstance > * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BasicEntityConstraint_begin(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::BasicEntity< ampl::ConstraintInstance > *arg1 = (ampl::BasicEntity< ampl::ConstraintInstance > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ampl::BasicEntity< ampl::ConstraintInstance >::iterator result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "BasicEntityConstraint_begin takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__BasicEntityT_ampl__ConstraintInstance_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BasicEntityConstraint_begin" "', argument " "1"" of type '" "ampl::BasicEntity< ampl::ConstraintInstance > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::BasicEntity< ampl::ConstraintInstance > * >(argp1);
  {
    try {
      result = (arg1)->begin();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::BasicEntity< ampl::ConstraintInstance >::iterator(static_cast< const ampl::BasicEntity< ampl::ConstraintInstance >::iterator& >(result))), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BasicEntityConstraint_end(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::BasicEntity< ampl::ConstraintInstance > *arg1 = (ampl::BasicEntity< ampl::ConstraintInstance > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ampl::BasicEntity< ampl::ConstraintInstance >::iterator result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "BasicEntityConstraint_end takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__BasicEntityT_ampl__ConstraintInstance_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BasicEntityConstraint_end" "', argument " "1"" of type '" "ampl::BasicEntity< ampl::ConstraintInstance > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::BasicEntity< ampl::ConstraintInstance > * >(argp1);
  {
    try {
      result = (arg1)->end();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::BasicEntity< ampl::ConstraintInstance >::iterator(static_cast< const ampl::BasicEntity< ampl::ConstraintInstance >::iterator& >(result))), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BasicEntityConstraint_find(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::BasicEntity< ampl::ConstraintInstance > *arg1 = (ampl::BasicEntity< ampl::ConstraintInstance > *) 0 ;
  ampl::Tuple arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  ampl::BasicEntity< ampl::ConstraintInstance >::iterator result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:BasicEntityConstraint_find",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__BasicEntityT_ampl__ConstraintInstance_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BasicEntityConstraint_find" "', argument " "1"" of type '" "ampl::BasicEntity< ampl::ConstraintInstance > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::BasicEntity< ampl::ConstraintInstance > * >(argp1);
  {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__Tuple,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "BasicEntityConstraint_find" "', argument " "2"" of type '" "ampl::Tuple""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "BasicEntityConstraint_find" "', argument " "2"" of type '" "ampl::Tuple""'");
    } else {
      ampl::Tuple * temp = reinterpret_cast< ampl::Tuple * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (arg1)->find(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::BasicEntity< ampl::ConstraintInstance >::iterator(static_cast< const ampl::BasicEntity< ampl::ConstraintInstance >::iterator& >(result))), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BasicEntityConstraint_get__SWIG_0(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::BasicEntity< ampl::ConstraintInstance > *arg1 = (ampl::BasicEntity< ampl::ConstraintInstance > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< ampl::ConstraintInstance > result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "BasicEntityConstraint_get takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__BasicEntityT_ampl__ConstraintInstance_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BasicEntityConstraint_get" "', argument " "1"" of type '" "ampl::BasicEntity< ampl::ConstraintInstance > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::BasicEntity< ampl::ConstraintInstance > * >(argp1);
  {
    try {
      result = (arg1)->get();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::ConstraintInstance(static_cast< const ampl::ConstraintInstance& >(result))), SWIGTYPE_p_ampl__ConstraintInstance, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BasicEntityConstraint_get__SWIG_1(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::BasicEntity< ampl::ConstraintInstance > *arg1 = (ampl::BasicEntity< ampl::ConstraintInstance > *) 0 ;
  ampl::Tuple arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  SwigValueWrapper< ampl::ConstraintInstance > result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:BasicEntityConstraint_get",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__BasicEntityT_ampl__ConstraintInstance_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BasicEntityConstraint_get" "', argument " "1"" of type '" "ampl::BasicEntity< ampl::ConstraintInstance > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::BasicEntity< ampl::ConstraintInstance > * >(argp1);
  {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__Tuple,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "BasicEntityConstraint_get" "', argument " "2"" of type '" "ampl::Tuple""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "BasicEntityConstraint_get" "', argument " "2"" of type '" "ampl::Tuple""'");
    } else {
      ampl::Tuple * temp = reinterpret_cast< ampl::Tuple * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (arg1)->get(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::ConstraintInstance(static_cast< const ampl::ConstraintInstance& >(result))), SWIGTYPE_p_ampl__ConstraintInstance, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BasicEntityConstraint_get(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  Py_ssize_t ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = args ? PyObject_Length(args) : 0;
  argv[0] = self;
  for (ii = 0; (ii < 1) && (ii < argc); ii++) {
    argv[ii + 1] = PyTuple_GET_ITEM(args,ii);
  }
  argc++;
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__BasicEntityT_ampl__ConstraintInstance_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_BasicEntityConstraint_get__SWIG_0(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__BasicEntityT_ampl__ConstraintInstance_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_ampl__Tuple, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_BasicEntityConstraint_get__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'BasicEntityConstraint_get'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    ampl::BasicEntity< ampl::ConstraintInstance >::get()\n"
    "    ampl::BasicEntity< ampl::ConstraintInstance >::get(ampl::Tuple)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_delete_BasicEntityConstraint(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::BasicEntity< ampl::ConstraintInstance > *arg1 = (ampl::BasicEntity< ampl::ConstraintInstance > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_BasicEntityConstraint takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__BasicEntityT_ampl__ConstraintInstance_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_BasicEntityConstraint" "', argument " "1"" of type '" "ampl::BasicEntity< ampl::ConstraintInstance > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::BasicEntity< ampl::ConstraintInstance > * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BasicEntitySet_begin(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::BasicEntity< ampl::SetInstance > *arg1 = (ampl::BasicEntity< ampl::SetInstance > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ampl::BasicEntity< ampl::SetInstance >::iterator result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "BasicEntitySet_begin takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__BasicEntityT_ampl__SetInstance_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BasicEntitySet_begin" "', argument " "1"" of type '" "ampl::BasicEntity< ampl::SetInstance > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::BasicEntity< ampl::SetInstance > * >(argp1);
  {
    try {
      result = (arg1)->begin();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::BasicEntity< ampl::SetInstance >::iterator(static_cast< const ampl::BasicEntity< ampl::SetInstance >::iterator& >(result))), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BasicEntitySet_end(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::BasicEntity< ampl::SetInstance > *arg1 = (ampl::BasicEntity< ampl::SetInstance > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ampl::BasicEntity< ampl::SetInstance >::iterator result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "BasicEntitySet_end takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__BasicEntityT_ampl__SetInstance_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BasicEntitySet_end" "', argument " "1"" of type '" "ampl::BasicEntity< ampl::SetInstance > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::BasicEntity< ampl::SetInstance > * >(argp1);
  {
    try {
      result = (arg1)->end();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::BasicEntity< ampl::SetInstance >::iterator(static_cast< const ampl::BasicEntity< ampl::SetInstance >::iterator& >(result))), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BasicEntitySet_find(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::BasicEntity< ampl::SetInstance > *arg1 = (ampl::BasicEntity< ampl::SetInstance > *) 0 ;
  ampl::Tuple arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  ampl::BasicEntity< ampl::SetInstance >::iterator result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:BasicEntitySet_find",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__BasicEntityT_ampl__SetInstance_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BasicEntitySet_find" "', argument " "1"" of type '" "ampl::BasicEntity< ampl::SetInstance > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::BasicEntity< ampl::SetInstance > * >(argp1);
  {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__Tuple,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "BasicEntitySet_find" "', argument " "2"" of type '" "ampl::Tuple""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "BasicEntitySet_find" "', argument " "2"" of type '" "ampl::Tuple""'");
    } else {
      ampl::Tuple * temp = reinterpret_cast< ampl::Tuple * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (arg1)->find(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::BasicEntity< ampl::SetInstance >::iterator(static_cast< const ampl::BasicEntity< ampl::SetInstance >::iterator& >(result))), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BasicEntitySet_get__SWIG_0(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::BasicEntity< ampl::SetInstance > *arg1 = (ampl::BasicEntity< ampl::SetInstance > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< ampl::SetInstance > result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "BasicEntitySet_get takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__BasicEntityT_ampl__SetInstance_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BasicEntitySet_get" "', argument " "1"" of type '" "ampl::BasicEntity< ampl::SetInstance > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::BasicEntity< ampl::SetInstance > * >(argp1);
  {
    try {
      result = (arg1)->get();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::SetInstance(static_cast< const ampl::SetInstance& >(result))), SWIGTYPE_p_ampl__SetInstance, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BasicEntitySet_get__SWIG_1(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::BasicEntity< ampl::SetInstance > *arg1 = (ampl::BasicEntity< ampl::SetInstance > *) 0 ;
  ampl::Tuple arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  SwigValueWrapper< ampl::SetInstance > result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:BasicEntitySet_get",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__BasicEntityT_ampl__SetInstance_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BasicEntitySet_get" "', argument " "1"" of type '" "ampl::BasicEntity< ampl::SetInstance > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::BasicEntity< ampl::SetInstance > * >(argp1);
  {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__Tuple,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "BasicEntitySet_get" "', argument " "2"" of type '" "ampl::Tuple""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "BasicEntitySet_get" "', argument " "2"" of type '" "ampl::Tuple""'");
    } else {
      ampl::Tuple * temp = reinterpret_cast< ampl::Tuple * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (arg1)->get(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::SetInstance(static_cast< const ampl::SetInstance& >(result))), SWIGTYPE_p_ampl__SetInstance, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BasicEntitySet_get(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  Py_ssize_t ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = args ? PyObject_Length(args) : 0;
  argv[0] = self;
  for (ii = 0; (ii < 1) && (ii < argc); ii++) {
    argv[ii + 1] = PyTuple_GET_ITEM(args,ii);
  }
  argc++;
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__BasicEntityT_ampl__SetInstance_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_BasicEntitySet_get__SWIG_0(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__BasicEntityT_ampl__SetInstance_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_ampl__Tuple, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_BasicEntitySet_get__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'BasicEntitySet_get'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    ampl::BasicEntity< ampl::SetInstance >::get()\n"
    "    ampl::BasicEntity< ampl::SetInstance >::get(ampl::Tuple)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_delete_BasicEntitySet(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::BasicEntity< ampl::SetInstance > *arg1 = (ampl::BasicEntity< ampl::SetInstance > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_BasicEntitySet takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__BasicEntityT_ampl__SetInstance_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_BasicEntitySet" "', argument " "1"" of type '" "ampl::BasicEntity< ampl::SetInstance > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::BasicEntity< ampl::SetInstance > * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BasicEntityObjective_begin(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::BasicEntity< ampl::ObjectiveInstance > *arg1 = (ampl::BasicEntity< ampl::ObjectiveInstance > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ampl::BasicEntity< ampl::ObjectiveInstance >::iterator result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "BasicEntityObjective_begin takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__BasicEntityT_ampl__ObjectiveInstance_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BasicEntityObjective_begin" "', argument " "1"" of type '" "ampl::BasicEntity< ampl::ObjectiveInstance > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::BasicEntity< ampl::ObjectiveInstance > * >(argp1);
  {
    try {
      result = (arg1)->begin();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::BasicEntity< ampl::ObjectiveInstance >::iterator(static_cast< const ampl::BasicEntity< ampl::ObjectiveInstance >::iterator& >(result))), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BasicEntityObjective_end(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::BasicEntity< ampl::ObjectiveInstance > *arg1 = (ampl::BasicEntity< ampl::ObjectiveInstance > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ampl::BasicEntity< ampl::ObjectiveInstance >::iterator result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "BasicEntityObjective_end takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__BasicEntityT_ampl__ObjectiveInstance_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BasicEntityObjective_end" "', argument " "1"" of type '" "ampl::BasicEntity< ampl::ObjectiveInstance > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::BasicEntity< ampl::ObjectiveInstance > * >(argp1);
  {
    try {
      result = (arg1)->end();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::BasicEntity< ampl::ObjectiveInstance >::iterator(static_cast< const ampl::BasicEntity< ampl::ObjectiveInstance >::iterator& >(result))), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BasicEntityObjective_find(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::BasicEntity< ampl::ObjectiveInstance > *arg1 = (ampl::BasicEntity< ampl::ObjectiveInstance > *) 0 ;
  ampl::Tuple arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  ampl::BasicEntity< ampl::ObjectiveInstance >::iterator result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:BasicEntityObjective_find",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__BasicEntityT_ampl__ObjectiveInstance_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BasicEntityObjective_find" "', argument " "1"" of type '" "ampl::BasicEntity< ampl::ObjectiveInstance > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::BasicEntity< ampl::ObjectiveInstance > * >(argp1);
  {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__Tuple,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "BasicEntityObjective_find" "', argument " "2"" of type '" "ampl::Tuple""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "BasicEntityObjective_find" "', argument " "2"" of type '" "ampl::Tuple""'");
    } else {
      ampl::Tuple * temp = reinterpret_cast< ampl::Tuple * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (arg1)->find(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::BasicEntity< ampl::ObjectiveInstance >::iterator(static_cast< const ampl::BasicEntity< ampl::ObjectiveInstance >::iterator& >(result))), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BasicEntityObjective_get__SWIG_0(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::BasicEntity< ampl::ObjectiveInstance > *arg1 = (ampl::BasicEntity< ampl::ObjectiveInstance > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< ampl::ObjectiveInstance > result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "BasicEntityObjective_get takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__BasicEntityT_ampl__ObjectiveInstance_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BasicEntityObjective_get" "', argument " "1"" of type '" "ampl::BasicEntity< ampl::ObjectiveInstance > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::BasicEntity< ampl::ObjectiveInstance > * >(argp1);
  {
    try {
      result = (arg1)->get();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::ObjectiveInstance(static_cast< const ampl::ObjectiveInstance& >(result))), SWIGTYPE_p_ampl__ObjectiveInstance, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BasicEntityObjective_get__SWIG_1(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::BasicEntity< ampl::ObjectiveInstance > *arg1 = (ampl::BasicEntity< ampl::ObjectiveInstance > *) 0 ;
  ampl::Tuple arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  SwigValueWrapper< ampl::ObjectiveInstance > result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:BasicEntityObjective_get",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__BasicEntityT_ampl__ObjectiveInstance_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BasicEntityObjective_get" "', argument " "1"" of type '" "ampl::BasicEntity< ampl::ObjectiveInstance > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::BasicEntity< ampl::ObjectiveInstance > * >(argp1);
  {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__Tuple,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "BasicEntityObjective_get" "', argument " "2"" of type '" "ampl::Tuple""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "BasicEntityObjective_get" "', argument " "2"" of type '" "ampl::Tuple""'");
    } else {
      ampl::Tuple * temp = reinterpret_cast< ampl::Tuple * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (arg1)->get(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::ObjectiveInstance(static_cast< const ampl::ObjectiveInstance& >(result))), SWIGTYPE_p_ampl__ObjectiveInstance, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BasicEntityObjective_get(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  Py_ssize_t ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = args ? PyObject_Length(args) : 0;
  argv[0] = self;
  for (ii = 0; (ii < 1) && (ii < argc); ii++) {
    argv[ii + 1] = PyTuple_GET_ITEM(args,ii);
  }
  argc++;
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__BasicEntityT_ampl__ObjectiveInstance_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_BasicEntityObjective_get__SWIG_0(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__BasicEntityT_ampl__ObjectiveInstance_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_ampl__Tuple, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_BasicEntityObjective_get__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'BasicEntityObjective_get'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    ampl::BasicEntity< ampl::ObjectiveInstance >::get()\n"
    "    ampl::BasicEntity< ampl::ObjectiveInstance >::get(ampl::Tuple)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_delete_BasicEntityObjective(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::BasicEntity< ampl::ObjectiveInstance > *arg1 = (ampl::BasicEntity< ampl::ObjectiveInstance > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_BasicEntityObjective takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__BasicEntityT_ampl__ObjectiveInstance_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_BasicEntityObjective" "', argument " "1"" of type '" "ampl::BasicEntity< ampl::ObjectiveInstance > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::BasicEntity< ampl::ObjectiveInstance > * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BasicEntityParameter_begin(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::BasicEntity< ampl::VariantRef > *arg1 = (ampl::BasicEntity< ampl::VariantRef > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ampl::BasicEntity< ampl::VariantRef >::iterator result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "BasicEntityParameter_begin takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__BasicEntityT_ampl__VariantRef_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BasicEntityParameter_begin" "', argument " "1"" of type '" "ampl::BasicEntity< ampl::VariantRef > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::BasicEntity< ampl::VariantRef > * >(argp1);
  {
    try {
      result = (arg1)->begin();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::BasicEntity< ampl::VariantRef >::iterator(static_cast< const ampl::BasicEntity< ampl::VariantRef >::iterator& >(result))), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BasicEntityParameter_end(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::BasicEntity< ampl::VariantRef > *arg1 = (ampl::BasicEntity< ampl::VariantRef > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ampl::BasicEntity< ampl::VariantRef >::iterator result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "BasicEntityParameter_end takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__BasicEntityT_ampl__VariantRef_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BasicEntityParameter_end" "', argument " "1"" of type '" "ampl::BasicEntity< ampl::VariantRef > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::BasicEntity< ampl::VariantRef > * >(argp1);
  {
    try {
      result = (arg1)->end();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::BasicEntity< ampl::VariantRef >::iterator(static_cast< const ampl::BasicEntity< ampl::VariantRef >::iterator& >(result))), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BasicEntityParameter_find(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::BasicEntity< ampl::VariantRef > *arg1 = (ampl::BasicEntity< ampl::VariantRef > *) 0 ;
  ampl::Tuple arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  ampl::BasicEntity< ampl::VariantRef >::iterator result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:BasicEntityParameter_find",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__BasicEntityT_ampl__VariantRef_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BasicEntityParameter_find" "', argument " "1"" of type '" "ampl::BasicEntity< ampl::VariantRef > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::BasicEntity< ampl::VariantRef > * >(argp1);
  {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__Tuple,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "BasicEntityParameter_find" "', argument " "2"" of type '" "ampl::Tuple""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "BasicEntityParameter_find" "', argument " "2"" of type '" "ampl::Tuple""'");
    } else {
      ampl::Tuple * temp = reinterpret_cast< ampl::Tuple * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (arg1)->find(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::BasicEntity< ampl::VariantRef >::iterator(static_cast< const ampl::BasicEntity< ampl::VariantRef >::iterator& >(result))), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BasicEntityParameter_get__SWIG_0(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::BasicEntity< ampl::VariantRef > *arg1 = (ampl::BasicEntity< ampl::VariantRef > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< ampl::VariantRef > result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "BasicEntityParameter_get takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__BasicEntityT_ampl__VariantRef_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BasicEntityParameter_get" "', argument " "1"" of type '" "ampl::BasicEntity< ampl::VariantRef > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::BasicEntity< ampl::VariantRef > * >(argp1);
  {
    try {
      result = (arg1)->get();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::VariantRef(static_cast< const ampl::VariantRef& >(result))), SWIGTYPE_p_ampl__VariantRef, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BasicEntityParameter_get__SWIG_1(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::BasicEntity< ampl::VariantRef > *arg1 = (ampl::BasicEntity< ampl::VariantRef > *) 0 ;
  ampl::Tuple arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  SwigValueWrapper< ampl::VariantRef > result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:BasicEntityParameter_get",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__BasicEntityT_ampl__VariantRef_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BasicEntityParameter_get" "', argument " "1"" of type '" "ampl::BasicEntity< ampl::VariantRef > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::BasicEntity< ampl::VariantRef > * >(argp1);
  {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__Tuple,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "BasicEntityParameter_get" "', argument " "2"" of type '" "ampl::Tuple""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "BasicEntityParameter_get" "', argument " "2"" of type '" "ampl::Tuple""'");
    } else {
      ampl::Tuple * temp = reinterpret_cast< ampl::Tuple * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (arg1)->get(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::VariantRef(static_cast< const ampl::VariantRef& >(result))), SWIGTYPE_p_ampl__VariantRef, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BasicEntityParameter_get(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  Py_ssize_t ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = args ? PyObject_Length(args) : 0;
  argv[0] = self;
  for (ii = 0; (ii < 1) && (ii < argc); ii++) {
    argv[ii + 1] = PyTuple_GET_ITEM(args,ii);
  }
  argc++;
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__BasicEntityT_ampl__VariantRef_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_BasicEntityParameter_get__SWIG_0(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__BasicEntityT_ampl__VariantRef_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_ampl__Tuple, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_BasicEntityParameter_get__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'BasicEntityParameter_get'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    ampl::BasicEntity< ampl::VariantRef >::get()\n"
    "    ampl::BasicEntity< ampl::VariantRef >::get(ampl::Tuple)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_delete_BasicEntityParameter(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::BasicEntity< ampl::VariantRef > *arg1 = (ampl::BasicEntity< ampl::VariantRef > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_BasicEntityParameter takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__BasicEntityT_ampl__VariantRef_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_BasicEntityParameter" "', argument " "1"" of type '" "ampl::BasicEntity< ampl::VariantRef > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::BasicEntity< ampl::VariantRef > * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Constraint_isLogical(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Constraint *arg1 = (ampl::Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Constraint_isLogical takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Constraint_isLogical" "', argument " "1"" of type '" "ampl::Constraint *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Constraint * >(argp1);
  {
    try {
      result = (bool)(arg1)->isLogical();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Constraint_drop(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Constraint *arg1 = (ampl::Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Constraint_drop takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Constraint_drop" "', argument " "1"" of type '" "ampl::Constraint *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Constraint * >(argp1);
  {
    try {
      (arg1)->drop();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Constraint_restore(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Constraint *arg1 = (ampl::Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Constraint_restore takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Constraint_restore" "', argument " "1"" of type '" "ampl::Constraint *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Constraint * >(argp1);
  {
    try {
      (arg1)->restore();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Constraint_body(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Constraint *arg1 = (ampl::Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Constraint_body takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Constraint_body" "', argument " "1"" of type '" "ampl::Constraint *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Constraint * >(argp1);
  {
    try {
      result = (double)(arg1)->body();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Constraint_astatus(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Constraint *arg1 = (ampl::Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Constraint_astatus takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Constraint_astatus" "', argument " "1"" of type '" "ampl::Constraint *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Constraint * >(argp1);
  {
    try {
      result = (arg1)->astatus();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Constraint_defvar(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Constraint *arg1 = (ampl::Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Constraint_defvar takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Constraint_defvar" "', argument " "1"" of type '" "ampl::Constraint *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Constraint * >(argp1);
  {
    try {
      result = (int)(arg1)->defvar();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Constraint_dinit(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Constraint *arg1 = (ampl::Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Constraint_dinit takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Constraint_dinit" "', argument " "1"" of type '" "ampl::Constraint *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Constraint * >(argp1);
  {
    try {
      result = (double)(arg1)->dinit();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Constraint_dinit0(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Constraint *arg1 = (ampl::Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Constraint_dinit0 takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Constraint_dinit0" "', argument " "1"" of type '" "ampl::Constraint *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Constraint * >(argp1);
  {
    try {
      result = (double)(arg1)->dinit0();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Constraint_dual(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Constraint *arg1 = (ampl::Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Constraint_dual takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Constraint_dual" "', argument " "1"" of type '" "ampl::Constraint *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Constraint * >(argp1);
  {
    try {
      result = (double)(arg1)->dual();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Constraint_lb(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Constraint *arg1 = (ampl::Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Constraint_lb takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Constraint_lb" "', argument " "1"" of type '" "ampl::Constraint *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Constraint * >(argp1);
  {
    try {
      result = (double)(arg1)->lb();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Constraint_ub(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Constraint *arg1 = (ampl::Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Constraint_ub takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Constraint_ub" "', argument " "1"" of type '" "ampl::Constraint *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Constraint * >(argp1);
  {
    try {
      result = (double)(arg1)->ub();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Constraint_lbs(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Constraint *arg1 = (ampl::Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Constraint_lbs takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Constraint_lbs" "', argument " "1"" of type '" "ampl::Constraint *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Constraint * >(argp1);
  {
    try {
      result = (double)(arg1)->lbs();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Constraint_ubs(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Constraint *arg1 = (ampl::Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Constraint_ubs takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Constraint_ubs" "', argument " "1"" of type '" "ampl::Constraint *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Constraint * >(argp1);
  {
    try {
      result = (double)(arg1)->ubs();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Constraint_ldual(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Constraint *arg1 = (ampl::Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Constraint_ldual takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Constraint_ldual" "', argument " "1"" of type '" "ampl::Constraint *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Constraint * >(argp1);
  {
    try {
      result = (double)(arg1)->ldual();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Constraint_udual(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Constraint *arg1 = (ampl::Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Constraint_udual takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Constraint_udual" "', argument " "1"" of type '" "ampl::Constraint *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Constraint * >(argp1);
  {
    try {
      result = (double)(arg1)->udual();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Constraint_lslack(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Constraint *arg1 = (ampl::Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Constraint_lslack takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Constraint_lslack" "', argument " "1"" of type '" "ampl::Constraint *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Constraint * >(argp1);
  {
    try {
      result = (double)(arg1)->lslack();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Constraint_uslack(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Constraint *arg1 = (ampl::Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Constraint_uslack takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Constraint_uslack" "', argument " "1"" of type '" "ampl::Constraint *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Constraint * >(argp1);
  {
    try {
      result = (double)(arg1)->uslack();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Constraint_slack(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Constraint *arg1 = (ampl::Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Constraint_slack takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Constraint_slack" "', argument " "1"" of type '" "ampl::Constraint *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Constraint * >(argp1);
  {
    try {
      result = (double)(arg1)->slack();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Constraint_sstatus(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Constraint *arg1 = (ampl::Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Constraint_sstatus takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Constraint_sstatus" "', argument " "1"" of type '" "ampl::Constraint *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Constraint * >(argp1);
  {
    try {
      result = (arg1)->sstatus();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Constraint_status(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Constraint *arg1 = (ampl::Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Constraint_status takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Constraint_status" "', argument " "1"" of type '" "ampl::Constraint *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Constraint * >(argp1);
  {
    try {
      result = (arg1)->status();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Constraint_setDual(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Constraint *arg1 = (ampl::Constraint *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Constraint_setDual",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Constraint_setDual" "', argument " "1"" of type '" "ampl::Constraint *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Constraint * >(argp1);
  ecode2 = SWIG_AsVal_double(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Constraint_setDual" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->setDual(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Constraint_val(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Constraint *arg1 = (ampl::Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Constraint_val takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Constraint_val" "', argument " "1"" of type '" "ampl::Constraint *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Constraint * >(argp1);
  {
    try {
      result = (double)(arg1)->val();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_Constraint(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Constraint *arg1 = (ampl::Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_Constraint takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Constraint, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Constraint" "', argument " "1"" of type '" "ampl::Constraint *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Constraint * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variable_integrality(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Variable *arg1 = (ampl::Variable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ampl::var::Integrality result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Variable_integrality takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Variable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variable_integrality" "', argument " "1"" of type '" "ampl::Variable *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Variable * >(argp1);
  {
    try {
      result = (ampl::var::Integrality)(arg1)->integrality();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variable_fix__SWIG_0(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Variable *arg1 = (ampl::Variable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Variable_fix takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Variable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variable_fix" "', argument " "1"" of type '" "ampl::Variable *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Variable * >(argp1);
  {
    try {
      (arg1)->fix();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variable_fix__SWIG_1(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Variable *arg1 = (ampl::Variable *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Variable_fix",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Variable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variable_fix" "', argument " "1"" of type '" "ampl::Variable *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Variable * >(argp1);
  ecode2 = SWIG_AsVal_double(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Variable_fix" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->fix(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variable_fix(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  Py_ssize_t ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = args ? PyObject_Length(args) : 0;
  argv[0] = self;
  for (ii = 0; (ii < 1) && (ii < argc); ii++) {
    argv[ii + 1] = PyTuple_GET_ITEM(args,ii);
  }
  argc++;
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__Variable, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Variable_fix__SWIG_0(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__Variable, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Variable_fix__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'Variable_fix'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    ampl::Variable::fix()\n"
    "    ampl::Variable::fix(double)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_Variable_unfix(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Variable *arg1 = (ampl::Variable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Variable_unfix takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Variable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variable_unfix" "', argument " "1"" of type '" "ampl::Variable *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Variable * >(argp1);
  {
    try {
      (arg1)->unfix();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variable_setValue(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Variable *arg1 = (ampl::Variable *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Variable_setValue",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Variable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variable_setValue" "', argument " "1"" of type '" "ampl::Variable *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Variable * >(argp1);
  ecode2 = SWIG_AsVal_double(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Variable_setValue" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      (arg1)->setValue(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variable_value(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Variable *arg1 = (ampl::Variable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Variable_value takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Variable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variable_value" "', argument " "1"" of type '" "ampl::Variable *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Variable * >(argp1);
  {
    try {
      result = (double)(arg1)->value();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variable_astatus(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Variable *arg1 = (ampl::Variable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Variable_astatus takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Variable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variable_astatus" "', argument " "1"" of type '" "ampl::Variable *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Variable * >(argp1);
  {
    try {
      result = (arg1)->astatus();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variable_defeqn(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Variable *arg1 = (ampl::Variable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Variable_defeqn takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Variable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variable_defeqn" "', argument " "1"" of type '" "ampl::Variable *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Variable * >(argp1);
  {
    try {
      result = (int)(arg1)->defeqn();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variable_dual(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Variable *arg1 = (ampl::Variable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Variable_dual takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Variable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variable_dual" "', argument " "1"" of type '" "ampl::Variable *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Variable * >(argp1);
  {
    try {
      result = (double)(arg1)->dual();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variable_init(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Variable *arg1 = (ampl::Variable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Variable_init takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Variable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variable_init" "', argument " "1"" of type '" "ampl::Variable *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Variable * >(argp1);
  {
    try {
      result = (double)(arg1)->init();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variable_init0(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Variable *arg1 = (ampl::Variable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Variable_init0 takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Variable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variable_init0" "', argument " "1"" of type '" "ampl::Variable *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Variable * >(argp1);
  {
    try {
      result = (double)(arg1)->init0();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variable_lb(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Variable *arg1 = (ampl::Variable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Variable_lb takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Variable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variable_lb" "', argument " "1"" of type '" "ampl::Variable *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Variable * >(argp1);
  {
    try {
      result = (double)(arg1)->lb();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variable_ub(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Variable *arg1 = (ampl::Variable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Variable_ub takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Variable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variable_ub" "', argument " "1"" of type '" "ampl::Variable *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Variable * >(argp1);
  {
    try {
      result = (double)(arg1)->ub();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variable_lb0(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Variable *arg1 = (ampl::Variable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Variable_lb0 takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Variable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variable_lb0" "', argument " "1"" of type '" "ampl::Variable *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Variable * >(argp1);
  {
    try {
      result = (double)(arg1)->lb0();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variable_ub0(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Variable *arg1 = (ampl::Variable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Variable_ub0 takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Variable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variable_ub0" "', argument " "1"" of type '" "ampl::Variable *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Variable * >(argp1);
  {
    try {
      result = (double)(arg1)->ub0();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variable_lb1(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Variable *arg1 = (ampl::Variable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Variable_lb1 takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Variable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variable_lb1" "', argument " "1"" of type '" "ampl::Variable *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Variable * >(argp1);
  {
    try {
      result = (double)(arg1)->lb1();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variable_ub1(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Variable *arg1 = (ampl::Variable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Variable_ub1 takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Variable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variable_ub1" "', argument " "1"" of type '" "ampl::Variable *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Variable * >(argp1);
  {
    try {
      result = (double)(arg1)->ub1();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variable_lb2(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Variable *arg1 = (ampl::Variable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Variable_lb2 takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Variable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variable_lb2" "', argument " "1"" of type '" "ampl::Variable *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Variable * >(argp1);
  {
    try {
      result = (double)(arg1)->lb2();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variable_ub2(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Variable *arg1 = (ampl::Variable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Variable_ub2 takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Variable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variable_ub2" "', argument " "1"" of type '" "ampl::Variable *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Variable * >(argp1);
  {
    try {
      result = (double)(arg1)->ub2();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variable_lrc(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Variable *arg1 = (ampl::Variable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Variable_lrc takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Variable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variable_lrc" "', argument " "1"" of type '" "ampl::Variable *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Variable * >(argp1);
  {
    try {
      result = (double)(arg1)->lrc();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variable_urc(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Variable *arg1 = (ampl::Variable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Variable_urc takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Variable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variable_urc" "', argument " "1"" of type '" "ampl::Variable *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Variable * >(argp1);
  {
    try {
      result = (double)(arg1)->urc();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variable_lslack(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Variable *arg1 = (ampl::Variable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Variable_lslack takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Variable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variable_lslack" "', argument " "1"" of type '" "ampl::Variable *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Variable * >(argp1);
  {
    try {
      result = (double)(arg1)->lslack();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variable_uslack(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Variable *arg1 = (ampl::Variable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Variable_uslack takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Variable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variable_uslack" "', argument " "1"" of type '" "ampl::Variable *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Variable * >(argp1);
  {
    try {
      result = (double)(arg1)->uslack();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variable_rc(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Variable *arg1 = (ampl::Variable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Variable_rc takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Variable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variable_rc" "', argument " "1"" of type '" "ampl::Variable *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Variable * >(argp1);
  {
    try {
      result = (double)(arg1)->rc();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variable_slack(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Variable *arg1 = (ampl::Variable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Variable_slack takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Variable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variable_slack" "', argument " "1"" of type '" "ampl::Variable *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Variable * >(argp1);
  {
    try {
      result = (double)(arg1)->slack();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variable_sstatus(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Variable *arg1 = (ampl::Variable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Variable_sstatus takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Variable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variable_sstatus" "', argument " "1"" of type '" "ampl::Variable *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Variable * >(argp1);
  {
    try {
      result = (arg1)->sstatus();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variable_status(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Variable *arg1 = (ampl::Variable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Variable_status takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Variable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variable_status" "', argument " "1"" of type '" "ampl::Variable *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Variable * >(argp1);
  {
    try {
      result = (arg1)->status();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_Variable(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Variable *arg1 = (ampl::Variable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_Variable takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Variable, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Variable" "', argument " "1"" of type '" "ampl::Variable *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Variable * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Objective_value(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Objective *arg1 = (ampl::Objective *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Objective_value takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Objective, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Objective_value" "', argument " "1"" of type '" "ampl::Objective *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Objective * >(argp1);
  {
    try {
      result = (double)(arg1)->value();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Objective_astatus(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Objective *arg1 = (ampl::Objective *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Objective_astatus takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Objective, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Objective_astatus" "', argument " "1"" of type '" "ampl::Objective *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Objective * >(argp1);
  {
    try {
      result = (arg1)->astatus();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Objective_sstatus(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Objective *arg1 = (ampl::Objective *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Objective_sstatus takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Objective, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Objective_sstatus" "', argument " "1"" of type '" "ampl::Objective *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Objective * >(argp1);
  {
    try {
      result = (arg1)->sstatus();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Objective_exitcode(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Objective *arg1 = (ampl::Objective *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Objective_exitcode takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Objective, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Objective_exitcode" "', argument " "1"" of type '" "ampl::Objective *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Objective * >(argp1);
  {
    try {
      result = (int)(arg1)->exitcode();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Objective_message(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Objective *arg1 = (ampl::Objective *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Objective_message takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Objective, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Objective_message" "', argument " "1"" of type '" "ampl::Objective *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Objective * >(argp1);
  {
    try {
      result = (arg1)->message();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Objective_result(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Objective *arg1 = (ampl::Objective *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Objective_result takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Objective, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Objective_result" "', argument " "1"" of type '" "ampl::Objective *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Objective * >(argp1);
  {
    try {
      result = (arg1)->result();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Objective_drop(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Objective *arg1 = (ampl::Objective *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Objective_drop takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Objective, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Objective_drop" "', argument " "1"" of type '" "ampl::Objective *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Objective * >(argp1);
  {
    try {
      (arg1)->drop();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Objective_restore(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Objective *arg1 = (ampl::Objective *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Objective_restore takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Objective, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Objective_restore" "', argument " "1"" of type '" "ampl::Objective *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Objective * >(argp1);
  {
    try {
      (arg1)->restore();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Objective_minimization(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Objective *arg1 = (ampl::Objective *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Objective_minimization takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Objective, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Objective_minimization" "', argument " "1"" of type '" "ampl::Objective *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Objective * >(argp1);
  {
    try {
      result = (bool)(arg1)->minimization();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_Objective(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Objective *arg1 = (ampl::Objective *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_Objective takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Objective, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Objective" "', argument " "1"" of type '" "ampl::Objective *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Objective * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Set_arity(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Set *arg1 = (ampl::Set *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::size_t result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Set_arity takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Set, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Set_arity" "', argument " "1"" of type '" "ampl::Set const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Set * >(argp1);
  {
    try {
      result = (std::size_t)((ampl::Set const *)arg1)->arity();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Set_getValues(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Set *arg1 = (ampl::Set *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< ampl::DataFrame > result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Set_getValues takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Set, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Set_getValues" "', argument " "1"" of type '" "ampl::Set const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Set * >(argp1);
  {
    try {
      result = ((ampl::Set const *)arg1)->getValues();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::DataFrame(static_cast< const ampl::DataFrame& >(result))), SWIGTYPE_p_ampl__DataFrame, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Set_size(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Set *arg1 = (ampl::Set *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::size_t result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Set_size takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Set, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Set_size" "', argument " "1"" of type '" "ampl::Set const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Set * >(argp1);
  {
    try {
      result = (std::size_t)((ampl::Set const *)arg1)->size();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Set_setValuesDf(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Set *arg1 = (ampl::Set *) 0 ;
  SwigValueWrapper< ampl::DataFrame > arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Set_setValuesDf",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Set, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Set_setValuesDf" "', argument " "1"" of type '" "ampl::Set *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Set * >(argp1);
  {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__DataFrame,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Set_setValuesDf" "', argument " "2"" of type '" "ampl::DataFrame""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Set_setValuesDf" "', argument " "2"" of type '" "ampl::DataFrame""'");
    } else {
      ampl::DataFrame * temp = reinterpret_cast< ampl::DataFrame * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      (arg1)->setValues(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Set_contains(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Set *arg1 = (ampl::Set *) 0 ;
  ampl::Tuple arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Set_contains",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Set, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Set_contains" "', argument " "1"" of type '" "ampl::Set const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Set * >(argp1);
  {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__Tuple,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Set_contains" "', argument " "2"" of type '" "ampl::Tuple""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Set_contains" "', argument " "2"" of type '" "ampl::Tuple""'");
    } else {
      ampl::Tuple * temp = reinterpret_cast< ampl::Tuple * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      result = (bool)ampl_Set_contains((ampl::Set const *)arg1,arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Set_setValues(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Set *arg1 = (ampl::Set *) 0 ;
  TupleArray *arg2 = 0 ;
  std::size_t arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Set_setValues",&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Set, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Set_setValues" "', argument " "1"" of type '" "ampl::Set *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Set * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_TupleArray,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Set_setValues" "', argument " "2"" of type '" "TupleArray &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Set_setValues" "', argument " "2"" of type '" "TupleArray &""'"); 
  }
  arg2 = reinterpret_cast< TupleArray * >(argp2);
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Set_setValues" "', argument " "3"" of type '" "std::size_t""'");
  } 
  arg3 = static_cast< std::size_t >(val3);
  {
    try {
      ampl_Set_setValues(arg1,*arg2,arg3);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Set_setValuesDbl(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Set *arg1 = (ampl::Set *) 0 ;
  double *arg2 = (double *) 0 ;
  std::size_t arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Set_setValuesDbl",&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Set, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Set_setValuesDbl" "', argument " "1"" of type '" "ampl::Set *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Set * >(argp1);
  {
    /* Check if is a list */
    if (PyList_Check(obj1)) {
      int size = PyList_Size(obj1);
      int i = 0;
      arg2 = (double *)malloc(size * sizeof(double));
      for (i = 0; i < size; i++) {
        PyObject *o = PyList_GetItem(obj1,i);
        if (PyFloat_Check(o))
        arg2[i] = PyFloat_AsDouble(PyList_GetItem(obj1,i));
        else {
          PyErr_SetString(PyExc_TypeError, "The input list must contain floating point numbers");
          free(arg2);
          return NULL;
        }
      }
    }
    else {
      PyErr_SetString(PyExc_TypeError,"The input is not a list");
      return NULL;
    }
  }
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Set_setValuesDbl" "', argument " "3"" of type '" "std::size_t""'");
  } 
  arg3 = static_cast< std::size_t >(val3);
  {
    try {
      ampl_Set_setValues(arg1,arg2,arg3);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  {
    free((double *)arg2);
  }
  return resultobj;
fail:
  {
    free((double *)arg2);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_Set_setValuesStr(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Set *arg1 = (ampl::Set *) 0 ;
  char **arg2 ;
  std::size_t arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  {
    arg2 = NULL;
  }
  if (!PyArg_ParseTuple(args,(char *)"OO:Set_setValuesStr",&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Set, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Set_setValuesStr" "', argument " "1"" of type '" "ampl::Set *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Set * >(argp1);
  {
    /* Check if is a list */
    if (PyList_Check(obj1)) {
      int size = PyList_Size(obj1);
      int i = 0;
      arg2 = (char **)malloc((size + 1) * sizeof(char *));
      for (i = 0; i < size; i++) {
        PyObject *obj = PyList_GetItem(obj1,i);
        if (_PyString_Check(obj)) {
          arg2[i] = _PyString_AsString(PyList_GetItem(obj1,i));
        } else {
          PyErr_SetString(PyExc_TypeError,"list must contain strings");
          free(arg2);
          return NULL;
        }
      }
      arg2[i] = 0;
    }
    else {
      PyErr_SetString(PyExc_TypeError,"not a list");
      return NULL;
    }
  }
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Set_setValuesStr" "', argument " "3"" of type '" "std::size_t""'");
  } 
  arg3 = static_cast< std::size_t >(val3);
  {
    try {
      ampl_Set_setValues(arg1,(char const *(*))arg2,arg3);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  {
    free((char *)arg2);
  }
  return resultobj;
fail:
  {
    free((char *)arg2);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_Set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Set *arg1 = (ampl::Set *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_Set takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Set, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Set" "', argument " "1"" of type '" "ampl::Set *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Set * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_isSymbolic(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Parameter *arg1 = (ampl::Parameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Parameter_isSymbolic takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_isSymbolic" "', argument " "1"" of type '" "ampl::Parameter *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Parameter * >(argp1);
  {
    try {
      result = (bool)(arg1)->isSymbolic();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_hasDefault(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Parameter *arg1 = (ampl::Parameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Parameter_hasDefault takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_hasDefault" "', argument " "1"" of type '" "ampl::Parameter *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Parameter * >(argp1);
  {
    try {
      result = (bool)(arg1)->hasDefault();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_set__SWIG_0(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Parameter *arg1 = (ampl::Parameter *) 0 ;
  SwigValueWrapper< ampl::Variant > arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Parameter_set",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_set" "', argument " "1"" of type '" "ampl::Parameter *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Parameter * >(argp1);
  {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__Variant,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Parameter_set" "', argument " "2"" of type '" "ampl::Variant""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Parameter_set" "', argument " "2"" of type '" "ampl::Variant""'");
    } else {
      ampl::Variant * temp = reinterpret_cast< ampl::Variant * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      ampl_Parameter_set__SWIG_0(arg1,arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_set__SWIG_1(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Parameter *arg1 = (ampl::Parameter *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Parameter_set",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_set" "', argument " "1"" of type '" "ampl::Parameter *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Parameter * >(argp1);
  ecode2 = SWIG_AsVal_double(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Parameter_set" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try {
      ampl_Parameter_set__SWIG_1(arg1,arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_set__SWIG_2(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Parameter *arg1 = (ampl::Parameter *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Parameter_set",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_set" "', argument " "1"" of type '" "ampl::Parameter *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Parameter * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Parameter_set" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      ampl_Parameter_set__SWIG_2(arg1,(char const *)arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_set__SWIG_3(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Parameter *arg1 = (ampl::Parameter *) 0 ;
  ampl::Tuple arg2 ;
  SwigValueWrapper< ampl::Variant > arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Parameter_set",&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_set" "', argument " "1"" of type '" "ampl::Parameter *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Parameter * >(argp1);
  {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__Tuple,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Parameter_set" "', argument " "2"" of type '" "ampl::Tuple""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Parameter_set" "', argument " "2"" of type '" "ampl::Tuple""'");
    } else {
      ampl::Tuple * temp = reinterpret_cast< ampl::Tuple * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_ampl__Variant,  0  | 0);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Parameter_set" "', argument " "3"" of type '" "ampl::Variant""'"); 
    }  
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Parameter_set" "', argument " "3"" of type '" "ampl::Variant""'");
    } else {
      ampl::Variant * temp = reinterpret_cast< ampl::Variant * >(argp3);
      arg3 = *temp;
      if (SWIG_IsNewObj(res3)) delete temp;
    }
  }
  {
    try {
      ampl_Parameter_set__SWIG_3(arg1,arg2,arg3);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_set(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  Py_ssize_t ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = args ? PyObject_Length(args) : 0;
  argv[0] = self;
  for (ii = 0; (ii < 2) && (ii < argc); ii++) {
    argv[ii + 1] = PyTuple_GET_ITEM(args,ii);
  }
  argc++;
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__Parameter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_ampl__Variant, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Parameter_set__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__Parameter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Parameter_set__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__Parameter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Parameter_set__SWIG_2(self, args);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__Parameter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_ampl__Tuple, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_ConvertPtr(argv[2], 0, SWIGTYPE_p_ampl__Variant, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_Parameter_set__SWIG_3(self, args);
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'Parameter_set'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    ampl::Parameter::set(ampl::Variant)\n"
    "    ampl::Parameter::set(double)\n"
    "    ampl::Parameter::set(char const *)\n"
    "    ampl::Parameter::set(ampl::Tuple,ampl::Variant)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_Parameter_setTplDbl(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Parameter *arg1 = (ampl::Parameter *) 0 ;
  ampl::Tuple arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Parameter_setTplDbl",&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_setTplDbl" "', argument " "1"" of type '" "ampl::Parameter *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Parameter * >(argp1);
  {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__Tuple,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Parameter_setTplDbl" "', argument " "2"" of type '" "ampl::Tuple""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Parameter_setTplDbl" "', argument " "2"" of type '" "ampl::Tuple""'");
    } else {
      ampl::Tuple * temp = reinterpret_cast< ampl::Tuple * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  ecode3 = SWIG_AsVal_double(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Parameter_setTplDbl" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  {
    try {
      ampl_Parameter_set(arg1,arg2,arg3);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_setTplStr(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Parameter *arg1 = (ampl::Parameter *) 0 ;
  ampl::Tuple arg2 ;
  char *arg3 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Parameter_setTplStr",&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_setTplStr" "', argument " "1"" of type '" "ampl::Parameter *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Parameter * >(argp1);
  {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__Tuple,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Parameter_setTplStr" "', argument " "2"" of type '" "ampl::Tuple""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Parameter_setTplStr" "', argument " "2"" of type '" "ampl::Tuple""'");
    } else {
      ampl::Tuple * temp = reinterpret_cast< ampl::Tuple * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  res3 = SWIG_AsCharPtrAndSize(obj2, &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Parameter_setTplStr" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = reinterpret_cast< char * >(buf3);
  {
    try {
      ampl_Parameter_set(arg1,arg2,(char const *)arg3);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return resultobj;
fail:
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_setValuesTaDbl(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Parameter *arg1 = (ampl::Parameter *) 0 ;
  TupleArray *arg2 = 0 ;
  double *arg3 = (double *) 0 ;
  std::size_t arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  size_t val4 ;
  int ecode4 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:Parameter_setValuesTaDbl",&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_setValuesTaDbl" "', argument " "1"" of type '" "ampl::Parameter *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Parameter * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_TupleArray,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Parameter_setValuesTaDbl" "', argument " "2"" of type '" "TupleArray &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Parameter_setValuesTaDbl" "', argument " "2"" of type '" "TupleArray &""'"); 
  }
  arg2 = reinterpret_cast< TupleArray * >(argp2);
  {
    /* Check if is a list */
    if (PyList_Check(obj2)) {
      int size = PyList_Size(obj2);
      int i = 0;
      arg3 = (double *)malloc(size * sizeof(double));
      for (i = 0; i < size; i++) {
        PyObject *o = PyList_GetItem(obj2,i);
        if (PyFloat_Check(o))
        arg3[i] = PyFloat_AsDouble(PyList_GetItem(obj2,i));
        else {
          PyErr_SetString(PyExc_TypeError, "The input list must contain floating point numbers");
          free(arg3);
          return NULL;
        }
      }
    }
    else {
      PyErr_SetString(PyExc_TypeError,"The input is not a list");
      return NULL;
    }
  }
  ecode4 = SWIG_AsVal_size_t(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Parameter_setValuesTaDbl" "', argument " "4"" of type '" "std::size_t""'");
  } 
  arg4 = static_cast< std::size_t >(val4);
  {
    try {
      ampl_Parameter_setValues(arg1,*arg2,arg3,arg4);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  {
    free((double *)arg3);
  }
  return resultobj;
fail:
  {
    free((double *)arg3);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_setValuesTaStr(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Parameter *arg1 = (ampl::Parameter *) 0 ;
  TupleArray *arg2 = 0 ;
  char **arg3 ;
  std::size_t arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  size_t val4 ;
  int ecode4 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  {
    arg3 = NULL;
  }
  if (!PyArg_ParseTuple(args,(char *)"OOO:Parameter_setValuesTaStr",&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_setValuesTaStr" "', argument " "1"" of type '" "ampl::Parameter *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Parameter * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_TupleArray,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Parameter_setValuesTaStr" "', argument " "2"" of type '" "TupleArray &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Parameter_setValuesTaStr" "', argument " "2"" of type '" "TupleArray &""'"); 
  }
  arg2 = reinterpret_cast< TupleArray * >(argp2);
  {
    /* Check if is a list */
    if (PyList_Check(obj2)) {
      int size = PyList_Size(obj2);
      int i = 0;
      arg3 = (char **)malloc((size + 1) * sizeof(char *));
      for (i = 0; i < size; i++) {
        PyObject *obj = PyList_GetItem(obj2,i);
        if (_PyString_Check(obj)) {
          arg3[i] = _PyString_AsString(PyList_GetItem(obj2,i));
        } else {
          PyErr_SetString(PyExc_TypeError,"list must contain strings");
          free(arg3);
          return NULL;
        }
      }
      arg3[i] = 0;
    }
    else {
      PyErr_SetString(PyExc_TypeError,"not a list");
      return NULL;
    }
  }
  ecode4 = SWIG_AsVal_size_t(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Parameter_setValuesTaStr" "', argument " "4"" of type '" "std::size_t""'");
  } 
  arg4 = static_cast< std::size_t >(val4);
  {
    try {
      ampl_Parameter_setValues(arg1,*arg2,(char const *(*))arg3,arg4);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  {
    free((char *)arg3);
  }
  return resultobj;
fail:
  {
    free((char *)arg3);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_setValuesDbl(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Parameter *arg1 = (ampl::Parameter *) 0 ;
  double *arg2 = (double *) 0 ;
  std::size_t arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Parameter_setValuesDbl",&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_setValuesDbl" "', argument " "1"" of type '" "ampl::Parameter *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Parameter * >(argp1);
  {
    /* Check if is a list */
    if (PyList_Check(obj1)) {
      int size = PyList_Size(obj1);
      int i = 0;
      arg2 = (double *)malloc(size * sizeof(double));
      for (i = 0; i < size; i++) {
        PyObject *o = PyList_GetItem(obj1,i);
        if (PyFloat_Check(o))
        arg2[i] = PyFloat_AsDouble(PyList_GetItem(obj1,i));
        else {
          PyErr_SetString(PyExc_TypeError, "The input list must contain floating point numbers");
          free(arg2);
          return NULL;
        }
      }
    }
    else {
      PyErr_SetString(PyExc_TypeError,"The input is not a list");
      return NULL;
    }
  }
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Parameter_setValuesDbl" "', argument " "3"" of type '" "std::size_t""'");
  } 
  arg3 = static_cast< std::size_t >(val3);
  {
    try {
      ampl_Parameter_setValues(arg1,arg2,arg3);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  {
    free((double *)arg2);
  }
  return resultobj;
fail:
  {
    free((double *)arg2);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_setValuesStr(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Parameter *arg1 = (ampl::Parameter *) 0 ;
  char **arg2 ;
  std::size_t arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  {
    arg2 = NULL;
  }
  if (!PyArg_ParseTuple(args,(char *)"OO:Parameter_setValuesStr",&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_setValuesStr" "', argument " "1"" of type '" "ampl::Parameter *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Parameter * >(argp1);
  {
    /* Check if is a list */
    if (PyList_Check(obj1)) {
      int size = PyList_Size(obj1);
      int i = 0;
      arg2 = (char **)malloc((size + 1) * sizeof(char *));
      for (i = 0; i < size; i++) {
        PyObject *obj = PyList_GetItem(obj1,i);
        if (_PyString_Check(obj)) {
          arg2[i] = _PyString_AsString(PyList_GetItem(obj1,i));
        } else {
          PyErr_SetString(PyExc_TypeError,"list must contain strings");
          free(arg2);
          return NULL;
        }
      }
      arg2[i] = 0;
    }
    else {
      PyErr_SetString(PyExc_TypeError,"not a list");
      return NULL;
    }
  }
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Parameter_setValuesStr" "', argument " "3"" of type '" "std::size_t""'");
  } 
  arg3 = static_cast< std::size_t >(val3);
  {
    try {
      ampl_Parameter_setValues(arg1,(char const *(*))arg2,arg3);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  {
    free((char *)arg2);
  }
  return resultobj;
fail:
  {
    free((char *)arg2);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_setValues__SWIG_0(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Parameter *arg1 = (ampl::Parameter *) 0 ;
  std::size_t arg2 ;
  char **arg3 ;
  std::size_t arg4 ;
  char **arg5 ;
  double *arg6 = (double *) 0 ;
  bool arg7 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  size_t val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  bool val7 ;
  int ecode7 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOOO:Parameter_setValues",&obj1,&obj2,&obj3,&obj4,&obj5,&obj6)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_setValues" "', argument " "1"" of type '" "ampl::Parameter *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Parameter * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Parameter_setValues" "', argument " "2"" of type '" "std::size_t""'");
  } 
  arg2 = static_cast< std::size_t >(val2);
  res3 = SWIG_ConvertPtr(obj2, &argp3,SWIGTYPE_p_p_char, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Parameter_setValues" "', argument " "3"" of type '" "char const *[]""'"); 
  } 
  arg3 = reinterpret_cast< char ** >(argp3);
  ecode4 = SWIG_AsVal_size_t(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Parameter_setValues" "', argument " "4"" of type '" "std::size_t""'");
  } 
  arg4 = static_cast< std::size_t >(val4);
  res5 = SWIG_ConvertPtr(obj4, &argp5,SWIGTYPE_p_p_char, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "Parameter_setValues" "', argument " "5"" of type '" "char const *[]""'"); 
  } 
  arg5 = reinterpret_cast< char ** >(argp5);
  {
    /* Check if is a list */
    if (PyList_Check(obj5)) {
      int size = PyList_Size(obj5);
      int i = 0;
      arg6 = (double *)malloc(size * sizeof(double));
      for (i = 0; i < size; i++) {
        PyObject *o = PyList_GetItem(obj5,i);
        if (PyFloat_Check(o))
        arg6[i] = PyFloat_AsDouble(PyList_GetItem(obj5,i));
        else {
          PyErr_SetString(PyExc_TypeError, "The input list must contain floating point numbers");
          free(arg6);
          return NULL;
        }
      }
    }
    else {
      PyErr_SetString(PyExc_TypeError,"The input is not a list");
      return NULL;
    }
  }
  ecode7 = SWIG_AsVal_bool(obj6, &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "Parameter_setValues" "', argument " "7"" of type '" "bool""'");
  } 
  arg7 = static_cast< bool >(val7);
  {
    try {
      ampl_Parameter_setValues__SWIG_0(arg1,arg2,(char const *(*))arg3,arg4,(char const *(*))arg5,(double const *)arg6,arg7);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  {
    free((double *)arg6);
  }
  return resultobj;
fail:
  {
    free((double *)arg6);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_setValues__SWIG_1(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Parameter *arg1 = (ampl::Parameter *) 0 ;
  std::size_t arg2 ;
  double *arg3 = (double *) 0 ;
  std::size_t arg4 ;
  double *arg5 = (double *) 0 ;
  double *arg6 = (double *) 0 ;
  bool arg7 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  size_t val4 ;
  int ecode4 = 0 ;
  bool val7 ;
  int ecode7 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOOO:Parameter_setValues",&obj1,&obj2,&obj3,&obj4,&obj5,&obj6)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_setValues" "', argument " "1"" of type '" "ampl::Parameter *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Parameter * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Parameter_setValues" "', argument " "2"" of type '" "std::size_t""'");
  } 
  arg2 = static_cast< std::size_t >(val2);
  {
    /* Check if is a list */
    if (PyList_Check(obj2)) {
      int size = PyList_Size(obj2);
      int i = 0;
      arg3 = (double *)malloc(size * sizeof(double));
      for (i = 0; i < size; i++) {
        PyObject *o = PyList_GetItem(obj2,i);
        if (PyFloat_Check(o))
        arg3[i] = PyFloat_AsDouble(PyList_GetItem(obj2,i));
        else {
          PyErr_SetString(PyExc_TypeError, "The input list must contain floating point numbers");
          free(arg3);
          return NULL;
        }
      }
    }
    else {
      PyErr_SetString(PyExc_TypeError,"The input is not a list");
      return NULL;
    }
  }
  ecode4 = SWIG_AsVal_size_t(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Parameter_setValues" "', argument " "4"" of type '" "std::size_t""'");
  } 
  arg4 = static_cast< std::size_t >(val4);
  {
    /* Check if is a list */
    if (PyList_Check(obj4)) {
      int size = PyList_Size(obj4);
      int i = 0;
      arg5 = (double *)malloc(size * sizeof(double));
      for (i = 0; i < size; i++) {
        PyObject *o = PyList_GetItem(obj4,i);
        if (PyFloat_Check(o))
        arg5[i] = PyFloat_AsDouble(PyList_GetItem(obj4,i));
        else {
          PyErr_SetString(PyExc_TypeError, "The input list must contain floating point numbers");
          free(arg5);
          return NULL;
        }
      }
    }
    else {
      PyErr_SetString(PyExc_TypeError,"The input is not a list");
      return NULL;
    }
  }
  {
    /* Check if is a list */
    if (PyList_Check(obj5)) {
      int size = PyList_Size(obj5);
      int i = 0;
      arg6 = (double *)malloc(size * sizeof(double));
      for (i = 0; i < size; i++) {
        PyObject *o = PyList_GetItem(obj5,i);
        if (PyFloat_Check(o))
        arg6[i] = PyFloat_AsDouble(PyList_GetItem(obj5,i));
        else {
          PyErr_SetString(PyExc_TypeError, "The input list must contain floating point numbers");
          free(arg6);
          return NULL;
        }
      }
    }
    else {
      PyErr_SetString(PyExc_TypeError,"The input is not a list");
      return NULL;
    }
  }
  ecode7 = SWIG_AsVal_bool(obj6, &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "Parameter_setValues" "', argument " "7"" of type '" "bool""'");
  } 
  arg7 = static_cast< bool >(val7);
  {
    try {
      ampl_Parameter_setValues__SWIG_1(arg1,arg2,arg3,arg4,arg5,(double const *)arg6,arg7);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  {
    free((double *)arg3);
  }
  {
    free((double *)arg5);
  }
  {
    free((double *)arg6);
  }
  return resultobj;
fail:
  {
    free((double *)arg3);
  }
  {
    free((double *)arg5);
  }
  {
    free((double *)arg6);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_setValues(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[8] = {
    0
  };
  Py_ssize_t ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = args ? PyObject_Length(args) : 0;
  argv[0] = self;
  for (ii = 0; (ii < 6) && (ii < argc); ii++) {
    argv[ii + 1] = PyTuple_GET_ITEM(args,ii);
  }
  argc++;
  if (argc == 7) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__Parameter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_p_char, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_size_t(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            void *vptr = 0;
            int res = SWIG_ConvertPtr(argv[4], &vptr, SWIGTYPE_p_p_char, 0);
            _v = SWIG_CheckState(res);
            if (_v) {
              void *vptr = 0;
              int res = SWIG_ConvertPtr(argv[5], &vptr, SWIGTYPE_p_double, 0);
              _v = SWIG_CheckState(res);
              if (_v) {
                {
                  int res = SWIG_AsVal_bool(argv[6], NULL);
                  _v = SWIG_CheckState(res);
                }
                if (_v) {
                  return _wrap_Parameter_setValues__SWIG_0(self, args);
                }
              }
            }
          }
        }
      }
    }
  }
  if (argc == 7) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__Parameter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_double, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_size_t(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            void *vptr = 0;
            int res = SWIG_ConvertPtr(argv[4], &vptr, SWIGTYPE_p_double, 0);
            _v = SWIG_CheckState(res);
            if (_v) {
              void *vptr = 0;
              int res = SWIG_ConvertPtr(argv[5], &vptr, SWIGTYPE_p_double, 0);
              _v = SWIG_CheckState(res);
              if (_v) {
                {
                  int res = SWIG_AsVal_bool(argv[6], NULL);
                  _v = SWIG_CheckState(res);
                }
                if (_v) {
                  return _wrap_Parameter_setValues__SWIG_1(self, args);
                }
              }
            }
          }
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'Parameter_setValues'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    ampl::Parameter::setValues(std::size_t,char const *[],std::size_t,char const *[],double const *,bool)\n"
    "    ampl::Parameter::setValues(std::size_t,double *,std::size_t,double *,double const *,bool)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_delete_Parameter(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Parameter *arg1 = (ampl::Parameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_Parameter takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Parameter, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Parameter" "', argument " "1"" of type '" "ampl::Parameter *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Parameter * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_VariableIteratorWrapper(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::EntityWrapper< ampl::VariableInstance > *arg1 = (ampl::internal::EntityWrapper< ampl::VariableInstance > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_VariableIteratorWrapper takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__EntityWrapperT_ampl__VariableInstance_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_VariableIteratorWrapper" "', argument " "1"" of type '" "ampl::internal::EntityWrapper< ampl::VariableInstance > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::EntityWrapper< ampl::VariableInstance > * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariableIterator_equals(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > *) 0 ;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:VariableIterator_equals",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariableIterator_equals" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VariableIterator_equals" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VariableIterator_equals" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > * >(argp2);
  {
    try {
      result = (bool)((ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > const *)arg1)->operator ==((ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariableIterator_differs(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > *) 0 ;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:VariableIterator_differs",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariableIterator_differs" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VariableIterator_differs" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VariableIterator_differs" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > * >(argp2);
  {
    try {
      result = (bool)((ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > const *)arg1)->operator !=((ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariableIterator_clone(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > *) 0 ;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:VariableIterator_clone",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariableIterator_clone" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VariableIterator_clone" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VariableIterator_clone" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > * >(argp2);
  {
    try {
      result = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > *) &(arg1)->operator =((ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariableIterator_postIncrement(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > *result = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "VariableIterator_postIncrement takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariableIterator_postIncrement" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > * >(argp1);
  {
    try {
      result = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > *) &(arg1)->operator ++();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariableIterator_postIncrementBy(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj1 = 0 ;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:VariableIterator_postIncrementBy",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariableIterator_postIncrementBy" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VariableIterator_postIncrementBy" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  {
    try {
      result = (arg1)->operator ++(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > >(static_cast< const ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > >& >(result))), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariableIterator_first(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< ampl::TupleRef > result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "VariableIterator_first takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariableIterator_first" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > * >(argp1);
  {
    try {
      result = ampl_internal_CountedIterator_Sl_ampl_internal_EntityWrapper_Sl_ampl_VariableInstance_Sg__Sg__first(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::internal::EntityWrapper< ampl::VariableInstance >::KeyType(static_cast< const ampl::internal::EntityWrapper< ampl::VariableInstance >::KeyType& >(result))), SWIGTYPE_p_ampl__TupleRef, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_VariableIterator_second(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< ampl::VariableInstance > result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "VariableIterator_second takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VariableIterator_second" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > * >(argp1);
  {
    try {
      result = ampl_internal_CountedIterator_Sl_ampl_internal_EntityWrapper_Sl_ampl_VariableInstance_Sg__Sg__second(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::internal::EntityWrapper< ampl::VariableInstance >::InstanceType(static_cast< const ampl::internal::EntityWrapper< ampl::VariableInstance >::InstanceType& >(result))), SWIGTYPE_p_ampl__VariableInstance, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_VariableIterator(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_VariableIterator takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_VariableIterator" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ConstraintIteratorWrapper(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::EntityWrapper< ampl::ConstraintInstance > *arg1 = (ampl::internal::EntityWrapper< ampl::ConstraintInstance > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_ConstraintIteratorWrapper takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ConstraintIteratorWrapper" "', argument " "1"" of type '" "ampl::internal::EntityWrapper< ampl::ConstraintInstance > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::EntityWrapper< ampl::ConstraintInstance > * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ConstraintIterator_equals(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > *) 0 ;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ConstraintIterator_equals",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConstraintIterator_equals" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ConstraintIterator_equals" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ConstraintIterator_equals" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > * >(argp2);
  {
    try {
      result = (bool)((ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > const *)arg1)->operator ==((ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ConstraintIterator_differs(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > *) 0 ;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ConstraintIterator_differs",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConstraintIterator_differs" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ConstraintIterator_differs" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ConstraintIterator_differs" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > * >(argp2);
  {
    try {
      result = (bool)((ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > const *)arg1)->operator !=((ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ConstraintIterator_clone(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > *) 0 ;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ConstraintIterator_clone",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConstraintIterator_clone" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ConstraintIterator_clone" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ConstraintIterator_clone" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > * >(argp2);
  {
    try {
      result = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > *) &(arg1)->operator =((ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ConstraintIterator_postIncrement(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > *result = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "ConstraintIterator_postIncrement takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConstraintIterator_postIncrement" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > * >(argp1);
  {
    try {
      result = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > *) &(arg1)->operator ++();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ConstraintIterator_postIncrementBy(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj1 = 0 ;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ConstraintIterator_postIncrementBy",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConstraintIterator_postIncrementBy" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ConstraintIterator_postIncrementBy" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  {
    try {
      result = (arg1)->operator ++(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > >(static_cast< const ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > >& >(result))), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ConstraintIterator_first(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< ampl::TupleRef > result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "ConstraintIterator_first takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConstraintIterator_first" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > * >(argp1);
  {
    try {
      result = ampl_internal_CountedIterator_Sl_ampl_internal_EntityWrapper_Sl_ampl_ConstraintInstance_Sg__Sg__first(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::internal::EntityWrapper< ampl::ConstraintInstance >::KeyType(static_cast< const ampl::internal::EntityWrapper< ampl::ConstraintInstance >::KeyType& >(result))), SWIGTYPE_p_ampl__TupleRef, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ConstraintIterator_second(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< ampl::ConstraintInstance > result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "ConstraintIterator_second takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConstraintIterator_second" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > * >(argp1);
  {
    try {
      result = ampl_internal_CountedIterator_Sl_ampl_internal_EntityWrapper_Sl_ampl_ConstraintInstance_Sg__Sg__second(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::internal::EntityWrapper< ampl::ConstraintInstance >::InstanceType(static_cast< const ampl::internal::EntityWrapper< ampl::ConstraintInstance >::InstanceType& >(result))), SWIGTYPE_p_ampl__ConstraintInstance, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ConstraintIterator(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_ConstraintIterator takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ConstraintIterator" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ObjectiveIteratorWrapper(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::EntityWrapper< ampl::ObjectiveInstance > *arg1 = (ampl::internal::EntityWrapper< ampl::ObjectiveInstance > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_ObjectiveIteratorWrapper takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ObjectiveIteratorWrapper" "', argument " "1"" of type '" "ampl::internal::EntityWrapper< ampl::ObjectiveInstance > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ObjectiveIterator_equals(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > *) 0 ;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ObjectiveIterator_equals",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ObjectiveIterator_equals" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ObjectiveIterator_equals" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ObjectiveIterator_equals" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > * >(argp2);
  {
    try {
      result = (bool)((ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > const *)arg1)->operator ==((ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ObjectiveIterator_differs(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > *) 0 ;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ObjectiveIterator_differs",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ObjectiveIterator_differs" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ObjectiveIterator_differs" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ObjectiveIterator_differs" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > * >(argp2);
  {
    try {
      result = (bool)((ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > const *)arg1)->operator !=((ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ObjectiveIterator_clone(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > *) 0 ;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ObjectiveIterator_clone",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ObjectiveIterator_clone" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ObjectiveIterator_clone" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ObjectiveIterator_clone" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > * >(argp2);
  {
    try {
      result = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > *) &(arg1)->operator =((ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ObjectiveIterator_postIncrement(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > *result = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "ObjectiveIterator_postIncrement takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ObjectiveIterator_postIncrement" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > * >(argp1);
  {
    try {
      result = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > *) &(arg1)->operator ++();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ObjectiveIterator_postIncrementBy(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj1 = 0 ;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ObjectiveIterator_postIncrementBy",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ObjectiveIterator_postIncrementBy" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ObjectiveIterator_postIncrementBy" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  {
    try {
      result = (arg1)->operator ++(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > >(static_cast< const ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > >& >(result))), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ObjectiveIterator_first(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< ampl::TupleRef > result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "ObjectiveIterator_first takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ObjectiveIterator_first" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > * >(argp1);
  {
    try {
      result = ampl_internal_CountedIterator_Sl_ampl_internal_EntityWrapper_Sl_ampl_ObjectiveInstance_Sg__Sg__first(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::internal::EntityWrapper< ampl::ObjectiveInstance >::KeyType(static_cast< const ampl::internal::EntityWrapper< ampl::ObjectiveInstance >::KeyType& >(result))), SWIGTYPE_p_ampl__TupleRef, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ObjectiveIterator_second(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< ampl::ObjectiveInstance > result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "ObjectiveIterator_second takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ObjectiveIterator_second" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > * >(argp1);
  {
    try {
      result = ampl_internal_CountedIterator_Sl_ampl_internal_EntityWrapper_Sl_ampl_ObjectiveInstance_Sg__Sg__second(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::internal::EntityWrapper< ampl::ObjectiveInstance >::InstanceType(static_cast< const ampl::internal::EntityWrapper< ampl::ObjectiveInstance >::InstanceType& >(result))), SWIGTYPE_p_ampl__ObjectiveInstance, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ObjectiveIterator(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_ObjectiveIterator takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ObjectiveIterator" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_SetIteratorWrapper(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::EntityWrapper< ampl::SetInstance > *arg1 = (ampl::internal::EntityWrapper< ampl::SetInstance > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_SetIteratorWrapper takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__EntityWrapperT_ampl__SetInstance_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SetIteratorWrapper" "', argument " "1"" of type '" "ampl::internal::EntityWrapper< ampl::SetInstance > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::EntityWrapper< ampl::SetInstance > * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SetIterator_equals(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > *) 0 ;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SetIterator_equals",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetIterator_equals" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetIterator_equals" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetIterator_equals" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > * >(argp2);
  {
    try {
      result = (bool)((ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > const *)arg1)->operator ==((ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SetIterator_differs(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > *) 0 ;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SetIterator_differs",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetIterator_differs" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetIterator_differs" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetIterator_differs" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > * >(argp2);
  {
    try {
      result = (bool)((ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > const *)arg1)->operator !=((ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SetIterator_clone(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > *) 0 ;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SetIterator_clone",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetIterator_clone" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetIterator_clone" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetIterator_clone" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > * >(argp2);
  {
    try {
      result = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > *) &(arg1)->operator =((ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SetIterator_postIncrement(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > *result = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "SetIterator_postIncrement takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetIterator_postIncrement" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > * >(argp1);
  {
    try {
      result = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > *) &(arg1)->operator ++();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SetIterator_postIncrementBy(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj1 = 0 ;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SetIterator_postIncrementBy",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetIterator_postIncrementBy" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetIterator_postIncrementBy" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  {
    try {
      result = (arg1)->operator ++(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > >(static_cast< const ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > >& >(result))), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SetIterator_first(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< ampl::TupleRef > result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "SetIterator_first takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetIterator_first" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > * >(argp1);
  {
    try {
      result = ampl_internal_CountedIterator_Sl_ampl_internal_EntityWrapper_Sl_ampl_SetInstance_Sg__Sg__first(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::internal::EntityWrapper< ampl::SetInstance >::KeyType(static_cast< const ampl::internal::EntityWrapper< ampl::SetInstance >::KeyType& >(result))), SWIGTYPE_p_ampl__TupleRef, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SetIterator_second(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< ampl::SetInstance > result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "SetIterator_second takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetIterator_second" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > * >(argp1);
  {
    try {
      result = ampl_internal_CountedIterator_Sl_ampl_internal_EntityWrapper_Sl_ampl_SetInstance_Sg__Sg__second(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::internal::EntityWrapper< ampl::SetInstance >::InstanceType(static_cast< const ampl::internal::EntityWrapper< ampl::SetInstance >::InstanceType& >(result))), SWIGTYPE_p_ampl__SetInstance, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_SetIterator(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_SetIterator takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SetIterator" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ParameterIteratorWrapper(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::EntityWrapper< ampl::VariantRef > *arg1 = (ampl::internal::EntityWrapper< ampl::VariantRef > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_ParameterIteratorWrapper takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__EntityWrapperT_ampl__VariantRef_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ParameterIteratorWrapper" "', argument " "1"" of type '" "ampl::internal::EntityWrapper< ampl::VariantRef > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::EntityWrapper< ampl::VariantRef > * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ParameterIterator_equals(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > *) 0 ;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ParameterIterator_equals",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ParameterIterator_equals" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ParameterIterator_equals" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ParameterIterator_equals" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > * >(argp2);
  {
    try {
      result = (bool)((ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > const *)arg1)->operator ==((ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ParameterIterator_differs(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > *) 0 ;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ParameterIterator_differs",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ParameterIterator_differs" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ParameterIterator_differs" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ParameterIterator_differs" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > * >(argp2);
  {
    try {
      result = (bool)((ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > const *)arg1)->operator !=((ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ParameterIterator_clone(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > *) 0 ;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ParameterIterator_clone",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ParameterIterator_clone" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ParameterIterator_clone" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ParameterIterator_clone" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > * >(argp2);
  {
    try {
      result = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > *) &(arg1)->operator =((ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ParameterIterator_postIncrement(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > *result = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "ParameterIterator_postIncrement takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ParameterIterator_postIncrement" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > * >(argp1);
  {
    try {
      result = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > *) &(arg1)->operator ++();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ParameterIterator_postIncrementBy(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj1 = 0 ;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ParameterIterator_postIncrementBy",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ParameterIterator_postIncrementBy" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ParameterIterator_postIncrementBy" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  {
    try {
      result = (arg1)->operator ++(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > >(static_cast< const ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > >& >(result))), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ParameterIterator_first(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< ampl::TupleRef > result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "ParameterIterator_first takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ParameterIterator_first" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > * >(argp1);
  {
    try {
      result = ampl_internal_CountedIterator_Sl_ampl_internal_EntityWrapper_Sl_ampl_VariantRef_Sg__Sg__first(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::internal::EntityWrapper< ampl::VariantRef >::KeyType(static_cast< const ampl::internal::EntityWrapper< ampl::VariantRef >::KeyType& >(result))), SWIGTYPE_p_ampl__TupleRef, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ParameterIterator_second(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< ampl::VariantRef > result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "ParameterIterator_second takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ParameterIterator_second" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > * >(argp1);
  {
    try {
      result = ampl_internal_CountedIterator_Sl_ampl_internal_EntityWrapper_Sl_ampl_VariantRef_Sg__Sg__second(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::internal::EntityWrapper< ampl::VariantRef >::InstanceType(static_cast< const ampl::internal::EntityWrapper< ampl::VariantRef >::InstanceType& >(result))), SWIGTYPE_p_ampl__VariantRef, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ParameterIterator(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_ParameterIterator takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ParameterIterator" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapVariable_begin(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Variable > *arg1 = (ampl::EntityMap< ampl::Variable > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ampl::EntityMap< ampl::Variable >::iterator result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "EntityMapVariable_begin takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Variable_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapVariable_begin" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Variable > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Variable > * >(argp1);
  {
    try {
      result = ((ampl::EntityMap< ampl::Variable > const *)arg1)->begin();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::EntityMap< ampl::Variable >::iterator(static_cast< const ampl::EntityMap< ampl::Variable >::iterator& >(result))), SWIGTYPE_p_ampl__EntityMapT_ampl__Variable_t__iterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapVariable_end(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Variable > *arg1 = (ampl::EntityMap< ampl::Variable > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ampl::EntityMap< ampl::Variable >::iterator result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "EntityMapVariable_end takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Variable_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapVariable_end" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Variable > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Variable > * >(argp1);
  {
    try {
      result = ((ampl::EntityMap< ampl::Variable > const *)arg1)->end();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::EntityMap< ampl::Variable >::iterator(static_cast< const ampl::EntityMap< ampl::Variable >::iterator& >(result))), SWIGTYPE_p_ampl__EntityMapT_ampl__Variable_t__iterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapVariable_find(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Variable > *arg1 = (ampl::EntityMap< ampl::Variable > *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject * obj1 = 0 ;
  ampl::EntityMap< ampl::Variable >::iterator result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:EntityMapVariable_find",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Variable_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapVariable_find" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Variable > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Variable > * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "EntityMapVariable_find" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      result = (arg1)->find(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::EntityMap< ampl::Variable >::iterator(static_cast< const ampl::EntityMap< ampl::Variable >::iterator& >(result))), SWIGTYPE_p_ampl__EntityMapT_ampl__Variable_t__iterator, SWIG_POINTER_OWN |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapVariable_size(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Variable > *arg1 = (ampl::EntityMap< ampl::Variable > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::size_t result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "EntityMapVariable_size takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Variable_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapVariable_size" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Variable > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Variable > * >(argp1);
  {
    try {
      result = (std::size_t)((ampl::EntityMap< ampl::Variable > const *)arg1)->size();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapVariable_getIndex(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Variable > *arg1 = (ampl::EntityMap< ampl::Variable > *) 0 ;
  fmt::CStringRef arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj1 = 0 ;
  SwigValueWrapper< ampl::Variable > result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:EntityMapVariable_getIndex",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Variable_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapVariable_getIndex" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Variable > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Variable > * >(argp1);
  
  arg2 = _PyString_AsString(obj1);
  
  {
    try {
      result = ((ampl::EntityMap< ampl::Variable > const *)arg1)->operator [](arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::Variable(static_cast< const ampl::Variable& >(result))), SWIGTYPE_p_ampl__Variable, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_EntityMapVariable(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Variable > *arg1 = (ampl::EntityMap< ampl::Variable > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_EntityMapVariable takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Variable_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_EntityMapVariable" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Variable > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Variable > * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapVariableIterator_equals(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Variable >::iterator *arg1 = (ampl::EntityMap< ampl::Variable >::iterator *) 0 ;
  ampl::EntityMap< ampl::Variable >::iterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:EntityMapVariableIterator_equals",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Variable_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapVariableIterator_equals" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Variable >::iterator const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Variable >::iterator * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__EntityMapT_ampl__Variable_t__iterator,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "EntityMapVariableIterator_equals" "', argument " "2"" of type '" "ampl::EntityMap< ampl::Variable >::iterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "EntityMapVariableIterator_equals" "', argument " "2"" of type '" "ampl::EntityMap< ampl::Variable >::iterator const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::EntityMap< ampl::Variable >::iterator * >(argp2);
  {
    try {
      result = (bool)((ampl::EntityMap< ampl::Variable >::iterator const *)arg1)->operator ==((ampl::EntityMap< ampl::Variable >::iterator const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapVariableIterator_differs(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Variable >::iterator *arg1 = (ampl::EntityMap< ampl::Variable >::iterator *) 0 ;
  ampl::EntityMap< ampl::Variable >::iterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:EntityMapVariableIterator_differs",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Variable_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapVariableIterator_differs" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Variable >::iterator const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Variable >::iterator * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__EntityMapT_ampl__Variable_t__iterator,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "EntityMapVariableIterator_differs" "', argument " "2"" of type '" "ampl::EntityMap< ampl::Variable >::iterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "EntityMapVariableIterator_differs" "', argument " "2"" of type '" "ampl::EntityMap< ampl::Variable >::iterator const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::EntityMap< ampl::Variable >::iterator * >(argp2);
  {
    try {
      result = (bool)((ampl::EntityMap< ampl::Variable >::iterator const *)arg1)->operator !=((ampl::EntityMap< ampl::Variable >::iterator const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapVariableIterator___ref__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Variable >::iterator *arg1 = (ampl::EntityMap< ampl::Variable >::iterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< ampl::Variable > result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "EntityMapVariableIterator___ref__ takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Variable_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapVariableIterator___ref__" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Variable >::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Variable >::iterator * >(argp1);
  {
    try {
      result = (arg1)->operator *();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::Variable(static_cast< const ampl::Variable& >(result))), SWIGTYPE_p_ampl__Variable, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGPY_BINARYFUNC_CLOSURE(_wrap_EntityMapVariableIterator___ref__)

SWIGINTERN PyObject *_wrap_EntityMapVariableIterator_clone(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Variable >::iterator *arg1 = (ampl::EntityMap< ampl::Variable >::iterator *) 0 ;
  ampl::EntityMap< ampl::Variable >::iterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  ampl::EntityMap< ampl::Variable >::iterator *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:EntityMapVariableIterator_clone",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Variable_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapVariableIterator_clone" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Variable >::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Variable >::iterator * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__EntityMapT_ampl__Variable_t__iterator,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "EntityMapVariableIterator_clone" "', argument " "2"" of type '" "ampl::EntityMap< ampl::Variable >::iterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "EntityMapVariableIterator_clone" "', argument " "2"" of type '" "ampl::EntityMap< ampl::Variable >::iterator const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::EntityMap< ampl::Variable >::iterator * >(argp2);
  {
    try {
      result = (ampl::EntityMap< ampl::Variable >::iterator *) &(arg1)->operator =((ampl::EntityMap< ampl::Variable >::iterator const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__EntityMapT_ampl__Variable_t__iterator, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapVariableIterator_postIncrement(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Variable >::iterator *arg1 = (ampl::EntityMap< ampl::Variable >::iterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ampl::EntityMap< ampl::Variable >::iterator *result = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "EntityMapVariableIterator_postIncrement takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Variable_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapVariableIterator_postIncrement" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Variable >::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Variable >::iterator * >(argp1);
  {
    try {
      result = (ampl::EntityMap< ampl::Variable >::iterator *) &(arg1)->operator ++();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__EntityMapT_ampl__Variable_t__iterator, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapVariableIterator_postIncrementBy(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Variable >::iterator *arg1 = (ampl::EntityMap< ampl::Variable >::iterator *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj1 = 0 ;
  ampl::EntityMap< ampl::Variable >::iterator result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:EntityMapVariableIterator_postIncrementBy",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Variable_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapVariableIterator_postIncrementBy" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Variable >::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Variable >::iterator * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "EntityMapVariableIterator_postIncrementBy" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  {
    try {
      result = (arg1)->operator ++(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::EntityMap< ampl::Variable >::iterator(static_cast< const ampl::EntityMap< ampl::Variable >::iterator& >(result))), SWIGTYPE_p_ampl__EntityMapT_ampl__Variable_t__iterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_EntityMapVariableIterator(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Variable >::iterator *arg1 = (ampl::EntityMap< ampl::Variable >::iterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_EntityMapVariableIterator takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Variable_t__iterator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_EntityMapVariableIterator" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Variable >::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Variable >::iterator * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapConstraint_begin(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Constraint > *arg1 = (ampl::EntityMap< ampl::Constraint > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ampl::EntityMap< ampl::Constraint >::iterator result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "EntityMapConstraint_begin takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Constraint_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapConstraint_begin" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Constraint > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Constraint > * >(argp1);
  {
    try {
      result = ((ampl::EntityMap< ampl::Constraint > const *)arg1)->begin();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::EntityMap< ampl::Constraint >::iterator(static_cast< const ampl::EntityMap< ampl::Constraint >::iterator& >(result))), SWIGTYPE_p_ampl__EntityMapT_ampl__Constraint_t__iterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapConstraint_end(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Constraint > *arg1 = (ampl::EntityMap< ampl::Constraint > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ampl::EntityMap< ampl::Constraint >::iterator result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "EntityMapConstraint_end takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Constraint_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapConstraint_end" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Constraint > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Constraint > * >(argp1);
  {
    try {
      result = ((ampl::EntityMap< ampl::Constraint > const *)arg1)->end();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::EntityMap< ampl::Constraint >::iterator(static_cast< const ampl::EntityMap< ampl::Constraint >::iterator& >(result))), SWIGTYPE_p_ampl__EntityMapT_ampl__Constraint_t__iterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapConstraint_find(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Constraint > *arg1 = (ampl::EntityMap< ampl::Constraint > *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject * obj1 = 0 ;
  ampl::EntityMap< ampl::Constraint >::iterator result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:EntityMapConstraint_find",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Constraint_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapConstraint_find" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Constraint > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Constraint > * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "EntityMapConstraint_find" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      result = (arg1)->find(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::EntityMap< ampl::Constraint >::iterator(static_cast< const ampl::EntityMap< ampl::Constraint >::iterator& >(result))), SWIGTYPE_p_ampl__EntityMapT_ampl__Constraint_t__iterator, SWIG_POINTER_OWN |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapConstraint_size(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Constraint > *arg1 = (ampl::EntityMap< ampl::Constraint > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::size_t result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "EntityMapConstraint_size takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Constraint_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapConstraint_size" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Constraint > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Constraint > * >(argp1);
  {
    try {
      result = (std::size_t)((ampl::EntityMap< ampl::Constraint > const *)arg1)->size();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapConstraint_getIndex(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Constraint > *arg1 = (ampl::EntityMap< ampl::Constraint > *) 0 ;
  fmt::CStringRef arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj1 = 0 ;
  SwigValueWrapper< ampl::Constraint > result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:EntityMapConstraint_getIndex",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Constraint_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapConstraint_getIndex" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Constraint > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Constraint > * >(argp1);
  
  arg2 = _PyString_AsString(obj1);
  
  {
    try {
      result = ((ampl::EntityMap< ampl::Constraint > const *)arg1)->operator [](arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::Constraint(static_cast< const ampl::Constraint& >(result))), SWIGTYPE_p_ampl__Constraint, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_EntityMapConstraint(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Constraint > *arg1 = (ampl::EntityMap< ampl::Constraint > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_EntityMapConstraint takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Constraint_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_EntityMapConstraint" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Constraint > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Constraint > * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapConstraintIterator_equals(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Constraint >::iterator *arg1 = (ampl::EntityMap< ampl::Constraint >::iterator *) 0 ;
  ampl::EntityMap< ampl::Constraint >::iterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:EntityMapConstraintIterator_equals",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Constraint_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapConstraintIterator_equals" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Constraint >::iterator const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Constraint >::iterator * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__EntityMapT_ampl__Constraint_t__iterator,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "EntityMapConstraintIterator_equals" "', argument " "2"" of type '" "ampl::EntityMap< ampl::Constraint >::iterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "EntityMapConstraintIterator_equals" "', argument " "2"" of type '" "ampl::EntityMap< ampl::Constraint >::iterator const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::EntityMap< ampl::Constraint >::iterator * >(argp2);
  {
    try {
      result = (bool)((ampl::EntityMap< ampl::Constraint >::iterator const *)arg1)->operator ==((ampl::EntityMap< ampl::Constraint >::iterator const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapConstraintIterator_differs(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Constraint >::iterator *arg1 = (ampl::EntityMap< ampl::Constraint >::iterator *) 0 ;
  ampl::EntityMap< ampl::Constraint >::iterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:EntityMapConstraintIterator_differs",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Constraint_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapConstraintIterator_differs" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Constraint >::iterator const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Constraint >::iterator * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__EntityMapT_ampl__Constraint_t__iterator,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "EntityMapConstraintIterator_differs" "', argument " "2"" of type '" "ampl::EntityMap< ampl::Constraint >::iterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "EntityMapConstraintIterator_differs" "', argument " "2"" of type '" "ampl::EntityMap< ampl::Constraint >::iterator const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::EntityMap< ampl::Constraint >::iterator * >(argp2);
  {
    try {
      result = (bool)((ampl::EntityMap< ampl::Constraint >::iterator const *)arg1)->operator !=((ampl::EntityMap< ampl::Constraint >::iterator const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapConstraintIterator___ref__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Constraint >::iterator *arg1 = (ampl::EntityMap< ampl::Constraint >::iterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< ampl::Constraint > result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "EntityMapConstraintIterator___ref__ takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Constraint_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapConstraintIterator___ref__" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Constraint >::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Constraint >::iterator * >(argp1);
  {
    try {
      result = (arg1)->operator *();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::Constraint(static_cast< const ampl::Constraint& >(result))), SWIGTYPE_p_ampl__Constraint, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGPY_BINARYFUNC_CLOSURE(_wrap_EntityMapConstraintIterator___ref__)

SWIGINTERN PyObject *_wrap_EntityMapConstraintIterator_clone(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Constraint >::iterator *arg1 = (ampl::EntityMap< ampl::Constraint >::iterator *) 0 ;
  ampl::EntityMap< ampl::Constraint >::iterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  ampl::EntityMap< ampl::Constraint >::iterator *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:EntityMapConstraintIterator_clone",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Constraint_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapConstraintIterator_clone" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Constraint >::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Constraint >::iterator * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__EntityMapT_ampl__Constraint_t__iterator,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "EntityMapConstraintIterator_clone" "', argument " "2"" of type '" "ampl::EntityMap< ampl::Constraint >::iterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "EntityMapConstraintIterator_clone" "', argument " "2"" of type '" "ampl::EntityMap< ampl::Constraint >::iterator const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::EntityMap< ampl::Constraint >::iterator * >(argp2);
  {
    try {
      result = (ampl::EntityMap< ampl::Constraint >::iterator *) &(arg1)->operator =((ampl::EntityMap< ampl::Constraint >::iterator const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__EntityMapT_ampl__Constraint_t__iterator, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapConstraintIterator_postIncrement(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Constraint >::iterator *arg1 = (ampl::EntityMap< ampl::Constraint >::iterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ampl::EntityMap< ampl::Constraint >::iterator *result = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "EntityMapConstraintIterator_postIncrement takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Constraint_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapConstraintIterator_postIncrement" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Constraint >::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Constraint >::iterator * >(argp1);
  {
    try {
      result = (ampl::EntityMap< ampl::Constraint >::iterator *) &(arg1)->operator ++();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__EntityMapT_ampl__Constraint_t__iterator, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapConstraintIterator_postIncrementBy(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Constraint >::iterator *arg1 = (ampl::EntityMap< ampl::Constraint >::iterator *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj1 = 0 ;
  ampl::EntityMap< ampl::Constraint >::iterator result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:EntityMapConstraintIterator_postIncrementBy",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Constraint_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapConstraintIterator_postIncrementBy" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Constraint >::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Constraint >::iterator * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "EntityMapConstraintIterator_postIncrementBy" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  {
    try {
      result = (arg1)->operator ++(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::EntityMap< ampl::Constraint >::iterator(static_cast< const ampl::EntityMap< ampl::Constraint >::iterator& >(result))), SWIGTYPE_p_ampl__EntityMapT_ampl__Constraint_t__iterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_EntityMapConstraintIterator(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Constraint >::iterator *arg1 = (ampl::EntityMap< ampl::Constraint >::iterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_EntityMapConstraintIterator takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Constraint_t__iterator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_EntityMapConstraintIterator" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Constraint >::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Constraint >::iterator * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapObjective_begin(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Objective > *arg1 = (ampl::EntityMap< ampl::Objective > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ampl::EntityMap< ampl::Objective >::iterator result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "EntityMapObjective_begin takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Objective_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapObjective_begin" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Objective > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Objective > * >(argp1);
  {
    try {
      result = ((ampl::EntityMap< ampl::Objective > const *)arg1)->begin();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::EntityMap< ampl::Objective >::iterator(static_cast< const ampl::EntityMap< ampl::Objective >::iterator& >(result))), SWIGTYPE_p_ampl__EntityMapT_ampl__Objective_t__iterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapObjective_end(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Objective > *arg1 = (ampl::EntityMap< ampl::Objective > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ampl::EntityMap< ampl::Objective >::iterator result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "EntityMapObjective_end takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Objective_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapObjective_end" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Objective > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Objective > * >(argp1);
  {
    try {
      result = ((ampl::EntityMap< ampl::Objective > const *)arg1)->end();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::EntityMap< ampl::Objective >::iterator(static_cast< const ampl::EntityMap< ampl::Objective >::iterator& >(result))), SWIGTYPE_p_ampl__EntityMapT_ampl__Objective_t__iterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapObjective_find(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Objective > *arg1 = (ampl::EntityMap< ampl::Objective > *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject * obj1 = 0 ;
  ampl::EntityMap< ampl::Objective >::iterator result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:EntityMapObjective_find",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Objective_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapObjective_find" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Objective > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Objective > * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "EntityMapObjective_find" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      result = (arg1)->find(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::EntityMap< ampl::Objective >::iterator(static_cast< const ampl::EntityMap< ampl::Objective >::iterator& >(result))), SWIGTYPE_p_ampl__EntityMapT_ampl__Objective_t__iterator, SWIG_POINTER_OWN |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapObjective_size(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Objective > *arg1 = (ampl::EntityMap< ampl::Objective > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::size_t result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "EntityMapObjective_size takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Objective_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapObjective_size" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Objective > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Objective > * >(argp1);
  {
    try {
      result = (std::size_t)((ampl::EntityMap< ampl::Objective > const *)arg1)->size();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapObjective_getIndex(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Objective > *arg1 = (ampl::EntityMap< ampl::Objective > *) 0 ;
  fmt::CStringRef arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj1 = 0 ;
  SwigValueWrapper< ampl::Objective > result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:EntityMapObjective_getIndex",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Objective_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapObjective_getIndex" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Objective > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Objective > * >(argp1);
  
  arg2 = _PyString_AsString(obj1);
  
  {
    try {
      result = ((ampl::EntityMap< ampl::Objective > const *)arg1)->operator [](arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::Objective(static_cast< const ampl::Objective& >(result))), SWIGTYPE_p_ampl__Objective, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_EntityMapObjective(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Objective > *arg1 = (ampl::EntityMap< ampl::Objective > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_EntityMapObjective takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Objective_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_EntityMapObjective" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Objective > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Objective > * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapObjectiveIterator_equals(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Objective >::iterator *arg1 = (ampl::EntityMap< ampl::Objective >::iterator *) 0 ;
  ampl::EntityMap< ampl::Objective >::iterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:EntityMapObjectiveIterator_equals",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Objective_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapObjectiveIterator_equals" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Objective >::iterator const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Objective >::iterator * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__EntityMapT_ampl__Objective_t__iterator,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "EntityMapObjectiveIterator_equals" "', argument " "2"" of type '" "ampl::EntityMap< ampl::Objective >::iterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "EntityMapObjectiveIterator_equals" "', argument " "2"" of type '" "ampl::EntityMap< ampl::Objective >::iterator const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::EntityMap< ampl::Objective >::iterator * >(argp2);
  {
    try {
      result = (bool)((ampl::EntityMap< ampl::Objective >::iterator const *)arg1)->operator ==((ampl::EntityMap< ampl::Objective >::iterator const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapObjectiveIterator_differs(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Objective >::iterator *arg1 = (ampl::EntityMap< ampl::Objective >::iterator *) 0 ;
  ampl::EntityMap< ampl::Objective >::iterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:EntityMapObjectiveIterator_differs",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Objective_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapObjectiveIterator_differs" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Objective >::iterator const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Objective >::iterator * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__EntityMapT_ampl__Objective_t__iterator,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "EntityMapObjectiveIterator_differs" "', argument " "2"" of type '" "ampl::EntityMap< ampl::Objective >::iterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "EntityMapObjectiveIterator_differs" "', argument " "2"" of type '" "ampl::EntityMap< ampl::Objective >::iterator const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::EntityMap< ampl::Objective >::iterator * >(argp2);
  {
    try {
      result = (bool)((ampl::EntityMap< ampl::Objective >::iterator const *)arg1)->operator !=((ampl::EntityMap< ampl::Objective >::iterator const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapObjectiveIterator___ref__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Objective >::iterator *arg1 = (ampl::EntityMap< ampl::Objective >::iterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< ampl::Objective > result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "EntityMapObjectiveIterator___ref__ takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Objective_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapObjectiveIterator___ref__" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Objective >::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Objective >::iterator * >(argp1);
  {
    try {
      result = (arg1)->operator *();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::Objective(static_cast< const ampl::Objective& >(result))), SWIGTYPE_p_ampl__Objective, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGPY_BINARYFUNC_CLOSURE(_wrap_EntityMapObjectiveIterator___ref__)

SWIGINTERN PyObject *_wrap_EntityMapObjectiveIterator_clone(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Objective >::iterator *arg1 = (ampl::EntityMap< ampl::Objective >::iterator *) 0 ;
  ampl::EntityMap< ampl::Objective >::iterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  ampl::EntityMap< ampl::Objective >::iterator *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:EntityMapObjectiveIterator_clone",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Objective_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapObjectiveIterator_clone" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Objective >::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Objective >::iterator * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__EntityMapT_ampl__Objective_t__iterator,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "EntityMapObjectiveIterator_clone" "', argument " "2"" of type '" "ampl::EntityMap< ampl::Objective >::iterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "EntityMapObjectiveIterator_clone" "', argument " "2"" of type '" "ampl::EntityMap< ampl::Objective >::iterator const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::EntityMap< ampl::Objective >::iterator * >(argp2);
  {
    try {
      result = (ampl::EntityMap< ampl::Objective >::iterator *) &(arg1)->operator =((ampl::EntityMap< ampl::Objective >::iterator const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__EntityMapT_ampl__Objective_t__iterator, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapObjectiveIterator_postIncrement(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Objective >::iterator *arg1 = (ampl::EntityMap< ampl::Objective >::iterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ampl::EntityMap< ampl::Objective >::iterator *result = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "EntityMapObjectiveIterator_postIncrement takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Objective_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapObjectiveIterator_postIncrement" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Objective >::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Objective >::iterator * >(argp1);
  {
    try {
      result = (ampl::EntityMap< ampl::Objective >::iterator *) &(arg1)->operator ++();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__EntityMapT_ampl__Objective_t__iterator, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapObjectiveIterator_postIncrementBy(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Objective >::iterator *arg1 = (ampl::EntityMap< ampl::Objective >::iterator *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj1 = 0 ;
  ampl::EntityMap< ampl::Objective >::iterator result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:EntityMapObjectiveIterator_postIncrementBy",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Objective_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapObjectiveIterator_postIncrementBy" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Objective >::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Objective >::iterator * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "EntityMapObjectiveIterator_postIncrementBy" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  {
    try {
      result = (arg1)->operator ++(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::EntityMap< ampl::Objective >::iterator(static_cast< const ampl::EntityMap< ampl::Objective >::iterator& >(result))), SWIGTYPE_p_ampl__EntityMapT_ampl__Objective_t__iterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_EntityMapObjectiveIterator(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Objective >::iterator *arg1 = (ampl::EntityMap< ampl::Objective >::iterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_EntityMapObjectiveIterator takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Objective_t__iterator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_EntityMapObjectiveIterator" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Objective >::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Objective >::iterator * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapSet_begin(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Set > *arg1 = (ampl::EntityMap< ampl::Set > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ampl::EntityMap< ampl::Set >::iterator result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "EntityMapSet_begin takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Set_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapSet_begin" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Set > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Set > * >(argp1);
  {
    try {
      result = ((ampl::EntityMap< ampl::Set > const *)arg1)->begin();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::EntityMap< ampl::Set >::iterator(static_cast< const ampl::EntityMap< ampl::Set >::iterator& >(result))), SWIGTYPE_p_ampl__EntityMapT_ampl__Set_t__iterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapSet_end(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Set > *arg1 = (ampl::EntityMap< ampl::Set > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ampl::EntityMap< ampl::Set >::iterator result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "EntityMapSet_end takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Set_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapSet_end" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Set > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Set > * >(argp1);
  {
    try {
      result = ((ampl::EntityMap< ampl::Set > const *)arg1)->end();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::EntityMap< ampl::Set >::iterator(static_cast< const ampl::EntityMap< ampl::Set >::iterator& >(result))), SWIGTYPE_p_ampl__EntityMapT_ampl__Set_t__iterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapSet_find(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Set > *arg1 = (ampl::EntityMap< ampl::Set > *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject * obj1 = 0 ;
  ampl::EntityMap< ampl::Set >::iterator result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:EntityMapSet_find",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Set_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapSet_find" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Set > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Set > * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "EntityMapSet_find" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      result = (arg1)->find(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::EntityMap< ampl::Set >::iterator(static_cast< const ampl::EntityMap< ampl::Set >::iterator& >(result))), SWIGTYPE_p_ampl__EntityMapT_ampl__Set_t__iterator, SWIG_POINTER_OWN |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapSet_size(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Set > *arg1 = (ampl::EntityMap< ampl::Set > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::size_t result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "EntityMapSet_size takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Set_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapSet_size" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Set > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Set > * >(argp1);
  {
    try {
      result = (std::size_t)((ampl::EntityMap< ampl::Set > const *)arg1)->size();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapSet_getIndex(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Set > *arg1 = (ampl::EntityMap< ampl::Set > *) 0 ;
  fmt::CStringRef arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj1 = 0 ;
  SwigValueWrapper< ampl::Set > result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:EntityMapSet_getIndex",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Set_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapSet_getIndex" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Set > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Set > * >(argp1);
  
  arg2 = _PyString_AsString(obj1);
  
  {
    try {
      result = ((ampl::EntityMap< ampl::Set > const *)arg1)->operator [](arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::Set(static_cast< const ampl::Set& >(result))), SWIGTYPE_p_ampl__Set, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_EntityMapSet(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Set > *arg1 = (ampl::EntityMap< ampl::Set > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_EntityMapSet takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Set_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_EntityMapSet" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Set > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Set > * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapSetIterator_equals(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Set >::iterator *arg1 = (ampl::EntityMap< ampl::Set >::iterator *) 0 ;
  ampl::EntityMap< ampl::Set >::iterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:EntityMapSetIterator_equals",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Set_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapSetIterator_equals" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Set >::iterator const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Set >::iterator * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__EntityMapT_ampl__Set_t__iterator,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "EntityMapSetIterator_equals" "', argument " "2"" of type '" "ampl::EntityMap< ampl::Set >::iterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "EntityMapSetIterator_equals" "', argument " "2"" of type '" "ampl::EntityMap< ampl::Set >::iterator const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::EntityMap< ampl::Set >::iterator * >(argp2);
  {
    try {
      result = (bool)((ampl::EntityMap< ampl::Set >::iterator const *)arg1)->operator ==((ampl::EntityMap< ampl::Set >::iterator const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapSetIterator_differs(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Set >::iterator *arg1 = (ampl::EntityMap< ampl::Set >::iterator *) 0 ;
  ampl::EntityMap< ampl::Set >::iterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:EntityMapSetIterator_differs",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Set_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapSetIterator_differs" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Set >::iterator const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Set >::iterator * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__EntityMapT_ampl__Set_t__iterator,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "EntityMapSetIterator_differs" "', argument " "2"" of type '" "ampl::EntityMap< ampl::Set >::iterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "EntityMapSetIterator_differs" "', argument " "2"" of type '" "ampl::EntityMap< ampl::Set >::iterator const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::EntityMap< ampl::Set >::iterator * >(argp2);
  {
    try {
      result = (bool)((ampl::EntityMap< ampl::Set >::iterator const *)arg1)->operator !=((ampl::EntityMap< ampl::Set >::iterator const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapSetIterator___ref__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Set >::iterator *arg1 = (ampl::EntityMap< ampl::Set >::iterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< ampl::Set > result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "EntityMapSetIterator___ref__ takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Set_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapSetIterator___ref__" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Set >::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Set >::iterator * >(argp1);
  {
    try {
      result = (arg1)->operator *();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::Set(static_cast< const ampl::Set& >(result))), SWIGTYPE_p_ampl__Set, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGPY_BINARYFUNC_CLOSURE(_wrap_EntityMapSetIterator___ref__)

SWIGINTERN PyObject *_wrap_EntityMapSetIterator_clone(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Set >::iterator *arg1 = (ampl::EntityMap< ampl::Set >::iterator *) 0 ;
  ampl::EntityMap< ampl::Set >::iterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  ampl::EntityMap< ampl::Set >::iterator *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:EntityMapSetIterator_clone",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Set_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapSetIterator_clone" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Set >::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Set >::iterator * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__EntityMapT_ampl__Set_t__iterator,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "EntityMapSetIterator_clone" "', argument " "2"" of type '" "ampl::EntityMap< ampl::Set >::iterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "EntityMapSetIterator_clone" "', argument " "2"" of type '" "ampl::EntityMap< ampl::Set >::iterator const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::EntityMap< ampl::Set >::iterator * >(argp2);
  {
    try {
      result = (ampl::EntityMap< ampl::Set >::iterator *) &(arg1)->operator =((ampl::EntityMap< ampl::Set >::iterator const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__EntityMapT_ampl__Set_t__iterator, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapSetIterator_postIncrement(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Set >::iterator *arg1 = (ampl::EntityMap< ampl::Set >::iterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ampl::EntityMap< ampl::Set >::iterator *result = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "EntityMapSetIterator_postIncrement takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Set_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapSetIterator_postIncrement" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Set >::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Set >::iterator * >(argp1);
  {
    try {
      result = (ampl::EntityMap< ampl::Set >::iterator *) &(arg1)->operator ++();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__EntityMapT_ampl__Set_t__iterator, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapSetIterator_postIncrementBy(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Set >::iterator *arg1 = (ampl::EntityMap< ampl::Set >::iterator *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj1 = 0 ;
  ampl::EntityMap< ampl::Set >::iterator result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:EntityMapSetIterator_postIncrementBy",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Set_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapSetIterator_postIncrementBy" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Set >::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Set >::iterator * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "EntityMapSetIterator_postIncrementBy" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  {
    try {
      result = (arg1)->operator ++(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::EntityMap< ampl::Set >::iterator(static_cast< const ampl::EntityMap< ampl::Set >::iterator& >(result))), SWIGTYPE_p_ampl__EntityMapT_ampl__Set_t__iterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_EntityMapSetIterator(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Set >::iterator *arg1 = (ampl::EntityMap< ampl::Set >::iterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_EntityMapSetIterator takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Set_t__iterator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_EntityMapSetIterator" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Set >::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Set >::iterator * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapParameter_begin(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Parameter > *arg1 = (ampl::EntityMap< ampl::Parameter > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ampl::EntityMap< ampl::Parameter >::iterator result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "EntityMapParameter_begin takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Parameter_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapParameter_begin" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Parameter > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Parameter > * >(argp1);
  {
    try {
      result = ((ampl::EntityMap< ampl::Parameter > const *)arg1)->begin();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::EntityMap< ampl::Parameter >::iterator(static_cast< const ampl::EntityMap< ampl::Parameter >::iterator& >(result))), SWIGTYPE_p_ampl__EntityMapT_ampl__Parameter_t__iterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapParameter_end(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Parameter > *arg1 = (ampl::EntityMap< ampl::Parameter > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ampl::EntityMap< ampl::Parameter >::iterator result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "EntityMapParameter_end takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Parameter_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapParameter_end" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Parameter > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Parameter > * >(argp1);
  {
    try {
      result = ((ampl::EntityMap< ampl::Parameter > const *)arg1)->end();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::EntityMap< ampl::Parameter >::iterator(static_cast< const ampl::EntityMap< ampl::Parameter >::iterator& >(result))), SWIGTYPE_p_ampl__EntityMapT_ampl__Parameter_t__iterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapParameter_find(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Parameter > *arg1 = (ampl::EntityMap< ampl::Parameter > *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject * obj1 = 0 ;
  ampl::EntityMap< ampl::Parameter >::iterator result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:EntityMapParameter_find",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Parameter_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapParameter_find" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Parameter > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Parameter > * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "EntityMapParameter_find" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      result = (arg1)->find(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::EntityMap< ampl::Parameter >::iterator(static_cast< const ampl::EntityMap< ampl::Parameter >::iterator& >(result))), SWIGTYPE_p_ampl__EntityMapT_ampl__Parameter_t__iterator, SWIG_POINTER_OWN |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapParameter_size(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Parameter > *arg1 = (ampl::EntityMap< ampl::Parameter > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::size_t result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "EntityMapParameter_size takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Parameter_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapParameter_size" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Parameter > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Parameter > * >(argp1);
  {
    try {
      result = (std::size_t)((ampl::EntityMap< ampl::Parameter > const *)arg1)->size();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapParameter_getIndex(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Parameter > *arg1 = (ampl::EntityMap< ampl::Parameter > *) 0 ;
  fmt::CStringRef arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj1 = 0 ;
  SwigValueWrapper< ampl::Parameter > result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:EntityMapParameter_getIndex",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Parameter_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapParameter_getIndex" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Parameter > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Parameter > * >(argp1);
  
  arg2 = _PyString_AsString(obj1);
  
  {
    try {
      result = ((ampl::EntityMap< ampl::Parameter > const *)arg1)->operator [](arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::Parameter(static_cast< const ampl::Parameter& >(result))), SWIGTYPE_p_ampl__Parameter, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_EntityMapParameter(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Parameter > *arg1 = (ampl::EntityMap< ampl::Parameter > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_EntityMapParameter takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Parameter_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_EntityMapParameter" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Parameter > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Parameter > * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapParameterIterator_equals(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Parameter >::iterator *arg1 = (ampl::EntityMap< ampl::Parameter >::iterator *) 0 ;
  ampl::EntityMap< ampl::Parameter >::iterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:EntityMapParameterIterator_equals",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Parameter_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapParameterIterator_equals" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Parameter >::iterator const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Parameter >::iterator * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__EntityMapT_ampl__Parameter_t__iterator,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "EntityMapParameterIterator_equals" "', argument " "2"" of type '" "ampl::EntityMap< ampl::Parameter >::iterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "EntityMapParameterIterator_equals" "', argument " "2"" of type '" "ampl::EntityMap< ampl::Parameter >::iterator const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::EntityMap< ampl::Parameter >::iterator * >(argp2);
  {
    try {
      result = (bool)((ampl::EntityMap< ampl::Parameter >::iterator const *)arg1)->operator ==((ampl::EntityMap< ampl::Parameter >::iterator const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapParameterIterator_differs(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Parameter >::iterator *arg1 = (ampl::EntityMap< ampl::Parameter >::iterator *) 0 ;
  ampl::EntityMap< ampl::Parameter >::iterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:EntityMapParameterIterator_differs",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Parameter_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapParameterIterator_differs" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Parameter >::iterator const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Parameter >::iterator * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__EntityMapT_ampl__Parameter_t__iterator,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "EntityMapParameterIterator_differs" "', argument " "2"" of type '" "ampl::EntityMap< ampl::Parameter >::iterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "EntityMapParameterIterator_differs" "', argument " "2"" of type '" "ampl::EntityMap< ampl::Parameter >::iterator const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::EntityMap< ampl::Parameter >::iterator * >(argp2);
  {
    try {
      result = (bool)((ampl::EntityMap< ampl::Parameter >::iterator const *)arg1)->operator !=((ampl::EntityMap< ampl::Parameter >::iterator const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapParameterIterator___ref__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Parameter >::iterator *arg1 = (ampl::EntityMap< ampl::Parameter >::iterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< ampl::Parameter > result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "EntityMapParameterIterator___ref__ takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Parameter_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapParameterIterator___ref__" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Parameter >::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Parameter >::iterator * >(argp1);
  {
    try {
      result = (arg1)->operator *();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::Parameter(static_cast< const ampl::Parameter& >(result))), SWIGTYPE_p_ampl__Parameter, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGPY_BINARYFUNC_CLOSURE(_wrap_EntityMapParameterIterator___ref__)

SWIGINTERN PyObject *_wrap_EntityMapParameterIterator_clone(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Parameter >::iterator *arg1 = (ampl::EntityMap< ampl::Parameter >::iterator *) 0 ;
  ampl::EntityMap< ampl::Parameter >::iterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  ampl::EntityMap< ampl::Parameter >::iterator *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:EntityMapParameterIterator_clone",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Parameter_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapParameterIterator_clone" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Parameter >::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Parameter >::iterator * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__EntityMapT_ampl__Parameter_t__iterator,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "EntityMapParameterIterator_clone" "', argument " "2"" of type '" "ampl::EntityMap< ampl::Parameter >::iterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "EntityMapParameterIterator_clone" "', argument " "2"" of type '" "ampl::EntityMap< ampl::Parameter >::iterator const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::EntityMap< ampl::Parameter >::iterator * >(argp2);
  {
    try {
      result = (ampl::EntityMap< ampl::Parameter >::iterator *) &(arg1)->operator =((ampl::EntityMap< ampl::Parameter >::iterator const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__EntityMapT_ampl__Parameter_t__iterator, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapParameterIterator_postIncrement(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Parameter >::iterator *arg1 = (ampl::EntityMap< ampl::Parameter >::iterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ampl::EntityMap< ampl::Parameter >::iterator *result = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "EntityMapParameterIterator_postIncrement takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Parameter_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapParameterIterator_postIncrement" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Parameter >::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Parameter >::iterator * >(argp1);
  {
    try {
      result = (ampl::EntityMap< ampl::Parameter >::iterator *) &(arg1)->operator ++();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__EntityMapT_ampl__Parameter_t__iterator, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EntityMapParameterIterator_postIncrementBy(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Parameter >::iterator *arg1 = (ampl::EntityMap< ampl::Parameter >::iterator *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj1 = 0 ;
  ampl::EntityMap< ampl::Parameter >::iterator result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:EntityMapParameterIterator_postIncrementBy",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Parameter_t__iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EntityMapParameterIterator_postIncrementBy" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Parameter >::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Parameter >::iterator * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "EntityMapParameterIterator_postIncrementBy" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  {
    try {
      result = (arg1)->operator ++(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::EntityMap< ampl::Parameter >::iterator(static_cast< const ampl::EntityMap< ampl::Parameter >::iterator& >(result))), SWIGTYPE_p_ampl__EntityMapT_ampl__Parameter_t__iterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_EntityMapParameterIterator(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::EntityMap< ampl::Parameter >::iterator *arg1 = (ampl::EntityMap< ampl::Parameter >::iterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_EntityMapParameterIterator takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__EntityMapT_ampl__Parameter_t__iterator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_EntityMapParameterIterator" "', argument " "1"" of type '" "ampl::EntityMap< ampl::Parameter >::iterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::EntityMap< ampl::Parameter >::iterator * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN int _wrap_new_AMPLException__SWIG_0(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPLException *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj1 = 0 ;
  ampl::AMPLException *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_AMPLException",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj1, &argp1, SWIGTYPE_p_ampl__AMPLException,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_AMPLException" "', argument " "1"" of type '" "ampl::AMPLException const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_AMPLException" "', argument " "1"" of type '" "ampl::AMPLException const &""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPLException * >(argp1);
  {
    try {
      result = (ampl::AMPLException *)new ampl::AMPLException((ampl::AMPLException const &)*arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__AMPLException, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN int _wrap_new_AMPLException__SWIG_1(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  fmt::CStringRef arg1 ;
  PyObject * obj1 = 0 ;
  ampl::AMPLException *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_AMPLException",&obj1)) SWIG_fail;
  
  arg1 = _PyString_AsString(obj1);
  
  {
    try {
      result = (ampl::AMPLException *)new ampl::AMPLException(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__AMPLException, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN int _wrap_new_AMPLException__SWIG_2(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPLException *result = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "new_AMPLException takes no arguments");
  {
    try {
      result = (ampl::AMPLException *)new ampl::AMPLException();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__AMPLException, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN int _wrap_new_AMPLException__SWIG_3(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  fmt::CStringRef arg1 ;
  int arg2 ;
  int arg3 ;
  fmt::CStringRef arg4 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  ampl::AMPLException *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:new_AMPLException",&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  
  arg1 = _PyString_AsString(obj1);
  
  ecode2 = SWIG_AsVal_int(obj2, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_AMPLException" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(obj3, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_AMPLException" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  
  arg4 = _PyString_AsString(obj4);
  
  {
    try {
      result = (ampl::AMPLException *)new ampl::AMPLException(arg1,arg2,arg3,arg4);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__AMPLException, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN int _wrap_new_AMPLException(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[5] = {
    0
  };
  Py_ssize_t ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = args ? PyObject_Length(args) : 0;
  for (ii = 0; (ii < 4) && (ii < argc); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 0) {
    return _wrap_new_AMPLException__SWIG_2(self, args);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_ampl__AMPLException, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_AMPLException__SWIG_0(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_AMPLException__SWIG_1(self, args);
    }
  }
  if (argc == 4) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          int res = SWIG_AsCharPtrAndSize(argv[3], 0, NULL, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_new_AMPLException__SWIG_3(self, args);
          }
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'new_AMPLException'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    ampl::AMPLException::AMPLException(ampl::AMPLException const &)\n"
    "    ampl::AMPLException::AMPLException(fmt::CStringRef)\n"
    "    ampl::AMPLException::AMPLException()\n"
    "    ampl::AMPLException::AMPLException(fmt::CStringRef,int,int,fmt::CStringRef)\n");
  return -1;
}


SWIGINTERN PyObject *_wrap_delete_AMPLException(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPLException *arg1 = (ampl::AMPLException *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_AMPLException takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPLException, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_AMPLException" "', argument " "1"" of type '" "ampl::AMPLException *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPLException * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPLException_getSourceName(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPLException *arg1 = (ampl::AMPLException *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "AMPLException_getSourceName takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPLException, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPLException_getSourceName" "', argument " "1"" of type '" "ampl::AMPLException const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPLException * >(argp1);
  {
    try {
      result = ((ampl::AMPLException const *)arg1)->getSourceName();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPLException_getLineNumber(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPLException *arg1 = (ampl::AMPLException *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "AMPLException_getLineNumber takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPLException, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPLException_getLineNumber" "', argument " "1"" of type '" "ampl::AMPLException const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPLException * >(argp1);
  {
    try {
      result = (int)((ampl::AMPLException const *)arg1)->getLineNumber();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPLException_getOffset(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPLException *arg1 = (ampl::AMPLException *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "AMPLException_getOffset takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPLException, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPLException_getOffset" "', argument " "1"" of type '" "ampl::AMPLException const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPLException * >(argp1);
  {
    try {
      result = (int)((ampl::AMPLException const *)arg1)->getOffset();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPLException_getMessage(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPLException *arg1 = (ampl::AMPLException *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "AMPLException_getMessage takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPLException, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPLException_getMessage" "', argument " "1"" of type '" "ampl::AMPLException const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPLException * >(argp1);
  {
    try {
      result = ((ampl::AMPLException const *)arg1)->getMessage();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPLException_setSourceName(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPLException *arg1 = (ampl::AMPLException *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:AMPLException_setSourceName",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPLException, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPLException_setSourceName" "', argument " "1"" of type '" "ampl::AMPLException *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPLException * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AMPLException_setSourceName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "AMPLException_setSourceName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    try {
      (arg1)->setSourceName((std::string const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN int _wrap_new_LicenseException(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  fmt::CStringRef arg1 ;
  PyObject * obj1 = 0 ;
  ampl::LicenseException *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_LicenseException",&obj1)) SWIG_fail;
  
  arg1 = _PyString_AsString(obj1);
  
  {
    try {
      result = (ampl::LicenseException *)new ampl::LicenseException(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__LicenseException, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN PyObject *_wrap_delete_LicenseException(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::LicenseException *arg1 = (ampl::LicenseException *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_LicenseException takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__LicenseException, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_LicenseException" "', argument " "1"" of type '" "ampl::LicenseException *""'"); 
  }
  arg1 = reinterpret_cast< ampl::LicenseException * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN int _wrap_new_FileIOException(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  fmt::CStringRef arg1 ;
  PyObject * obj1 = 0 ;
  ampl::FileIOException *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_FileIOException",&obj1)) SWIG_fail;
  
  arg1 = _PyString_AsString(obj1);
  
  {
    try {
      result = (ampl::FileIOException *)new ampl::FileIOException(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__FileIOException, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN PyObject *_wrap_delete_FileIOException(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::FileIOException *arg1 = (ampl::FileIOException *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_FileIOException takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__FileIOException, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_FileIOException" "', argument " "1"" of type '" "ampl::FileIOException *""'"); 
  }
  arg1 = reinterpret_cast< ampl::FileIOException * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN int _wrap_new_UnsupportedOperationException(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  fmt::CStringRef arg1 ;
  PyObject * obj1 = 0 ;
  ampl::UnsupportedOperationException *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_UnsupportedOperationException",&obj1)) SWIG_fail;
  
  arg1 = _PyString_AsString(obj1);
  
  {
    try {
      result = (ampl::UnsupportedOperationException *)new ampl::UnsupportedOperationException(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__UnsupportedOperationException, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN PyObject *_wrap_delete_UnsupportedOperationException(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::UnsupportedOperationException *arg1 = (ampl::UnsupportedOperationException *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_UnsupportedOperationException takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__UnsupportedOperationException, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_UnsupportedOperationException" "', argument " "1"" of type '" "ampl::UnsupportedOperationException *""'"); 
  }
  arg1 = reinterpret_cast< ampl::UnsupportedOperationException * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN int _wrap_new_InvalidSubscriptException(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  fmt::CStringRef arg1 ;
  int arg2 ;
  int arg3 ;
  fmt::CStringRef arg4 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  ampl::InvalidSubscriptException *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:new_InvalidSubscriptException",&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  
  arg1 = _PyString_AsString(obj1);
  
  ecode2 = SWIG_AsVal_int(obj2, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_InvalidSubscriptException" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(obj3, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_InvalidSubscriptException" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  
  arg4 = _PyString_AsString(obj4);
  
  {
    try {
      result = (ampl::InvalidSubscriptException *)new ampl::InvalidSubscriptException(arg1,arg2,arg3,arg4);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__InvalidSubscriptException, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN PyObject *_wrap_delete_InvalidSubscriptException(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::InvalidSubscriptException *arg1 = (ampl::InvalidSubscriptException *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_InvalidSubscriptException takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__InvalidSubscriptException, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_InvalidSubscriptException" "', argument " "1"" of type '" "ampl::InvalidSubscriptException *""'"); 
  }
  arg1 = reinterpret_cast< ampl::InvalidSubscriptException * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN int _wrap_new_SyntaxErrorException(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  fmt::CStringRef arg1 ;
  int arg2 ;
  int arg3 ;
  fmt::CStringRef arg4 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  ampl::SyntaxErrorException *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:new_SyntaxErrorException",&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  
  arg1 = _PyString_AsString(obj1);
  
  ecode2 = SWIG_AsVal_int(obj2, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_SyntaxErrorException" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(obj3, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_SyntaxErrorException" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  
  arg4 = _PyString_AsString(obj4);
  
  {
    try {
      result = (ampl::SyntaxErrorException *)new ampl::SyntaxErrorException(arg1,arg2,arg3,arg4);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__SyntaxErrorException, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN PyObject *_wrap_delete_SyntaxErrorException(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::SyntaxErrorException *arg1 = (ampl::SyntaxErrorException *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_SyntaxErrorException takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__SyntaxErrorException, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SyntaxErrorException" "', argument " "1"" of type '" "ampl::SyntaxErrorException *""'"); 
  }
  arg1 = reinterpret_cast< ampl::SyntaxErrorException * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN int _wrap_new_NoDataException(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  fmt::CStringRef arg1 ;
  int arg2 ;
  int arg3 ;
  fmt::CStringRef arg4 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  ampl::NoDataException *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:new_NoDataException",&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  
  arg1 = _PyString_AsString(obj1);
  
  ecode2 = SWIG_AsVal_int(obj2, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_NoDataException" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(obj3, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_NoDataException" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  
  arg4 = _PyString_AsString(obj4);
  
  {
    try {
      result = (ampl::NoDataException *)new ampl::NoDataException(arg1,arg2,arg3,arg4);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__NoDataException, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN PyObject *_wrap_delete_NoDataException(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::NoDataException *arg1 = (ampl::NoDataException *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_NoDataException takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__NoDataException, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_NoDataException" "', argument " "1"" of type '" "ampl::NoDataException *""'"); 
  }
  arg1 = reinterpret_cast< ampl::NoDataException * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN int _wrap_new_ErrorHandler(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) 0 ;
  ampl::ErrorHandler *result = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "new_ErrorHandler takes no arguments");
  arg1 = self;
  {
    try {
      if ( self->ob_type != ((SwigPyClientData*) (SWIGTYPE_p_ampl__ErrorHandler)->clientdata)->pytype ) {
        /* subclassed */
        result = (ampl::ErrorHandler *)new SwigDirector_ErrorHandler(arg1); 
      } else {
        SWIG_SetErrorMsg(PyExc_RuntimeError,"accessing abstract class or protected constructor"); 
        SWIG_fail;
      }
      
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__ErrorHandler, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN PyObject *_wrap_delete_ErrorHandler(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::ErrorHandler *arg1 = (ampl::ErrorHandler *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_ErrorHandler takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__ErrorHandler, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ErrorHandler" "', argument " "1"" of type '" "ampl::ErrorHandler *""'"); 
  }
  arg1 = reinterpret_cast< ampl::ErrorHandler * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ErrorHandler_error(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::ErrorHandler *arg1 = (ampl::ErrorHandler *) 0 ;
  ampl::AMPLException *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  Swig::Director *director = 0;
  bool upcall = false;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ErrorHandler_error",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__ErrorHandler, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ErrorHandler_error" "', argument " "1"" of type '" "ampl::ErrorHandler *""'"); 
  }
  arg1 = reinterpret_cast< ampl::ErrorHandler * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__AMPLException,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ErrorHandler_error" "', argument " "2"" of type '" "ampl::AMPLException const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ErrorHandler_error" "', argument " "2"" of type '" "ampl::AMPLException const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::AMPLException * >(argp2);
  director = SWIG_DIRECTOR_CAST(arg1);
  upcall = (director && (director->swig_get_self()==self));
  try {
    {
      try {
        if (upcall) {
          Swig::DirectorPureVirtualException::raise("ampl::ErrorHandler::error");
        } else {
          (arg1)->error((ampl::AMPLException const &)*arg2);
        }
      }
      catch (std::range_error) {
        SWIG_exception(SWIG_ValueError, "Range Error");
      }
      catch (ampl::AMPLException e) {
        SWIG_exception(SWIG_RuntimeError, e.what());
      }
      catch (std::logic_error e) {
        SWIG_exception(SWIG_TypeError, e.what());
      }
      catch (ampl::UnsupportedOperationException e)
      {
        SWIG_exception(SWIG_TypeError, e.what());
      }
      catch (ampl::LicenseException e) {
        SWIG_exception(SWIG_SystemError, e.what());
      }
      catch (ampl::FileIOException e) {
        SWIG_exception(SWIG_IOError, e.what());
      }
      catch (std::runtime_error e) {
        SWIG_exception(SWIG_RuntimeError, e.what());
      }
      catch (std::exception e) {
        SWIG_exception(SWIG_UnknownError, e.what());
      }
      catch (...) {
        SWIG_exception(SWIG_UnknownError,"Unknown exception");
      }
    }
  } catch (Swig::DirectorException&) {
    SWIG_fail;
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ErrorHandler_warning(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::ErrorHandler *arg1 = (ampl::ErrorHandler *) 0 ;
  ampl::AMPLException *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  Swig::Director *director = 0;
  bool upcall = false;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ErrorHandler_warning",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__ErrorHandler, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ErrorHandler_warning" "', argument " "1"" of type '" "ampl::ErrorHandler *""'"); 
  }
  arg1 = reinterpret_cast< ampl::ErrorHandler * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__AMPLException,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ErrorHandler_warning" "', argument " "2"" of type '" "ampl::AMPLException const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ErrorHandler_warning" "', argument " "2"" of type '" "ampl::AMPLException const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::AMPLException * >(argp2);
  director = SWIG_DIRECTOR_CAST(arg1);
  upcall = (director && (director->swig_get_self()==self));
  try {
    {
      try {
        if (upcall) {
          Swig::DirectorPureVirtualException::raise("ampl::ErrorHandler::warning");
        } else {
          (arg1)->warning((ampl::AMPLException const &)*arg2);
        }
      }
      catch (std::range_error) {
        SWIG_exception(SWIG_ValueError, "Range Error");
      }
      catch (ampl::AMPLException e) {
        SWIG_exception(SWIG_RuntimeError, e.what());
      }
      catch (std::logic_error e) {
        SWIG_exception(SWIG_TypeError, e.what());
      }
      catch (ampl::UnsupportedOperationException e)
      {
        SWIG_exception(SWIG_TypeError, e.what());
      }
      catch (ampl::LicenseException e) {
        SWIG_exception(SWIG_SystemError, e.what());
      }
      catch (ampl::FileIOException e) {
        SWIG_exception(SWIG_IOError, e.what());
      }
      catch (std::runtime_error e) {
        SWIG_exception(SWIG_RuntimeError, e.what());
      }
      catch (std::exception e) {
        SWIG_exception(SWIG_UnknownError, e.what());
      }
      catch (...) {
        SWIG_exception(SWIG_UnknownError,"Unknown exception");
      }
    }
  } catch (Swig::DirectorException&) {
    SWIG_fail;
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_disown_ErrorHandler(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::ErrorHandler *arg1 = (ampl::ErrorHandler *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:disown_ErrorHandler",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ampl__ErrorHandler, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "disown_ErrorHandler" "', argument " "1"" of type '" "ampl::ErrorHandler *""'"); 
  }
  arg1 = reinterpret_cast< ampl::ErrorHandler * >(argp1);
  {
    Swig::Director *director = SWIG_DIRECTOR_CAST(arg1);
    if (director) director->swig_disown();
  }
  
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_Runnable(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Runnable *arg1 = (ampl::Runnable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_Runnable takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Runnable, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Runnable" "', argument " "1"" of type '" "ampl::Runnable *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Runnable * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Runnable_run(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Runnable *arg1 = (ampl::Runnable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Swig::Director *director = 0;
  bool upcall = false;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Runnable_run takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Runnable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Runnable_run" "', argument " "1"" of type '" "ampl::Runnable *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Runnable * >(argp1);
  director = SWIG_DIRECTOR_CAST(arg1);
  upcall = (director && (director->swig_get_self()==self));
  try {
    {
      try {
        if (upcall) {
          Swig::DirectorPureVirtualException::raise("ampl::Runnable::run");
        } else {
          (arg1)->run();
        }
      }
      catch (std::range_error) {
        SWIG_exception(SWIG_ValueError, "Range Error");
      }
      catch (ampl::AMPLException e) {
        SWIG_exception(SWIG_RuntimeError, e.what());
      }
      catch (std::logic_error e) {
        SWIG_exception(SWIG_TypeError, e.what());
      }
      catch (ampl::UnsupportedOperationException e)
      {
        SWIG_exception(SWIG_TypeError, e.what());
      }
      catch (ampl::LicenseException e) {
        SWIG_exception(SWIG_SystemError, e.what());
      }
      catch (ampl::FileIOException e) {
        SWIG_exception(SWIG_IOError, e.what());
      }
      catch (std::runtime_error e) {
        SWIG_exception(SWIG_RuntimeError, e.what());
      }
      catch (std::exception e) {
        SWIG_exception(SWIG_UnknownError, e.what());
      }
      catch (...) {
        SWIG_exception(SWIG_UnknownError,"Unknown exception");
      }
    }
  } catch (Swig::DirectorException&) {
    SWIG_fail;
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN int _wrap_new_Runnable(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) 0 ;
  ampl::Runnable *result = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "new_Runnable takes no arguments");
  arg1 = self;
  {
    try {
      if ( self->ob_type != ((SwigPyClientData*) (SWIGTYPE_p_ampl__Runnable)->clientdata)->pytype ) {
        /* subclassed */
        result = (ampl::Runnable *)new SwigDirector_Runnable(arg1); 
      } else {
        SWIG_SetErrorMsg(PyExc_RuntimeError,"accessing abstract class or protected constructor"); 
        SWIG_fail;
      }
      
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__Runnable, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN PyObject *_wrap_disown_Runnable(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Runnable *arg1 = (ampl::Runnable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:disown_Runnable",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ampl__Runnable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "disown_Runnable" "', argument " "1"" of type '" "ampl::Runnable *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Runnable * >(argp1);
  {
    Swig::Director *director = SWIG_DIRECTOR_CAST(arg1);
    if (director) director->swig_disown();
  }
  
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_OutputHandler(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::OutputHandler *arg1 = (ampl::OutputHandler *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_OutputHandler takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__OutputHandler, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_OutputHandler" "', argument " "1"" of type '" "ampl::OutputHandler *""'"); 
  }
  arg1 = reinterpret_cast< ampl::OutputHandler * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_OutputHandler_output(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::OutputHandler *arg1 = (ampl::OutputHandler *) 0 ;
  ampl::output::Kind arg2 ;
  char *arg3 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  Swig::Director *director = 0;
  bool upcall = false;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:OutputHandler_output",&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__OutputHandler, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OutputHandler_output" "', argument " "1"" of type '" "ampl::OutputHandler *""'"); 
  }
  arg1 = reinterpret_cast< ampl::OutputHandler * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "OutputHandler_output" "', argument " "2"" of type '" "ampl::output::Kind""'");
  } 
  arg2 = static_cast< ampl::output::Kind >(val2);
  res3 = SWIG_AsCharPtrAndSize(obj2, &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "OutputHandler_output" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = reinterpret_cast< char * >(buf3);
  director = SWIG_DIRECTOR_CAST(arg1);
  upcall = (director && (director->swig_get_self()==self));
  try {
    {
      try {
        if (upcall) {
          Swig::DirectorPureVirtualException::raise("ampl::OutputHandler::output");
        } else {
          (arg1)->output(arg2,(char const *)arg3);
        }
      }
      catch (std::range_error) {
        SWIG_exception(SWIG_ValueError, "Range Error");
      }
      catch (ampl::AMPLException e) {
        SWIG_exception(SWIG_RuntimeError, e.what());
      }
      catch (std::logic_error e) {
        SWIG_exception(SWIG_TypeError, e.what());
      }
      catch (ampl::UnsupportedOperationException e)
      {
        SWIG_exception(SWIG_TypeError, e.what());
      }
      catch (ampl::LicenseException e) {
        SWIG_exception(SWIG_SystemError, e.what());
      }
      catch (ampl::FileIOException e) {
        SWIG_exception(SWIG_IOError, e.what());
      }
      catch (std::runtime_error e) {
        SWIG_exception(SWIG_RuntimeError, e.what());
      }
      catch (std::exception e) {
        SWIG_exception(SWIG_UnknownError, e.what());
      }
      catch (...) {
        SWIG_exception(SWIG_UnknownError,"Unknown exception");
      }
    }
  } catch (Swig::DirectorException&) {
    SWIG_fail;
  }
  resultobj = SWIG_Py_Void();
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return resultobj;
fail:
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return NULL;
}


SWIGINTERN int _wrap_new_OutputHandler(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) 0 ;
  ampl::OutputHandler *result = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "new_OutputHandler takes no arguments");
  arg1 = self;
  {
    try {
      if ( self->ob_type != ((SwigPyClientData*) (SWIGTYPE_p_ampl__OutputHandler)->clientdata)->pytype ) {
        /* subclassed */
        result = (ampl::OutputHandler *)new SwigDirector_OutputHandler(arg1); 
      } else {
        SWIG_SetErrorMsg(PyExc_RuntimeError,"accessing abstract class or protected constructor"); 
        SWIG_fail;
      }
      
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__OutputHandler, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN PyObject *_wrap_disown_OutputHandler(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::OutputHandler *arg1 = (ampl::OutputHandler *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:disown_OutputHandler",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ampl__OutputHandler, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "disown_OutputHandler" "', argument " "1"" of type '" "ampl::OutputHandler *""'"); 
  }
  arg1 = reinterpret_cast< ampl::OutputHandler * >(argp1);
  {
    Swig::Director *director = SWIG_DIRECTOR_CAST(arg1);
    if (director) director->swig_disown();
  }
  
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN int _wrap_new_EnvironmentIterator(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::EnvironmentIterator *result = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "new_EnvironmentIterator takes no arguments");
  {
    try {
      result = (ampl::internal::EnvironmentIterator *)new ampl::internal::EnvironmentIterator();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__internal__EnvironmentIterator, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN PyObject *_wrap_delete_EnvironmentIterator(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::EnvironmentIterator *arg1 = (ampl::internal::EnvironmentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_EnvironmentIterator takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__EnvironmentIterator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_EnvironmentIterator" "', argument " "1"" of type '" "ampl::internal::EnvironmentIterator *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::EnvironmentIterator * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN int _wrap_new_Environment__SWIG_0(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Environment *result = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "new_Environment takes no arguments");
  {
    try {
      result = (ampl::Environment *)new ampl::Environment();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__Environment, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN int _wrap_new_Environment__SWIG_1(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Environment *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj1 = 0 ;
  ampl::Environment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_Environment",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj1, &argp1, SWIGTYPE_p_ampl__Environment,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Environment" "', argument " "1"" of type '" "ampl::Environment const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Environment" "', argument " "1"" of type '" "ampl::Environment const &""'"); 
  }
  arg1 = reinterpret_cast< ampl::Environment * >(argp1);
  {
    try {
      result = (ampl::Environment *)new ampl::Environment((ampl::Environment const &)*arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__Environment, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN PyObject *_wrap_Environment_Clone(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Environment *arg1 = (ampl::Environment *) 0 ;
  ampl::Environment *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  ampl::Environment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Environment_Clone",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Environment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Environment_Clone" "', argument " "1"" of type '" "ampl::Environment *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Environment * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__Environment,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Environment_Clone" "', argument " "2"" of type '" "ampl::Environment const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Environment_Clone" "', argument " "2"" of type '" "ampl::Environment const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::Environment * >(argp2);
  {
    try {
      result = (ampl::Environment *) &(arg1)->operator =((ampl::Environment const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__Environment, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN int _wrap_new_Environment__SWIG_2(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  fmt::CStringRef arg1 ;
  PyObject * obj1 = 0 ;
  ampl::Environment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_Environment",&obj1)) SWIG_fail;
  
  arg1 = _PyString_AsString(obj1);
  
  {
    try {
      result = (ampl::Environment *)new ampl::Environment(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__Environment, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN int _wrap_new_Environment(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  Py_ssize_t ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = args ? PyObject_Length(args) : 0;
  for (ii = 0; (ii < 1) && (ii < argc); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 0) {
    return _wrap_new_Environment__SWIG_0(self, args);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_ampl__Environment, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Environment__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Environment__SWIG_2(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'new_Environment'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    ampl::Environment::Environment()\n"
    "    ampl::Environment::Environment(ampl::Environment const &)\n"
    "    ampl::Environment::Environment(fmt::CStringRef)\n");
  return -1;
}


SWIGINTERN PyObject *_wrap_delete_Environment(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Environment *arg1 = (ampl::Environment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_Environment takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Environment, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Environment" "', argument " "1"" of type '" "ampl::Environment *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Environment * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Environment_put(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Environment *arg1 = (ampl::Environment *) 0 ;
  fmt::CStringRef arg2 ;
  fmt::CStringRef arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Environment_put",&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Environment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Environment_put" "', argument " "1"" of type '" "ampl::Environment *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Environment * >(argp1);
  
  arg2 = _PyString_AsString(obj1);
  
  
  arg3 = _PyString_AsString(obj2);
  
  {
    try {
      (arg1)->put(arg2,arg3);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Environment_setBinDir(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Environment *arg1 = (ampl::Environment *) 0 ;
  fmt::CStringRef arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Environment_setBinDir",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Environment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Environment_setBinDir" "', argument " "1"" of type '" "ampl::Environment *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Environment * >(argp1);
  
  arg2 = _PyString_AsString(obj1);
  
  {
    try {
      (arg1)->setBinDir(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Environment_getBinDir(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Environment *arg1 = (ampl::Environment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Environment_getBinDir takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Environment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Environment_getBinDir" "', argument " "1"" of type '" "ampl::Environment const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Environment * >(argp1);
  {
    try {
      result = ((ampl::Environment const *)arg1)->getBinDir();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Environment_toString(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Environment *arg1 = (ampl::Environment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Environment_toString takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Environment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Environment_toString" "', argument " "1"" of type '" "ampl::Environment const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Environment * >(argp1);
  {
    try {
      result = ((ampl::Environment const *)arg1)->toString();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Environment_begin(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Environment *arg1 = (ampl::Environment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ampl::Environment::iterator result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Environment_begin takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Environment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Environment_begin" "', argument " "1"" of type '" "ampl::Environment const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Environment * >(argp1);
  {
    try {
      result = ((ampl::Environment const *)arg1)->begin();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::Environment::iterator(static_cast< const ampl::Environment::iterator& >(result))), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Environment_end(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Environment *arg1 = (ampl::Environment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ampl::Environment::iterator result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "Environment_end takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Environment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Environment_end" "', argument " "1"" of type '" "ampl::Environment const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Environment * >(argp1);
  {
    try {
      result = ((ampl::Environment const *)arg1)->end();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::Environment::iterator(static_cast< const ampl::Environment::iterator& >(result))), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Environment_find(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Environment *arg1 = (ampl::Environment *) 0 ;
  fmt::CStringRef arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj1 = 0 ;
  ampl::Environment::iterator result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Environment_find",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__Environment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Environment_find" "', argument " "1"" of type '" "ampl::Environment const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::Environment * >(argp1);
  
  arg2 = _PyString_AsString(obj1);
  
  {
    try {
      result = ((ampl::Environment const *)arg1)->find(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::Environment::iterator(static_cast< const ampl::Environment::iterator& >(result))), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EnvironmentIteratorTemplate_equals(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > *) 0 ;
  ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:EnvironmentIteratorTemplate_equals",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EnvironmentIteratorTemplate_equals" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "EnvironmentIteratorTemplate_equals" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "EnvironmentIteratorTemplate_equals" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > * >(argp2);
  {
    try {
      result = (bool)((ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > const *)arg1)->operator ==((ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EnvironmentIteratorTemplate_differs(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > *) 0 ;
  ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:EnvironmentIteratorTemplate_differs",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EnvironmentIteratorTemplate_differs" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "EnvironmentIteratorTemplate_differs" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "EnvironmentIteratorTemplate_differs" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > * >(argp2);
  {
    try {
      result = (bool)((ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > const *)arg1)->operator !=((ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EnvironmentIteratorTemplate_Clone(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > *) 0 ;
  ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:EnvironmentIteratorTemplate_Clone",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EnvironmentIteratorTemplate_Clone" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "EnvironmentIteratorTemplate_Clone" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "EnvironmentIteratorTemplate_Clone" "', argument " "2"" of type '" "ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > * >(argp2);
  {
    try {
      result = (ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > *) &(arg1)->operator =((ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EnvironmentIteratorTemplate_postIncrement(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > *result = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "EnvironmentIteratorTemplate_postIncrement takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EnvironmentIteratorTemplate_postIncrement" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > * >(argp1);
  {
    try {
      result = (ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > *) &(arg1)->operator ++();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EnvironmentIteratorTemplate_postIncrementBy(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj1 = 0 ;
  ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:EnvironmentIteratorTemplate_postIncrementBy",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EnvironmentIteratorTemplate_postIncrementBy" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "EnvironmentIteratorTemplate_postIncrementBy" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  {
    try {
      result = (arg1)->operator ++(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator >(static_cast< const ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator >& >(result))), SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EnvironmentIteratorTemplate_first(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ampl::internal::EnvironmentIterator::KeyType result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "EnvironmentIteratorTemplate_first takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EnvironmentIteratorTemplate_first" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > * >(argp1);
  {
    try {
      result = (ampl::internal::EnvironmentIterator::KeyType)ampl_internal_CountedIterator_Sl_ampl_internal_EnvironmentIterator_Sg__first(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EnvironmentIteratorTemplate_second(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ampl::internal::EnvironmentIterator::InstanceType result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "EnvironmentIteratorTemplate_second takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EnvironmentIteratorTemplate_second" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > * >(argp1);
  {
    try {
      result = (ampl::internal::EnvironmentIterator::InstanceType)ampl_internal_CountedIterator_Sl_ampl_internal_EnvironmentIterator_Sg__second(arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_EnvironmentIteratorTemplate(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > *arg1 = (ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_EnvironmentIteratorTemplate takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_EnvironmentIteratorTemplate" "', argument " "1"" of type '" "ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > *""'"); 
  }
  arg1 = reinterpret_cast< ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN int _wrap_new_AMPL__SWIG_0(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *result = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "new_AMPL takes no arguments");
  {
    try {
      result = (ampl::AMPL *)new ampl::AMPL();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__AMPL, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN int _wrap_new_AMPL__SWIG_1(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::Environment *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj1 = 0 ;
  ampl::AMPL *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_AMPL",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj1, &argp1, SWIGTYPE_p_ampl__Environment,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_AMPL" "', argument " "1"" of type '" "ampl::Environment const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_AMPL" "', argument " "1"" of type '" "ampl::Environment const &""'"); 
  }
  arg1 = reinterpret_cast< ampl::Environment * >(argp1);
  {
    try {
      result = (ampl::AMPL *)new ampl::AMPL((ampl::Environment const &)*arg1);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__AMPL, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN int _wrap_new_AMPL(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  Py_ssize_t ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = args ? PyObject_Length(args) : 0;
  for (ii = 0; (ii < 1) && (ii < argc); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 0) {
    return _wrap_new_AMPL__SWIG_0(self, args);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_ampl__Environment, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_AMPL__SWIG_1(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'new_AMPL'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    ampl::AMPL::AMPL()\n"
    "    ampl::AMPL::AMPL(ampl::Environment const &)\n");
  return -1;
}


SWIGINTERN PyObject *_wrap_delete_AMPL(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "delete_AMPL takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_AMPL" "', argument " "1"" of type '" "ampl::AMPL *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  {
    try {
      delete arg1;
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_getEntity(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  fmt::CStringRef arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj1 = 0 ;
  SwigValueWrapper< ampl::Entity > result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:AMPL_getEntity",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_getEntity" "', argument " "1"" of type '" "ampl::AMPL const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  
  arg2 = _PyString_AsString(obj1);
  
  {
    try {
      result = ((ampl::AMPL const *)arg1)->getEntity(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::Entity(static_cast< const ampl::Entity& >(result))), SWIGTYPE_p_ampl__Entity, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_getVariable(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  fmt::CStringRef arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj1 = 0 ;
  SwigValueWrapper< ampl::Variable > result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:AMPL_getVariable",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_getVariable" "', argument " "1"" of type '" "ampl::AMPL const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  
  arg2 = _PyString_AsString(obj1);
  
  {
    try {
      result = ((ampl::AMPL const *)arg1)->getVariable(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::Variable(static_cast< const ampl::Variable& >(result))), SWIGTYPE_p_ampl__Variable, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_getConstraint(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  fmt::CStringRef arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj1 = 0 ;
  SwigValueWrapper< ampl::Constraint > result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:AMPL_getConstraint",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_getConstraint" "', argument " "1"" of type '" "ampl::AMPL const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  
  arg2 = _PyString_AsString(obj1);
  
  {
    try {
      result = ((ampl::AMPL const *)arg1)->getConstraint(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::Constraint(static_cast< const ampl::Constraint& >(result))), SWIGTYPE_p_ampl__Constraint, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_getObjective(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  fmt::CStringRef arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj1 = 0 ;
  SwigValueWrapper< ampl::Objective > result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:AMPL_getObjective",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_getObjective" "', argument " "1"" of type '" "ampl::AMPL const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  
  arg2 = _PyString_AsString(obj1);
  
  {
    try {
      result = ((ampl::AMPL const *)arg1)->getObjective(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::Objective(static_cast< const ampl::Objective& >(result))), SWIGTYPE_p_ampl__Objective, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_getSet(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  fmt::CStringRef arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj1 = 0 ;
  SwigValueWrapper< ampl::Set > result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:AMPL_getSet",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_getSet" "', argument " "1"" of type '" "ampl::AMPL const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  
  arg2 = _PyString_AsString(obj1);
  
  {
    try {
      result = ((ampl::AMPL const *)arg1)->getSet(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::Set(static_cast< const ampl::Set& >(result))), SWIGTYPE_p_ampl__Set, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_getParameter(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  fmt::CStringRef arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj1 = 0 ;
  SwigValueWrapper< ampl::Parameter > result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:AMPL_getParameter",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_getParameter" "', argument " "1"" of type '" "ampl::AMPL const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  
  arg2 = _PyString_AsString(obj1);
  
  {
    try {
      result = ((ampl::AMPL const *)arg1)->getParameter(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::Parameter(static_cast< const ampl::Parameter& >(result))), SWIGTYPE_p_ampl__Parameter, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_eval(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  fmt::CStringRef arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:AMPL_eval",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_eval" "', argument " "1"" of type '" "ampl::AMPL *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  
  arg2 = _PyString_AsString(obj1);
  
  {
    try {
      (arg1)->eval(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_reset(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "AMPL_reset takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_reset" "', argument " "1"" of type '" "ampl::AMPL *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  {
    try {
      (arg1)->reset();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_close(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "AMPL_close takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_close" "', argument " "1"" of type '" "ampl::AMPL *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  {
    try {
      (arg1)->close();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_isRunning(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "AMPL_isRunning takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_isRunning" "', argument " "1"" of type '" "ampl::AMPL const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  {
    try {
      result = (bool)((ampl::AMPL const *)arg1)->isRunning();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_isBusy(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "AMPL_isBusy takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_isBusy" "', argument " "1"" of type '" "ampl::AMPL const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  {
    try {
      result = (bool)((ampl::AMPL const *)arg1)->isBusy();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_solve(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "AMPL_solve takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_solve" "', argument " "1"" of type '" "ampl::AMPL *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  {
    try {
      (arg1)->solve();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_readAsync(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  fmt::CStringRef arg2 ;
  ampl::Runnable *arg3 = (ampl::Runnable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:AMPL_readAsync",&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_readAsync" "', argument " "1"" of type '" "ampl::AMPL *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  
  arg2 = _PyString_AsString(obj1);
  
  res3 = SWIG_ConvertPtr(obj2, &argp3,SWIGTYPE_p_ampl__Runnable, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "AMPL_readAsync" "', argument " "3"" of type '" "ampl::Runnable *""'"); 
  }
  arg3 = reinterpret_cast< ampl::Runnable * >(argp3);
  {
    try {
      (arg1)->readAsync(arg2,arg3);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_readDataAsync(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  fmt::CStringRef arg2 ;
  ampl::Runnable *arg3 = (ampl::Runnable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:AMPL_readDataAsync",&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_readDataAsync" "', argument " "1"" of type '" "ampl::AMPL *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  
  arg2 = _PyString_AsString(obj1);
  
  res3 = SWIG_ConvertPtr(obj2, &argp3,SWIGTYPE_p_ampl__Runnable, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "AMPL_readDataAsync" "', argument " "3"" of type '" "ampl::Runnable *""'"); 
  }
  arg3 = reinterpret_cast< ampl::Runnable * >(argp3);
  {
    try {
      (arg1)->readDataAsync(arg2,arg3);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_evalAsync(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  fmt::CStringRef arg2 ;
  ampl::Runnable *arg3 = (ampl::Runnable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:AMPL_evalAsync",&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_evalAsync" "', argument " "1"" of type '" "ampl::AMPL *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  
  arg2 = _PyString_AsString(obj1);
  
  res3 = SWIG_ConvertPtr(obj2, &argp3,SWIGTYPE_p_ampl__Runnable, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "AMPL_evalAsync" "', argument " "3"" of type '" "ampl::Runnable *""'"); 
  }
  arg3 = reinterpret_cast< ampl::Runnable * >(argp3);
  {
    try {
      (arg1)->evalAsync(arg2,arg3);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_solveAsync(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  ampl::Runnable *arg2 = (ampl::Runnable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:AMPL_solveAsync",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_solveAsync" "', argument " "1"" of type '" "ampl::AMPL *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_ampl__Runnable, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AMPL_solveAsync" "', argument " "2"" of type '" "ampl::Runnable *""'"); 
  }
  arg2 = reinterpret_cast< ampl::Runnable * >(argp2);
  {
    try {
      (arg1)->solveAsync(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_interrupt(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "AMPL_interrupt takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_interrupt" "', argument " "1"" of type '" "ampl::AMPL *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  {
    try {
      (arg1)->interrupt();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_cd__SWIG_0(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "AMPL_cd takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_cd" "', argument " "1"" of type '" "ampl::AMPL const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  {
    try {
      result = ((ampl::AMPL const *)arg1)->cd();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_cd__SWIG_1(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  fmt::CStringRef arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj1 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:AMPL_cd",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_cd" "', argument " "1"" of type '" "ampl::AMPL *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  
  arg2 = _PyString_AsString(obj1);
  
  {
    try {
      result = (arg1)->cd(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_cd(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  Py_ssize_t ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = args ? PyObject_Length(args) : 0;
  argv[0] = self;
  for (ii = 0; (ii < 1) && (ii < argc); ii++) {
    argv[ii + 1] = PyTuple_GET_ITEM(args,ii);
  }
  argc++;
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__AMPL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_AMPL_cd__SWIG_0(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__AMPL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_AMPL_cd__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'AMPL_cd'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    ampl::AMPL::cd() const\n"
    "    ampl::AMPL::cd(fmt::CStringRef)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_AMPL_setOption(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  fmt::CStringRef arg2 ;
  fmt::CStringRef arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:AMPL_setOption",&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_setOption" "', argument " "1"" of type '" "ampl::AMPL *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  
  arg2 = _PyString_AsString(obj1);
  
  
  arg3 = _PyString_AsString(obj2);
  
  {
    try {
      (arg1)->setOption(arg2,arg3);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_getOption(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  fmt::CStringRef arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj1 = 0 ;
  ampl::Optional< std::string > result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:AMPL_getOption",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_getOption" "', argument " "1"" of type '" "ampl::AMPL const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  
  arg2 = _PyString_AsString(obj1);
  
  {
    try {
      result = ((ampl::AMPL const *)arg1)->getOption(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::Optional< std::string >(static_cast< const ampl::Optional< std::string >& >(result))), SWIGTYPE_p_ampl__OptionalT_std__string_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_getIntOption(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  fmt::CStringRef arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj1 = 0 ;
  ampl::Optional< int > result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:AMPL_getIntOption",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_getIntOption" "', argument " "1"" of type '" "ampl::AMPL const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  
  arg2 = _PyString_AsString(obj1);
  
  {
    try {
      result = ((ampl::AMPL const *)arg1)->getIntOption(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::Optional< int >(static_cast< const ampl::Optional< int >& >(result))), SWIGTYPE_p_ampl__OptionalT_int_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_setIntOption(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  fmt::CStringRef arg2 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:AMPL_setIntOption",&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_setIntOption" "', argument " "1"" of type '" "ampl::AMPL *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  
  arg2 = _PyString_AsString(obj1);
  
  ecode3 = SWIG_AsVal_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "AMPL_setIntOption" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  {
    try {
      (arg1)->setIntOption(arg2,arg3);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_getDblOption(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  fmt::CStringRef arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj1 = 0 ;
  ampl::Optional< double > result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:AMPL_getDblOption",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_getDblOption" "', argument " "1"" of type '" "ampl::AMPL const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  
  arg2 = _PyString_AsString(obj1);
  
  {
    try {
      result = ((ampl::AMPL const *)arg1)->getDblOption(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::Optional< double >(static_cast< const ampl::Optional< double >& >(result))), SWIGTYPE_p_ampl__OptionalT_double_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_setDblOption(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  fmt::CStringRef arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:AMPL_setDblOption",&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_setDblOption" "', argument " "1"" of type '" "ampl::AMPL *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  
  arg2 = _PyString_AsString(obj1);
  
  ecode3 = SWIG_AsVal_double(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "AMPL_setDblOption" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  {
    try {
      (arg1)->setDblOption(arg2,arg3);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_getBoolOption(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  fmt::CStringRef arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj1 = 0 ;
  ampl::Optional< bool > result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:AMPL_getBoolOption",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_getBoolOption" "', argument " "1"" of type '" "ampl::AMPL const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  
  arg2 = _PyString_AsString(obj1);
  
  {
    try {
      result = ((ampl::AMPL const *)arg1)->getBoolOption(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::Optional< bool >(static_cast< const ampl::Optional< bool >& >(result))), SWIGTYPE_p_ampl__OptionalT_bool_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_setBoolOption(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  fmt::CStringRef arg2 ;
  bool arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:AMPL_setBoolOption",&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_setBoolOption" "', argument " "1"" of type '" "ampl::AMPL *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  
  arg2 = _PyString_AsString(obj1);
  
  ecode3 = SWIG_AsVal_bool(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "AMPL_setBoolOption" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  {
    try {
      (arg1)->setBoolOption(arg2,arg3);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_read(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  fmt::CStringRef arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:AMPL_read",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_read" "', argument " "1"" of type '" "ampl::AMPL *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  
  arg2 = _PyString_AsString(obj1);
  
  {
    try {
      (arg1)->read(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_readData(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  fmt::CStringRef arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:AMPL_readData",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_readData" "', argument " "1"" of type '" "ampl::AMPL *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  
  arg2 = _PyString_AsString(obj1);
  
  {
    try {
      (arg1)->readData(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_getValue(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  fmt::CStringRef arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj1 = 0 ;
  SwigValueWrapper< ampl::Variant > result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:AMPL_getValue",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_getValue" "', argument " "1"" of type '" "ampl::AMPL const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  
  arg2 = _PyString_AsString(obj1);
  
  {
    try {
      result = ((ampl::AMPL const *)arg1)->getValue(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::Variant(static_cast< const ampl::Variant& >(result))), SWIGTYPE_p_ampl__Variant, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_setData__SWIG_0(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  ampl::DataFrame *arg2 = 0 ;
  fmt::CStringRef arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:AMPL_setData",&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_setData" "', argument " "1"" of type '" "ampl::AMPL *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__DataFrame,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AMPL_setData" "', argument " "2"" of type '" "ampl::DataFrame const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "AMPL_setData" "', argument " "2"" of type '" "ampl::DataFrame const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::DataFrame * >(argp2);
  
  arg3 = _PyString_AsString(obj2);
  
  {
    try {
      (arg1)->setData((ampl::DataFrame const &)*arg2,arg3);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_setData__SWIG_1(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  ampl::DataFrame *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:AMPL_setData",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_setData" "', argument " "1"" of type '" "ampl::AMPL *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__DataFrame,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AMPL_setData" "', argument " "2"" of type '" "ampl::DataFrame const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "AMPL_setData" "', argument " "2"" of type '" "ampl::DataFrame const &""'"); 
  }
  arg2 = reinterpret_cast< ampl::DataFrame * >(argp2);
  {
    try {
      (arg1)->setData((ampl::DataFrame const &)*arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_setData(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  Py_ssize_t ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = args ? PyObject_Length(args) : 0;
  argv[0] = self;
  for (ii = 0; (ii < 2) && (ii < argc); ii++) {
    argv[ii + 1] = PyTuple_GET_ITEM(args,ii);
  }
  argc++;
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__AMPL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_ampl__DataFrame, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_AMPL_setData__SWIG_1(self, args);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ampl__AMPL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_ampl__DataFrame, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_AMPL_setData__SWIG_0(self, args);
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'AMPL_setData'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    ampl::AMPL::setData(ampl::DataFrame const &,fmt::CStringRef)\n"
    "    ampl::AMPL::setData(ampl::DataFrame const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_AMPL_toString(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "AMPL_toString takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_toString" "', argument " "1"" of type '" "ampl::AMPL const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  {
    try {
      result = ((ampl::AMPL const *)arg1)->toString();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_readTable(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  fmt::CStringRef arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:AMPL_readTable",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_readTable" "', argument " "1"" of type '" "ampl::AMPL *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  
  arg2 = _PyString_AsString(obj1);
  
  {
    try {
      (arg1)->readTable(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_writeTable(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  fmt::CStringRef arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:AMPL_writeTable",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_writeTable" "', argument " "1"" of type '" "ampl::AMPL *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  
  arg2 = _PyString_AsString(obj1);
  
  {
    try {
      (arg1)->writeTable(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_display(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  SwigValueWrapper< ampl::EntityArgs > arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:AMPL_display",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_display" "', argument " "1"" of type '" "ampl::AMPL *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__EntityArgs,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AMPL_display" "', argument " "2"" of type '" "ampl::EntityArgs""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "AMPL_display" "', argument " "2"" of type '" "ampl::EntityArgs""'");
    } else {
      ampl::EntityArgs * temp = reinterpret_cast< ampl::EntityArgs * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      (arg1)->display(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_show(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  SwigValueWrapper< ampl::EntityArgs > arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:AMPL_show",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_show" "', argument " "1"" of type '" "ampl::AMPL *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__EntityArgs,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AMPL_show" "', argument " "2"" of type '" "ampl::EntityArgs""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "AMPL_show" "', argument " "2"" of type '" "ampl::EntityArgs""'");
    } else {
      ampl::EntityArgs * temp = reinterpret_cast< ampl::EntityArgs * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      (arg1)->show(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_expand(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  SwigValueWrapper< ampl::EntityArgs > arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:AMPL_expand",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_expand" "', argument " "1"" of type '" "ampl::AMPL *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_ampl__EntityArgs,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AMPL_expand" "', argument " "2"" of type '" "ampl::EntityArgs""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "AMPL_expand" "', argument " "2"" of type '" "ampl::EntityArgs""'");
    } else {
      ampl::EntityArgs * temp = reinterpret_cast< ampl::EntityArgs * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try {
      (arg1)->expand(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_setOutputHandler(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  ampl::OutputHandler *arg2 = (ampl::OutputHandler *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:AMPL_setOutputHandler",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_setOutputHandler" "', argument " "1"" of type '" "ampl::AMPL *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_ampl__OutputHandler, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AMPL_setOutputHandler" "', argument " "2"" of type '" "ampl::OutputHandler *""'"); 
  }
  arg2 = reinterpret_cast< ampl::OutputHandler * >(argp2);
  {
    try {
      (arg1)->setOutputHandler(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_setErrorHandler(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  ampl::ErrorHandler *arg2 = (ampl::ErrorHandler *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:AMPL_setErrorHandler",&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_setErrorHandler" "', argument " "1"" of type '" "ampl::AMPL *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_ampl__ErrorHandler, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AMPL_setErrorHandler" "', argument " "2"" of type '" "ampl::ErrorHandler *""'"); 
  }
  arg2 = reinterpret_cast< ampl::ErrorHandler * >(argp2);
  {
    try {
      (arg1)->setErrorHandler(arg2);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_getOutputHandler(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Swig::Director *director = 0;
  ampl::OutputHandler *result = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "AMPL_getOutputHandler takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_getOutputHandler" "', argument " "1"" of type '" "ampl::AMPL const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  {
    try {
      result = (ampl::OutputHandler *)((ampl::AMPL const *)arg1)->getOutputHandler();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  director = SWIG_DIRECTOR_CAST(result);
  if (director) {
    resultobj = director->swig_get_self();
    Py_INCREF(resultobj);
  } else {
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__OutputHandler, 0 |  0 );
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_getErrorHandler(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Swig::Director *director = 0;
  ampl::ErrorHandler *result = 0 ;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "AMPL_getErrorHandler takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_getErrorHandler" "', argument " "1"" of type '" "ampl::AMPL const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  {
    try {
      result = (ampl::ErrorHandler *)((ampl::AMPL const *)arg1)->getErrorHandler();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  director = SWIG_DIRECTOR_CAST(result);
  if (director) {
    resultobj = director->swig_get_self();
    Py_INCREF(resultobj);
  } else {
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ampl__ErrorHandler, 0 |  0 );
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_getVariables(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< ampl::EntityMap< ampl::Variable > > result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "AMPL_getVariables takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_getVariables" "', argument " "1"" of type '" "ampl::AMPL const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  {
    try {
      result = ((ampl::AMPL const *)arg1)->getVariables();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::EntityMap< ampl::Variable >(static_cast< const ampl::EntityMap< ampl::Variable >& >(result))), SWIGTYPE_p_ampl__EntityMapT_ampl__Variable_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_getConstraints(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< ampl::EntityMap< ampl::Constraint > > result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "AMPL_getConstraints takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_getConstraints" "', argument " "1"" of type '" "ampl::AMPL const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  {
    try {
      result = ((ampl::AMPL const *)arg1)->getConstraints();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::EntityMap< ampl::Constraint >(static_cast< const ampl::EntityMap< ampl::Constraint >& >(result))), SWIGTYPE_p_ampl__EntityMapT_ampl__Constraint_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_getObjectives(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< ampl::EntityMap< ampl::Objective > > result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "AMPL_getObjectives takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_getObjectives" "', argument " "1"" of type '" "ampl::AMPL const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  {
    try {
      result = ((ampl::AMPL const *)arg1)->getObjectives();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::EntityMap< ampl::Objective >(static_cast< const ampl::EntityMap< ampl::Objective >& >(result))), SWIGTYPE_p_ampl__EntityMapT_ampl__Objective_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_getSets(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< ampl::EntityMap< ampl::Set > > result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "AMPL_getSets takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_getSets" "', argument " "1"" of type '" "ampl::AMPL const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  {
    try {
      result = ((ampl::AMPL const *)arg1)->getSets();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::EntityMap< ampl::Set >(static_cast< const ampl::EntityMap< ampl::Set >& >(result))), SWIGTYPE_p_ampl__EntityMapT_ampl__Set_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_getParameters(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< ampl::EntityMap< ampl::Parameter > > result;
  
  if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "AMPL_getParameters takes no arguments");
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_getParameters" "', argument " "1"" of type '" "ampl::AMPL const *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  {
    try {
      result = ((ampl::AMPL const *)arg1)->getParameters();
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::EntityMap< ampl::Parameter >(static_cast< const ampl::EntityMap< ampl::Parameter >& >(result))), SWIGTYPE_p_ampl__EntityMapT_ampl__Parameter_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_displayLst(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  char **arg2 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  {
    arg2 = NULL;
  }
  if (!PyArg_ParseTuple(args,(char *)"OO:AMPL_displayLst",&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_displayLst" "', argument " "1"" of type '" "ampl::AMPL *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  {
    /* Check if is a list */
    if (PyList_Check(obj1)) {
      int size = PyList_Size(obj1);
      int i = 0;
      arg2 = (char **)malloc((size + 1) * sizeof(char *));
      for (i = 0; i < size; i++) {
        PyObject *obj = PyList_GetItem(obj1,i);
        if (_PyString_Check(obj)) {
          arg2[i] = _PyString_AsString(PyList_GetItem(obj1,i));
        } else {
          PyErr_SetString(PyExc_TypeError,"list must contain strings");
          free(arg2);
          return NULL;
        }
      }
      arg2[i] = 0;
    }
    else {
      PyErr_SetString(PyExc_TypeError,"not a list");
      return NULL;
    }
  }
  ecode3 = SWIG_AsVal_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "AMPL_displayLst" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  {
    try {
      ampl_AMPL_display(arg1,(char const *(*))arg2,arg3);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_Py_Void();
  {
    free((char *)arg2);
  }
  return resultobj;
fail:
  {
    free((char *)arg2);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_AMPL_getData(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ampl::AMPL *arg1 = (ampl::AMPL *) 0 ;
  char **arg2 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  SwigValueWrapper< ampl::DataFrame > result;
  
  {
    arg2 = NULL;
  }
  if (!PyArg_ParseTuple(args,(char *)"OO:AMPL_getData",&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ampl__AMPL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AMPL_getData" "', argument " "1"" of type '" "ampl::AMPL *""'"); 
  }
  arg1 = reinterpret_cast< ampl::AMPL * >(argp1);
  {
    /* Check if is a list */
    if (PyList_Check(obj1)) {
      int size = PyList_Size(obj1);
      int i = 0;
      arg2 = (char **)malloc((size + 1) * sizeof(char *));
      for (i = 0; i < size; i++) {
        PyObject *obj = PyList_GetItem(obj1,i);
        if (_PyString_Check(obj)) {
          arg2[i] = _PyString_AsString(PyList_GetItem(obj1,i));
        } else {
          PyErr_SetString(PyExc_TypeError,"list must contain strings");
          free(arg2);
          return NULL;
        }
      }
      arg2[i] = 0;
    }
    else {
      PyErr_SetString(PyExc_TypeError,"not a list");
      return NULL;
    }
  }
  ecode3 = SWIG_AsVal_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "AMPL_getData" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  {
    try {
      result = ampl_AMPL_getData(arg1,(char const *(*))arg2,arg3);
    }
    catch (std::range_error) {
      SWIG_exception(SWIG_ValueError, "Range Error");
    }
    catch (ampl::AMPLException e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::logic_error e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::UnsupportedOperationException e)
    {
      SWIG_exception(SWIG_TypeError, e.what());
    }
    catch (ampl::LicenseException e) {
      SWIG_exception(SWIG_SystemError, e.what());
    }
    catch (ampl::FileIOException e) {
      SWIG_exception(SWIG_IOError, e.what());
    }
    catch (std::runtime_error e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
    catch (std::exception e) {
      SWIG_exception(SWIG_UnknownError, e.what());
    }
    catch (...) {
      SWIG_exception(SWIG_UnknownError,"Unknown exception");
    }
  }
  resultobj = SWIG_NewPointerObj((new ampl::DataFrame(static_cast< const ampl::DataFrame& >(result))), SWIGTYPE_p_ampl__DataFrame, SWIG_POINTER_OWN |  0 );
  {
    free((char *)arg2);
  }
  return resultobj;
fail:
  {
    free((char *)arg2);
  }
  return NULL;
}


static PyMethodDef SwigMethods[] = {
	 { (char *)"SWIG_PyInstanceMethod_New", (PyCFunction)SWIG_PyInstanceMethod_New, METH_O, NULL},
	 { (char *)"VariantArray_frompointer", _wrap_VariantArray_frompointer, METH_VARARGS, NULL},
	 { (char *)"TupleArray_frompointer", _wrap_TupleArray_frompointer, METH_VARARGS, NULL},
	 { (char *)"Tuple_Factory", _wrap_Tuple_Factory, METH_VARARGS, NULL},
	 { (char *)"DataFrame_factory", _wrap_DataFrame_factory, METH_VARARGS, NULL},
	 { (char *)"EntityArray_frompointer", _wrap_EntityArray_frompointer, METH_VARARGS, NULL},
	 { (char *)"EntityArgs_Factory", _wrap_EntityArgs_Factory, METH_VARARGS, NULL},
	 { (char *)"disown_ErrorHandler", _wrap_disown_ErrorHandler, METH_VARARGS, NULL},
	 { (char *)"disown_Runnable", _wrap_disown_Runnable, METH_VARARGS, NULL},
	 { (char *)"disown_OutputHandler", _wrap_disown_OutputHandler, METH_VARARGS, NULL},
	 { NULL, NULL, 0, NULL }
};

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_StringArray)
static SwigPyGetSet StringArray___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__StringArray_getset[] = {
    { (char*) "__dict__", (getter) SwigPyBuiltin_GetterClosure, (setter) 0, (char*)"ampl::StringArray.__dict__", (void*) &StringArray___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__StringArray_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  PyObject *tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, other);
  Py_XINCREF(other);
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__StringArray_methods[] = {
  { "size", (PyCFunction) _wrap_StringArray_size, METH_VARARGS, (char*) "" },
  { "getIndex", (PyCFunction) _wrap_StringArray_getIndex, METH_VARARGS, (char*) "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__StringArray_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.StringArray",                 /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) _wrap_delete_StringArray_closure, /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__StringArray_type.as_number,      /* tp_as_number */
    &SwigPyBuiltin__ampl__StringArray_type.as_sequence,    /* tp_as_sequence */
    &SwigPyBuiltin__ampl__StringArray_type.as_mapping,     /* tp_as_mapping */
    (hashfunc) 0,                             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__StringArray_type.as_buffer,      /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::StringArray",                      /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ampl__StringArray_richcompare, /* feature:python:tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__StringArray_methods, /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__StringArray_getset,  /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t)offsetof(SwigPyObject, dict), /* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject*) 0,                            /* tp_bases */
    (PyObject*) 0,                            /* tp_mro */
    (PyObject*) 0,                            /* tp_cache */
    (PyObject*) 0,                            /* tp_subclasses */
    (PyObject*) 0,                            /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    (struct _typeobject*) 0,                  /* tp_prev */
#endif
    (struct _typeobject*) 0,                  /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject*) 0,                            /* ht_name */
    (PyObject*) 0,                            /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject*) 0,                            /* ht_qualname */
    (struct _dictkeysobject*) 0,              /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__StringArray_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__StringArray_type};

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_StringRefArray)
static SwigPyGetSet StringRefArray___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__StringRefArray_getset[] = {
    { (char*) "__dict__", (getter) SwigPyBuiltin_GetterClosure, (setter) 0, (char*)"ampl::StringRefArray.__dict__", (void*) &StringRefArray___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__StringRefArray_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  PyObject *tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, other);
  Py_XINCREF(other);
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__StringRefArray_methods[] = {
  { "size", (PyCFunction) _wrap_StringRefArray_size, METH_VARARGS, (char*) "" },
  { "getIndex", (PyCFunction) _wrap_StringRefArray_getIndex, METH_VARARGS, (char*) "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__StringRefArray_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.StringRefArray",              /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) _wrap_delete_StringRefArray_closure, /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__StringRefArray_type.as_number,      /* tp_as_number */
    &SwigPyBuiltin__ampl__StringRefArray_type.as_sequence,    /* tp_as_sequence */
    &SwigPyBuiltin__ampl__StringRefArray_type.as_mapping,     /* tp_as_mapping */
    (hashfunc) 0,                             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__StringRefArray_type.as_buffer,      /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::StringRefArray",                   /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ampl__StringRefArray_richcompare, /* feature:python:tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__StringRefArray_methods, /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__StringRefArray_getset, /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t)offsetof(SwigPyObject, dict), /* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject*) 0,                            /* tp_bases */
    (PyObject*) 0,                            /* tp_mro */
    (PyObject*) 0,                            /* tp_cache */
    (PyObject*) 0,                            /* tp_subclasses */
    (PyObject*) 0,                            /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    (struct _typeobject*) 0,                  /* tp_prev */
#endif
    (struct _typeobject*) 0,                  /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject*) 0,                            /* ht_name */
    (PyObject*) 0,                            /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject*) 0,                            /* ht_qualname */
    (struct _dictkeysobject*) 0,              /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__StringRefArray_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__StringRefArray_type};

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_runtime_error)
static SwigPyGetSet runtime_error___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__std__runtime_error_getset[] = {
    { (char*) "__dict__", (getter) SwigPyBuiltin_GetterClosure, (setter) 0, (char*)"std::runtime_error.__dict__", (void*) &runtime_error___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__std__runtime_error_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  PyObject *tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, other);
  Py_XINCREF(other);
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__std__runtime_error_methods[] = {
  { "what", (PyCFunction) _wrap_runtime_error_what, METH_VARARGS, (char*) "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__std__runtime_error_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.runtime_error",               /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) _wrap_delete_runtime_error_closure, /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__std__runtime_error_type.as_number,      /* tp_as_number */
    &SwigPyBuiltin__std__runtime_error_type.as_sequence,    /* tp_as_sequence */
    &SwigPyBuiltin__std__runtime_error_type.as_mapping,     /* tp_as_mapping */
    (hashfunc) 0,                             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__std__runtime_error_type.as_buffer,      /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "std::runtime_error",                     /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__std__runtime_error_richcompare, /* feature:python:tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__std__runtime_error_methods, /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__std__runtime_error_getset, /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t)offsetof(SwigPyObject, dict), /* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject*) 0,                            /* tp_bases */
    (PyObject*) 0,                            /* tp_mro */
    (PyObject*) 0,                            /* tp_cache */
    (PyObject*) 0,                            /* tp_subclasses */
    (PyObject*) 0,                            /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    (struct _typeobject*) 0,                  /* tp_prev */
#endif
    (struct _typeobject*) 0,                  /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject*) 0,                            /* ht_name */
    (PyObject*) 0,                            /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject*) 0,                            /* ht_qualname */
    (struct _dictkeysobject*) 0,              /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__std__runtime_error_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__std__runtime_error_type};

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_VariantArray)
static SwigPyGetSet VariantArray_el_getset = { _wrap_VariantArray_el_get, _wrap_VariantArray_el_set };
static SwigPyGetSet VariantArray___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__VariantArray_getset[] = {
    { (char*) "el", (getter) SwigPyBuiltin_GetterClosure, (setter) SwigPyBuiltin_SetterClosure, (char*)"VariantArray.el", (void*) &VariantArray_el_getset }
,
    { (char*) "__dict__", (getter) SwigPyBuiltin_GetterClosure, (setter) 0, (char*)"VariantArray.__dict__", (void*) &VariantArray___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__VariantArray_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  PyObject *tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, other);
  Py_XINCREF(other);
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__VariantArray_methods[] = {
  { "__getitem__", (PyCFunction) _wrap_VariantArray___getitem__, METH_VARARGS, (char*) "" },
  { "__setitem__", (PyCFunction) _wrap_VariantArray___setitem__, METH_VARARGS, (char*) "" },
  { "cast", (PyCFunction) _wrap_VariantArray_cast, METH_VARARGS, (char*) "" },
  { "frompointer", (PyCFunction) _wrap_VariantArray_frompointer, METH_STATIC|METH_VARARGS, "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__VariantArray_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.VariantArray",                /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) _wrap_delete_VariantArray_closure, /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__VariantArray_type.as_number,      /* tp_as_number */
    &SwigPyBuiltin__VariantArray_type.as_sequence,    /* tp_as_sequence */
    &SwigPyBuiltin__VariantArray_type.as_mapping,     /* tp_as_mapping */
    (hashfunc) 0,                             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__VariantArray_type.as_buffer,      /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "::VariantArray",                         /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__VariantArray_richcompare, /* feature:python:tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__VariantArray_methods,      /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__VariantArray_getset,       /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t)offsetof(SwigPyObject, dict), /* tp_dictoffset */
    (initproc) _wrap_new_VariantArray,        /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject*) 0,                            /* tp_bases */
    (PyObject*) 0,                            /* tp_mro */
    (PyObject*) 0,                            /* tp_cache */
    (PyObject*) 0,                            /* tp_subclasses */
    (PyObject*) 0,                            /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    (struct _typeobject*) 0,                  /* tp_prev */
#endif
    (struct _typeobject*) 0,                  /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) (ssizeargfunc) _wrap_VariantArray___getitem___closure, /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) (ssizeobjargproc) _wrap_VariantArray___setitem___closure, /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject*) 0,                            /* ht_name */
    (PyObject*) 0,                            /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject*) 0,                            /* ht_qualname */
    (struct _dictkeysobject*) 0,              /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__VariantArray_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__VariantArray_type};

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_TupleArray)
static SwigPyGetSet TupleArray_el_getset = { _wrap_TupleArray_el_get, _wrap_TupleArray_el_set };
static SwigPyGetSet TupleArray___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__TupleArray_getset[] = {
    { (char*) "el", (getter) SwigPyBuiltin_GetterClosure, (setter) SwigPyBuiltin_SetterClosure, (char*)"TupleArray.el", (void*) &TupleArray_el_getset }
,
    { (char*) "__dict__", (getter) SwigPyBuiltin_GetterClosure, (setter) 0, (char*)"TupleArray.__dict__", (void*) &TupleArray___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__TupleArray_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  PyObject *tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, other);
  Py_XINCREF(other);
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__TupleArray_methods[] = {
  { "__getitem__", (PyCFunction) _wrap_TupleArray___getitem__, METH_VARARGS, (char*) "" },
  { "__setitem__", (PyCFunction) _wrap_TupleArray___setitem__, METH_VARARGS, (char*) "" },
  { "cast", (PyCFunction) _wrap_TupleArray_cast, METH_VARARGS, (char*) "" },
  { "frompointer", (PyCFunction) _wrap_TupleArray_frompointer, METH_STATIC|METH_VARARGS, "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__TupleArray_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.TupleArray",                  /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) _wrap_delete_TupleArray_closure, /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__TupleArray_type.as_number,      /* tp_as_number */
    &SwigPyBuiltin__TupleArray_type.as_sequence,    /* tp_as_sequence */
    &SwigPyBuiltin__TupleArray_type.as_mapping,     /* tp_as_mapping */
    (hashfunc) 0,                             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__TupleArray_type.as_buffer,      /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "::TupleArray",                           /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__TupleArray_richcompare, /* feature:python:tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__TupleArray_methods,        /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__TupleArray_getset,         /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t)offsetof(SwigPyObject, dict), /* tp_dictoffset */
    (initproc) _wrap_new_TupleArray,          /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject*) 0,                            /* tp_bases */
    (PyObject*) 0,                            /* tp_mro */
    (PyObject*) 0,                            /* tp_cache */
    (PyObject*) 0,                            /* tp_subclasses */
    (PyObject*) 0,                            /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    (struct _typeobject*) 0,                  /* tp_prev */
#endif
    (struct _typeobject*) 0,                  /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) (ssizeargfunc) _wrap_TupleArray___getitem___closure, /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) (ssizeobjargproc) _wrap_TupleArray___setitem___closure, /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject*) 0,                            /* ht_name */
    (PyObject*) 0,                            /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject*) 0,                            /* ht_qualname */
    (struct _dictkeysobject*) 0,              /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__TupleArray_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__TupleArray_type};

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_OptionalInt)
static SwigPyGetSet OptionalInt___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__OptionalT_int_t_getset[] = {
    { (char*) "__dict__", (getter) SwigPyBuiltin_GetterClosure, (setter) 0, (char*)"ampl::Optional<(int)>.__dict__", (void*) &OptionalInt___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__OptionalT_int_t_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  PyObject *tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, other);
  Py_XINCREF(other);
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__OptionalT_int_t_methods[] = {
  { "__nonzero__", (PyCFunction) _wrap_OptionalInt___nonzero__, METH_VARARGS, (char*) "" },
  { "value", (PyCFunction) _wrap_OptionalInt_value, METH_VARARGS, (char*) "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__OptionalT_int_t_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.OptionalInt",                 /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) _wrap_delete_OptionalInt_closure, /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__OptionalT_int_t_type.as_number,      /* tp_as_number */
    &SwigPyBuiltin__ampl__OptionalT_int_t_type.as_sequence,    /* tp_as_sequence */
    &SwigPyBuiltin__ampl__OptionalT_int_t_type.as_mapping,     /* tp_as_mapping */
    (hashfunc) 0,                             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__OptionalT_int_t_type.as_buffer,      /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::Optional< int >",                  /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ampl__OptionalT_int_t_richcompare, /* feature:python:tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__OptionalT_int_t_methods, /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__OptionalT_int_t_getset, /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t)offsetof(SwigPyObject, dict), /* tp_dictoffset */
    (initproc) _wrap_new_OptionalInt,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject*) 0,                            /* tp_bases */
    (PyObject*) 0,                            /* tp_mro */
    (PyObject*) 0,                            /* tp_cache */
    (PyObject*) 0,                            /* tp_subclasses */
    (PyObject*) 0,                            /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    (struct _typeobject*) 0,                  /* tp_prev */
#endif
    (struct _typeobject*) 0,                  /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) (inquiry) _wrap_OptionalInt___nonzero___closure, /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject*) 0,                            /* ht_name */
    (PyObject*) 0,                            /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject*) 0,                            /* ht_qualname */
    (struct _dictkeysobject*) 0,              /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__OptionalT_int_t_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__OptionalT_int_t_type};

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_OptionalString)
static SwigPyGetSet OptionalString___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__OptionalT_std__string_t_getset[] = {
    { (char*) "__dict__", (getter) SwigPyBuiltin_GetterClosure, (setter) 0, (char*)"ampl::Optional<(std::string)>.__dict__", (void*) &OptionalString___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__OptionalT_std__string_t_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  PyObject *tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, other);
  Py_XINCREF(other);
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__OptionalT_std__string_t_methods[] = {
  { "__nonzero__", (PyCFunction) _wrap_OptionalString___nonzero__, METH_VARARGS, (char*) "" },
  { "value", (PyCFunction) _wrap_OptionalString_value, METH_VARARGS, (char*) "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__OptionalT_std__string_t_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.OptionalString",              /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) _wrap_delete_OptionalString_closure, /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__OptionalT_std__string_t_type.as_number,      /* tp_as_number */
    &SwigPyBuiltin__ampl__OptionalT_std__string_t_type.as_sequence,    /* tp_as_sequence */
    &SwigPyBuiltin__ampl__OptionalT_std__string_t_type.as_mapping,     /* tp_as_mapping */
    (hashfunc) 0,                             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__OptionalT_std__string_t_type.as_buffer,      /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::Optional< std::string >",          /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ampl__OptionalT_std__string_t_richcompare, /* feature:python:tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__OptionalT_std__string_t_methods, /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__OptionalT_std__string_t_getset, /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t)offsetof(SwigPyObject, dict), /* tp_dictoffset */
    (initproc) _wrap_new_OptionalString,      /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject*) 0,                            /* tp_bases */
    (PyObject*) 0,                            /* tp_mro */
    (PyObject*) 0,                            /* tp_cache */
    (PyObject*) 0,                            /* tp_subclasses */
    (PyObject*) 0,                            /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    (struct _typeobject*) 0,                  /* tp_prev */
#endif
    (struct _typeobject*) 0,                  /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) (inquiry) _wrap_OptionalString___nonzero___closure, /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject*) 0,                            /* ht_name */
    (PyObject*) 0,                            /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject*) 0,                            /* ht_qualname */
    (struct _dictkeysobject*) 0,              /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__OptionalT_std__string_t_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__OptionalT_std__string_t_type};

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_OptionalBool)
static SwigPyGetSet OptionalBool___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__OptionalT_bool_t_getset[] = {
    { (char*) "__dict__", (getter) SwigPyBuiltin_GetterClosure, (setter) 0, (char*)"ampl::Optional<(bool)>.__dict__", (void*) &OptionalBool___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__OptionalT_bool_t_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  PyObject *tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, other);
  Py_XINCREF(other);
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__OptionalT_bool_t_methods[] = {
  { "__nonzero__", (PyCFunction) _wrap_OptionalBool___nonzero__, METH_VARARGS, (char*) "" },
  { "value", (PyCFunction) _wrap_OptionalBool_value, METH_VARARGS, (char*) "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__OptionalT_bool_t_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.OptionalBool",                /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) _wrap_delete_OptionalBool_closure, /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__OptionalT_bool_t_type.as_number,      /* tp_as_number */
    &SwigPyBuiltin__ampl__OptionalT_bool_t_type.as_sequence,    /* tp_as_sequence */
    &SwigPyBuiltin__ampl__OptionalT_bool_t_type.as_mapping,     /* tp_as_mapping */
    (hashfunc) 0,                             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__OptionalT_bool_t_type.as_buffer,      /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::Optional< bool >",                 /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ampl__OptionalT_bool_t_richcompare, /* feature:python:tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__OptionalT_bool_t_methods, /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__OptionalT_bool_t_getset, /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t)offsetof(SwigPyObject, dict), /* tp_dictoffset */
    (initproc) _wrap_new_OptionalBool,        /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject*) 0,                            /* tp_bases */
    (PyObject*) 0,                            /* tp_mro */
    (PyObject*) 0,                            /* tp_cache */
    (PyObject*) 0,                            /* tp_subclasses */
    (PyObject*) 0,                            /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    (struct _typeobject*) 0,                  /* tp_prev */
#endif
    (struct _typeobject*) 0,                  /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) (inquiry) _wrap_OptionalBool___nonzero___closure, /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject*) 0,                            /* ht_name */
    (PyObject*) 0,                            /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject*) 0,                            /* ht_qualname */
    (struct _dictkeysobject*) 0,              /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__OptionalT_bool_t_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__OptionalT_bool_t_type};

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_OptionalDouble)
static SwigPyGetSet OptionalDouble___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__OptionalT_double_t_getset[] = {
    { (char*) "__dict__", (getter) SwigPyBuiltin_GetterClosure, (setter) 0, (char*)"ampl::Optional<(double)>.__dict__", (void*) &OptionalDouble___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__OptionalT_double_t_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  PyObject *tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, other);
  Py_XINCREF(other);
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__OptionalT_double_t_methods[] = {
  { "__nonzero__", (PyCFunction) _wrap_OptionalDouble___nonzero__, METH_VARARGS, (char*) "" },
  { "value", (PyCFunction) _wrap_OptionalDouble_value, METH_VARARGS, (char*) "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__OptionalT_double_t_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.OptionalDouble",              /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) _wrap_delete_OptionalDouble_closure, /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__OptionalT_double_t_type.as_number,      /* tp_as_number */
    &SwigPyBuiltin__ampl__OptionalT_double_t_type.as_sequence,    /* tp_as_sequence */
    &SwigPyBuiltin__ampl__OptionalT_double_t_type.as_mapping,     /* tp_as_mapping */
    (hashfunc) 0,                             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__OptionalT_double_t_type.as_buffer,      /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::Optional< double >",               /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ampl__OptionalT_double_t_richcompare, /* feature:python:tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__OptionalT_double_t_methods, /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__OptionalT_double_t_getset, /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t)offsetof(SwigPyObject, dict), /* tp_dictoffset */
    (initproc) _wrap_new_OptionalDouble,      /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject*) 0,                            /* tp_bases */
    (PyObject*) 0,                            /* tp_mro */
    (PyObject*) 0,                            /* tp_cache */
    (PyObject*) 0,                            /* tp_subclasses */
    (PyObject*) 0,                            /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    (struct _typeobject*) 0,                  /* tp_prev */
#endif
    (struct _typeobject*) 0,                  /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) (inquiry) _wrap_OptionalDouble___nonzero___closure, /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject*) 0,                            /* ht_name */
    (PyObject*) 0,                            /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject*) 0,                            /* ht_qualname */
    (struct _dictkeysobject*) 0,              /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__OptionalT_double_t_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__OptionalT_double_t_type};

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_Variant)
static SwigPyGetSet Variant___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__Variant_getset[] = {
    { (char*) "__dict__", (getter) SwigPyBuiltin_GetterClosure, (setter) 0, (char*)"ampl::Variant.__dict__", (void*) &Variant___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__Variant_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  PyObject *tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, other);
  Py_XINCREF(other);
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__Variant_methods[] = {
  { "str", (PyCFunction) _wrap_Variant_str, METH_VARARGS, (char*) "" },
  { "dbl", (PyCFunction) _wrap_Variant_dbl, METH_VARARGS, (char*) "" },
  { "type", (PyCFunction) _wrap_Variant_type, METH_VARARGS, (char*) "" },
  { "toString", (PyCFunction) _wrap_Variant_toString, METH_VARARGS, (char*) "" },
  { "equals", (PyCFunction) _wrap_Variant_equals, METH_VARARGS, (char*) "" },
  { "compare", (PyCFunction) _wrap_Variant_compare, METH_VARARGS, (char*) "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__Variant_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.Variant",                     /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) _wrap_delete_Variant_closure, /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__Variant_type.as_number,      /* tp_as_number */
    &SwigPyBuiltin__ampl__Variant_type.as_sequence,    /* tp_as_sequence */
    &SwigPyBuiltin__ampl__Variant_type.as_mapping,     /* tp_as_mapping */
    (hashfunc) 0,                             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__Variant_type.as_buffer,      /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::Variant",                          /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ampl__Variant_richcompare, /* feature:python:tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__Variant_methods,     /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__Variant_getset,      /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t)offsetof(SwigPyObject, dict), /* tp_dictoffset */
    (initproc) _wrap_new_Variant,             /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject*) 0,                            /* tp_bases */
    (PyObject*) 0,                            /* tp_mro */
    (PyObject*) 0,                            /* tp_cache */
    (PyObject*) 0,                            /* tp_subclasses */
    (PyObject*) 0,                            /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    (struct _typeobject*) 0,                  /* tp_prev */
#endif
    (struct _typeobject*) 0,                  /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject*) 0,                            /* ht_name */
    (PyObject*) 0,                            /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject*) 0,                            /* ht_qualname */
    (struct _dictkeysobject*) 0,              /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__Variant_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__Variant_type};

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_VariantRef)
static SwigPyGetSet VariantRef___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__VariantRef_getset[] = {
    { (char*) "__dict__", (getter) SwigPyBuiltin_GetterClosure, (setter) 0, (char*)"ampl::VariantRef.__dict__", (void*) &VariantRef___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__VariantRef_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  PyObject *tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, other);
  Py_XINCREF(other);
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__VariantRef_methods[] = {
  { "str", (PyCFunction) _wrap_VariantRef_str, METH_VARARGS, (char*) "" },
  { "dbl", (PyCFunction) _wrap_VariantRef_dbl, METH_VARARGS, (char*) "" },
  { "type", (PyCFunction) _wrap_VariantRef_type, METH_VARARGS, (char*) "" },
  { "toString", (PyCFunction) _wrap_VariantRef_toString, METH_VARARGS, (char*) "" },
  { "equals", (PyCFunction) _wrap_VariantRef_equals, METH_VARARGS, (char*) "" },
  { "compare", (PyCFunction) _wrap_VariantRef_compare, METH_VARARGS, (char*) "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__VariantRef_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.VariantRef",                  /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) _wrap_delete_VariantRef_closure, /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__VariantRef_type.as_number,      /* tp_as_number */
    &SwigPyBuiltin__ampl__VariantRef_type.as_sequence,    /* tp_as_sequence */
    &SwigPyBuiltin__ampl__VariantRef_type.as_mapping,     /* tp_as_mapping */
    (hashfunc) 0,                             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__VariantRef_type.as_buffer,      /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::VariantRef",                       /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ampl__VariantRef_richcompare, /* feature:python:tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__VariantRef_methods,  /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__VariantRef_getset,   /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t)offsetof(SwigPyObject, dict), /* tp_dictoffset */
    (initproc) _wrap_new_VariantRef,          /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject*) 0,                            /* tp_bases */
    (PyObject*) 0,                            /* tp_mro */
    (PyObject*) 0,                            /* tp_cache */
    (PyObject*) 0,                            /* tp_subclasses */
    (PyObject*) 0,                            /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    (struct _typeobject*) 0,                  /* tp_prev */
#endif
    (struct _typeobject*) 0,                  /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject*) 0,                            /* ht_name */
    (PyObject*) 0,                            /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject*) 0,                            /* ht_qualname */
    (struct _dictkeysobject*) 0,              /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__VariantRef_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__VariantRef_type};

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_TupleRef)
static SwigPyGetSet TupleRef___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__TupleRef_getset[] = {
    { (char*) "__dict__", (getter) SwigPyBuiltin_GetterClosure, (setter) 0, (char*)"ampl::TupleRef.__dict__", (void*) &TupleRef___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__TupleRef_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  PyObject *tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, other);
  Py_XINCREF(other);
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__TupleRef_methods[] = {
  { "size", (PyCFunction) _wrap_TupleRef_size, METH_VARARGS, (char*) "" },
  { "toString", (PyCFunction) _wrap_TupleRef_toString, METH_VARARGS, (char*) "" },
  { "getIndex", (PyCFunction) _wrap_TupleRef_getIndex, METH_VARARGS, (char*) "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__TupleRef_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.TupleRef",                    /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) _wrap_delete_TupleRef_closure, /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__TupleRef_type.as_number,      /* tp_as_number */
    &SwigPyBuiltin__ampl__TupleRef_type.as_sequence,    /* tp_as_sequence */
    &SwigPyBuiltin__ampl__TupleRef_type.as_mapping,     /* tp_as_mapping */
    (hashfunc) 0,                             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__TupleRef_type.as_buffer,      /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::TupleRef",                         /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ampl__TupleRef_richcompare, /* feature:python:tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__TupleRef_methods,    /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__TupleRef_getset,     /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t)offsetof(SwigPyObject, dict), /* tp_dictoffset */
    (initproc) _wrap_new_TupleRef,            /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject*) 0,                            /* tp_bases */
    (PyObject*) 0,                            /* tp_mro */
    (PyObject*) 0,                            /* tp_cache */
    (PyObject*) 0,                            /* tp_subclasses */
    (PyObject*) 0,                            /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    (struct _typeobject*) 0,                  /* tp_prev */
#endif
    (struct _typeobject*) 0,                  /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject*) 0,                            /* ht_name */
    (PyObject*) 0,                            /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject*) 0,                            /* ht_qualname */
    (struct _dictkeysobject*) 0,              /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__TupleRef_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__TupleRef_type};

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_Tuple)
static SwigPyGetSet Tuple___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__Tuple_getset[] = {
    { (char*) "__dict__", (getter) SwigPyBuiltin_GetterClosure, (setter) 0, (char*)"ampl::Tuple.__dict__", (void*) &Tuple___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__Tuple_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  PyObject *tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, other);
  Py_XINCREF(other);
  switch (op) {
    case Py_EQ : result = _wrap_Tuple_equals(self, tuple); break;
    default : break;
  }
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__Tuple_methods[] = {
  { "size", (PyCFunction) _wrap_Tuple_size, METH_VARARGS, (char*) "" },
  { "toString", (PyCFunction) _wrap_Tuple_toString, METH_VARARGS, (char*) "" },
  { "getIndex", (PyCFunction) _wrap_Tuple_getIndex, METH_VARARGS, (char*) "" },
  { "equals", (PyCFunction) _wrap_Tuple_equals, METH_VARARGS, (char*) "" },
  { "Factory", (PyCFunction) _wrap_Tuple_Factory, METH_STATIC|METH_VARARGS, "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__Tuple_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.Tuple",                       /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) _wrap_delete_Tuple_closure,  /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__Tuple_type.as_number,      /* tp_as_number */
    &SwigPyBuiltin__ampl__Tuple_type.as_sequence,    /* tp_as_sequence */
    &SwigPyBuiltin__ampl__Tuple_type.as_mapping,     /* tp_as_mapping */
    (hashfunc) 0,                             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__Tuple_type.as_buffer,      /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::Tuple",                            /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ampl__Tuple_richcompare, /* feature:python:tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__Tuple_methods,       /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__Tuple_getset,        /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t)offsetof(SwigPyObject, dict), /* tp_dictoffset */
    (initproc) _wrap_new_Tuple,               /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject*) 0,                            /* tp_bases */
    (PyObject*) 0,                            /* tp_mro */
    (PyObject*) 0,                            /* tp_cache */
    (PyObject*) 0,                            /* tp_subclasses */
    (PyObject*) 0,                            /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    (struct _typeobject*) 0,                  /* tp_prev */
#endif
    (struct _typeobject*) 0,                  /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject*) 0,                            /* ht_name */
    (PyObject*) 0,                            /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject*) 0,                            /* ht_qualname */
    (struct _dictkeysobject*) 0,              /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__Tuple_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__Tuple_type};

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_DataFrame)
static SwigPyGetSet DataFrame___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__DataFrame_getset[] = {
    { (char*) "__dict__", (getter) SwigPyBuiltin_GetterClosure, (setter) 0, (char*)"ampl::DataFrame.__dict__", (void*) &DataFrame___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__DataFrame_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  PyObject *tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, other);
  Py_XINCREF(other);
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__DataFrame_methods[] = {
  { "clone", (PyCFunction) _wrap_DataFrame_clone, METH_VARARGS, (char*) "" },
  { "getNumCols", (PyCFunction) _wrap_DataFrame_getNumCols, METH_VARARGS, (char*) "" },
  { "getNumRows", (PyCFunction) _wrap_DataFrame_getNumRows, METH_VARARGS, (char*) "" },
  { "getNumIndices", (PyCFunction) _wrap_DataFrame_getNumIndices, METH_VARARGS, (char*) "" },
  { "addRow", (PyCFunction) _wrap_DataFrame_addRow, METH_VARARGS, (char*) "" },
  { "reserve", (PyCFunction) _wrap_DataFrame_reserve, METH_VARARGS, (char*) "" },
  { "toString", (PyCFunction) _wrap_DataFrame_toString, METH_VARARGS, (char*) "" },
  { "getColumn", (PyCFunction) _wrap_DataFrame_getColumn, METH_VARARGS, (char*) "" },
  { "getRowByIndex", (PyCFunction) _wrap_DataFrame_getRowByIndex, METH_VARARGS, (char*) "" },
  { "getRow", (PyCFunction) _wrap_DataFrame_getRow, METH_VARARGS, (char*) "" },
  { "getHeaders", (PyCFunction) _wrap_DataFrame_getHeaders, METH_VARARGS, (char*) "" },
  { "impl", (PyCFunction) _wrap_DataFrame_impl, METH_VARARGS, (char*) "" },
  { "addColumn", (PyCFunction) _wrap_DataFrame_addColumn, METH_VARARGS, (char*) "" },
  { "addColumnStr", (PyCFunction) _wrap_DataFrame_addColumnStr, METH_VARARGS, (char*) "" },
  { "addColumnDbl", (PyCFunction) _wrap_DataFrame_addColumnDbl, METH_VARARGS, (char*) "" },
  { "setColumnStr", (PyCFunction) _wrap_DataFrame_setColumnStr, METH_VARARGS, (char*) "" },
  { "setColumnDbl", (PyCFunction) _wrap_DataFrame_setColumnDbl, METH_VARARGS, (char*) "" },
  { "setArrayDblDbl", (PyCFunction) _wrap_DataFrame_setArrayDblDbl, METH_VARARGS, (char*) "" },
  { "setArrayStrDbl", (PyCFunction) _wrap_DataFrame_setArrayStrDbl, METH_VARARGS, (char*) "" },
  { "setArrayDblStr", (PyCFunction) _wrap_DataFrame_setArrayDblStr, METH_VARARGS, (char*) "" },
  { "setArrayStrStr", (PyCFunction) _wrap_DataFrame_setArrayStrStr, METH_VARARGS, (char*) "" },
  { "setMatrixDblDblDbl", (PyCFunction) _wrap_DataFrame_setMatrixDblDblDbl, METH_VARARGS, (char*) "" },
  { "setMatrixStrStrDbl", (PyCFunction) _wrap_DataFrame_setMatrixStrStrDbl, METH_VARARGS, (char*) "" },
  { "setMatrixDblStrDbl", (PyCFunction) _wrap_DataFrame_setMatrixDblStrDbl, METH_VARARGS, (char*) "" },
  { "setMatrixStrDblDbl", (PyCFunction) _wrap_DataFrame_setMatrixStrDblDbl, METH_VARARGS, (char*) "" },
  { "setMatrixDblDblStr", (PyCFunction) _wrap_DataFrame_setMatrixDblDblStr, METH_VARARGS, (char*) "" },
  { "setMatrixDblStrStr", (PyCFunction) _wrap_DataFrame_setMatrixDblStrStr, METH_VARARGS, (char*) "" },
  { "setMatrixStrDblStr", (PyCFunction) _wrap_DataFrame_setMatrixStrDblStr, METH_VARARGS, (char*) "" },
  { "setMatrixStrStrStr", (PyCFunction) _wrap_DataFrame_setMatrixStrStrStr, METH_VARARGS, (char*) "" },
  { "factory", (PyCFunction) _wrap_DataFrame_factory, METH_STATIC|METH_VARARGS, "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__DataFrame_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.DataFrame",                   /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) _wrap_delete_DataFrame_closure, /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__DataFrame_type.as_number,      /* tp_as_number */
    &SwigPyBuiltin__ampl__DataFrame_type.as_sequence,    /* tp_as_sequence */
    &SwigPyBuiltin__ampl__DataFrame_type.as_mapping,     /* tp_as_mapping */
    (hashfunc) 0,                             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__DataFrame_type.as_buffer,      /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::DataFrame",                        /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ampl__DataFrame_richcompare, /* feature:python:tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__DataFrame_methods,   /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__DataFrame_getset,    /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t)offsetof(SwigPyObject, dict), /* tp_dictoffset */
    (initproc) _wrap_new_DataFrame,           /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject*) 0,                            /* tp_bases */
    (PyObject*) 0,                            /* tp_mro */
    (PyObject*) 0,                            /* tp_cache */
    (PyObject*) 0,                            /* tp_subclasses */
    (PyObject*) 0,                            /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    (struct _typeobject*) 0,                  /* tp_prev */
#endif
    (struct _typeobject*) 0,                  /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject*) 0,                            /* ht_name */
    (PyObject*) 0,                            /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject*) 0,                            /* ht_qualname */
    (struct _dictkeysobject*) 0,              /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__DataFrame_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__DataFrame_type};

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_DataFrameColumn)
static SwigPyGetSet DataFrameColumn___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__internal__SliceT_false_t_getset[] = {
    { (char*) "__dict__", (getter) SwigPyBuiltin_GetterClosure, (setter) 0, (char*)"ampl::internal::Slice<(false)>.__dict__", (void*) &DataFrameColumn___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__internal__SliceT_false_t_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  PyObject *tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, other);
  Py_XINCREF(other);
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__internal__SliceT_false_t_methods[] = {
  { "size", (PyCFunction) _wrap_DataFrameColumn_size, METH_VARARGS, (char*) "" },
  { "begin", (PyCFunction) _wrap_DataFrameColumn_begin, METH_VARARGS, (char*) "" },
  { "end", (PyCFunction) _wrap_DataFrameColumn_end, METH_VARARGS, (char*) "" },
  { "getIndex", (PyCFunction) _wrap_DataFrameColumn_getIndex, METH_VARARGS, (char*) "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__internal__SliceT_false_t_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.DataFrameColumn",             /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) _wrap_delete_DataFrameColumn_closure, /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__internal__SliceT_false_t_type.as_number,      /* tp_as_number */
    &SwigPyBuiltin__ampl__internal__SliceT_false_t_type.as_sequence,    /* tp_as_sequence */
    &SwigPyBuiltin__ampl__internal__SliceT_false_t_type.as_mapping,     /* tp_as_mapping */
    (hashfunc) 0,                             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__internal__SliceT_false_t_type.as_buffer,      /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::internal::Slice< false >",         /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ampl__internal__SliceT_false_t_richcompare, /* feature:python:tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__internal__SliceT_false_t_methods, /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__internal__SliceT_false_t_getset, /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t)offsetof(SwigPyObject, dict), /* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject*) 0,                            /* tp_bases */
    (PyObject*) 0,                            /* tp_mro */
    (PyObject*) 0,                            /* tp_cache */
    (PyObject*) 0,                            /* tp_subclasses */
    (PyObject*) 0,                            /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    (struct _typeobject*) 0,                  /* tp_prev */
#endif
    (struct _typeobject*) 0,                  /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject*) 0,                            /* ht_name */
    (PyObject*) 0,                            /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject*) 0,                            /* ht_qualname */
    (struct _dictkeysobject*) 0,              /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__internal__SliceT_false_t_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__internal__SliceT_false_t_type};

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_ColIterator)
static SwigPyGetSet ColIterator___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__internal__SliceT_false_t__iterator_getset[] = {
    { (char*) "__dict__", (getter) SwigPyBuiltin_GetterClosure, (setter) 0, (char*)"ampl::internal::Slice<(false)>::iterator.__dict__", (void*) &ColIterator___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__internal__SliceT_false_t__iterator_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  PyObject *tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, other);
  Py_XINCREF(other);
  switch (op) {
    case Py_EQ : result = _wrap_ColIterator_equals(self, tuple); break;
    case Py_NE : result = _wrap_ColIterator_differs(self, tuple); break;
    default : break;
  }
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__internal__SliceT_false_t__iterator_methods[] = {
  { "equals", (PyCFunction) _wrap_ColIterator_equals, METH_VARARGS, (char*) "" },
  { "differs", (PyCFunction) _wrap_ColIterator_differs, METH_VARARGS, (char*) "" },
  { "__ref__", (PyCFunction) _wrap_ColIterator___ref__, METH_VARARGS, (char*) "" },
  { "clone", (PyCFunction) _wrap_ColIterator_clone, METH_VARARGS, (char*) "" },
  { "postIncrement", (PyCFunction) _wrap_ColIterator_postIncrement, METH_VARARGS, (char*) "" },
  { "postIncrementBy", (PyCFunction) _wrap_ColIterator_postIncrementBy, METH_VARARGS, (char*) "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__internal__SliceT_false_t__iterator_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.ColIterator",                 /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) _wrap_delete_ColIterator_closure, /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__internal__SliceT_false_t__iterator_type.as_number,      /* tp_as_number */
    &SwigPyBuiltin__ampl__internal__SliceT_false_t__iterator_type.as_sequence,    /* tp_as_sequence */
    &SwigPyBuiltin__ampl__internal__SliceT_false_t__iterator_type.as_mapping,     /* tp_as_mapping */
    (hashfunc) 0,                             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__internal__SliceT_false_t__iterator_type.as_buffer,      /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::internal::Slice< false >::iterator", /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ampl__internal__SliceT_false_t__iterator_richcompare, /* feature:python:tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__internal__SliceT_false_t__iterator_methods, /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__internal__SliceT_false_t__iterator_getset, /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t)offsetof(SwigPyObject, dict), /* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject*) 0,                            /* tp_bases */
    (PyObject*) 0,                            /* tp_mro */
    (PyObject*) 0,                            /* tp_cache */
    (PyObject*) 0,                            /* tp_subclasses */
    (PyObject*) 0,                            /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    (struct _typeobject*) 0,                  /* tp_prev */
#endif
    (struct _typeobject*) 0,                  /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) (binaryfunc) _wrap_ColIterator___ref___closure, /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject*) 0,                            /* ht_name */
    (PyObject*) 0,                            /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject*) 0,                            /* ht_qualname */
    (struct _dictkeysobject*) 0,              /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__internal__SliceT_false_t__iterator_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__internal__SliceT_false_t__iterator_type};

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_DataFrameRow)
static SwigPyGetSet DataFrameRow___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__internal__SliceT_true_t_getset[] = {
    { (char*) "__dict__", (getter) SwigPyBuiltin_GetterClosure, (setter) 0, (char*)"ampl::internal::Slice<(true)>.__dict__", (void*) &DataFrameRow___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__internal__SliceT_true_t_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  PyObject *tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, other);
  Py_XINCREF(other);
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__internal__SliceT_true_t_methods[] = {
  { "size", (PyCFunction) _wrap_DataFrameRow_size, METH_VARARGS, (char*) "" },
  { "begin", (PyCFunction) _wrap_DataFrameRow_begin, METH_VARARGS, (char*) "" },
  { "end", (PyCFunction) _wrap_DataFrameRow_end, METH_VARARGS, (char*) "" },
  { "getIndex", (PyCFunction) _wrap_DataFrameRow_getIndex, METH_VARARGS, (char*) "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__internal__SliceT_true_t_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.DataFrameRow",                /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) _wrap_delete_DataFrameRow_closure, /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__internal__SliceT_true_t_type.as_number,      /* tp_as_number */
    &SwigPyBuiltin__ampl__internal__SliceT_true_t_type.as_sequence,    /* tp_as_sequence */
    &SwigPyBuiltin__ampl__internal__SliceT_true_t_type.as_mapping,     /* tp_as_mapping */
    (hashfunc) 0,                             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__internal__SliceT_true_t_type.as_buffer,      /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::internal::Slice< true >",          /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ampl__internal__SliceT_true_t_richcompare, /* feature:python:tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__internal__SliceT_true_t_methods, /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__internal__SliceT_true_t_getset, /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t)offsetof(SwigPyObject, dict), /* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject*) 0,                            /* tp_bases */
    (PyObject*) 0,                            /* tp_mro */
    (PyObject*) 0,                            /* tp_cache */
    (PyObject*) 0,                            /* tp_subclasses */
    (PyObject*) 0,                            /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    (struct _typeobject*) 0,                  /* tp_prev */
#endif
    (struct _typeobject*) 0,                  /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject*) 0,                            /* ht_name */
    (PyObject*) 0,                            /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject*) 0,                            /* ht_qualname */
    (struct _dictkeysobject*) 0,              /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__internal__SliceT_true_t_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__internal__SliceT_true_t_type};

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_RowIterator)
static SwigPyGetSet RowIterator___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__internal__SliceT_true_t__iterator_getset[] = {
    { (char*) "__dict__", (getter) SwigPyBuiltin_GetterClosure, (setter) 0, (char*)"ampl::internal::Slice<(true)>::iterator.__dict__", (void*) &RowIterator___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__internal__SliceT_true_t__iterator_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  PyObject *tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, other);
  Py_XINCREF(other);
  switch (op) {
    case Py_EQ : result = _wrap_RowIterator_equals(self, tuple); break;
    case Py_NE : result = _wrap_RowIterator_differs(self, tuple); break;
    default : break;
  }
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__internal__SliceT_true_t__iterator_methods[] = {
  { "equals", (PyCFunction) _wrap_RowIterator_equals, METH_VARARGS, (char*) "" },
  { "differs", (PyCFunction) _wrap_RowIterator_differs, METH_VARARGS, (char*) "" },
  { "__ref__", (PyCFunction) _wrap_RowIterator___ref__, METH_VARARGS, (char*) "" },
  { "clone", (PyCFunction) _wrap_RowIterator_clone, METH_VARARGS, (char*) "" },
  { "postIncrement", (PyCFunction) _wrap_RowIterator_postIncrement, METH_VARARGS, (char*) "" },
  { "postIncrementBy", (PyCFunction) _wrap_RowIterator_postIncrementBy, METH_VARARGS, (char*) "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__internal__SliceT_true_t__iterator_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.RowIterator",                 /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) _wrap_delete_RowIterator_closure, /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__internal__SliceT_true_t__iterator_type.as_number,      /* tp_as_number */
    &SwigPyBuiltin__ampl__internal__SliceT_true_t__iterator_type.as_sequence,    /* tp_as_sequence */
    &SwigPyBuiltin__ampl__internal__SliceT_true_t__iterator_type.as_mapping,     /* tp_as_mapping */
    (hashfunc) 0,                             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__internal__SliceT_true_t__iterator_type.as_buffer,      /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::internal::Slice< true >::iterator", /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ampl__internal__SliceT_true_t__iterator_richcompare, /* feature:python:tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__internal__SliceT_true_t__iterator_methods, /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__internal__SliceT_true_t__iterator_getset, /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t)offsetof(SwigPyObject, dict), /* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject*) 0,                            /* tp_bases */
    (PyObject*) 0,                            /* tp_mro */
    (PyObject*) 0,                            /* tp_cache */
    (PyObject*) 0,                            /* tp_subclasses */
    (PyObject*) 0,                            /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    (struct _typeobject*) 0,                  /* tp_prev */
#endif
    (struct _typeobject*) 0,                  /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) (binaryfunc) _wrap_RowIterator___ref___closure, /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject*) 0,                            /* ht_name */
    (PyObject*) 0,                            /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject*) 0,                            /* ht_qualname */
    (struct _dictkeysobject*) 0,              /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__internal__SliceT_true_t__iterator_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__internal__SliceT_true_t__iterator_type};

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_Instance)
static SwigPyGetSet Instance___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__Instance_getset[] = {
    { (char*) "__dict__", (getter) SwigPyBuiltin_GetterClosure, (setter) 0, (char*)"ampl::Instance.__dict__", (void*) &Instance___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__Instance_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  PyObject *tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, other);
  Py_XINCREF(other);
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__Instance_methods[] = {
  { "toString", (PyCFunction) _wrap_Instance_toString, METH_VARARGS, (char*) "" },
  { "name", (PyCFunction) _wrap_Instance_name, METH_VARARGS, (char*) "" },
  { "entity", (PyCFunction) _wrap_Instance_entity, METH_VARARGS, (char*) "" },
  { "key", (PyCFunction) _wrap_Instance_key, METH_VARARGS, (char*) "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__Instance_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.Instance",                    /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) _wrap_delete_Instance_closure, /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__Instance_type.as_number,      /* tp_as_number */
    &SwigPyBuiltin__ampl__Instance_type.as_sequence,    /* tp_as_sequence */
    &SwigPyBuiltin__ampl__Instance_type.as_mapping,     /* tp_as_mapping */
    (hashfunc) 0,                             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__Instance_type.as_buffer,      /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::Instance",                         /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ampl__Instance_richcompare, /* feature:python:tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__Instance_methods,    /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__Instance_getset,     /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t)offsetof(SwigPyObject, dict), /* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject*) 0,                            /* tp_bases */
    (PyObject*) 0,                            /* tp_mro */
    (PyObject*) 0,                            /* tp_cache */
    (PyObject*) 0,                            /* tp_subclasses */
    (PyObject*) 0,                            /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    (struct _typeobject*) 0,                  /* tp_prev */
#endif
    (struct _typeobject*) 0,                  /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject*) 0,                            /* ht_name */
    (PyObject*) 0,                            /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject*) 0,                            /* ht_qualname */
    (struct _dictkeysobject*) 0,              /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__Instance_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__Instance_type};

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_SetInstance)
static SwigPyGetSet SetInstance___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__SetInstance_getset[] = {
    { (char*) "__dict__", (getter) SwigPyBuiltin_GetterClosure, (setter) 0, (char*)"ampl::SetInstance.__dict__", (void*) &SetInstance___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__SetInstance_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  PyObject *tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, other);
  Py_XINCREF(other);
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__SetInstance_methods[] = {
  { "size", (PyCFunction) _wrap_SetInstance_size, METH_VARARGS, (char*) "" },
  { "contains", (PyCFunction) _wrap_SetInstance_contains, METH_VARARGS, (char*) "" },
  { "getValues", (PyCFunction) _wrap_SetInstance_getValues, METH_VARARGS, (char*) "" },
  { "setValuesDf", (PyCFunction) _wrap_SetInstance_setValuesDf, METH_VARARGS, (char*) "" },
  { "members", (PyCFunction) _wrap_SetInstance_members, METH_VARARGS, (char*) "" },
  { "Contains", (PyCFunction) _wrap_SetInstance_Contains, METH_VARARGS, (char*) "" },
  { "setValues", (PyCFunction) _wrap_SetInstance_setValues, METH_VARARGS, (char*) "" },
  { "setValuesDbl", (PyCFunction) _wrap_SetInstance_setValuesDbl, METH_VARARGS, (char*) "" },
  { "setValuesStr", (PyCFunction) _wrap_SetInstance_setValuesStr, METH_VARARGS, (char*) "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__SetInstance_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.SetInstance",                 /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) _wrap_delete_SetInstance_closure, /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__SetInstance_type.as_number,      /* tp_as_number */
    &SwigPyBuiltin__ampl__SetInstance_type.as_sequence,    /* tp_as_sequence */
    &SwigPyBuiltin__ampl__SetInstance_type.as_mapping,     /* tp_as_mapping */
    (hashfunc) 0,                             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__SetInstance_type.as_buffer,      /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::SetInstance",                      /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ampl__SetInstance_richcompare, /* feature:python:tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__SetInstance_methods, /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__SetInstance_getset,  /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t)offsetof(SwigPyObject, dict), /* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject*) 0,                            /* tp_bases */
    (PyObject*) 0,                            /* tp_mro */
    (PyObject*) 0,                            /* tp_cache */
    (PyObject*) 0,                            /* tp_subclasses */
    (PyObject*) 0,                            /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    (struct _typeobject*) 0,                  /* tp_prev */
#endif
    (struct _typeobject*) 0,                  /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject*) 0,                            /* ht_name */
    (PyObject*) 0,                            /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject*) 0,                            /* ht_qualname */
    (struct _dictkeysobject*) 0,              /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__SetInstance_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__SetInstance_type};

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_MemberRange)
static SwigPyGetSet MemberRange___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__SetInstance__MemberRange_getset[] = {
    { (char*) "__dict__", (getter) SwigPyBuiltin_GetterClosure, (setter) 0, (char*)"ampl::SetInstance::MemberRange.__dict__", (void*) &MemberRange___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__SetInstance__MemberRange_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  PyObject *tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, other);
  Py_XINCREF(other);
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__SetInstance__MemberRange_methods[] = {
  { "begin", (PyCFunction) _wrap_MemberRange_begin, METH_VARARGS, (char*) "" },
  { "end", (PyCFunction) _wrap_MemberRange_end, METH_VARARGS, (char*) "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__SetInstance__MemberRange_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.MemberRange",                 /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) _wrap_delete_MemberRange_closure, /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__SetInstance__MemberRange_type.as_number,      /* tp_as_number */
    &SwigPyBuiltin__ampl__SetInstance__MemberRange_type.as_sequence,    /* tp_as_sequence */
    &SwigPyBuiltin__ampl__SetInstance__MemberRange_type.as_mapping,     /* tp_as_mapping */
    (hashfunc) 0,                             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__SetInstance__MemberRange_type.as_buffer,      /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::SetInstance::MemberRange",         /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ampl__SetInstance__MemberRange_richcompare, /* feature:python:tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__SetInstance__MemberRange_methods, /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__SetInstance__MemberRange_getset, /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t)offsetof(SwigPyObject, dict), /* tp_dictoffset */
    (initproc) _wrap_new_MemberRange,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject*) 0,                            /* tp_bases */
    (PyObject*) 0,                            /* tp_mro */
    (PyObject*) 0,                            /* tp_cache */
    (PyObject*) 0,                            /* tp_subclasses */
    (PyObject*) 0,                            /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    (struct _typeobject*) 0,                  /* tp_prev */
#endif
    (struct _typeobject*) 0,                  /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject*) 0,                            /* ht_name */
    (PyObject*) 0,                            /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject*) 0,                            /* ht_qualname */
    (struct _dictkeysobject*) 0,              /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__SetInstance__MemberRange_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__SetInstance__MemberRange_type};

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_iterator)
static SwigPyGetSet iterator___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__SetInstance__MemberRange__iterator_getset[] = {
    { (char*) "__dict__", (getter) SwigPyBuiltin_GetterClosure, (setter) 0, (char*)"ampl::SetInstance::MemberRange::iterator.__dict__", (void*) &iterator___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__SetInstance__MemberRange__iterator_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  PyObject *tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, other);
  Py_XINCREF(other);
  switch (op) {
    case Py_EQ : result = _wrap_iterator_equals(self, tuple); break;
    case Py_NE : result = _wrap_iterator_differs(self, tuple); break;
    default : break;
  }
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__SetInstance__MemberRange__iterator_methods[] = {
  { "__ref__", (PyCFunction) _wrap_iterator___ref__, METH_VARARGS, (char*) "" },
  { "postIncrement", (PyCFunction) _wrap_iterator_postIncrement, METH_VARARGS, (char*) "" },
  { "postIncrementBy", (PyCFunction) _wrap_iterator_postIncrementBy, METH_VARARGS, (char*) "" },
  { "equals", (PyCFunction) _wrap_iterator_equals, METH_VARARGS, (char*) "" },
  { "differs", (PyCFunction) _wrap_iterator_differs, METH_VARARGS, (char*) "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__SetInstance__MemberRange__iterator_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.iterator",                    /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) _wrap_delete_iterator_closure, /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__SetInstance__MemberRange__iterator_type.as_number,      /* tp_as_number */
    &SwigPyBuiltin__ampl__SetInstance__MemberRange__iterator_type.as_sequence,    /* tp_as_sequence */
    &SwigPyBuiltin__ampl__SetInstance__MemberRange__iterator_type.as_mapping,     /* tp_as_mapping */
    (hashfunc) 0,                             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__SetInstance__MemberRange__iterator_type.as_buffer,      /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::SetInstance::MemberRange::iterator", /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ampl__SetInstance__MemberRange__iterator_richcompare, /* feature:python:tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__SetInstance__MemberRange__iterator_methods, /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__SetInstance__MemberRange__iterator_getset, /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t)offsetof(SwigPyObject, dict), /* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject*) 0,                            /* tp_bases */
    (PyObject*) 0,                            /* tp_mro */
    (PyObject*) 0,                            /* tp_cache */
    (PyObject*) 0,                            /* tp_subclasses */
    (PyObject*) 0,                            /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    (struct _typeobject*) 0,                  /* tp_prev */
#endif
    (struct _typeobject*) 0,                  /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) (binaryfunc) _wrap_iterator___ref___closure, /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject*) 0,                            /* ht_name */
    (PyObject*) 0,                            /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject*) 0,                            /* ht_qualname */
    (struct _dictkeysobject*) 0,              /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__SetInstance__MemberRange__iterator_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__SetInstance__MemberRange__iterator_type};

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_ObjectiveInstance)
static SwigPyGetSet ObjectiveInstance___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__ObjectiveInstance_getset[] = {
    { (char*) "__dict__", (getter) SwigPyBuiltin_GetterClosure, (setter) 0, (char*)"ampl::ObjectiveInstance.__dict__", (void*) &ObjectiveInstance___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__ObjectiveInstance_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  PyObject *tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, other);
  Py_XINCREF(other);
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__ObjectiveInstance_methods[] = {
  { "value", (PyCFunction) _wrap_ObjectiveInstance_value, METH_VARARGS, (char*) "" },
  { "astatus", (PyCFunction) _wrap_ObjectiveInstance_astatus, METH_VARARGS, (char*) "" },
  { "sstatus", (PyCFunction) _wrap_ObjectiveInstance_sstatus, METH_VARARGS, (char*) "" },
  { "exitcode", (PyCFunction) _wrap_ObjectiveInstance_exitcode, METH_VARARGS, (char*) "" },
  { "message", (PyCFunction) _wrap_ObjectiveInstance_message, METH_VARARGS, (char*) "" },
  { "result", (PyCFunction) _wrap_ObjectiveInstance_result, METH_VARARGS, (char*) "" },
  { "drop", (PyCFunction) _wrap_ObjectiveInstance_drop, METH_VARARGS, (char*) "" },
  { "restore", (PyCFunction) _wrap_ObjectiveInstance_restore, METH_VARARGS, (char*) "" },
  { "minimization", (PyCFunction) _wrap_ObjectiveInstance_minimization, METH_VARARGS, (char*) "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__ObjectiveInstance_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.ObjectiveInstance",           /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) _wrap_delete_ObjectiveInstance_closure, /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__ObjectiveInstance_type.as_number,      /* tp_as_number */
    &SwigPyBuiltin__ampl__ObjectiveInstance_type.as_sequence,    /* tp_as_sequence */
    &SwigPyBuiltin__ampl__ObjectiveInstance_type.as_mapping,     /* tp_as_mapping */
    (hashfunc) 0,                             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__ObjectiveInstance_type.as_buffer,      /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::ObjectiveInstance",                /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ampl__ObjectiveInstance_richcompare, /* feature:python:tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__ObjectiveInstance_methods, /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__ObjectiveInstance_getset, /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t)offsetof(SwigPyObject, dict), /* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject*) 0,                            /* tp_bases */
    (PyObject*) 0,                            /* tp_mro */
    (PyObject*) 0,                            /* tp_cache */
    (PyObject*) 0,                            /* tp_subclasses */
    (PyObject*) 0,                            /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    (struct _typeobject*) 0,                  /* tp_prev */
#endif
    (struct _typeobject*) 0,                  /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject*) 0,                            /* ht_name */
    (PyObject*) 0,                            /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject*) 0,                            /* ht_qualname */
    (struct _dictkeysobject*) 0,              /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__ObjectiveInstance_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__ObjectiveInstance_type};

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_VariableInstance)
static SwigPyGetSet VariableInstance___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__VariableInstance_getset[] = {
    { (char*) "__dict__", (getter) SwigPyBuiltin_GetterClosure, (setter) 0, (char*)"ampl::VariableInstance.__dict__", (void*) &VariableInstance___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__VariableInstance_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  PyObject *tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, other);
  Py_XINCREF(other);
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__VariableInstance_methods[] = {
  { "fix", (PyCFunction) _wrap_VariableInstance_fix, METH_VARARGS, (char*) "" },
  { "unfix", (PyCFunction) _wrap_VariableInstance_unfix, METH_VARARGS, (char*) "" },
  { "setValue", (PyCFunction) _wrap_VariableInstance_setValue, METH_VARARGS, (char*) "" },
  { "value", (PyCFunction) _wrap_VariableInstance_value, METH_VARARGS, (char*) "" },
  { "defeqn", (PyCFunction) _wrap_VariableInstance_defeqn, METH_VARARGS, (char*) "" },
  { "dual", (PyCFunction) _wrap_VariableInstance_dual, METH_VARARGS, (char*) "" },
  { "init", (PyCFunction) _wrap_VariableInstance_init, METH_VARARGS, (char*) "" },
  { "init0", (PyCFunction) _wrap_VariableInstance_init0, METH_VARARGS, (char*) "" },
  { "lb", (PyCFunction) _wrap_VariableInstance_lb, METH_VARARGS, (char*) "" },
  { "ub", (PyCFunction) _wrap_VariableInstance_ub, METH_VARARGS, (char*) "" },
  { "lb0", (PyCFunction) _wrap_VariableInstance_lb0, METH_VARARGS, (char*) "" },
  { "ub0", (PyCFunction) _wrap_VariableInstance_ub0, METH_VARARGS, (char*) "" },
  { "lb1", (PyCFunction) _wrap_VariableInstance_lb1, METH_VARARGS, (char*) "" },
  { "ub1", (PyCFunction) _wrap_VariableInstance_ub1, METH_VARARGS, (char*) "" },
  { "lb2", (PyCFunction) _wrap_VariableInstance_lb2, METH_VARARGS, (char*) "" },
  { "ub2", (PyCFunction) _wrap_VariableInstance_ub2, METH_VARARGS, (char*) "" },
  { "lrc", (PyCFunction) _wrap_VariableInstance_lrc, METH_VARARGS, (char*) "" },
  { "urc", (PyCFunction) _wrap_VariableInstance_urc, METH_VARARGS, (char*) "" },
  { "lslack", (PyCFunction) _wrap_VariableInstance_lslack, METH_VARARGS, (char*) "" },
  { "uslack", (PyCFunction) _wrap_VariableInstance_uslack, METH_VARARGS, (char*) "" },
  { "rc", (PyCFunction) _wrap_VariableInstance_rc, METH_VARARGS, (char*) "" },
  { "slack", (PyCFunction) _wrap_VariableInstance_slack, METH_VARARGS, (char*) "" },
  { "astatus", (PyCFunction) _wrap_VariableInstance_astatus, METH_VARARGS, (char*) "" },
  { "sstatus", (PyCFunction) _wrap_VariableInstance_sstatus, METH_VARARGS, (char*) "" },
  { "status", (PyCFunction) _wrap_VariableInstance_status, METH_VARARGS, (char*) "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__VariableInstance_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.VariableInstance",            /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) _wrap_delete_VariableInstance_closure, /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__VariableInstance_type.as_number,      /* tp_as_number */
    &SwigPyBuiltin__ampl__VariableInstance_type.as_sequence,    /* tp_as_sequence */
    &SwigPyBuiltin__ampl__VariableInstance_type.as_mapping,     /* tp_as_mapping */
    (hashfunc) 0,                             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__VariableInstance_type.as_buffer,      /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::VariableInstance",                 /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ampl__VariableInstance_richcompare, /* feature:python:tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__VariableInstance_methods, /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__VariableInstance_getset, /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t)offsetof(SwigPyObject, dict), /* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject*) 0,                            /* tp_bases */
    (PyObject*) 0,                            /* tp_mro */
    (PyObject*) 0,                            /* tp_cache */
    (PyObject*) 0,                            /* tp_subclasses */
    (PyObject*) 0,                            /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    (struct _typeobject*) 0,                  /* tp_prev */
#endif
    (struct _typeobject*) 0,                  /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject*) 0,                            /* ht_name */
    (PyObject*) 0,                            /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject*) 0,                            /* ht_qualname */
    (struct _dictkeysobject*) 0,              /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__VariableInstance_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__VariableInstance_type};

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_ConstraintInstance)
static SwigPyGetSet ConstraintInstance___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__ConstraintInstance_getset[] = {
    { (char*) "__dict__", (getter) SwigPyBuiltin_GetterClosure, (setter) 0, (char*)"ampl::ConstraintInstance.__dict__", (void*) &ConstraintInstance___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__ConstraintInstance_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  PyObject *tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, other);
  Py_XINCREF(other);
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__ConstraintInstance_methods[] = {
  { "drop", (PyCFunction) _wrap_ConstraintInstance_drop, METH_VARARGS, (char*) "" },
  { "restore", (PyCFunction) _wrap_ConstraintInstance_restore, METH_VARARGS, (char*) "" },
  { "body", (PyCFunction) _wrap_ConstraintInstance_body, METH_VARARGS, (char*) "" },
  { "astatus", (PyCFunction) _wrap_ConstraintInstance_astatus, METH_VARARGS, (char*) "" },
  { "defvar", (PyCFunction) _wrap_ConstraintInstance_defvar, METH_VARARGS, (char*) "" },
  { "dinit", (PyCFunction) _wrap_ConstraintInstance_dinit, METH_VARARGS, (char*) "" },
  { "dinit0", (PyCFunction) _wrap_ConstraintInstance_dinit0, METH_VARARGS, (char*) "" },
  { "dual", (PyCFunction) _wrap_ConstraintInstance_dual, METH_VARARGS, (char*) "" },
  { "lb", (PyCFunction) _wrap_ConstraintInstance_lb, METH_VARARGS, (char*) "" },
  { "ub", (PyCFunction) _wrap_ConstraintInstance_ub, METH_VARARGS, (char*) "" },
  { "lbs", (PyCFunction) _wrap_ConstraintInstance_lbs, METH_VARARGS, (char*) "" },
  { "ubs", (PyCFunction) _wrap_ConstraintInstance_ubs, METH_VARARGS, (char*) "" },
  { "ldual", (PyCFunction) _wrap_ConstraintInstance_ldual, METH_VARARGS, (char*) "" },
  { "udual", (PyCFunction) _wrap_ConstraintInstance_udual, METH_VARARGS, (char*) "" },
  { "lslack", (PyCFunction) _wrap_ConstraintInstance_lslack, METH_VARARGS, (char*) "" },
  { "uslack", (PyCFunction) _wrap_ConstraintInstance_uslack, METH_VARARGS, (char*) "" },
  { "slack", (PyCFunction) _wrap_ConstraintInstance_slack, METH_VARARGS, (char*) "" },
  { "sstatus", (PyCFunction) _wrap_ConstraintInstance_sstatus, METH_VARARGS, (char*) "" },
  { "status", (PyCFunction) _wrap_ConstraintInstance_status, METH_VARARGS, (char*) "" },
  { "setDual", (PyCFunction) _wrap_ConstraintInstance_setDual, METH_VARARGS, (char*) "" },
  { "val", (PyCFunction) _wrap_ConstraintInstance_val, METH_VARARGS, (char*) "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__ConstraintInstance_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.ConstraintInstance",          /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) _wrap_delete_ConstraintInstance_closure, /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__ConstraintInstance_type.as_number,      /* tp_as_number */
    &SwigPyBuiltin__ampl__ConstraintInstance_type.as_sequence,    /* tp_as_sequence */
    &SwigPyBuiltin__ampl__ConstraintInstance_type.as_mapping,     /* tp_as_mapping */
    (hashfunc) 0,                             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__ConstraintInstance_type.as_buffer,      /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::ConstraintInstance",               /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ampl__ConstraintInstance_richcompare, /* feature:python:tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__ConstraintInstance_methods, /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__ConstraintInstance_getset, /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t)offsetof(SwigPyObject, dict), /* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject*) 0,                            /* tp_bases */
    (PyObject*) 0,                            /* tp_mro */
    (PyObject*) 0,                            /* tp_cache */
    (PyObject*) 0,                            /* tp_subclasses */
    (PyObject*) 0,                            /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    (struct _typeobject*) 0,                  /* tp_prev */
#endif
    (struct _typeobject*) 0,                  /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject*) 0,                            /* ht_name */
    (PyObject*) 0,                            /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject*) 0,                            /* ht_qualname */
    (struct _dictkeysobject*) 0,              /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__ConstraintInstance_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__ConstraintInstance_type};

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_EntityArray)
static SwigPyGetSet EntityArray_el_getset = { _wrap_EntityArray_el_get, _wrap_EntityArray_el_set };
static SwigPyGetSet EntityArray___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__EntityArray_getset[] = {
    { (char*) "el", (getter) SwigPyBuiltin_GetterClosure, (setter) SwigPyBuiltin_SetterClosure, (char*)"EntityArray.el", (void*) &EntityArray_el_getset }
,
    { (char*) "__dict__", (getter) SwigPyBuiltin_GetterClosure, (setter) 0, (char*)"EntityArray.__dict__", (void*) &EntityArray___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__EntityArray_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  PyObject *tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, other);
  Py_XINCREF(other);
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__EntityArray_methods[] = {
  { "__getitem__", (PyCFunction) _wrap_EntityArray___getitem__, METH_VARARGS, (char*) "" },
  { "__setitem__", (PyCFunction) _wrap_EntityArray___setitem__, METH_VARARGS, (char*) "" },
  { "cast", (PyCFunction) _wrap_EntityArray_cast, METH_VARARGS, (char*) "" },
  { "frompointer", (PyCFunction) _wrap_EntityArray_frompointer, METH_STATIC|METH_VARARGS, "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__EntityArray_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.EntityArray",                 /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) _wrap_delete_EntityArray_closure, /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__EntityArray_type.as_number,      /* tp_as_number */
    &SwigPyBuiltin__EntityArray_type.as_sequence,    /* tp_as_sequence */
    &SwigPyBuiltin__EntityArray_type.as_mapping,     /* tp_as_mapping */
    (hashfunc) 0,                             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__EntityArray_type.as_buffer,      /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "::EntityArray",                          /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__EntityArray_richcompare, /* feature:python:tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__EntityArray_methods,       /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__EntityArray_getset,        /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t)offsetof(SwigPyObject, dict), /* tp_dictoffset */
    (initproc) _wrap_new_EntityArray,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject*) 0,                            /* tp_bases */
    (PyObject*) 0,                            /* tp_mro */
    (PyObject*) 0,                            /* tp_cache */
    (PyObject*) 0,                            /* tp_subclasses */
    (PyObject*) 0,                            /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    (struct _typeobject*) 0,                  /* tp_prev */
#endif
    (struct _typeobject*) 0,                  /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) (ssizeargfunc) _wrap_EntityArray___getitem___closure, /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) (ssizeobjargproc) _wrap_EntityArray___setitem___closure, /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject*) 0,                            /* ht_name */
    (PyObject*) 0,                            /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject*) 0,                            /* ht_qualname */
    (struct _dictkeysobject*) 0,              /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__EntityArray_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__EntityArray_type};

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_Entity)
static SwigPyGetSet Entity___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__Entity_getset[] = {
    { (char*) "__dict__", (getter) SwigPyBuiltin_GetterClosure, (setter) 0, (char*)"ampl::Entity.__dict__", (void*) &Entity___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__Entity_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  PyObject *tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, other);
  Py_XINCREF(other);
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__Entity_methods[] = {
  { "toString", (PyCFunction) _wrap_Entity_toString, METH_VARARGS, (char*) "" },
  { "name", (PyCFunction) _wrap_Entity_name, METH_VARARGS, (char*) "" },
  { "indexarity", (PyCFunction) _wrap_Entity_indexarity, METH_VARARGS, (char*) "" },
  { "isScalar", (PyCFunction) _wrap_Entity_isScalar, METH_VARARGS, (char*) "" },
  { "numInstances", (PyCFunction) _wrap_Entity_numInstances, METH_VARARGS, (char*) "" },
  { "getIndexingSets", (PyCFunction) _wrap_Entity_getIndexingSets, METH_VARARGS, (char*) "" },
  { "getValues", (PyCFunction) _wrap_Entity_getValues, METH_VARARGS, (char*) "" },
  { "setValuesDf", (PyCFunction) _wrap_Entity_setValuesDf, METH_VARARGS, (char*) "" },
  { "getValuesLst", (PyCFunction) _wrap_Entity_getValuesLst, METH_VARARGS, (char*) "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__Entity_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.Entity",                      /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) _wrap_delete_Entity_closure, /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__Entity_type.as_number,      /* tp_as_number */
    &SwigPyBuiltin__ampl__Entity_type.as_sequence,    /* tp_as_sequence */
    &SwigPyBuiltin__ampl__Entity_type.as_mapping,     /* tp_as_mapping */
    (hashfunc) 0,                             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__Entity_type.as_buffer,      /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::Entity",                           /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ampl__Entity_richcompare, /* feature:python:tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__Entity_methods,      /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__Entity_getset,       /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t)offsetof(SwigPyObject, dict), /* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject*) 0,                            /* tp_bases */
    (PyObject*) 0,                            /* tp_mro */
    (PyObject*) 0,                            /* tp_cache */
    (PyObject*) 0,                            /* tp_subclasses */
    (PyObject*) 0,                            /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    (struct _typeobject*) 0,                  /* tp_prev */
#endif
    (struct _typeobject*) 0,                  /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject*) 0,                            /* ht_name */
    (PyObject*) 0,                            /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject*) 0,                            /* ht_qualname */
    (struct _dictkeysobject*) 0,              /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__Entity_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__Entity_type};

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_EntityArgs)
static SwigPyGetSet EntityArgs___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__EntityArgs_getset[] = {
    { (char*) "__dict__", (getter) SwigPyBuiltin_GetterClosure, (setter) 0, (char*)"ampl::EntityArgs.__dict__", (void*) &EntityArgs___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__EntityArgs_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  PyObject *tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, other);
  Py_XINCREF(other);
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__EntityArgs_methods[] = {
  { "Factory", (PyCFunction) _wrap_EntityArgs_Factory, METH_STATIC|METH_VARARGS, "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__EntityArgs_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.EntityArgs",                  /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) _wrap_delete_EntityArgs_closure, /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__EntityArgs_type.as_number,      /* tp_as_number */
    &SwigPyBuiltin__ampl__EntityArgs_type.as_sequence,    /* tp_as_sequence */
    &SwigPyBuiltin__ampl__EntityArgs_type.as_mapping,     /* tp_as_mapping */
    (hashfunc) 0,                             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__EntityArgs_type.as_buffer,      /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::EntityArgs",                       /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ampl__EntityArgs_richcompare, /* feature:python:tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__EntityArgs_methods,  /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__EntityArgs_getset,   /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t)offsetof(SwigPyObject, dict), /* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject*) 0,                            /* tp_bases */
    (PyObject*) 0,                            /* tp_mro */
    (PyObject*) 0,                            /* tp_cache */
    (PyObject*) 0,                            /* tp_subclasses */
    (PyObject*) 0,                            /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    (struct _typeobject*) 0,                  /* tp_prev */
#endif
    (struct _typeobject*) 0,                  /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject*) 0,                            /* ht_name */
    (PyObject*) 0,                            /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject*) 0,                            /* ht_qualname */
    (struct _dictkeysobject*) 0,              /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__EntityArgs_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__EntityArgs_type};

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_BasicEntityVariable)
static SwigPyGetSet BasicEntityVariable___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__BasicEntityT_ampl__VariableInstance_t_getset[] = {
    { (char*) "__dict__", (getter) SwigPyBuiltin_GetterClosure, (setter) 0, (char*)"ampl::BasicEntity<(ampl::VariableInstance)>.__dict__", (void*) &BasicEntityVariable___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__BasicEntityT_ampl__VariableInstance_t_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  PyObject *tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, other);
  Py_XINCREF(other);
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__BasicEntityT_ampl__VariableInstance_t_methods[] = {
  { "begin", (PyCFunction) _wrap_BasicEntityVariable_begin, METH_VARARGS, (char*) "" },
  { "end", (PyCFunction) _wrap_BasicEntityVariable_end, METH_VARARGS, (char*) "" },
  { "find", (PyCFunction) _wrap_BasicEntityVariable_find, METH_VARARGS, (char*) "" },
  { "get", (PyCFunction) _wrap_BasicEntityVariable_get, METH_VARARGS, (char*) "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__BasicEntityT_ampl__VariableInstance_t_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.BasicEntityVariable",         /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) _wrap_delete_BasicEntityVariable_closure, /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__BasicEntityT_ampl__VariableInstance_t_type.as_number,      /* tp_as_number */
    &SwigPyBuiltin__ampl__BasicEntityT_ampl__VariableInstance_t_type.as_sequence,    /* tp_as_sequence */
    &SwigPyBuiltin__ampl__BasicEntityT_ampl__VariableInstance_t_type.as_mapping,     /* tp_as_mapping */
    (hashfunc) 0,                             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__BasicEntityT_ampl__VariableInstance_t_type.as_buffer,      /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::BasicEntity< ampl::VariableInstance >", /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ampl__BasicEntityT_ampl__VariableInstance_t_richcompare, /* feature:python:tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__BasicEntityT_ampl__VariableInstance_t_methods, /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__BasicEntityT_ampl__VariableInstance_t_getset, /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t)offsetof(SwigPyObject, dict), /* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject*) 0,                            /* tp_bases */
    (PyObject*) 0,                            /* tp_mro */
    (PyObject*) 0,                            /* tp_cache */
    (PyObject*) 0,                            /* tp_subclasses */
    (PyObject*) 0,                            /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    (struct _typeobject*) 0,                  /* tp_prev */
#endif
    (struct _typeobject*) 0,                  /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject*) 0,                            /* ht_name */
    (PyObject*) 0,                            /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject*) 0,                            /* ht_qualname */
    (struct _dictkeysobject*) 0,              /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__BasicEntityT_ampl__VariableInstance_t_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__BasicEntityT_ampl__VariableInstance_t_type};

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_BasicEntityConstraint)
static SwigPyGetSet BasicEntityConstraint___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__BasicEntityT_ampl__ConstraintInstance_t_getset[] = {
    { (char*) "__dict__", (getter) SwigPyBuiltin_GetterClosure, (setter) 0, (char*)"ampl::BasicEntity<(ampl::ConstraintInstance)>.__dict__", (void*) &BasicEntityConstraint___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__BasicEntityT_ampl__ConstraintInstance_t_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  PyObject *tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, other);
  Py_XINCREF(other);
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__BasicEntityT_ampl__ConstraintInstance_t_methods[] = {
  { "begin", (PyCFunction) _wrap_BasicEntityConstraint_begin, METH_VARARGS, (char*) "" },
  { "end", (PyCFunction) _wrap_BasicEntityConstraint_end, METH_VARARGS, (char*) "" },
  { "find", (PyCFunction) _wrap_BasicEntityConstraint_find, METH_VARARGS, (char*) "" },
  { "get", (PyCFunction) _wrap_BasicEntityConstraint_get, METH_VARARGS, (char*) "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__BasicEntityT_ampl__ConstraintInstance_t_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.BasicEntityConstraint",       /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) _wrap_delete_BasicEntityConstraint_closure, /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__BasicEntityT_ampl__ConstraintInstance_t_type.as_number,      /* tp_as_number */
    &SwigPyBuiltin__ampl__BasicEntityT_ampl__ConstraintInstance_t_type.as_sequence,    /* tp_as_sequence */
    &SwigPyBuiltin__ampl__BasicEntityT_ampl__ConstraintInstance_t_type.as_mapping,     /* tp_as_mapping */
    (hashfunc) 0,                             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__BasicEntityT_ampl__ConstraintInstance_t_type.as_buffer,      /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::BasicEntity< ampl::ConstraintInstance >", /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ampl__BasicEntityT_ampl__ConstraintInstance_t_richcompare, /* feature:python:tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__BasicEntityT_ampl__ConstraintInstance_t_methods, /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__BasicEntityT_ampl__ConstraintInstance_t_getset, /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t)offsetof(SwigPyObject, dict), /* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject*) 0,                            /* tp_bases */
    (PyObject*) 0,                            /* tp_mro */
    (PyObject*) 0,                            /* tp_cache */
    (PyObject*) 0,                            /* tp_subclasses */
    (PyObject*) 0,                            /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    (struct _typeobject*) 0,                  /* tp_prev */
#endif
    (struct _typeobject*) 0,                  /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject*) 0,                            /* ht_name */
    (PyObject*) 0,                            /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject*) 0,                            /* ht_qualname */
    (struct _dictkeysobject*) 0,              /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__BasicEntityT_ampl__ConstraintInstance_t_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__BasicEntityT_ampl__ConstraintInstance_t_type};

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_BasicEntitySet)
static SwigPyGetSet BasicEntitySet___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__BasicEntityT_ampl__SetInstance_t_getset[] = {
    { (char*) "__dict__", (getter) SwigPyBuiltin_GetterClosure, (setter) 0, (char*)"ampl::BasicEntity<(ampl::SetInstance)>.__dict__", (void*) &BasicEntitySet___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__BasicEntityT_ampl__SetInstance_t_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  PyObject *tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, other);
  Py_XINCREF(other);
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__BasicEntityT_ampl__SetInstance_t_methods[] = {
  { "begin", (PyCFunction) _wrap_BasicEntitySet_begin, METH_VARARGS, (char*) "" },
  { "end", (PyCFunction) _wrap_BasicEntitySet_end, METH_VARARGS, (char*) "" },
  { "find", (PyCFunction) _wrap_BasicEntitySet_find, METH_VARARGS, (char*) "" },
  { "get", (PyCFunction) _wrap_BasicEntitySet_get, METH_VARARGS, (char*) "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__BasicEntityT_ampl__SetInstance_t_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.BasicEntitySet",              /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) _wrap_delete_BasicEntitySet_closure, /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__BasicEntityT_ampl__SetInstance_t_type.as_number,      /* tp_as_number */
    &SwigPyBuiltin__ampl__BasicEntityT_ampl__SetInstance_t_type.as_sequence,    /* tp_as_sequence */
    &SwigPyBuiltin__ampl__BasicEntityT_ampl__SetInstance_t_type.as_mapping,     /* tp_as_mapping */
    (hashfunc) 0,                             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__BasicEntityT_ampl__SetInstance_t_type.as_buffer,      /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::BasicEntity< ampl::SetInstance >", /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ampl__BasicEntityT_ampl__SetInstance_t_richcompare, /* feature:python:tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__BasicEntityT_ampl__SetInstance_t_methods, /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__BasicEntityT_ampl__SetInstance_t_getset, /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t)offsetof(SwigPyObject, dict), /* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject*) 0,                            /* tp_bases */
    (PyObject*) 0,                            /* tp_mro */
    (PyObject*) 0,                            /* tp_cache */
    (PyObject*) 0,                            /* tp_subclasses */
    (PyObject*) 0,                            /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    (struct _typeobject*) 0,                  /* tp_prev */
#endif
    (struct _typeobject*) 0,                  /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject*) 0,                            /* ht_name */
    (PyObject*) 0,                            /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject*) 0,                            /* ht_qualname */
    (struct _dictkeysobject*) 0,              /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__BasicEntityT_ampl__SetInstance_t_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__BasicEntityT_ampl__SetInstance_t_type};

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_BasicEntityObjective)
static SwigPyGetSet BasicEntityObjective___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__BasicEntityT_ampl__ObjectiveInstance_t_getset[] = {
    { (char*) "__dict__", (getter) SwigPyBuiltin_GetterClosure, (setter) 0, (char*)"ampl::BasicEntity<(ampl::ObjectiveInstance)>.__dict__", (void*) &BasicEntityObjective___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__BasicEntityT_ampl__ObjectiveInstance_t_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  PyObject *tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, other);
  Py_XINCREF(other);
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__BasicEntityT_ampl__ObjectiveInstance_t_methods[] = {
  { "begin", (PyCFunction) _wrap_BasicEntityObjective_begin, METH_VARARGS, (char*) "" },
  { "end", (PyCFunction) _wrap_BasicEntityObjective_end, METH_VARARGS, (char*) "" },
  { "find", (PyCFunction) _wrap_BasicEntityObjective_find, METH_VARARGS, (char*) "" },
  { "get", (PyCFunction) _wrap_BasicEntityObjective_get, METH_VARARGS, (char*) "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__BasicEntityT_ampl__ObjectiveInstance_t_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.BasicEntityObjective",        /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) _wrap_delete_BasicEntityObjective_closure, /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__BasicEntityT_ampl__ObjectiveInstance_t_type.as_number,      /* tp_as_number */
    &SwigPyBuiltin__ampl__BasicEntityT_ampl__ObjectiveInstance_t_type.as_sequence,    /* tp_as_sequence */
    &SwigPyBuiltin__ampl__BasicEntityT_ampl__ObjectiveInstance_t_type.as_mapping,     /* tp_as_mapping */
    (hashfunc) 0,                             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__BasicEntityT_ampl__ObjectiveInstance_t_type.as_buffer,      /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::BasicEntity< ampl::ObjectiveInstance >", /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ampl__BasicEntityT_ampl__ObjectiveInstance_t_richcompare, /* feature:python:tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__BasicEntityT_ampl__ObjectiveInstance_t_methods, /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__BasicEntityT_ampl__ObjectiveInstance_t_getset, /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t)offsetof(SwigPyObject, dict), /* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject*) 0,                            /* tp_bases */
    (PyObject*) 0,                            /* tp_mro */
    (PyObject*) 0,                            /* tp_cache */
    (PyObject*) 0,                            /* tp_subclasses */
    (PyObject*) 0,                            /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    (struct _typeobject*) 0,                  /* tp_prev */
#endif
    (struct _typeobject*) 0,                  /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject*) 0,                            /* ht_name */
    (PyObject*) 0,                            /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject*) 0,                            /* ht_qualname */
    (struct _dictkeysobject*) 0,              /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__BasicEntityT_ampl__ObjectiveInstance_t_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__BasicEntityT_ampl__ObjectiveInstance_t_type};

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_BasicEntityParameter)
static SwigPyGetSet BasicEntityParameter___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__BasicEntityT_ampl__VariantRef_t_getset[] = {
    { (char*) "__dict__", (getter) SwigPyBuiltin_GetterClosure, (setter) 0, (char*)"ampl::BasicEntity<(ampl::VariantRef)>.__dict__", (void*) &BasicEntityParameter___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__BasicEntityT_ampl__VariantRef_t_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  PyObject *tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, other);
  Py_XINCREF(other);
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__BasicEntityT_ampl__VariantRef_t_methods[] = {
  { "begin", (PyCFunction) _wrap_BasicEntityParameter_begin, METH_VARARGS, (char*) "" },
  { "end", (PyCFunction) _wrap_BasicEntityParameter_end, METH_VARARGS, (char*) "" },
  { "find", (PyCFunction) _wrap_BasicEntityParameter_find, METH_VARARGS, (char*) "" },
  { "get", (PyCFunction) _wrap_BasicEntityParameter_get, METH_VARARGS, (char*) "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__BasicEntityT_ampl__VariantRef_t_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.BasicEntityParameter",        /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) _wrap_delete_BasicEntityParameter_closure, /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__BasicEntityT_ampl__VariantRef_t_type.as_number,      /* tp_as_number */
    &SwigPyBuiltin__ampl__BasicEntityT_ampl__VariantRef_t_type.as_sequence,    /* tp_as_sequence */
    &SwigPyBuiltin__ampl__BasicEntityT_ampl__VariantRef_t_type.as_mapping,     /* tp_as_mapping */
    (hashfunc) 0,                             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__BasicEntityT_ampl__VariantRef_t_type.as_buffer,      /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::BasicEntity< ampl::VariantRef >",  /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ampl__BasicEntityT_ampl__VariantRef_t_richcompare, /* feature:python:tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__BasicEntityT_ampl__VariantRef_t_methods, /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__BasicEntityT_ampl__VariantRef_t_getset, /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t)offsetof(SwigPyObject, dict), /* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject*) 0,                            /* tp_bases */
    (PyObject*) 0,                            /* tp_mro */
    (PyObject*) 0,                            /* tp_cache */
    (PyObject*) 0,                            /* tp_subclasses */
    (PyObject*) 0,                            /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    (struct _typeobject*) 0,                  /* tp_prev */
#endif
    (struct _typeobject*) 0,                  /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject*) 0,                            /* ht_name */
    (PyObject*) 0,                            /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject*) 0,                            /* ht_qualname */
    (struct _dictkeysobject*) 0,              /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__BasicEntityT_ampl__VariantRef_t_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__BasicEntityT_ampl__VariantRef_t_type};

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_Constraint)
static SwigPyGetSet Constraint___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__Constraint_getset[] = {
    { (char*) "__dict__", (getter) SwigPyBuiltin_GetterClosure, (setter) 0, (char*)"ampl::Constraint.__dict__", (void*) &Constraint___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__Constraint_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  PyObject *tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, other);
  Py_XINCREF(other);
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__Constraint_methods[] = {
  { "isLogical", (PyCFunction) _wrap_Constraint_isLogical, METH_VARARGS, (char*) "" },
  { "drop", (PyCFunction) _wrap_Constraint_drop, METH_VARARGS, (char*) "" },
  { "restore", (PyCFunction) _wrap_Constraint_restore, METH_VARARGS, (char*) "" },
  { "body", (PyCFunction) _wrap_Constraint_body, METH_VARARGS, (char*) "" },
  { "astatus", (PyCFunction) _wrap_Constraint_astatus, METH_VARARGS, (char*) "" },
  { "defvar", (PyCFunction) _wrap_Constraint_defvar, METH_VARARGS, (char*) "" },
  { "dinit", (PyCFunction) _wrap_Constraint_dinit, METH_VARARGS, (char*) "" },
  { "dinit0", (PyCFunction) _wrap_Constraint_dinit0, METH_VARARGS, (char*) "" },
  { "dual", (PyCFunction) _wrap_Constraint_dual, METH_VARARGS, (char*) "" },
  { "lb", (PyCFunction) _wrap_Constraint_lb, METH_VARARGS, (char*) "" },
  { "ub", (PyCFunction) _wrap_Constraint_ub, METH_VARARGS, (char*) "" },
  { "lbs", (PyCFunction) _wrap_Constraint_lbs, METH_VARARGS, (char*) "" },
  { "ubs", (PyCFunction) _wrap_Constraint_ubs, METH_VARARGS, (char*) "" },
  { "ldual", (PyCFunction) _wrap_Constraint_ldual, METH_VARARGS, (char*) "" },
  { "udual", (PyCFunction) _wrap_Constraint_udual, METH_VARARGS, (char*) "" },
  { "lslack", (PyCFunction) _wrap_Constraint_lslack, METH_VARARGS, (char*) "" },
  { "uslack", (PyCFunction) _wrap_Constraint_uslack, METH_VARARGS, (char*) "" },
  { "slack", (PyCFunction) _wrap_Constraint_slack, METH_VARARGS, (char*) "" },
  { "sstatus", (PyCFunction) _wrap_Constraint_sstatus, METH_VARARGS, (char*) "" },
  { "status", (PyCFunction) _wrap_Constraint_status, METH_VARARGS, (char*) "" },
  { "setDual", (PyCFunction) _wrap_Constraint_setDual, METH_VARARGS, (char*) "" },
  { "val", (PyCFunction) _wrap_Constraint_val, METH_VARARGS, (char*) "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__Constraint_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.Constraint",                  /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) _wrap_delete_Constraint_closure, /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__Constraint_type.as_number,      /* tp_as_number */
    &SwigPyBuiltin__ampl__Constraint_type.as_sequence,    /* tp_as_sequence */
    &SwigPyBuiltin__ampl__Constraint_type.as_mapping,     /* tp_as_mapping */
    (hashfunc) 0,                             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__Constraint_type.as_buffer,      /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::Constraint",                       /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ampl__Constraint_richcompare, /* feature:python:tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__Constraint_methods,  /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__Constraint_getset,   /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t)offsetof(SwigPyObject, dict), /* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject*) 0,                            /* tp_bases */
    (PyObject*) 0,                            /* tp_mro */
    (PyObject*) 0,                            /* tp_cache */
    (PyObject*) 0,                            /* tp_subclasses */
    (PyObject*) 0,                            /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    (struct _typeobject*) 0,                  /* tp_prev */
#endif
    (struct _typeobject*) 0,                  /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject*) 0,                            /* ht_name */
    (PyObject*) 0,                            /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject*) 0,                            /* ht_qualname */
    (struct _dictkeysobject*) 0,              /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__Constraint_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__Constraint_type};

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_Variable)
static SwigPyGetSet Variable___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__Variable_getset[] = {
    { (char*) "__dict__", (getter) SwigPyBuiltin_GetterClosure, (setter) 0, (char*)"ampl::Variable.__dict__", (void*) &Variable___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__Variable_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  PyObject *tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, other);
  Py_XINCREF(other);
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__Variable_methods[] = {
  { "integrality", (PyCFunction) _wrap_Variable_integrality, METH_VARARGS, (char*) "" },
  { "fix", (PyCFunction) _wrap_Variable_fix, METH_VARARGS, (char*) "" },
  { "unfix", (PyCFunction) _wrap_Variable_unfix, METH_VARARGS, (char*) "" },
  { "setValue", (PyCFunction) _wrap_Variable_setValue, METH_VARARGS, (char*) "" },
  { "value", (PyCFunction) _wrap_Variable_value, METH_VARARGS, (char*) "" },
  { "astatus", (PyCFunction) _wrap_Variable_astatus, METH_VARARGS, (char*) "" },
  { "defeqn", (PyCFunction) _wrap_Variable_defeqn, METH_VARARGS, (char*) "" },
  { "dual", (PyCFunction) _wrap_Variable_dual, METH_VARARGS, (char*) "" },
  { "init", (PyCFunction) _wrap_Variable_init, METH_VARARGS, (char*) "" },
  { "init0", (PyCFunction) _wrap_Variable_init0, METH_VARARGS, (char*) "" },
  { "lb", (PyCFunction) _wrap_Variable_lb, METH_VARARGS, (char*) "" },
  { "ub", (PyCFunction) _wrap_Variable_ub, METH_VARARGS, (char*) "" },
  { "lb0", (PyCFunction) _wrap_Variable_lb0, METH_VARARGS, (char*) "" },
  { "ub0", (PyCFunction) _wrap_Variable_ub0, METH_VARARGS, (char*) "" },
  { "lb1", (PyCFunction) _wrap_Variable_lb1, METH_VARARGS, (char*) "" },
  { "ub1", (PyCFunction) _wrap_Variable_ub1, METH_VARARGS, (char*) "" },
  { "lb2", (PyCFunction) _wrap_Variable_lb2, METH_VARARGS, (char*) "" },
  { "ub2", (PyCFunction) _wrap_Variable_ub2, METH_VARARGS, (char*) "" },
  { "lrc", (PyCFunction) _wrap_Variable_lrc, METH_VARARGS, (char*) "" },
  { "urc", (PyCFunction) _wrap_Variable_urc, METH_VARARGS, (char*) "" },
  { "lslack", (PyCFunction) _wrap_Variable_lslack, METH_VARARGS, (char*) "" },
  { "uslack", (PyCFunction) _wrap_Variable_uslack, METH_VARARGS, (char*) "" },
  { "rc", (PyCFunction) _wrap_Variable_rc, METH_VARARGS, (char*) "" },
  { "slack", (PyCFunction) _wrap_Variable_slack, METH_VARARGS, (char*) "" },
  { "sstatus", (PyCFunction) _wrap_Variable_sstatus, METH_VARARGS, (char*) "" },
  { "status", (PyCFunction) _wrap_Variable_status, METH_VARARGS, (char*) "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__Variable_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.Variable",                    /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) _wrap_delete_Variable_closure, /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__Variable_type.as_number,      /* tp_as_number */
    &SwigPyBuiltin__ampl__Variable_type.as_sequence,    /* tp_as_sequence */
    &SwigPyBuiltin__ampl__Variable_type.as_mapping,     /* tp_as_mapping */
    (hashfunc) 0,                             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__Variable_type.as_buffer,      /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::Variable",                         /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ampl__Variable_richcompare, /* feature:python:tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__Variable_methods,    /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__Variable_getset,     /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t)offsetof(SwigPyObject, dict), /* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject*) 0,                            /* tp_bases */
    (PyObject*) 0,                            /* tp_mro */
    (PyObject*) 0,                            /* tp_cache */
    (PyObject*) 0,                            /* tp_subclasses */
    (PyObject*) 0,                            /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    (struct _typeobject*) 0,                  /* tp_prev */
#endif
    (struct _typeobject*) 0,                  /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject*) 0,                            /* ht_name */
    (PyObject*) 0,                            /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject*) 0,                            /* ht_qualname */
    (struct _dictkeysobject*) 0,              /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__Variable_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__Variable_type};

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_Objective)
static SwigPyGetSet Objective___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__Objective_getset[] = {
    { (char*) "__dict__", (getter) SwigPyBuiltin_GetterClosure, (setter) 0, (char*)"ampl::Objective.__dict__", (void*) &Objective___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__Objective_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  PyObject *tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, other);
  Py_XINCREF(other);
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__Objective_methods[] = {
  { "value", (PyCFunction) _wrap_Objective_value, METH_VARARGS, (char*) "" },
  { "astatus", (PyCFunction) _wrap_Objective_astatus, METH_VARARGS, (char*) "" },
  { "sstatus", (PyCFunction) _wrap_Objective_sstatus, METH_VARARGS, (char*) "" },
  { "exitcode", (PyCFunction) _wrap_Objective_exitcode, METH_VARARGS, (char*) "" },
  { "message", (PyCFunction) _wrap_Objective_message, METH_VARARGS, (char*) "" },
  { "result", (PyCFunction) _wrap_Objective_result, METH_VARARGS, (char*) "" },
  { "drop", (PyCFunction) _wrap_Objective_drop, METH_VARARGS, (char*) "" },
  { "restore", (PyCFunction) _wrap_Objective_restore, METH_VARARGS, (char*) "" },
  { "minimization", (PyCFunction) _wrap_Objective_minimization, METH_VARARGS, (char*) "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__Objective_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.Objective",                   /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) _wrap_delete_Objective_closure, /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__Objective_type.as_number,      /* tp_as_number */
    &SwigPyBuiltin__ampl__Objective_type.as_sequence,    /* tp_as_sequence */
    &SwigPyBuiltin__ampl__Objective_type.as_mapping,     /* tp_as_mapping */
    (hashfunc) 0,                             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__Objective_type.as_buffer,      /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::Objective",                        /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ampl__Objective_richcompare, /* feature:python:tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__Objective_methods,   /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__Objective_getset,    /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t)offsetof(SwigPyObject, dict), /* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject*) 0,                            /* tp_bases */
    (PyObject*) 0,                            /* tp_mro */
    (PyObject*) 0,                            /* tp_cache */
    (PyObject*) 0,                            /* tp_subclasses */
    (PyObject*) 0,                            /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    (struct _typeobject*) 0,                  /* tp_prev */
#endif
    (struct _typeobject*) 0,                  /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject*) 0,                            /* ht_name */
    (PyObject*) 0,                            /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject*) 0,                            /* ht_qualname */
    (struct _dictkeysobject*) 0,              /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__Objective_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__Objective_type};

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_Set)
static SwigPyGetSet Set___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__Set_getset[] = {
    { (char*) "__dict__", (getter) SwigPyBuiltin_GetterClosure, (setter) 0, (char*)"ampl::Set.__dict__", (void*) &Set___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__Set_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  PyObject *tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, other);
  Py_XINCREF(other);
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__Set_methods[] = {
  { "arity", (PyCFunction) _wrap_Set_arity, METH_VARARGS, (char*) "" },
  { "getValues", (PyCFunction) _wrap_Set_getValues, METH_VARARGS, (char*) "" },
  { "size", (PyCFunction) _wrap_Set_size, METH_VARARGS, (char*) "" },
  { "setValuesDf", (PyCFunction) _wrap_Set_setValuesDf, METH_VARARGS, (char*) "" },
  { "contains", (PyCFunction) _wrap_Set_contains, METH_VARARGS, (char*) "" },
  { "setValues", (PyCFunction) _wrap_Set_setValues, METH_VARARGS, (char*) "" },
  { "setValuesDbl", (PyCFunction) _wrap_Set_setValuesDbl, METH_VARARGS, (char*) "" },
  { "setValuesStr", (PyCFunction) _wrap_Set_setValuesStr, METH_VARARGS, (char*) "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__Set_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.Set",                         /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) _wrap_delete_Set_closure,    /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__Set_type.as_number,      /* tp_as_number */
    &SwigPyBuiltin__ampl__Set_type.as_sequence,    /* tp_as_sequence */
    &SwigPyBuiltin__ampl__Set_type.as_mapping,     /* tp_as_mapping */
    (hashfunc) 0,                             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__Set_type.as_buffer,      /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::Set",                              /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ampl__Set_richcompare, /* feature:python:tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__Set_methods,         /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__Set_getset,          /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t)offsetof(SwigPyObject, dict), /* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject*) 0,                            /* tp_bases */
    (PyObject*) 0,                            /* tp_mro */
    (PyObject*) 0,                            /* tp_cache */
    (PyObject*) 0,                            /* tp_subclasses */
    (PyObject*) 0,                            /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    (struct _typeobject*) 0,                  /* tp_prev */
#endif
    (struct _typeobject*) 0,                  /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject*) 0,                            /* ht_name */
    (PyObject*) 0,                            /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject*) 0,                            /* ht_qualname */
    (struct _dictkeysobject*) 0,              /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__Set_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__Set_type};

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_Parameter)
static SwigPyGetSet Parameter___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__Parameter_getset[] = {
    { (char*) "__dict__", (getter) SwigPyBuiltin_GetterClosure, (setter) 0, (char*)"ampl::Parameter.__dict__", (void*) &Parameter___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__Parameter_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  PyObject *tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, other);
  Py_XINCREF(other);
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__Parameter_methods[] = {
  { "isSymbolic", (PyCFunction) _wrap_Parameter_isSymbolic, METH_VARARGS, (char*) "" },
  { "hasDefault", (PyCFunction) _wrap_Parameter_hasDefault, METH_VARARGS, (char*) "" },
  { "set", (PyCFunction) _wrap_Parameter_set, METH_VARARGS, (char*) "" },
  { "setTplDbl", (PyCFunction) _wrap_Parameter_setTplDbl, METH_VARARGS, (char*) "" },
  { "setTplStr", (PyCFunction) _wrap_Parameter_setTplStr, METH_VARARGS, (char*) "" },
  { "setValuesTaDbl", (PyCFunction) _wrap_Parameter_setValuesTaDbl, METH_VARARGS, (char*) "" },
  { "setValuesTaStr", (PyCFunction) _wrap_Parameter_setValuesTaStr, METH_VARARGS, (char*) "" },
  { "setValuesDbl", (PyCFunction) _wrap_Parameter_setValuesDbl, METH_VARARGS, (char*) "" },
  { "setValuesStr", (PyCFunction) _wrap_Parameter_setValuesStr, METH_VARARGS, (char*) "" },
  { "setValues", (PyCFunction) _wrap_Parameter_setValues, METH_VARARGS, (char*) "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__Parameter_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.Parameter",                   /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) _wrap_delete_Parameter_closure, /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__Parameter_type.as_number,      /* tp_as_number */
    &SwigPyBuiltin__ampl__Parameter_type.as_sequence,    /* tp_as_sequence */
    &SwigPyBuiltin__ampl__Parameter_type.as_mapping,     /* tp_as_mapping */
    (hashfunc) 0,                             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__Parameter_type.as_buffer,      /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::Parameter",                        /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ampl__Parameter_richcompare, /* feature:python:tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__Parameter_methods,   /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__Parameter_getset,    /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t)offsetof(SwigPyObject, dict), /* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject*) 0,                            /* tp_bases */
    (PyObject*) 0,                            /* tp_mro */
    (PyObject*) 0,                            /* tp_cache */
    (PyObject*) 0,                            /* tp_subclasses */
    (PyObject*) 0,                            /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    (struct _typeobject*) 0,                  /* tp_prev */
#endif
    (struct _typeobject*) 0,                  /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject*) 0,                            /* ht_name */
    (PyObject*) 0,                            /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject*) 0,                            /* ht_qualname */
    (struct _dictkeysobject*) 0,              /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__Parameter_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__Parameter_type};

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_VariableIteratorWrapper)
static SwigPyGetSet VariableIteratorWrapper___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__VariableInstance_t_getset[] = {
    { (char*) "__dict__", (getter) SwigPyBuiltin_GetterClosure, (setter) 0, (char*)"ampl::internal::EntityWrapper<(ampl::VariableInstance)>.__dict__", (void*) &VariableIteratorWrapper___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__VariableInstance_t_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  PyObject *tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, other);
  Py_XINCREF(other);
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__VariableInstance_t_methods[] = {
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__VariableInstance_t_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.VariableIteratorWrapper",     /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) _wrap_delete_VariableIteratorWrapper_closure, /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__VariableInstance_t_type.as_number,      /* tp_as_number */
    &SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__VariableInstance_t_type.as_sequence,    /* tp_as_sequence */
    &SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__VariableInstance_t_type.as_mapping,     /* tp_as_mapping */
    (hashfunc) 0,                             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__VariableInstance_t_type.as_buffer,      /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::internal::EntityWrapper< ampl::VariableInstance >", /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__VariableInstance_t_richcompare, /* feature:python:tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__VariableInstance_t_methods, /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__VariableInstance_t_getset, /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t)offsetof(SwigPyObject, dict), /* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject*) 0,                            /* tp_bases */
    (PyObject*) 0,                            /* tp_mro */
    (PyObject*) 0,                            /* tp_cache */
    (PyObject*) 0,                            /* tp_subclasses */
    (PyObject*) 0,                            /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    (struct _typeobject*) 0,                  /* tp_prev */
#endif
    (struct _typeobject*) 0,                  /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject*) 0,                            /* ht_name */
    (PyObject*) 0,                            /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject*) 0,                            /* ht_qualname */
    (struct _dictkeysobject*) 0,              /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__VariableInstance_t_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__VariableInstance_t_type};

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_VariableIterator)
static SwigPyGetSet VariableIterator___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t_getset[] = {
    { (char*) "__dict__", (getter) SwigPyBuiltin_GetterClosure, (setter) 0, (char*)"ampl::internal::CountedIterator<(ampl::internal::EntityWrapper<(ampl::VariableInstance)>)>.__dict__", (void*) &VariableIterator___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  PyObject *tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, other);
  Py_XINCREF(other);
  switch (op) {
    case Py_EQ : result = _wrap_VariableIterator_equals(self, tuple); break;
    case Py_NE : result = _wrap_VariableIterator_differs(self, tuple); break;
    default : break;
  }
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t_methods[] = {
  { "equals", (PyCFunction) _wrap_VariableIterator_equals, METH_VARARGS, (char*) "" },
  { "differs", (PyCFunction) _wrap_VariableIterator_differs, METH_VARARGS, (char*) "" },
  { "clone", (PyCFunction) _wrap_VariableIterator_clone, METH_VARARGS, (char*) "" },
  { "postIncrement", (PyCFunction) _wrap_VariableIterator_postIncrement, METH_VARARGS, (char*) "" },
  { "postIncrementBy", (PyCFunction) _wrap_VariableIterator_postIncrementBy, METH_VARARGS, (char*) "" },
  { "first", (PyCFunction) _wrap_VariableIterator_first, METH_VARARGS, (char*) "" },
  { "second", (PyCFunction) _wrap_VariableIterator_second, METH_VARARGS, (char*) "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.VariableIterator",            /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) _wrap_delete_VariableIterator_closure, /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t_type.as_number,      /* tp_as_number */
    &SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t_type.as_sequence,    /* tp_as_sequence */
    &SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t_type.as_mapping,     /* tp_as_mapping */
    (hashfunc) 0,                             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t_type.as_buffer,      /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > >", /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t_richcompare, /* feature:python:tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t_methods, /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t_getset, /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t)offsetof(SwigPyObject, dict), /* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject*) 0,                            /* tp_bases */
    (PyObject*) 0,                            /* tp_mro */
    (PyObject*) 0,                            /* tp_cache */
    (PyObject*) 0,                            /* tp_subclasses */
    (PyObject*) 0,                            /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    (struct _typeobject*) 0,                  /* tp_prev */
#endif
    (struct _typeobject*) 0,                  /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject*) 0,                            /* ht_name */
    (PyObject*) 0,                            /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject*) 0,                            /* ht_qualname */
    (struct _dictkeysobject*) 0,              /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t_type};

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_ConstraintIteratorWrapper)
static SwigPyGetSet ConstraintIteratorWrapper___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_getset[] = {
    { (char*) "__dict__", (getter) SwigPyBuiltin_GetterClosure, (setter) 0, (char*)"ampl::internal::EntityWrapper<(ampl::ConstraintInstance)>.__dict__", (void*) &ConstraintIteratorWrapper___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  PyObject *tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, other);
  Py_XINCREF(other);
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_methods[] = {
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.ConstraintIteratorWrapper",   /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) _wrap_delete_ConstraintIteratorWrapper_closure, /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_type.as_number,      /* tp_as_number */
    &SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_type.as_sequence,    /* tp_as_sequence */
    &SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_type.as_mapping,     /* tp_as_mapping */
    (hashfunc) 0,                             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_type.as_buffer,      /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::internal::EntityWrapper< ampl::ConstraintInstance >", /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_richcompare, /* feature:python:tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_methods, /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_getset, /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t)offsetof(SwigPyObject, dict), /* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject*) 0,                            /* tp_bases */
    (PyObject*) 0,                            /* tp_mro */
    (PyObject*) 0,                            /* tp_cache */
    (PyObject*) 0,                            /* tp_subclasses */
    (PyObject*) 0,                            /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    (struct _typeobject*) 0,                  /* tp_prev */
#endif
    (struct _typeobject*) 0,                  /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject*) 0,                            /* ht_name */
    (PyObject*) 0,                            /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject*) 0,                            /* ht_qualname */
    (struct _dictkeysobject*) 0,              /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_type};

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_ConstraintIterator)
static SwigPyGetSet ConstraintIterator___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t_getset[] = {
    { (char*) "__dict__", (getter) SwigPyBuiltin_GetterClosure, (setter) 0, (char*)"ampl::internal::CountedIterator<(ampl::internal::EntityWrapper<(ampl::ConstraintInstance)>)>.__dict__", (void*) &ConstraintIterator___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  PyObject *tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, other);
  Py_XINCREF(other);
  switch (op) {
    case Py_EQ : result = _wrap_ConstraintIterator_equals(self, tuple); break;
    case Py_NE : result = _wrap_ConstraintIterator_differs(self, tuple); break;
    default : break;
  }
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t_methods[] = {
  { "equals", (PyCFunction) _wrap_ConstraintIterator_equals, METH_VARARGS, (char*) "" },
  { "differs", (PyCFunction) _wrap_ConstraintIterator_differs, METH_VARARGS, (char*) "" },
  { "clone", (PyCFunction) _wrap_ConstraintIterator_clone, METH_VARARGS, (char*) "" },
  { "postIncrement", (PyCFunction) _wrap_ConstraintIterator_postIncrement, METH_VARARGS, (char*) "" },
  { "postIncrementBy", (PyCFunction) _wrap_ConstraintIterator_postIncrementBy, METH_VARARGS, (char*) "" },
  { "first", (PyCFunction) _wrap_ConstraintIterator_first, METH_VARARGS, (char*) "" },
  { "second", (PyCFunction) _wrap_ConstraintIterator_second, METH_VARARGS, (char*) "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.ConstraintIterator",          /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) _wrap_delete_ConstraintIterator_closure, /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t_type.as_number,      /* tp_as_number */
    &SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t_type.as_sequence,    /* tp_as_sequence */
    &SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t_type.as_mapping,     /* tp_as_mapping */
    (hashfunc) 0,                             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t_type.as_buffer,      /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > >", /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t_richcompare, /* feature:python:tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t_methods, /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t_getset, /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t)offsetof(SwigPyObject, dict), /* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject*) 0,                            /* tp_bases */
    (PyObject*) 0,                            /* tp_mro */
    (PyObject*) 0,                            /* tp_cache */
    (PyObject*) 0,                            /* tp_subclasses */
    (PyObject*) 0,                            /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    (struct _typeobject*) 0,                  /* tp_prev */
#endif
    (struct _typeobject*) 0,                  /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject*) 0,                            /* ht_name */
    (PyObject*) 0,                            /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject*) 0,                            /* ht_qualname */
    (struct _dictkeysobject*) 0,              /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t_type};

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_ObjectiveIteratorWrapper)
static SwigPyGetSet ObjectiveIteratorWrapper___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_getset[] = {
    { (char*) "__dict__", (getter) SwigPyBuiltin_GetterClosure, (setter) 0, (char*)"ampl::internal::EntityWrapper<(ampl::ObjectiveInstance)>.__dict__", (void*) &ObjectiveIteratorWrapper___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  PyObject *tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, other);
  Py_XINCREF(other);
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_methods[] = {
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.ObjectiveIteratorWrapper",    /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) _wrap_delete_ObjectiveIteratorWrapper_closure, /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_type.as_number,      /* tp_as_number */
    &SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_type.as_sequence,    /* tp_as_sequence */
    &SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_type.as_mapping,     /* tp_as_mapping */
    (hashfunc) 0,                             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_type.as_buffer,      /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::internal::EntityWrapper< ampl::ObjectiveInstance >", /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_richcompare, /* feature:python:tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_methods, /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_getset, /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t)offsetof(SwigPyObject, dict), /* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject*) 0,                            /* tp_bases */
    (PyObject*) 0,                            /* tp_mro */
    (PyObject*) 0,                            /* tp_cache */
    (PyObject*) 0,                            /* tp_subclasses */
    (PyObject*) 0,                            /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    (struct _typeobject*) 0,                  /* tp_prev */
#endif
    (struct _typeobject*) 0,                  /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject*) 0,                            /* ht_name */
    (PyObject*) 0,                            /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject*) 0,                            /* ht_qualname */
    (struct _dictkeysobject*) 0,              /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_type};

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_ObjectiveIterator)
static SwigPyGetSet ObjectiveIterator___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t_getset[] = {
    { (char*) "__dict__", (getter) SwigPyBuiltin_GetterClosure, (setter) 0, (char*)"ampl::internal::CountedIterator<(ampl::internal::EntityWrapper<(ampl::ObjectiveInstance)>)>.__dict__", (void*) &ObjectiveIterator___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  PyObject *tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, other);
  Py_XINCREF(other);
  switch (op) {
    case Py_EQ : result = _wrap_ObjectiveIterator_equals(self, tuple); break;
    case Py_NE : result = _wrap_ObjectiveIterator_differs(self, tuple); break;
    default : break;
  }
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t_methods[] = {
  { "equals", (PyCFunction) _wrap_ObjectiveIterator_equals, METH_VARARGS, (char*) "" },
  { "differs", (PyCFunction) _wrap_ObjectiveIterator_differs, METH_VARARGS, (char*) "" },
  { "clone", (PyCFunction) _wrap_ObjectiveIterator_clone, METH_VARARGS, (char*) "" },
  { "postIncrement", (PyCFunction) _wrap_ObjectiveIterator_postIncrement, METH_VARARGS, (char*) "" },
  { "postIncrementBy", (PyCFunction) _wrap_ObjectiveIterator_postIncrementBy, METH_VARARGS, (char*) "" },
  { "first", (PyCFunction) _wrap_ObjectiveIterator_first, METH_VARARGS, (char*) "" },
  { "second", (PyCFunction) _wrap_ObjectiveIterator_second, METH_VARARGS, (char*) "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.ObjectiveIterator",           /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) _wrap_delete_ObjectiveIterator_closure, /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t_type.as_number,      /* tp_as_number */
    &SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t_type.as_sequence,    /* tp_as_sequence */
    &SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t_type.as_mapping,     /* tp_as_mapping */
    (hashfunc) 0,                             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t_type.as_buffer,      /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > >", /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t_richcompare, /* feature:python:tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t_methods, /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t_getset, /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t)offsetof(SwigPyObject, dict), /* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject*) 0,                            /* tp_bases */
    (PyObject*) 0,                            /* tp_mro */
    (PyObject*) 0,                            /* tp_cache */
    (PyObject*) 0,                            /* tp_subclasses */
    (PyObject*) 0,                            /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    (struct _typeobject*) 0,                  /* tp_prev */
#endif
    (struct _typeobject*) 0,                  /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject*) 0,                            /* ht_name */
    (PyObject*) 0,                            /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject*) 0,                            /* ht_qualname */
    (struct _dictkeysobject*) 0,              /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t_type};

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_SetIteratorWrapper)
static SwigPyGetSet SetIteratorWrapper___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__SetInstance_t_getset[] = {
    { (char*) "__dict__", (getter) SwigPyBuiltin_GetterClosure, (setter) 0, (char*)"ampl::internal::EntityWrapper<(ampl::SetInstance)>.__dict__", (void*) &SetIteratorWrapper___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__SetInstance_t_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  PyObject *tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, other);
  Py_XINCREF(other);
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__SetInstance_t_methods[] = {
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__SetInstance_t_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.SetIteratorWrapper",          /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) _wrap_delete_SetIteratorWrapper_closure, /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__SetInstance_t_type.as_number,      /* tp_as_number */
    &SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__SetInstance_t_type.as_sequence,    /* tp_as_sequence */
    &SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__SetInstance_t_type.as_mapping,     /* tp_as_mapping */
    (hashfunc) 0,                             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__SetInstance_t_type.as_buffer,      /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::internal::EntityWrapper< ampl::SetInstance >", /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__SetInstance_t_richcompare, /* feature:python:tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__SetInstance_t_methods, /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__SetInstance_t_getset, /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t)offsetof(SwigPyObject, dict), /* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject*) 0,                            /* tp_bases */
    (PyObject*) 0,                            /* tp_mro */
    (PyObject*) 0,                            /* tp_cache */
    (PyObject*) 0,                            /* tp_subclasses */
    (PyObject*) 0,                            /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    (struct _typeobject*) 0,                  /* tp_prev */
#endif
    (struct _typeobject*) 0,                  /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject*) 0,                            /* ht_name */
    (PyObject*) 0,                            /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject*) 0,                            /* ht_qualname */
    (struct _dictkeysobject*) 0,              /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__SetInstance_t_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__SetInstance_t_type};

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_SetIterator)
static SwigPyGetSet SetIterator___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t_getset[] = {
    { (char*) "__dict__", (getter) SwigPyBuiltin_GetterClosure, (setter) 0, (char*)"ampl::internal::CountedIterator<(ampl::internal::EntityWrapper<(ampl::SetInstance)>)>.__dict__", (void*) &SetIterator___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  PyObject *tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, other);
  Py_XINCREF(other);
  switch (op) {
    case Py_EQ : result = _wrap_SetIterator_equals(self, tuple); break;
    case Py_NE : result = _wrap_SetIterator_differs(self, tuple); break;
    default : break;
  }
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t_methods[] = {
  { "equals", (PyCFunction) _wrap_SetIterator_equals, METH_VARARGS, (char*) "" },
  { "differs", (PyCFunction) _wrap_SetIterator_differs, METH_VARARGS, (char*) "" },
  { "clone", (PyCFunction) _wrap_SetIterator_clone, METH_VARARGS, (char*) "" },
  { "postIncrement", (PyCFunction) _wrap_SetIterator_postIncrement, METH_VARARGS, (char*) "" },
  { "postIncrementBy", (PyCFunction) _wrap_SetIterator_postIncrementBy, METH_VARARGS, (char*) "" },
  { "first", (PyCFunction) _wrap_SetIterator_first, METH_VARARGS, (char*) "" },
  { "second", (PyCFunction) _wrap_SetIterator_second, METH_VARARGS, (char*) "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.SetIterator",                 /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) _wrap_delete_SetIterator_closure, /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t_type.as_number,      /* tp_as_number */
    &SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t_type.as_sequence,    /* tp_as_sequence */
    &SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t_type.as_mapping,     /* tp_as_mapping */
    (hashfunc) 0,                             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t_type.as_buffer,      /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > >", /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t_richcompare, /* feature:python:tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t_methods, /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t_getset, /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t)offsetof(SwigPyObject, dict), /* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject*) 0,                            /* tp_bases */
    (PyObject*) 0,                            /* tp_mro */
    (PyObject*) 0,                            /* tp_cache */
    (PyObject*) 0,                            /* tp_subclasses */
    (PyObject*) 0,                            /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    (struct _typeobject*) 0,                  /* tp_prev */
#endif
    (struct _typeobject*) 0,                  /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject*) 0,                            /* ht_name */
    (PyObject*) 0,                            /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject*) 0,                            /* ht_qualname */
    (struct _dictkeysobject*) 0,              /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t_type};

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_ParameterIteratorWrapper)
static SwigPyGetSet ParameterIteratorWrapper___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__VariantRef_t_getset[] = {
    { (char*) "__dict__", (getter) SwigPyBuiltin_GetterClosure, (setter) 0, (char*)"ampl::internal::EntityWrapper<(ampl::VariantRef)>.__dict__", (void*) &ParameterIteratorWrapper___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__VariantRef_t_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  PyObject *tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, other);
  Py_XINCREF(other);
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__VariantRef_t_methods[] = {
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__VariantRef_t_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.ParameterIteratorWrapper",    /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) _wrap_delete_ParameterIteratorWrapper_closure, /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__VariantRef_t_type.as_number,      /* tp_as_number */
    &SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__VariantRef_t_type.as_sequence,    /* tp_as_sequence */
    &SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__VariantRef_t_type.as_mapping,     /* tp_as_mapping */
    (hashfunc) 0,                             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__VariantRef_t_type.as_buffer,      /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::internal::EntityWrapper< ampl::VariantRef >", /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__VariantRef_t_richcompare, /* feature:python:tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__VariantRef_t_methods, /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__VariantRef_t_getset, /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t)offsetof(SwigPyObject, dict), /* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject*) 0,                            /* tp_bases */
    (PyObject*) 0,                            /* tp_mro */
    (PyObject*) 0,                            /* tp_cache */
    (PyObject*) 0,                            /* tp_subclasses */
    (PyObject*) 0,                            /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    (struct _typeobject*) 0,                  /* tp_prev */
#endif
    (struct _typeobject*) 0,                  /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject*) 0,                            /* ht_name */
    (PyObject*) 0,                            /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject*) 0,                            /* ht_qualname */
    (struct _dictkeysobject*) 0,              /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__VariantRef_t_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__VariantRef_t_type};

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_ParameterIterator)
static SwigPyGetSet ParameterIterator___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t_getset[] = {
    { (char*) "__dict__", (getter) SwigPyBuiltin_GetterClosure, (setter) 0, (char*)"ampl::internal::CountedIterator<(ampl::internal::EntityWrapper<(ampl::VariantRef)>)>.__dict__", (void*) &ParameterIterator___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  PyObject *tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, other);
  Py_XINCREF(other);
  switch (op) {
    case Py_EQ : result = _wrap_ParameterIterator_equals(self, tuple); break;
    case Py_NE : result = _wrap_ParameterIterator_differs(self, tuple); break;
    default : break;
  }
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t_methods[] = {
  { "equals", (PyCFunction) _wrap_ParameterIterator_equals, METH_VARARGS, (char*) "" },
  { "differs", (PyCFunction) _wrap_ParameterIterator_differs, METH_VARARGS, (char*) "" },
  { "clone", (PyCFunction) _wrap_ParameterIterator_clone, METH_VARARGS, (char*) "" },
  { "postIncrement", (PyCFunction) _wrap_ParameterIterator_postIncrement, METH_VARARGS, (char*) "" },
  { "postIncrementBy", (PyCFunction) _wrap_ParameterIterator_postIncrementBy, METH_VARARGS, (char*) "" },
  { "first", (PyCFunction) _wrap_ParameterIterator_first, METH_VARARGS, (char*) "" },
  { "second", (PyCFunction) _wrap_ParameterIterator_second, METH_VARARGS, (char*) "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.ParameterIterator",           /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) _wrap_delete_ParameterIterator_closure, /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t_type.as_number,      /* tp_as_number */
    &SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t_type.as_sequence,    /* tp_as_sequence */
    &SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t_type.as_mapping,     /* tp_as_mapping */
    (hashfunc) 0,                             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t_type.as_buffer,      /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > >", /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t_richcompare, /* feature:python:tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t_methods, /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t_getset, /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t)offsetof(SwigPyObject, dict), /* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject*) 0,                            /* tp_bases */
    (PyObject*) 0,                            /* tp_mro */
    (PyObject*) 0,                            /* tp_cache */
    (PyObject*) 0,                            /* tp_subclasses */
    (PyObject*) 0,                            /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    (struct _typeobject*) 0,                  /* tp_prev */
#endif
    (struct _typeobject*) 0,                  /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject*) 0,                            /* ht_name */
    (PyObject*) 0,                            /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject*) 0,                            /* ht_qualname */
    (struct _dictkeysobject*) 0,              /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t_type};

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_EntityMapVariable)
static SwigPyGetSet EntityMapVariable___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__EntityMapT_ampl__Variable_t_getset[] = {
    { (char*) "__dict__", (getter) SwigPyBuiltin_GetterClosure, (setter) 0, (char*)"ampl::EntityMap<(ampl::Variable)>.__dict__", (void*) &EntityMapVariable___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__EntityMapT_ampl__Variable_t_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  PyObject *tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, other);
  Py_XINCREF(other);
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__EntityMapT_ampl__Variable_t_methods[] = {
  { "begin", (PyCFunction) _wrap_EntityMapVariable_begin, METH_VARARGS, (char*) "" },
  { "end", (PyCFunction) _wrap_EntityMapVariable_end, METH_VARARGS, (char*) "" },
  { "find", (PyCFunction) _wrap_EntityMapVariable_find, METH_VARARGS, (char*) "" },
  { "size", (PyCFunction) _wrap_EntityMapVariable_size, METH_VARARGS, (char*) "" },
  { "getIndex", (PyCFunction) _wrap_EntityMapVariable_getIndex, METH_VARARGS, (char*) "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__EntityMapT_ampl__Variable_t_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.EntityMapVariable",           /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) _wrap_delete_EntityMapVariable_closure, /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Variable_t_type.as_number,      /* tp_as_number */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Variable_t_type.as_sequence,    /* tp_as_sequence */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Variable_t_type.as_mapping,     /* tp_as_mapping */
    (hashfunc) 0,                             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Variable_t_type.as_buffer,      /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::EntityMap< ampl::Variable >",      /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ampl__EntityMapT_ampl__Variable_t_richcompare, /* feature:python:tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__EntityMapT_ampl__Variable_t_methods, /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__EntityMapT_ampl__Variable_t_getset, /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t)offsetof(SwigPyObject, dict), /* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject*) 0,                            /* tp_bases */
    (PyObject*) 0,                            /* tp_mro */
    (PyObject*) 0,                            /* tp_cache */
    (PyObject*) 0,                            /* tp_subclasses */
    (PyObject*) 0,                            /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    (struct _typeobject*) 0,                  /* tp_prev */
#endif
    (struct _typeobject*) 0,                  /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject*) 0,                            /* ht_name */
    (PyObject*) 0,                            /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject*) 0,                            /* ht_qualname */
    (struct _dictkeysobject*) 0,              /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__EntityMapT_ampl__Variable_t_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__EntityMapT_ampl__Variable_t_type};

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_EntityMapVariableIterator)
static SwigPyGetSet EntityMapVariableIterator___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__EntityMapT_ampl__Variable_t__iterator_getset[] = {
    { (char*) "__dict__", (getter) SwigPyBuiltin_GetterClosure, (setter) 0, (char*)"ampl::EntityMap<(ampl::Variable)>::iterator.__dict__", (void*) &EntityMapVariableIterator___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__EntityMapT_ampl__Variable_t__iterator_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  PyObject *tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, other);
  Py_XINCREF(other);
  switch (op) {
    case Py_EQ : result = _wrap_EntityMapVariableIterator_equals(self, tuple); break;
    case Py_NE : result = _wrap_EntityMapVariableIterator_differs(self, tuple); break;
    default : break;
  }
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__EntityMapT_ampl__Variable_t__iterator_methods[] = {
  { "equals", (PyCFunction) _wrap_EntityMapVariableIterator_equals, METH_VARARGS, (char*) "" },
  { "differs", (PyCFunction) _wrap_EntityMapVariableIterator_differs, METH_VARARGS, (char*) "" },
  { "__ref__", (PyCFunction) _wrap_EntityMapVariableIterator___ref__, METH_VARARGS, (char*) "" },
  { "clone", (PyCFunction) _wrap_EntityMapVariableIterator_clone, METH_VARARGS, (char*) "" },
  { "postIncrement", (PyCFunction) _wrap_EntityMapVariableIterator_postIncrement, METH_VARARGS, (char*) "" },
  { "postIncrementBy", (PyCFunction) _wrap_EntityMapVariableIterator_postIncrementBy, METH_VARARGS, (char*) "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__EntityMapT_ampl__Variable_t__iterator_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.EntityMapVariableIterator",   /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) _wrap_delete_EntityMapVariableIterator_closure, /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Variable_t__iterator_type.as_number,      /* tp_as_number */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Variable_t__iterator_type.as_sequence,    /* tp_as_sequence */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Variable_t__iterator_type.as_mapping,     /* tp_as_mapping */
    (hashfunc) 0,                             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Variable_t__iterator_type.as_buffer,      /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::EntityMap< ampl::Variable >::iterator", /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ampl__EntityMapT_ampl__Variable_t__iterator_richcompare, /* feature:python:tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__EntityMapT_ampl__Variable_t__iterator_methods, /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__EntityMapT_ampl__Variable_t__iterator_getset, /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t)offsetof(SwigPyObject, dict), /* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject*) 0,                            /* tp_bases */
    (PyObject*) 0,                            /* tp_mro */
    (PyObject*) 0,                            /* tp_cache */
    (PyObject*) 0,                            /* tp_subclasses */
    (PyObject*) 0,                            /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    (struct _typeobject*) 0,                  /* tp_prev */
#endif
    (struct _typeobject*) 0,                  /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) (binaryfunc) _wrap_EntityMapVariableIterator___ref___closure, /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject*) 0,                            /* ht_name */
    (PyObject*) 0,                            /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject*) 0,                            /* ht_qualname */
    (struct _dictkeysobject*) 0,              /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__EntityMapT_ampl__Variable_t__iterator_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__EntityMapT_ampl__Variable_t__iterator_type};

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_EntityMapConstraint)
static SwigPyGetSet EntityMapConstraint___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__EntityMapT_ampl__Constraint_t_getset[] = {
    { (char*) "__dict__", (getter) SwigPyBuiltin_GetterClosure, (setter) 0, (char*)"ampl::EntityMap<(ampl::Constraint)>.__dict__", (void*) &EntityMapConstraint___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__EntityMapT_ampl__Constraint_t_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  PyObject *tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, other);
  Py_XINCREF(other);
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__EntityMapT_ampl__Constraint_t_methods[] = {
  { "begin", (PyCFunction) _wrap_EntityMapConstraint_begin, METH_VARARGS, (char*) "" },
  { "end", (PyCFunction) _wrap_EntityMapConstraint_end, METH_VARARGS, (char*) "" },
  { "find", (PyCFunction) _wrap_EntityMapConstraint_find, METH_VARARGS, (char*) "" },
  { "size", (PyCFunction) _wrap_EntityMapConstraint_size, METH_VARARGS, (char*) "" },
  { "getIndex", (PyCFunction) _wrap_EntityMapConstraint_getIndex, METH_VARARGS, (char*) "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__EntityMapT_ampl__Constraint_t_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.EntityMapConstraint",         /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) _wrap_delete_EntityMapConstraint_closure, /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Constraint_t_type.as_number,      /* tp_as_number */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Constraint_t_type.as_sequence,    /* tp_as_sequence */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Constraint_t_type.as_mapping,     /* tp_as_mapping */
    (hashfunc) 0,                             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Constraint_t_type.as_buffer,      /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::EntityMap< ampl::Constraint >",    /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ampl__EntityMapT_ampl__Constraint_t_richcompare, /* feature:python:tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__EntityMapT_ampl__Constraint_t_methods, /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__EntityMapT_ampl__Constraint_t_getset, /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t)offsetof(SwigPyObject, dict), /* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject*) 0,                            /* tp_bases */
    (PyObject*) 0,                            /* tp_mro */
    (PyObject*) 0,                            /* tp_cache */
    (PyObject*) 0,                            /* tp_subclasses */
    (PyObject*) 0,                            /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    (struct _typeobject*) 0,                  /* tp_prev */
#endif
    (struct _typeobject*) 0,                  /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject*) 0,                            /* ht_name */
    (PyObject*) 0,                            /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject*) 0,                            /* ht_qualname */
    (struct _dictkeysobject*) 0,              /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__EntityMapT_ampl__Constraint_t_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__EntityMapT_ampl__Constraint_t_type};

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_EntityMapConstraintIterator)
static SwigPyGetSet EntityMapConstraintIterator___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__EntityMapT_ampl__Constraint_t__iterator_getset[] = {
    { (char*) "__dict__", (getter) SwigPyBuiltin_GetterClosure, (setter) 0, (char*)"ampl::EntityMap<(ampl::Constraint)>::iterator.__dict__", (void*) &EntityMapConstraintIterator___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__EntityMapT_ampl__Constraint_t__iterator_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  PyObject *tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, other);
  Py_XINCREF(other);
  switch (op) {
    case Py_EQ : result = _wrap_EntityMapConstraintIterator_equals(self, tuple); break;
    case Py_NE : result = _wrap_EntityMapConstraintIterator_differs(self, tuple); break;
    default : break;
  }
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__EntityMapT_ampl__Constraint_t__iterator_methods[] = {
  { "equals", (PyCFunction) _wrap_EntityMapConstraintIterator_equals, METH_VARARGS, (char*) "" },
  { "differs", (PyCFunction) _wrap_EntityMapConstraintIterator_differs, METH_VARARGS, (char*) "" },
  { "__ref__", (PyCFunction) _wrap_EntityMapConstraintIterator___ref__, METH_VARARGS, (char*) "" },
  { "clone", (PyCFunction) _wrap_EntityMapConstraintIterator_clone, METH_VARARGS, (char*) "" },
  { "postIncrement", (PyCFunction) _wrap_EntityMapConstraintIterator_postIncrement, METH_VARARGS, (char*) "" },
  { "postIncrementBy", (PyCFunction) _wrap_EntityMapConstraintIterator_postIncrementBy, METH_VARARGS, (char*) "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__EntityMapT_ampl__Constraint_t__iterator_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.EntityMapConstraintIterator", /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) _wrap_delete_EntityMapConstraintIterator_closure, /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Constraint_t__iterator_type.as_number,      /* tp_as_number */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Constraint_t__iterator_type.as_sequence,    /* tp_as_sequence */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Constraint_t__iterator_type.as_mapping,     /* tp_as_mapping */
    (hashfunc) 0,                             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Constraint_t__iterator_type.as_buffer,      /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::EntityMap< ampl::Constraint >::iterator", /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ampl__EntityMapT_ampl__Constraint_t__iterator_richcompare, /* feature:python:tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__EntityMapT_ampl__Constraint_t__iterator_methods, /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__EntityMapT_ampl__Constraint_t__iterator_getset, /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t)offsetof(SwigPyObject, dict), /* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject*) 0,                            /* tp_bases */
    (PyObject*) 0,                            /* tp_mro */
    (PyObject*) 0,                            /* tp_cache */
    (PyObject*) 0,                            /* tp_subclasses */
    (PyObject*) 0,                            /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    (struct _typeobject*) 0,                  /* tp_prev */
#endif
    (struct _typeobject*) 0,                  /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) (binaryfunc) _wrap_EntityMapConstraintIterator___ref___closure, /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject*) 0,                            /* ht_name */
    (PyObject*) 0,                            /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject*) 0,                            /* ht_qualname */
    (struct _dictkeysobject*) 0,              /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__EntityMapT_ampl__Constraint_t__iterator_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__EntityMapT_ampl__Constraint_t__iterator_type};

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_EntityMapObjective)
static SwigPyGetSet EntityMapObjective___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__EntityMapT_ampl__Objective_t_getset[] = {
    { (char*) "__dict__", (getter) SwigPyBuiltin_GetterClosure, (setter) 0, (char*)"ampl::EntityMap<(ampl::Objective)>.__dict__", (void*) &EntityMapObjective___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__EntityMapT_ampl__Objective_t_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  PyObject *tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, other);
  Py_XINCREF(other);
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__EntityMapT_ampl__Objective_t_methods[] = {
  { "begin", (PyCFunction) _wrap_EntityMapObjective_begin, METH_VARARGS, (char*) "" },
  { "end", (PyCFunction) _wrap_EntityMapObjective_end, METH_VARARGS, (char*) "" },
  { "find", (PyCFunction) _wrap_EntityMapObjective_find, METH_VARARGS, (char*) "" },
  { "size", (PyCFunction) _wrap_EntityMapObjective_size, METH_VARARGS, (char*) "" },
  { "getIndex", (PyCFunction) _wrap_EntityMapObjective_getIndex, METH_VARARGS, (char*) "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__EntityMapT_ampl__Objective_t_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.EntityMapObjective",          /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) _wrap_delete_EntityMapObjective_closure, /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Objective_t_type.as_number,      /* tp_as_number */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Objective_t_type.as_sequence,    /* tp_as_sequence */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Objective_t_type.as_mapping,     /* tp_as_mapping */
    (hashfunc) 0,                             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Objective_t_type.as_buffer,      /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::EntityMap< ampl::Objective >",     /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ampl__EntityMapT_ampl__Objective_t_richcompare, /* feature:python:tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__EntityMapT_ampl__Objective_t_methods, /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__EntityMapT_ampl__Objective_t_getset, /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t)offsetof(SwigPyObject, dict), /* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject*) 0,                            /* tp_bases */
    (PyObject*) 0,                            /* tp_mro */
    (PyObject*) 0,                            /* tp_cache */
    (PyObject*) 0,                            /* tp_subclasses */
    (PyObject*) 0,                            /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    (struct _typeobject*) 0,                  /* tp_prev */
#endif
    (struct _typeobject*) 0,                  /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject*) 0,                            /* ht_name */
    (PyObject*) 0,                            /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject*) 0,                            /* ht_qualname */
    (struct _dictkeysobject*) 0,              /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__EntityMapT_ampl__Objective_t_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__EntityMapT_ampl__Objective_t_type};

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_EntityMapObjectiveIterator)
static SwigPyGetSet EntityMapObjectiveIterator___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__EntityMapT_ampl__Objective_t__iterator_getset[] = {
    { (char*) "__dict__", (getter) SwigPyBuiltin_GetterClosure, (setter) 0, (char*)"ampl::EntityMap<(ampl::Objective)>::iterator.__dict__", (void*) &EntityMapObjectiveIterator___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__EntityMapT_ampl__Objective_t__iterator_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  PyObject *tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, other);
  Py_XINCREF(other);
  switch (op) {
    case Py_EQ : result = _wrap_EntityMapObjectiveIterator_equals(self, tuple); break;
    case Py_NE : result = _wrap_EntityMapObjectiveIterator_differs(self, tuple); break;
    default : break;
  }
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__EntityMapT_ampl__Objective_t__iterator_methods[] = {
  { "equals", (PyCFunction) _wrap_EntityMapObjectiveIterator_equals, METH_VARARGS, (char*) "" },
  { "differs", (PyCFunction) _wrap_EntityMapObjectiveIterator_differs, METH_VARARGS, (char*) "" },
  { "__ref__", (PyCFunction) _wrap_EntityMapObjectiveIterator___ref__, METH_VARARGS, (char*) "" },
  { "clone", (PyCFunction) _wrap_EntityMapObjectiveIterator_clone, METH_VARARGS, (char*) "" },
  { "postIncrement", (PyCFunction) _wrap_EntityMapObjectiveIterator_postIncrement, METH_VARARGS, (char*) "" },
  { "postIncrementBy", (PyCFunction) _wrap_EntityMapObjectiveIterator_postIncrementBy, METH_VARARGS, (char*) "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__EntityMapT_ampl__Objective_t__iterator_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.EntityMapObjectiveIterator",  /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) _wrap_delete_EntityMapObjectiveIterator_closure, /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Objective_t__iterator_type.as_number,      /* tp_as_number */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Objective_t__iterator_type.as_sequence,    /* tp_as_sequence */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Objective_t__iterator_type.as_mapping,     /* tp_as_mapping */
    (hashfunc) 0,                             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Objective_t__iterator_type.as_buffer,      /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::EntityMap< ampl::Objective >::iterator", /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ampl__EntityMapT_ampl__Objective_t__iterator_richcompare, /* feature:python:tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__EntityMapT_ampl__Objective_t__iterator_methods, /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__EntityMapT_ampl__Objective_t__iterator_getset, /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t)offsetof(SwigPyObject, dict), /* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject*) 0,                            /* tp_bases */
    (PyObject*) 0,                            /* tp_mro */
    (PyObject*) 0,                            /* tp_cache */
    (PyObject*) 0,                            /* tp_subclasses */
    (PyObject*) 0,                            /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    (struct _typeobject*) 0,                  /* tp_prev */
#endif
    (struct _typeobject*) 0,                  /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) (binaryfunc) _wrap_EntityMapObjectiveIterator___ref___closure, /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject*) 0,                            /* ht_name */
    (PyObject*) 0,                            /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject*) 0,                            /* ht_qualname */
    (struct _dictkeysobject*) 0,              /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__EntityMapT_ampl__Objective_t__iterator_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__EntityMapT_ampl__Objective_t__iterator_type};

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_EntityMapSet)
static SwigPyGetSet EntityMapSet___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__EntityMapT_ampl__Set_t_getset[] = {
    { (char*) "__dict__", (getter) SwigPyBuiltin_GetterClosure, (setter) 0, (char*)"ampl::EntityMap<(ampl::Set)>.__dict__", (void*) &EntityMapSet___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__EntityMapT_ampl__Set_t_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  PyObject *tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, other);
  Py_XINCREF(other);
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__EntityMapT_ampl__Set_t_methods[] = {
  { "begin", (PyCFunction) _wrap_EntityMapSet_begin, METH_VARARGS, (char*) "" },
  { "end", (PyCFunction) _wrap_EntityMapSet_end, METH_VARARGS, (char*) "" },
  { "find", (PyCFunction) _wrap_EntityMapSet_find, METH_VARARGS, (char*) "" },
  { "size", (PyCFunction) _wrap_EntityMapSet_size, METH_VARARGS, (char*) "" },
  { "getIndex", (PyCFunction) _wrap_EntityMapSet_getIndex, METH_VARARGS, (char*) "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__EntityMapT_ampl__Set_t_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.EntityMapSet",                /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) _wrap_delete_EntityMapSet_closure, /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Set_t_type.as_number,      /* tp_as_number */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Set_t_type.as_sequence,    /* tp_as_sequence */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Set_t_type.as_mapping,     /* tp_as_mapping */
    (hashfunc) 0,                             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Set_t_type.as_buffer,      /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::EntityMap< ampl::Set >",           /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ampl__EntityMapT_ampl__Set_t_richcompare, /* feature:python:tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__EntityMapT_ampl__Set_t_methods, /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__EntityMapT_ampl__Set_t_getset, /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t)offsetof(SwigPyObject, dict), /* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject*) 0,                            /* tp_bases */
    (PyObject*) 0,                            /* tp_mro */
    (PyObject*) 0,                            /* tp_cache */
    (PyObject*) 0,                            /* tp_subclasses */
    (PyObject*) 0,                            /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    (struct _typeobject*) 0,                  /* tp_prev */
#endif
    (struct _typeobject*) 0,                  /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject*) 0,                            /* ht_name */
    (PyObject*) 0,                            /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject*) 0,                            /* ht_qualname */
    (struct _dictkeysobject*) 0,              /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__EntityMapT_ampl__Set_t_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__EntityMapT_ampl__Set_t_type};

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_EntityMapSetIterator)
static SwigPyGetSet EntityMapSetIterator___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__EntityMapT_ampl__Set_t__iterator_getset[] = {
    { (char*) "__dict__", (getter) SwigPyBuiltin_GetterClosure, (setter) 0, (char*)"ampl::EntityMap<(ampl::Set)>::iterator.__dict__", (void*) &EntityMapSetIterator___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__EntityMapT_ampl__Set_t__iterator_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  PyObject *tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, other);
  Py_XINCREF(other);
  switch (op) {
    case Py_EQ : result = _wrap_EntityMapSetIterator_equals(self, tuple); break;
    case Py_NE : result = _wrap_EntityMapSetIterator_differs(self, tuple); break;
    default : break;
  }
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__EntityMapT_ampl__Set_t__iterator_methods[] = {
  { "equals", (PyCFunction) _wrap_EntityMapSetIterator_equals, METH_VARARGS, (char*) "" },
  { "differs", (PyCFunction) _wrap_EntityMapSetIterator_differs, METH_VARARGS, (char*) "" },
  { "__ref__", (PyCFunction) _wrap_EntityMapSetIterator___ref__, METH_VARARGS, (char*) "" },
  { "clone", (PyCFunction) _wrap_EntityMapSetIterator_clone, METH_VARARGS, (char*) "" },
  { "postIncrement", (PyCFunction) _wrap_EntityMapSetIterator_postIncrement, METH_VARARGS, (char*) "" },
  { "postIncrementBy", (PyCFunction) _wrap_EntityMapSetIterator_postIncrementBy, METH_VARARGS, (char*) "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__EntityMapT_ampl__Set_t__iterator_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.EntityMapSetIterator",        /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) _wrap_delete_EntityMapSetIterator_closure, /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Set_t__iterator_type.as_number,      /* tp_as_number */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Set_t__iterator_type.as_sequence,    /* tp_as_sequence */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Set_t__iterator_type.as_mapping,     /* tp_as_mapping */
    (hashfunc) 0,                             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Set_t__iterator_type.as_buffer,      /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::EntityMap< ampl::Set >::iterator", /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ampl__EntityMapT_ampl__Set_t__iterator_richcompare, /* feature:python:tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__EntityMapT_ampl__Set_t__iterator_methods, /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__EntityMapT_ampl__Set_t__iterator_getset, /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t)offsetof(SwigPyObject, dict), /* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject*) 0,                            /* tp_bases */
    (PyObject*) 0,                            /* tp_mro */
    (PyObject*) 0,                            /* tp_cache */
    (PyObject*) 0,                            /* tp_subclasses */
    (PyObject*) 0,                            /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    (struct _typeobject*) 0,                  /* tp_prev */
#endif
    (struct _typeobject*) 0,                  /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) (binaryfunc) _wrap_EntityMapSetIterator___ref___closure, /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject*) 0,                            /* ht_name */
    (PyObject*) 0,                            /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject*) 0,                            /* ht_qualname */
    (struct _dictkeysobject*) 0,              /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__EntityMapT_ampl__Set_t__iterator_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__EntityMapT_ampl__Set_t__iterator_type};

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_EntityMapParameter)
static SwigPyGetSet EntityMapParameter___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__EntityMapT_ampl__Parameter_t_getset[] = {
    { (char*) "__dict__", (getter) SwigPyBuiltin_GetterClosure, (setter) 0, (char*)"ampl::EntityMap<(ampl::Parameter)>.__dict__", (void*) &EntityMapParameter___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__EntityMapT_ampl__Parameter_t_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  PyObject *tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, other);
  Py_XINCREF(other);
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__EntityMapT_ampl__Parameter_t_methods[] = {
  { "begin", (PyCFunction) _wrap_EntityMapParameter_begin, METH_VARARGS, (char*) "" },
  { "end", (PyCFunction) _wrap_EntityMapParameter_end, METH_VARARGS, (char*) "" },
  { "find", (PyCFunction) _wrap_EntityMapParameter_find, METH_VARARGS, (char*) "" },
  { "size", (PyCFunction) _wrap_EntityMapParameter_size, METH_VARARGS, (char*) "" },
  { "getIndex", (PyCFunction) _wrap_EntityMapParameter_getIndex, METH_VARARGS, (char*) "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__EntityMapT_ampl__Parameter_t_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.EntityMapParameter",          /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) _wrap_delete_EntityMapParameter_closure, /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Parameter_t_type.as_number,      /* tp_as_number */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Parameter_t_type.as_sequence,    /* tp_as_sequence */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Parameter_t_type.as_mapping,     /* tp_as_mapping */
    (hashfunc) 0,                             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Parameter_t_type.as_buffer,      /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::EntityMap< ampl::Parameter >",     /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ampl__EntityMapT_ampl__Parameter_t_richcompare, /* feature:python:tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__EntityMapT_ampl__Parameter_t_methods, /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__EntityMapT_ampl__Parameter_t_getset, /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t)offsetof(SwigPyObject, dict), /* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject*) 0,                            /* tp_bases */
    (PyObject*) 0,                            /* tp_mro */
    (PyObject*) 0,                            /* tp_cache */
    (PyObject*) 0,                            /* tp_subclasses */
    (PyObject*) 0,                            /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    (struct _typeobject*) 0,                  /* tp_prev */
#endif
    (struct _typeobject*) 0,                  /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject*) 0,                            /* ht_name */
    (PyObject*) 0,                            /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject*) 0,                            /* ht_qualname */
    (struct _dictkeysobject*) 0,              /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__EntityMapT_ampl__Parameter_t_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__EntityMapT_ampl__Parameter_t_type};

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_EntityMapParameterIterator)
static SwigPyGetSet EntityMapParameterIterator___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__EntityMapT_ampl__Parameter_t__iterator_getset[] = {
    { (char*) "__dict__", (getter) SwigPyBuiltin_GetterClosure, (setter) 0, (char*)"ampl::EntityMap<(ampl::Parameter)>::iterator.__dict__", (void*) &EntityMapParameterIterator___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__EntityMapT_ampl__Parameter_t__iterator_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  PyObject *tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, other);
  Py_XINCREF(other);
  switch (op) {
    case Py_EQ : result = _wrap_EntityMapParameterIterator_equals(self, tuple); break;
    case Py_NE : result = _wrap_EntityMapParameterIterator_differs(self, tuple); break;
    default : break;
  }
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__EntityMapT_ampl__Parameter_t__iterator_methods[] = {
  { "equals", (PyCFunction) _wrap_EntityMapParameterIterator_equals, METH_VARARGS, (char*) "" },
  { "differs", (PyCFunction) _wrap_EntityMapParameterIterator_differs, METH_VARARGS, (char*) "" },
  { "__ref__", (PyCFunction) _wrap_EntityMapParameterIterator___ref__, METH_VARARGS, (char*) "" },
  { "clone", (PyCFunction) _wrap_EntityMapParameterIterator_clone, METH_VARARGS, (char*) "" },
  { "postIncrement", (PyCFunction) _wrap_EntityMapParameterIterator_postIncrement, METH_VARARGS, (char*) "" },
  { "postIncrementBy", (PyCFunction) _wrap_EntityMapParameterIterator_postIncrementBy, METH_VARARGS, (char*) "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__EntityMapT_ampl__Parameter_t__iterator_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.EntityMapParameterIterator",  /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) _wrap_delete_EntityMapParameterIterator_closure, /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Parameter_t__iterator_type.as_number,      /* tp_as_number */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Parameter_t__iterator_type.as_sequence,    /* tp_as_sequence */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Parameter_t__iterator_type.as_mapping,     /* tp_as_mapping */
    (hashfunc) 0,                             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__EntityMapT_ampl__Parameter_t__iterator_type.as_buffer,      /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::EntityMap< ampl::Parameter >::iterator", /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ampl__EntityMapT_ampl__Parameter_t__iterator_richcompare, /* feature:python:tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__EntityMapT_ampl__Parameter_t__iterator_methods, /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__EntityMapT_ampl__Parameter_t__iterator_getset, /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t)offsetof(SwigPyObject, dict), /* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject*) 0,                            /* tp_bases */
    (PyObject*) 0,                            /* tp_mro */
    (PyObject*) 0,                            /* tp_cache */
    (PyObject*) 0,                            /* tp_subclasses */
    (PyObject*) 0,                            /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    (struct _typeobject*) 0,                  /* tp_prev */
#endif
    (struct _typeobject*) 0,                  /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) (binaryfunc) _wrap_EntityMapParameterIterator___ref___closure, /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject*) 0,                            /* ht_name */
    (PyObject*) 0,                            /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject*) 0,                            /* ht_qualname */
    (struct _dictkeysobject*) 0,              /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__EntityMapT_ampl__Parameter_t__iterator_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__EntityMapT_ampl__Parameter_t__iterator_type};

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_AMPLException)
static SwigPyGetSet AMPLException___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__AMPLException_getset[] = {
    { (char*) "__dict__", (getter) SwigPyBuiltin_GetterClosure, (setter) 0, (char*)"ampl::AMPLException.__dict__", (void*) &AMPLException___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__AMPLException_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  PyObject *tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, other);
  Py_XINCREF(other);
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__AMPLException_methods[] = {
  { "getSourceName", (PyCFunction) _wrap_AMPLException_getSourceName, METH_VARARGS, (char*) "" },
  { "getLineNumber", (PyCFunction) _wrap_AMPLException_getLineNumber, METH_VARARGS, (char*) "" },
  { "getOffset", (PyCFunction) _wrap_AMPLException_getOffset, METH_VARARGS, (char*) "" },
  { "getMessage", (PyCFunction) _wrap_AMPLException_getMessage, METH_VARARGS, (char*) "" },
  { "setSourceName", (PyCFunction) _wrap_AMPLException_setSourceName, METH_VARARGS, (char*) "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__AMPLException_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.AMPLException",               /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) _wrap_delete_AMPLException_closure, /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__AMPLException_type.as_number,      /* tp_as_number */
    &SwigPyBuiltin__ampl__AMPLException_type.as_sequence,    /* tp_as_sequence */
    &SwigPyBuiltin__ampl__AMPLException_type.as_mapping,     /* tp_as_mapping */
    (hashfunc) 0,                             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__AMPLException_type.as_buffer,      /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::AMPLException",                    /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ampl__AMPLException_richcompare, /* feature:python:tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__AMPLException_methods, /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__AMPLException_getset, /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t)offsetof(SwigPyObject, dict), /* tp_dictoffset */
    (initproc) _wrap_new_AMPLException,       /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject*) 0,                            /* tp_bases */
    (PyObject*) 0,                            /* tp_mro */
    (PyObject*) 0,                            /* tp_cache */
    (PyObject*) 0,                            /* tp_subclasses */
    (PyObject*) 0,                            /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    (struct _typeobject*) 0,                  /* tp_prev */
#endif
    (struct _typeobject*) 0,                  /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject*) 0,                            /* ht_name */
    (PyObject*) 0,                            /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject*) 0,                            /* ht_qualname */
    (struct _dictkeysobject*) 0,              /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__AMPLException_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__AMPLException_type};

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_LicenseException)
static SwigPyGetSet LicenseException___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__LicenseException_getset[] = {
    { (char*) "__dict__", (getter) SwigPyBuiltin_GetterClosure, (setter) 0, (char*)"ampl::LicenseException.__dict__", (void*) &LicenseException___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__LicenseException_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  PyObject *tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, other);
  Py_XINCREF(other);
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__LicenseException_methods[] = {
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__LicenseException_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.LicenseException",            /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) _wrap_delete_LicenseException_closure, /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__LicenseException_type.as_number,      /* tp_as_number */
    &SwigPyBuiltin__ampl__LicenseException_type.as_sequence,    /* tp_as_sequence */
    &SwigPyBuiltin__ampl__LicenseException_type.as_mapping,     /* tp_as_mapping */
    (hashfunc) 0,                             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__LicenseException_type.as_buffer,      /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::LicenseException",                 /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ampl__LicenseException_richcompare, /* feature:python:tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__LicenseException_methods, /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__LicenseException_getset, /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t)offsetof(SwigPyObject, dict), /* tp_dictoffset */
    (initproc) _wrap_new_LicenseException,    /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject*) 0,                            /* tp_bases */
    (PyObject*) 0,                            /* tp_mro */
    (PyObject*) 0,                            /* tp_cache */
    (PyObject*) 0,                            /* tp_subclasses */
    (PyObject*) 0,                            /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    (struct _typeobject*) 0,                  /* tp_prev */
#endif
    (struct _typeobject*) 0,                  /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject*) 0,                            /* ht_name */
    (PyObject*) 0,                            /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject*) 0,                            /* ht_qualname */
    (struct _dictkeysobject*) 0,              /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__LicenseException_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__LicenseException_type};

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_FileIOException)
static SwigPyGetSet FileIOException___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__FileIOException_getset[] = {
    { (char*) "__dict__", (getter) SwigPyBuiltin_GetterClosure, (setter) 0, (char*)"ampl::FileIOException.__dict__", (void*) &FileIOException___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__FileIOException_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  PyObject *tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, other);
  Py_XINCREF(other);
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__FileIOException_methods[] = {
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__FileIOException_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.FileIOException",             /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) _wrap_delete_FileIOException_closure, /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__FileIOException_type.as_number,      /* tp_as_number */
    &SwigPyBuiltin__ampl__FileIOException_type.as_sequence,    /* tp_as_sequence */
    &SwigPyBuiltin__ampl__FileIOException_type.as_mapping,     /* tp_as_mapping */
    (hashfunc) 0,                             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__FileIOException_type.as_buffer,      /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::FileIOException",                  /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ampl__FileIOException_richcompare, /* feature:python:tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__FileIOException_methods, /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__FileIOException_getset, /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t)offsetof(SwigPyObject, dict), /* tp_dictoffset */
    (initproc) _wrap_new_FileIOException,     /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject*) 0,                            /* tp_bases */
    (PyObject*) 0,                            /* tp_mro */
    (PyObject*) 0,                            /* tp_cache */
    (PyObject*) 0,                            /* tp_subclasses */
    (PyObject*) 0,                            /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    (struct _typeobject*) 0,                  /* tp_prev */
#endif
    (struct _typeobject*) 0,                  /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject*) 0,                            /* ht_name */
    (PyObject*) 0,                            /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject*) 0,                            /* ht_qualname */
    (struct _dictkeysobject*) 0,              /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__FileIOException_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__FileIOException_type};

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_UnsupportedOperationException)
static SwigPyGetSet UnsupportedOperationException___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__UnsupportedOperationException_getset[] = {
    { (char*) "__dict__", (getter) SwigPyBuiltin_GetterClosure, (setter) 0, (char*)"ampl::UnsupportedOperationException.__dict__", (void*) &UnsupportedOperationException___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__UnsupportedOperationException_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  PyObject *tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, other);
  Py_XINCREF(other);
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__UnsupportedOperationException_methods[] = {
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__UnsupportedOperationException_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.UnsupportedOperationException", /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) _wrap_delete_UnsupportedOperationException_closure, /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__UnsupportedOperationException_type.as_number,      /* tp_as_number */
    &SwigPyBuiltin__ampl__UnsupportedOperationException_type.as_sequence,    /* tp_as_sequence */
    &SwigPyBuiltin__ampl__UnsupportedOperationException_type.as_mapping,     /* tp_as_mapping */
    (hashfunc) 0,                             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__UnsupportedOperationException_type.as_buffer,      /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::UnsupportedOperationException",    /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ampl__UnsupportedOperationException_richcompare, /* feature:python:tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__UnsupportedOperationException_methods, /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__UnsupportedOperationException_getset, /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t)offsetof(SwigPyObject, dict), /* tp_dictoffset */
    (initproc) _wrap_new_UnsupportedOperationException, /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject*) 0,                            /* tp_bases */
    (PyObject*) 0,                            /* tp_mro */
    (PyObject*) 0,                            /* tp_cache */
    (PyObject*) 0,                            /* tp_subclasses */
    (PyObject*) 0,                            /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    (struct _typeobject*) 0,                  /* tp_prev */
#endif
    (struct _typeobject*) 0,                  /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject*) 0,                            /* ht_name */
    (PyObject*) 0,                            /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject*) 0,                            /* ht_qualname */
    (struct _dictkeysobject*) 0,              /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__UnsupportedOperationException_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__UnsupportedOperationException_type};

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_InvalidSubscriptException)
static SwigPyGetSet InvalidSubscriptException___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__InvalidSubscriptException_getset[] = {
    { (char*) "__dict__", (getter) SwigPyBuiltin_GetterClosure, (setter) 0, (char*)"ampl::InvalidSubscriptException.__dict__", (void*) &InvalidSubscriptException___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__InvalidSubscriptException_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  PyObject *tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, other);
  Py_XINCREF(other);
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__InvalidSubscriptException_methods[] = {
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__InvalidSubscriptException_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.InvalidSubscriptException",   /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) _wrap_delete_InvalidSubscriptException_closure, /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__InvalidSubscriptException_type.as_number,      /* tp_as_number */
    &SwigPyBuiltin__ampl__InvalidSubscriptException_type.as_sequence,    /* tp_as_sequence */
    &SwigPyBuiltin__ampl__InvalidSubscriptException_type.as_mapping,     /* tp_as_mapping */
    (hashfunc) 0,                             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__InvalidSubscriptException_type.as_buffer,      /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::InvalidSubscriptException",        /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ampl__InvalidSubscriptException_richcompare, /* feature:python:tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__InvalidSubscriptException_methods, /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__InvalidSubscriptException_getset, /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t)offsetof(SwigPyObject, dict), /* tp_dictoffset */
    (initproc) _wrap_new_InvalidSubscriptException, /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject*) 0,                            /* tp_bases */
    (PyObject*) 0,                            /* tp_mro */
    (PyObject*) 0,                            /* tp_cache */
    (PyObject*) 0,                            /* tp_subclasses */
    (PyObject*) 0,                            /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    (struct _typeobject*) 0,                  /* tp_prev */
#endif
    (struct _typeobject*) 0,                  /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject*) 0,                            /* ht_name */
    (PyObject*) 0,                            /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject*) 0,                            /* ht_qualname */
    (struct _dictkeysobject*) 0,              /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__InvalidSubscriptException_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__InvalidSubscriptException_type};

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_SyntaxErrorException)
static SwigPyGetSet SyntaxErrorException___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__SyntaxErrorException_getset[] = {
    { (char*) "__dict__", (getter) SwigPyBuiltin_GetterClosure, (setter) 0, (char*)"ampl::SyntaxErrorException.__dict__", (void*) &SyntaxErrorException___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__SyntaxErrorException_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  PyObject *tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, other);
  Py_XINCREF(other);
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__SyntaxErrorException_methods[] = {
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__SyntaxErrorException_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.SyntaxErrorException",        /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) _wrap_delete_SyntaxErrorException_closure, /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__SyntaxErrorException_type.as_number,      /* tp_as_number */
    &SwigPyBuiltin__ampl__SyntaxErrorException_type.as_sequence,    /* tp_as_sequence */
    &SwigPyBuiltin__ampl__SyntaxErrorException_type.as_mapping,     /* tp_as_mapping */
    (hashfunc) 0,                             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__SyntaxErrorException_type.as_buffer,      /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::SyntaxErrorException",             /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ampl__SyntaxErrorException_richcompare, /* feature:python:tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__SyntaxErrorException_methods, /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__SyntaxErrorException_getset, /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t)offsetof(SwigPyObject, dict), /* tp_dictoffset */
    (initproc) _wrap_new_SyntaxErrorException, /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject*) 0,                            /* tp_bases */
    (PyObject*) 0,                            /* tp_mro */
    (PyObject*) 0,                            /* tp_cache */
    (PyObject*) 0,                            /* tp_subclasses */
    (PyObject*) 0,                            /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    (struct _typeobject*) 0,                  /* tp_prev */
#endif
    (struct _typeobject*) 0,                  /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject*) 0,                            /* ht_name */
    (PyObject*) 0,                            /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject*) 0,                            /* ht_qualname */
    (struct _dictkeysobject*) 0,              /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__SyntaxErrorException_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__SyntaxErrorException_type};

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_NoDataException)
static SwigPyGetSet NoDataException___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__NoDataException_getset[] = {
    { (char*) "__dict__", (getter) SwigPyBuiltin_GetterClosure, (setter) 0, (char*)"ampl::NoDataException.__dict__", (void*) &NoDataException___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__NoDataException_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  PyObject *tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, other);
  Py_XINCREF(other);
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__NoDataException_methods[] = {
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__NoDataException_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.NoDataException",             /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) _wrap_delete_NoDataException_closure, /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__NoDataException_type.as_number,      /* tp_as_number */
    &SwigPyBuiltin__ampl__NoDataException_type.as_sequence,    /* tp_as_sequence */
    &SwigPyBuiltin__ampl__NoDataException_type.as_mapping,     /* tp_as_mapping */
    (hashfunc) 0,                             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__NoDataException_type.as_buffer,      /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::NoDataException",                  /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ampl__NoDataException_richcompare, /* feature:python:tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__NoDataException_methods, /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__NoDataException_getset, /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t)offsetof(SwigPyObject, dict), /* tp_dictoffset */
    (initproc) _wrap_new_NoDataException,     /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject*) 0,                            /* tp_bases */
    (PyObject*) 0,                            /* tp_mro */
    (PyObject*) 0,                            /* tp_cache */
    (PyObject*) 0,                            /* tp_subclasses */
    (PyObject*) 0,                            /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    (struct _typeobject*) 0,                  /* tp_prev */
#endif
    (struct _typeobject*) 0,                  /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject*) 0,                            /* ht_name */
    (PyObject*) 0,                            /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject*) 0,                            /* ht_qualname */
    (struct _dictkeysobject*) 0,              /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__NoDataException_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__NoDataException_type};

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_ErrorHandler)
static SwigPyGetSet ErrorHandler___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__ErrorHandler_getset[] = {
    { (char*) "__dict__", (getter) SwigPyBuiltin_GetterClosure, (setter) 0, (char*)"ampl::ErrorHandler.__dict__", (void*) &ErrorHandler___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__ErrorHandler_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  PyObject *tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, other);
  Py_XINCREF(other);
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__ErrorHandler_methods[] = {
  { "error", (PyCFunction) _wrap_ErrorHandler_error, METH_VARARGS, (char*) "" },
  { "warning", (PyCFunction) _wrap_ErrorHandler_warning, METH_VARARGS, (char*) "" },
  { "__disown__", (PyCFunction) Swig::Director::swig_pyobj_disown< ampl::ErrorHandler >, METH_NOARGS, "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__ErrorHandler_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.ErrorHandler",                /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) _wrap_delete_ErrorHandler_closure, /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__ErrorHandler_type.as_number,      /* tp_as_number */
    &SwigPyBuiltin__ampl__ErrorHandler_type.as_sequence,    /* tp_as_sequence */
    &SwigPyBuiltin__ampl__ErrorHandler_type.as_mapping,     /* tp_as_mapping */
    (hashfunc) 0,                             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__ErrorHandler_type.as_buffer,      /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::ErrorHandler",                     /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ampl__ErrorHandler_richcompare, /* feature:python:tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__ErrorHandler_methods, /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__ErrorHandler_getset, /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t)offsetof(SwigPyObject, dict), /* tp_dictoffset */
    (initproc) _wrap_new_ErrorHandler,        /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject*) 0,                            /* tp_bases */
    (PyObject*) 0,                            /* tp_mro */
    (PyObject*) 0,                            /* tp_cache */
    (PyObject*) 0,                            /* tp_subclasses */
    (PyObject*) 0,                            /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    (struct _typeobject*) 0,                  /* tp_prev */
#endif
    (struct _typeobject*) 0,                  /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject*) 0,                            /* ht_name */
    (PyObject*) 0,                            /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject*) 0,                            /* ht_qualname */
    (struct _dictkeysobject*) 0,              /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__ErrorHandler_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__ErrorHandler_type};

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_Runnable)
static SwigPyGetSet Runnable___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__Runnable_getset[] = {
    { (char*) "__dict__", (getter) SwigPyBuiltin_GetterClosure, (setter) 0, (char*)"ampl::Runnable.__dict__", (void*) &Runnable___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__Runnable_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  PyObject *tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, other);
  Py_XINCREF(other);
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__Runnable_methods[] = {
  { "run", (PyCFunction) _wrap_Runnable_run, METH_VARARGS, (char*) "" },
  { "__disown__", (PyCFunction) Swig::Director::swig_pyobj_disown< ampl::Runnable >, METH_NOARGS, "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__Runnable_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.Runnable",                    /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) _wrap_delete_Runnable_closure, /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__Runnable_type.as_number,      /* tp_as_number */
    &SwigPyBuiltin__ampl__Runnable_type.as_sequence,    /* tp_as_sequence */
    &SwigPyBuiltin__ampl__Runnable_type.as_mapping,     /* tp_as_mapping */
    (hashfunc) 0,                             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__Runnable_type.as_buffer,      /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::Runnable",                         /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ampl__Runnable_richcompare, /* feature:python:tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__Runnable_methods,    /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__Runnable_getset,     /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t)offsetof(SwigPyObject, dict), /* tp_dictoffset */
    (initproc) _wrap_new_Runnable,            /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject*) 0,                            /* tp_bases */
    (PyObject*) 0,                            /* tp_mro */
    (PyObject*) 0,                            /* tp_cache */
    (PyObject*) 0,                            /* tp_subclasses */
    (PyObject*) 0,                            /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    (struct _typeobject*) 0,                  /* tp_prev */
#endif
    (struct _typeobject*) 0,                  /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject*) 0,                            /* ht_name */
    (PyObject*) 0,                            /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject*) 0,                            /* ht_qualname */
    (struct _dictkeysobject*) 0,              /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__Runnable_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__Runnable_type};

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_OutputHandler)
static SwigPyGetSet OutputHandler___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__OutputHandler_getset[] = {
    { (char*) "__dict__", (getter) SwigPyBuiltin_GetterClosure, (setter) 0, (char*)"ampl::OutputHandler.__dict__", (void*) &OutputHandler___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__OutputHandler_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  PyObject *tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, other);
  Py_XINCREF(other);
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__OutputHandler_methods[] = {
  { "output", (PyCFunction) _wrap_OutputHandler_output, METH_VARARGS, (char*) "" },
  { "__disown__", (PyCFunction) Swig::Director::swig_pyobj_disown< ampl::OutputHandler >, METH_NOARGS, "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__OutputHandler_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.OutputHandler",               /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) _wrap_delete_OutputHandler_closure, /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__OutputHandler_type.as_number,      /* tp_as_number */
    &SwigPyBuiltin__ampl__OutputHandler_type.as_sequence,    /* tp_as_sequence */
    &SwigPyBuiltin__ampl__OutputHandler_type.as_mapping,     /* tp_as_mapping */
    (hashfunc) 0,                             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__OutputHandler_type.as_buffer,      /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::OutputHandler",                    /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ampl__OutputHandler_richcompare, /* feature:python:tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__OutputHandler_methods, /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__OutputHandler_getset, /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t)offsetof(SwigPyObject, dict), /* tp_dictoffset */
    (initproc) _wrap_new_OutputHandler,       /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject*) 0,                            /* tp_bases */
    (PyObject*) 0,                            /* tp_mro */
    (PyObject*) 0,                            /* tp_cache */
    (PyObject*) 0,                            /* tp_subclasses */
    (PyObject*) 0,                            /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    (struct _typeobject*) 0,                  /* tp_prev */
#endif
    (struct _typeobject*) 0,                  /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject*) 0,                            /* ht_name */
    (PyObject*) 0,                            /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject*) 0,                            /* ht_qualname */
    (struct _dictkeysobject*) 0,              /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__OutputHandler_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__OutputHandler_type};

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_EnvironmentIterator)
static SwigPyGetSet EnvironmentIterator___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__internal__EnvironmentIterator_getset[] = {
    { (char*) "__dict__", (getter) SwigPyBuiltin_GetterClosure, (setter) 0, (char*)"ampl::internal::EnvironmentIterator.__dict__", (void*) &EnvironmentIterator___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__internal__EnvironmentIterator_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  PyObject *tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, other);
  Py_XINCREF(other);
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__internal__EnvironmentIterator_methods[] = {
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__internal__EnvironmentIterator_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.EnvironmentIterator",         /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) _wrap_delete_EnvironmentIterator_closure, /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__internal__EnvironmentIterator_type.as_number,      /* tp_as_number */
    &SwigPyBuiltin__ampl__internal__EnvironmentIterator_type.as_sequence,    /* tp_as_sequence */
    &SwigPyBuiltin__ampl__internal__EnvironmentIterator_type.as_mapping,     /* tp_as_mapping */
    (hashfunc) 0,                             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__internal__EnvironmentIterator_type.as_buffer,      /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::internal::EnvironmentIterator",    /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ampl__internal__EnvironmentIterator_richcompare, /* feature:python:tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__internal__EnvironmentIterator_methods, /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__internal__EnvironmentIterator_getset, /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t)offsetof(SwigPyObject, dict), /* tp_dictoffset */
    (initproc) _wrap_new_EnvironmentIterator, /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject*) 0,                            /* tp_bases */
    (PyObject*) 0,                            /* tp_mro */
    (PyObject*) 0,                            /* tp_cache */
    (PyObject*) 0,                            /* tp_subclasses */
    (PyObject*) 0,                            /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    (struct _typeobject*) 0,                  /* tp_prev */
#endif
    (struct _typeobject*) 0,                  /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject*) 0,                            /* ht_name */
    (PyObject*) 0,                            /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject*) 0,                            /* ht_qualname */
    (struct _dictkeysobject*) 0,              /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__internal__EnvironmentIterator_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__internal__EnvironmentIterator_type};

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_Environment)
static SwigPyGetSet Environment___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__Environment_getset[] = {
    { (char*) "__dict__", (getter) SwigPyBuiltin_GetterClosure, (setter) 0, (char*)"ampl::Environment.__dict__", (void*) &Environment___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__Environment_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  PyObject *tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, other);
  Py_XINCREF(other);
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__Environment_methods[] = {
  { "Clone", (PyCFunction) _wrap_Environment_Clone, METH_VARARGS, (char*) "" },
  { "put", (PyCFunction) _wrap_Environment_put, METH_VARARGS, (char*) "" },
  { "setBinDir", (PyCFunction) _wrap_Environment_setBinDir, METH_VARARGS, (char*) "" },
  { "getBinDir", (PyCFunction) _wrap_Environment_getBinDir, METH_VARARGS, (char*) "" },
  { "toString", (PyCFunction) _wrap_Environment_toString, METH_VARARGS, (char*) "" },
  { "begin", (PyCFunction) _wrap_Environment_begin, METH_VARARGS, (char*) "" },
  { "end", (PyCFunction) _wrap_Environment_end, METH_VARARGS, (char*) "" },
  { "find", (PyCFunction) _wrap_Environment_find, METH_VARARGS, (char*) "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__Environment_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.Environment",                 /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) _wrap_delete_Environment_closure, /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__Environment_type.as_number,      /* tp_as_number */
    &SwigPyBuiltin__ampl__Environment_type.as_sequence,    /* tp_as_sequence */
    &SwigPyBuiltin__ampl__Environment_type.as_mapping,     /* tp_as_mapping */
    (hashfunc) 0,                             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__Environment_type.as_buffer,      /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::Environment",                      /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ampl__Environment_richcompare, /* feature:python:tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__Environment_methods, /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__Environment_getset,  /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t)offsetof(SwigPyObject, dict), /* tp_dictoffset */
    (initproc) _wrap_new_Environment,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject*) 0,                            /* tp_bases */
    (PyObject*) 0,                            /* tp_mro */
    (PyObject*) 0,                            /* tp_cache */
    (PyObject*) 0,                            /* tp_subclasses */
    (PyObject*) 0,                            /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    (struct _typeobject*) 0,                  /* tp_prev */
#endif
    (struct _typeobject*) 0,                  /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject*) 0,                            /* ht_name */
    (PyObject*) 0,                            /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject*) 0,                            /* ht_qualname */
    (struct _dictkeysobject*) 0,              /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__Environment_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__Environment_type};

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_EnvironmentIteratorTemplate)
static SwigPyGetSet EnvironmentIteratorTemplate___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t_getset[] = {
    { (char*) "__dict__", (getter) SwigPyBuiltin_GetterClosure, (setter) 0, (char*)"ampl::internal::CountedIterator<(ampl::internal::EnvironmentIterator)>.__dict__", (void*) &EnvironmentIteratorTemplate___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  PyObject *tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, other);
  Py_XINCREF(other);
  switch (op) {
    case Py_EQ : result = _wrap_EnvironmentIteratorTemplate_equals(self, tuple); break;
    case Py_NE : result = _wrap_EnvironmentIteratorTemplate_differs(self, tuple); break;
    default : break;
  }
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t_methods[] = {
  { "equals", (PyCFunction) _wrap_EnvironmentIteratorTemplate_equals, METH_VARARGS, (char*) "" },
  { "differs", (PyCFunction) _wrap_EnvironmentIteratorTemplate_differs, METH_VARARGS, (char*) "" },
  { "Clone", (PyCFunction) _wrap_EnvironmentIteratorTemplate_Clone, METH_VARARGS, (char*) "" },
  { "postIncrement", (PyCFunction) _wrap_EnvironmentIteratorTemplate_postIncrement, METH_VARARGS, (char*) "" },
  { "postIncrementBy", (PyCFunction) _wrap_EnvironmentIteratorTemplate_postIncrementBy, METH_VARARGS, (char*) "" },
  { "first", (PyCFunction) _wrap_EnvironmentIteratorTemplate_first, METH_VARARGS, (char*) "" },
  { "second", (PyCFunction) _wrap_EnvironmentIteratorTemplate_second, METH_VARARGS, (char*) "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.EnvironmentIteratorTemplate", /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) _wrap_delete_EnvironmentIteratorTemplate_closure, /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t_type.as_number,      /* tp_as_number */
    &SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t_type.as_sequence,    /* tp_as_sequence */
    &SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t_type.as_mapping,     /* tp_as_mapping */
    (hashfunc) 0,                             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t_type.as_buffer,      /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator >", /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t_richcompare, /* feature:python:tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t_methods, /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t_getset, /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t)offsetof(SwigPyObject, dict), /* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject*) 0,                            /* tp_bases */
    (PyObject*) 0,                            /* tp_mro */
    (PyObject*) 0,                            /* tp_cache */
    (PyObject*) 0,                            /* tp_subclasses */
    (PyObject*) 0,                            /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    (struct _typeobject*) 0,                  /* tp_prev */
#endif
    (struct _typeobject*) 0,                  /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject*) 0,                            /* ht_name */
    (PyObject*) 0,                            /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject*) 0,                            /* ht_qualname */
    (struct _dictkeysobject*) 0,              /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t_type};

SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_AMPL)
static SwigPyGetSet AMPL___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ampl__AMPL_getset[] = {
    { (char*) "__dict__", (getter) SwigPyBuiltin_GetterClosure, (setter) 0, (char*)"ampl::AMPL.__dict__", (void*) &AMPL___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ampl__AMPL_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  PyObject *tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, other);
  Py_XINCREF(other);
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ampl__AMPL_methods[] = {
  { "getEntity", (PyCFunction) _wrap_AMPL_getEntity, METH_VARARGS, (char*) "" },
  { "getVariable", (PyCFunction) _wrap_AMPL_getVariable, METH_VARARGS, (char*) "" },
  { "getConstraint", (PyCFunction) _wrap_AMPL_getConstraint, METH_VARARGS, (char*) "" },
  { "getObjective", (PyCFunction) _wrap_AMPL_getObjective, METH_VARARGS, (char*) "" },
  { "getSet", (PyCFunction) _wrap_AMPL_getSet, METH_VARARGS, (char*) "" },
  { "getParameter", (PyCFunction) _wrap_AMPL_getParameter, METH_VARARGS, (char*) "" },
  { "eval", (PyCFunction) _wrap_AMPL_eval, METH_VARARGS, (char*) "" },
  { "reset", (PyCFunction) _wrap_AMPL_reset, METH_VARARGS, (char*) "" },
  { "close", (PyCFunction) _wrap_AMPL_close, METH_VARARGS, (char*) "" },
  { "isRunning", (PyCFunction) _wrap_AMPL_isRunning, METH_VARARGS, (char*) "" },
  { "isBusy", (PyCFunction) _wrap_AMPL_isBusy, METH_VARARGS, (char*) "" },
  { "solve", (PyCFunction) _wrap_AMPL_solve, METH_VARARGS, (char*) "" },
  { "readAsync", (PyCFunction) _wrap_AMPL_readAsync, METH_VARARGS, (char*) "" },
  { "readDataAsync", (PyCFunction) _wrap_AMPL_readDataAsync, METH_VARARGS, (char*) "" },
  { "evalAsync", (PyCFunction) _wrap_AMPL_evalAsync, METH_VARARGS, (char*) "" },
  { "solveAsync", (PyCFunction) _wrap_AMPL_solveAsync, METH_VARARGS, (char*) "" },
  { "interrupt", (PyCFunction) _wrap_AMPL_interrupt, METH_VARARGS, (char*) "" },
  { "cd", (PyCFunction) _wrap_AMPL_cd, METH_VARARGS, (char*) "" },
  { "setOption", (PyCFunction) _wrap_AMPL_setOption, METH_VARARGS, (char*) "" },
  { "getOption", (PyCFunction) _wrap_AMPL_getOption, METH_VARARGS, (char*) "" },
  { "getIntOption", (PyCFunction) _wrap_AMPL_getIntOption, METH_VARARGS, (char*) "" },
  { "setIntOption", (PyCFunction) _wrap_AMPL_setIntOption, METH_VARARGS, (char*) "" },
  { "getDblOption", (PyCFunction) _wrap_AMPL_getDblOption, METH_VARARGS, (char*) "" },
  { "setDblOption", (PyCFunction) _wrap_AMPL_setDblOption, METH_VARARGS, (char*) "" },
  { "getBoolOption", (PyCFunction) _wrap_AMPL_getBoolOption, METH_VARARGS, (char*) "" },
  { "setBoolOption", (PyCFunction) _wrap_AMPL_setBoolOption, METH_VARARGS, (char*) "" },
  { "read", (PyCFunction) _wrap_AMPL_read, METH_VARARGS, (char*) "" },
  { "readData", (PyCFunction) _wrap_AMPL_readData, METH_VARARGS, (char*) "" },
  { "getValue", (PyCFunction) _wrap_AMPL_getValue, METH_VARARGS, (char*) "" },
  { "setData", (PyCFunction) _wrap_AMPL_setData, METH_VARARGS, (char*) "" },
  { "toString", (PyCFunction) _wrap_AMPL_toString, METH_VARARGS, (char*) "" },
  { "readTable", (PyCFunction) _wrap_AMPL_readTable, METH_VARARGS, (char*) "" },
  { "writeTable", (PyCFunction) _wrap_AMPL_writeTable, METH_VARARGS, (char*) "" },
  { "display", (PyCFunction) _wrap_AMPL_display, METH_VARARGS, (char*) "" },
  { "show", (PyCFunction) _wrap_AMPL_show, METH_VARARGS, (char*) "" },
  { "expand", (PyCFunction) _wrap_AMPL_expand, METH_VARARGS, (char*) "" },
  { "setOutputHandler", (PyCFunction) _wrap_AMPL_setOutputHandler, METH_VARARGS, (char*) "" },
  { "setErrorHandler", (PyCFunction) _wrap_AMPL_setErrorHandler, METH_VARARGS, (char*) "" },
  { "getOutputHandler", (PyCFunction) _wrap_AMPL_getOutputHandler, METH_VARARGS, (char*) "" },
  { "getErrorHandler", (PyCFunction) _wrap_AMPL_getErrorHandler, METH_VARARGS, (char*) "" },
  { "getVariables", (PyCFunction) _wrap_AMPL_getVariables, METH_VARARGS, (char*) "" },
  { "getConstraints", (PyCFunction) _wrap_AMPL_getConstraints, METH_VARARGS, (char*) "" },
  { "getObjectives", (PyCFunction) _wrap_AMPL_getObjectives, METH_VARARGS, (char*) "" },
  { "getSets", (PyCFunction) _wrap_AMPL_getSets, METH_VARARGS, (char*) "" },
  { "getParameters", (PyCFunction) _wrap_AMPL_getParameters, METH_VARARGS, (char*) "" },
  { "displayLst", (PyCFunction) _wrap_AMPL_displayLst, METH_VARARGS, (char*) "" },
  { "getData", (PyCFunction) _wrap_AMPL_getData, METH_VARARGS, (char*) "" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ampl__AMPL_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "amplpython.AMPL",                        /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) _wrap_delete_AMPL_closure,   /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ampl__AMPL_type.as_number,      /* tp_as_number */
    &SwigPyBuiltin__ampl__AMPL_type.as_sequence,    /* tp_as_sequence */
    &SwigPyBuiltin__ampl__AMPL_type.as_mapping,     /* tp_as_mapping */
    (hashfunc) 0,                             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ampl__AMPL_type.as_buffer,      /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "ampl::AMPL",                             /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ampl__AMPL_richcompare, /* feature:python:tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ampl__AMPL_methods,        /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ampl__AMPL_getset,         /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t)offsetof(SwigPyObject, dict), /* tp_dictoffset */
    (initproc) _wrap_new_AMPL,                /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject*) 0,                            /* tp_bases */
    (PyObject*) 0,                            /* tp_mro */
    (PyObject*) 0,                            /* tp_cache */
    (PyObject*) 0,                            /* tp_subclasses */
    (PyObject*) 0,                            /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    (struct _typeobject*) 0,                  /* tp_prev */
#endif
    (struct _typeobject*) 0,                  /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void*) 0,                                /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject*) 0,                            /* ht_name */
    (PyObject*) 0,                            /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject*) 0,                            /* ht_qualname */
    (struct _dictkeysobject*) 0,              /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ampl__AMPL_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ampl__AMPL_type};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

static void *_p_VariantArrayTo_p_ampl__Variant(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ampl::Variant *)  ((VariantArray *) x));
}
static void *_p_ampl__SetTo_p_ampl__BasicEntityT_ampl__SetInstance_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ampl::BasicEntity< ampl::SetInstance > *)  ((ampl::Set *) x));
}
static void *_p_ampl__ObjectiveTo_p_ampl__BasicEntityT_ampl__ObjectiveInstance_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ampl::BasicEntity< ampl::ObjectiveInstance > *)  ((ampl::Objective *) x));
}
static void *_p_ampl__VariableTo_p_ampl__BasicEntityT_ampl__VariableInstance_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ampl::BasicEntity< ampl::VariableInstance > *)  ((ampl::Variable *) x));
}
static void *_p_ampl__ConstraintTo_p_ampl__BasicEntityT_ampl__ConstraintInstance_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ampl::BasicEntity< ampl::ConstraintInstance > *)  ((ampl::Constraint *) x));
}
static void *_p_ampl__SetTo_p_ampl__Entity(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ampl::Entity *) (ampl::BasicEntity< ampl::SetInstance > *) ((ampl::Set *) x));
}
static void *_p_EntityArrayTo_p_ampl__Entity(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ampl::Entity *)  ((EntityArray *) x));
}
static void *_p_ampl__ConstraintTo_p_ampl__Entity(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ampl::Entity *) (ampl::BasicEntity< ampl::ConstraintInstance > *) ((ampl::Constraint *) x));
}
static void *_p_ampl__VariableTo_p_ampl__Entity(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ampl::Entity *) (ampl::BasicEntity< ampl::VariableInstance > *) ((ampl::Variable *) x));
}
static void *_p_ampl__ParameterTo_p_ampl__Entity(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ampl::Entity *) (ampl::BasicEntity< ampl::VariantRef > *) ((ampl::Parameter *) x));
}
static void *_p_ampl__BasicEntityT_ampl__VariableInstance_tTo_p_ampl__Entity(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ampl::Entity *)  ((ampl::BasicEntity< ampl::VariableInstance > *) x));
}
static void *_p_ampl__BasicEntityT_ampl__ConstraintInstance_tTo_p_ampl__Entity(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ampl::Entity *)  ((ampl::BasicEntity< ampl::ConstraintInstance > *) x));
}
static void *_p_ampl__BasicEntityT_ampl__SetInstance_tTo_p_ampl__Entity(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ampl::Entity *)  ((ampl::BasicEntity< ampl::SetInstance > *) x));
}
static void *_p_ampl__BasicEntityT_ampl__ObjectiveInstance_tTo_p_ampl__Entity(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ampl::Entity *)  ((ampl::BasicEntity< ampl::ObjectiveInstance > *) x));
}
static void *_p_ampl__BasicEntityT_ampl__VariantRef_tTo_p_ampl__Entity(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ampl::Entity *)  ((ampl::BasicEntity< ampl::VariantRef > *) x));
}
static void *_p_ampl__ObjectiveTo_p_ampl__Entity(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ampl::Entity *) (ampl::BasicEntity< ampl::ObjectiveInstance > *) ((ampl::Objective *) x));
}
static void *_p_ampl__InvalidSubscriptExceptionTo_p_ampl__AMPLException(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ampl::AMPLException *)  ((ampl::InvalidSubscriptException *) x));
}
static void *_p_ampl__SyntaxErrorExceptionTo_p_ampl__AMPLException(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ampl::AMPLException *)  ((ampl::SyntaxErrorException *) x));
}
static void *_p_ampl__NoDataExceptionTo_p_ampl__AMPLException(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ampl::AMPLException *)  ((ampl::NoDataException *) x));
}
static void *_p_ampl__AMPLExceptionTo_p_std__runtime_error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::runtime_error *)  ((ampl::AMPLException *) x));
}
static void *_p_ampl__LicenseExceptionTo_p_std__runtime_error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::runtime_error *)  ((ampl::LicenseException *) x));
}
static void *_p_ampl__FileIOExceptionTo_p_std__runtime_error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::runtime_error *)  ((ampl::FileIOException *) x));
}
static void *_p_ampl__UnsupportedOperationExceptionTo_p_std__runtime_error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::runtime_error *)  ((ampl::UnsupportedOperationException *) x));
}
static void *_p_ampl__InvalidSubscriptExceptionTo_p_std__runtime_error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::runtime_error *) (ampl::AMPLException *) ((ampl::InvalidSubscriptException *) x));
}
static void *_p_ampl__SyntaxErrorExceptionTo_p_std__runtime_error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::runtime_error *) (ampl::AMPLException *) ((ampl::SyntaxErrorException *) x));
}
static void *_p_ampl__NoDataExceptionTo_p_std__runtime_error(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::runtime_error *) (ampl::AMPLException *) ((ampl::NoDataException *) x));
}
static void *_p_ampl__SetInstanceTo_p_ampl__Instance(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ampl::Instance *)  ((ampl::SetInstance *) x));
}
static void *_p_ampl__ObjectiveInstanceTo_p_ampl__Instance(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ampl::Instance *)  ((ampl::ObjectiveInstance *) x));
}
static void *_p_ampl__VariableInstanceTo_p_ampl__Instance(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ampl::Instance *)  ((ampl::VariableInstance *) x));
}
static void *_p_ampl__ConstraintInstanceTo_p_ampl__Instance(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ampl::Instance *)  ((ampl::ConstraintInstance *) x));
}
static void *_p_TupleArrayTo_p_ampl__Tuple(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ampl::Tuple *)  ((TupleArray *) x));
}
static void *_p_ampl__ParameterTo_p_ampl__BasicEntityT_ampl__VariantRef_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ampl::BasicEntity< ampl::VariantRef > *)  ((ampl::Parameter *) x));
}
static swig_type_info _swigt__p_Column = {"_p_Column", "Column *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_EntityArray = {"_p_EntityArray", "EntityArray *", 0, 0, (void*)&SwigPyBuiltin__EntityArray_clientdata, 0};
static swig_type_info _swigt__p_InstanceType = {"_p_InstanceType", "InstanceType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_KeyType = {"_p_KeyType", "KeyType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Row = {"_p_Row", "Row *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SwigPyObject = {"_p_SwigPyObject", "SwigPyObject *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_TupleArray = {"_p_TupleArray", "TupleArray *", 0, 0, (void*)&SwigPyBuiltin__TupleArray_clientdata, 0};
static swig_type_info _swigt__p_ValueType = {"_p_ValueType", "ValueType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_VariantArray = {"_p_VariantArray", "VariantArray *", 0, 0, (void*)&SwigPyBuiltin__VariantArray_clientdata, 0};
static swig_type_info _swigt__p_ampl__AMPL = {"_p_ampl__AMPL", "ampl::AMPL *", 0, 0, (void*)&SwigPyBuiltin__ampl__AMPL_clientdata, 0};
static swig_type_info _swigt__p_ampl__AMPLException = {"_p_ampl__AMPLException", "ampl::AMPLException *", 0, 0, (void*)&SwigPyBuiltin__ampl__AMPLException_clientdata, 0};
static swig_type_info _swigt__p_ampl__BasicEntityT_ampl__ConstraintInstance_t = {"_p_ampl__BasicEntityT_ampl__ConstraintInstance_t", "ampl::BasicEntity< ampl::ConstraintInstance > *", 0, 0, (void*)&SwigPyBuiltin__ampl__BasicEntityT_ampl__ConstraintInstance_t_clientdata, 0};
static swig_type_info _swigt__p_ampl__BasicEntityT_ampl__ObjectiveInstance_t = {"_p_ampl__BasicEntityT_ampl__ObjectiveInstance_t", "ampl::BasicEntity< ampl::ObjectiveInstance > *", 0, 0, (void*)&SwigPyBuiltin__ampl__BasicEntityT_ampl__ObjectiveInstance_t_clientdata, 0};
static swig_type_info _swigt__p_ampl__BasicEntityT_ampl__SetInstance_t = {"_p_ampl__BasicEntityT_ampl__SetInstance_t", "ampl::BasicEntity< ampl::SetInstance > *", 0, 0, (void*)&SwigPyBuiltin__ampl__BasicEntityT_ampl__SetInstance_t_clientdata, 0};
static swig_type_info _swigt__p_ampl__BasicEntityT_ampl__VariableInstance_t = {"_p_ampl__BasicEntityT_ampl__VariableInstance_t", "ampl::BasicEntity< ampl::VariableInstance > *", 0, 0, (void*)&SwigPyBuiltin__ampl__BasicEntityT_ampl__VariableInstance_t_clientdata, 0};
static swig_type_info _swigt__p_ampl__BasicEntityT_ampl__VariantRef_t = {"_p_ampl__BasicEntityT_ampl__VariantRef_t", "ampl::BasicEntity< ampl::VariantRef > *", 0, 0, (void*)&SwigPyBuiltin__ampl__BasicEntityT_ampl__VariantRef_t_clientdata, 0};
static swig_type_info _swigt__p_ampl__Constraint = {"_p_ampl__Constraint", "ampl::Constraint *", 0, 0, (void*)&SwigPyBuiltin__ampl__Constraint_clientdata, 0};
static swig_type_info _swigt__p_ampl__ConstraintInstance = {"_p_ampl__ConstraintInstance", "ampl::internal::EntityWrapper< ampl::ConstraintInstance >::InstanceType *|ampl::ConstraintInstance *", 0, 0, (void*)&SwigPyBuiltin__ampl__ConstraintInstance_clientdata, 0};
static swig_type_info _swigt__p_ampl__DataFrame = {"_p_ampl__DataFrame", "ampl::DataFrame *|ampl::internal::DataFrame *", 0, 0, (void*)&SwigPyBuiltin__ampl__DataFrame_clientdata, 0};
static swig_type_info _swigt__p_ampl__Entity = {"_p_ampl__Entity", "ampl::Entity *", 0, 0, (void*)&SwigPyBuiltin__ampl__Entity_clientdata, 0};
static swig_type_info _swigt__p_ampl__EntityArgs = {"_p_ampl__EntityArgs", "ampl::EntityArgs *", 0, 0, (void*)&SwigPyBuiltin__ampl__EntityArgs_clientdata, 0};
static swig_type_info _swigt__p_ampl__EntityMapT_ampl__Constraint_t = {"_p_ampl__EntityMapT_ampl__Constraint_t", "ampl::EntityMap< ampl::Constraint > *", 0, 0, (void*)&SwigPyBuiltin__ampl__EntityMapT_ampl__Constraint_t_clientdata, 0};
static swig_type_info _swigt__p_ampl__EntityMapT_ampl__Constraint_t__iterator = {"_p_ampl__EntityMapT_ampl__Constraint_t__iterator", "ampl::EntityMap< ampl::Constraint >::iterator *", 0, 0, (void*)&SwigPyBuiltin__ampl__EntityMapT_ampl__Constraint_t__iterator_clientdata, 0};
static swig_type_info _swigt__p_ampl__EntityMapT_ampl__Objective_t = {"_p_ampl__EntityMapT_ampl__Objective_t", "ampl::EntityMap< ampl::Objective > *", 0, 0, (void*)&SwigPyBuiltin__ampl__EntityMapT_ampl__Objective_t_clientdata, 0};
static swig_type_info _swigt__p_ampl__EntityMapT_ampl__Objective_t__iterator = {"_p_ampl__EntityMapT_ampl__Objective_t__iterator", "ampl::EntityMap< ampl::Objective >::iterator *", 0, 0, (void*)&SwigPyBuiltin__ampl__EntityMapT_ampl__Objective_t__iterator_clientdata, 0};
static swig_type_info _swigt__p_ampl__EntityMapT_ampl__Parameter_t = {"_p_ampl__EntityMapT_ampl__Parameter_t", "ampl::EntityMap< ampl::Parameter > *", 0, 0, (void*)&SwigPyBuiltin__ampl__EntityMapT_ampl__Parameter_t_clientdata, 0};
static swig_type_info _swigt__p_ampl__EntityMapT_ampl__Parameter_t__iterator = {"_p_ampl__EntityMapT_ampl__Parameter_t__iterator", "ampl::EntityMap< ampl::Parameter >::iterator *", 0, 0, (void*)&SwigPyBuiltin__ampl__EntityMapT_ampl__Parameter_t__iterator_clientdata, 0};
static swig_type_info _swigt__p_ampl__EntityMapT_ampl__Set_t = {"_p_ampl__EntityMapT_ampl__Set_t", "ampl::EntityMap< ampl::Set > *", 0, 0, (void*)&SwigPyBuiltin__ampl__EntityMapT_ampl__Set_t_clientdata, 0};
static swig_type_info _swigt__p_ampl__EntityMapT_ampl__Set_t__iterator = {"_p_ampl__EntityMapT_ampl__Set_t__iterator", "ampl::EntityMap< ampl::Set >::iterator *", 0, 0, (void*)&SwigPyBuiltin__ampl__EntityMapT_ampl__Set_t__iterator_clientdata, 0};
static swig_type_info _swigt__p_ampl__EntityMapT_ampl__Variable_t = {"_p_ampl__EntityMapT_ampl__Variable_t", "ampl::EntityMap< ampl::Variable > *", 0, 0, (void*)&SwigPyBuiltin__ampl__EntityMapT_ampl__Variable_t_clientdata, 0};
static swig_type_info _swigt__p_ampl__EntityMapT_ampl__Variable_t__iterator = {"_p_ampl__EntityMapT_ampl__Variable_t__iterator", "ampl::EntityMap< ampl::Variable >::iterator *", 0, 0, (void*)&SwigPyBuiltin__ampl__EntityMapT_ampl__Variable_t__iterator_clientdata, 0};
static swig_type_info _swigt__p_ampl__Environment = {"_p_ampl__Environment", "ampl::Environment *", 0, 0, (void*)&SwigPyBuiltin__ampl__Environment_clientdata, 0};
static swig_type_info _swigt__p_ampl__ErrorHandler = {"_p_ampl__ErrorHandler", "ampl::ErrorHandler *", 0, 0, (void*)&SwigPyBuiltin__ampl__ErrorHandler_clientdata, 0};
static swig_type_info _swigt__p_ampl__FileIOException = {"_p_ampl__FileIOException", "ampl::FileIOException *", 0, 0, (void*)&SwigPyBuiltin__ampl__FileIOException_clientdata, 0};
static swig_type_info _swigt__p_ampl__Instance = {"_p_ampl__Instance", "ampl::Instance *", 0, 0, (void*)&SwigPyBuiltin__ampl__Instance_clientdata, 0};
static swig_type_info _swigt__p_ampl__InvalidSubscriptException = {"_p_ampl__InvalidSubscriptException", "ampl::InvalidSubscriptException *", 0, 0, (void*)&SwigPyBuiltin__ampl__InvalidSubscriptException_clientdata, 0};
static swig_type_info _swigt__p_ampl__LicenseException = {"_p_ampl__LicenseException", "ampl::LicenseException *", 0, 0, (void*)&SwigPyBuiltin__ampl__LicenseException_clientdata, 0};
static swig_type_info _swigt__p_ampl__NoDataException = {"_p_ampl__NoDataException", "ampl::NoDataException *", 0, 0, (void*)&SwigPyBuiltin__ampl__NoDataException_clientdata, 0};
static swig_type_info _swigt__p_ampl__Objective = {"_p_ampl__Objective", "ampl::Objective *", 0, 0, (void*)&SwigPyBuiltin__ampl__Objective_clientdata, 0};
static swig_type_info _swigt__p_ampl__ObjectiveInstance = {"_p_ampl__ObjectiveInstance", "ampl::internal::EntityWrapper< ampl::ObjectiveInstance >::InstanceType *|ampl::ObjectiveInstance *", 0, 0, (void*)&SwigPyBuiltin__ampl__ObjectiveInstance_clientdata, 0};
static swig_type_info _swigt__p_ampl__OptionalT_bool_t = {"_p_ampl__OptionalT_bool_t", "ampl::Optional< bool > *", 0, 0, (void*)&SwigPyBuiltin__ampl__OptionalT_bool_t_clientdata, 0};
static swig_type_info _swigt__p_ampl__OptionalT_double_t = {"_p_ampl__OptionalT_double_t", "ampl::Optional< double > *", 0, 0, (void*)&SwigPyBuiltin__ampl__OptionalT_double_t_clientdata, 0};
static swig_type_info _swigt__p_ampl__OptionalT_int_t = {"_p_ampl__OptionalT_int_t", "ampl::Optional< int > *", 0, 0, (void*)&SwigPyBuiltin__ampl__OptionalT_int_t_clientdata, 0};
static swig_type_info _swigt__p_ampl__OptionalT_std__string_t = {"_p_ampl__OptionalT_std__string_t", "ampl::Optional< std::string > *", 0, 0, (void*)&SwigPyBuiltin__ampl__OptionalT_std__string_t_clientdata, 0};
static swig_type_info _swigt__p_ampl__OutputHandler = {"_p_ampl__OutputHandler", "ampl::OutputHandler *", 0, 0, (void*)&SwigPyBuiltin__ampl__OutputHandler_clientdata, 0};
static swig_type_info _swigt__p_ampl__Parameter = {"_p_ampl__Parameter", "ampl::Parameter *", 0, 0, (void*)&SwigPyBuiltin__ampl__Parameter_clientdata, 0};
static swig_type_info _swigt__p_ampl__Runnable = {"_p_ampl__Runnable", "ampl::Runnable *", 0, 0, (void*)&SwigPyBuiltin__ampl__Runnable_clientdata, 0};
static swig_type_info _swigt__p_ampl__Set = {"_p_ampl__Set", "ampl::Set *", 0, 0, (void*)&SwigPyBuiltin__ampl__Set_clientdata, 0};
static swig_type_info _swigt__p_ampl__SetInstance = {"_p_ampl__SetInstance", "ampl::internal::EntityWrapper< ampl::SetInstance >::InstanceType *|ampl::SetInstance *|ampl::internal::SetInstance *", 0, 0, (void*)&SwigPyBuiltin__ampl__SetInstance_clientdata, 0};
static swig_type_info _swigt__p_ampl__SetInstance__MemberRange = {"_p_ampl__SetInstance__MemberRange", "ampl::SetInstance::MemberRange *", 0, 0, (void*)&SwigPyBuiltin__ampl__SetInstance__MemberRange_clientdata, 0};
static swig_type_info _swigt__p_ampl__SetInstance__MemberRange__iterator = {"_p_ampl__SetInstance__MemberRange__iterator", "ampl::SetInstance::MemberRange::iterator *", 0, 0, (void*)&SwigPyBuiltin__ampl__SetInstance__MemberRange__iterator_clientdata, 0};
static swig_type_info _swigt__p_ampl__StringArray = {"_p_ampl__StringArray", "ampl::StringArray *", 0, 0, (void*)&SwigPyBuiltin__ampl__StringArray_clientdata, 0};
static swig_type_info _swigt__p_ampl__StringRefArray = {"_p_ampl__StringRefArray", "ampl::StringRefArray *", 0, 0, (void*)&SwigPyBuiltin__ampl__StringRefArray_clientdata, 0};
static swig_type_info _swigt__p_ampl__SyntaxErrorException = {"_p_ampl__SyntaxErrorException", "ampl::SyntaxErrorException *", 0, 0, (void*)&SwigPyBuiltin__ampl__SyntaxErrorException_clientdata, 0};
static swig_type_info _swigt__p_ampl__Tuple = {"_p_ampl__Tuple", "ampl::Tuple *", 0, 0, (void*)&SwigPyBuiltin__ampl__Tuple_clientdata, 0};
static swig_type_info _swigt__p_ampl__TupleRef = {"_p_ampl__TupleRef", "ampl::internal::EntityWrapper< ampl::VariableInstance >::KeyType *|ampl::internal::EntityWrapper< ampl::ConstraintInstance >::KeyType *|ampl::internal::EntityWrapper< ampl::ObjectiveInstance >::KeyType *|ampl::TupleRef *|ampl::internal::EntityWrapper< ampl::VariantRef >::KeyType *|ampl::internal::EntityWrapper< ampl::SetInstance >::KeyType *", 0, 0, (void*)&SwigPyBuiltin__ampl__TupleRef_clientdata, 0};
static swig_type_info _swigt__p_ampl__UnsupportedOperationException = {"_p_ampl__UnsupportedOperationException", "ampl::UnsupportedOperationException *", 0, 0, (void*)&SwigPyBuiltin__ampl__UnsupportedOperationException_clientdata, 0};
static swig_type_info _swigt__p_ampl__Variable = {"_p_ampl__Variable", "ampl::Variable *", 0, 0, (void*)&SwigPyBuiltin__ampl__Variable_clientdata, 0};
static swig_type_info _swigt__p_ampl__VariableInstance = {"_p_ampl__VariableInstance", "ampl::internal::EntityWrapper< ampl::VariableInstance >::InstanceType *|ampl::VariableInstance *", 0, 0, (void*)&SwigPyBuiltin__ampl__VariableInstance_clientdata, 0};
static swig_type_info _swigt__p_ampl__Variant = {"_p_ampl__Variant", "ampl::Variant *", 0, 0, (void*)&SwigPyBuiltin__ampl__Variant_clientdata, 0};
static swig_type_info _swigt__p_ampl__VariantRef = {"_p_ampl__VariantRef", "ampl::internal::EntityWrapper< ampl::VariantRef >::InstanceType *|ampl::VariantRef *", 0, 0, (void*)&SwigPyBuiltin__ampl__VariantRef_clientdata, 0};
static swig_type_info _swigt__p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t = {"_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t", "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > > *|ampl::BasicEntity< ampl::ConstraintInstance >::iterator *", 0, 0, (void*)&SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t_clientdata, 0};
static swig_type_info _swigt__p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t = {"_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t", "ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > > *|ampl::BasicEntity< ampl::ObjectiveInstance >::iterator *", 0, 0, (void*)&SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t_clientdata, 0};
static swig_type_info _swigt__p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t = {"_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t", "ampl::BasicEntity< ampl::SetInstance >::iterator *|ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > > *", 0, 0, (void*)&SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t_clientdata, 0};
static swig_type_info _swigt__p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t = {"_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t", "ampl::BasicEntity< ampl::VariableInstance >::iterator *|ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > > *", 0, 0, (void*)&SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t_clientdata, 0};
static swig_type_info _swigt__p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t = {"_p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t", "ampl::BasicEntity< ampl::VariantRef >::iterator *|ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > > *", 0, 0, (void*)&SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t_clientdata, 0};
static swig_type_info _swigt__p_ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t = {"_p_ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t", "ampl::Environment::iterator *|ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator > *", 0, 0, (void*)&SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t_clientdata, 0};
static swig_type_info _swigt__p_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t = {"_p_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t", "ampl::internal::EntityWrapper< ampl::ConstraintInstance > *", 0, 0, (void*)&SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_clientdata, 0};
static swig_type_info _swigt__p_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t = {"_p_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t", "ampl::internal::EntityWrapper< ampl::ObjectiveInstance > *", 0, 0, (void*)&SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_clientdata, 0};
static swig_type_info _swigt__p_ampl__internal__EntityWrapperT_ampl__SetInstance_t = {"_p_ampl__internal__EntityWrapperT_ampl__SetInstance_t", "ampl::internal::EntityWrapper< ampl::SetInstance > *", 0, 0, (void*)&SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__SetInstance_t_clientdata, 0};
static swig_type_info _swigt__p_ampl__internal__EntityWrapperT_ampl__VariableInstance_t = {"_p_ampl__internal__EntityWrapperT_ampl__VariableInstance_t", "ampl::internal::EntityWrapper< ampl::VariableInstance > *", 0, 0, (void*)&SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__VariableInstance_t_clientdata, 0};
static swig_type_info _swigt__p_ampl__internal__EntityWrapperT_ampl__VariantRef_t = {"_p_ampl__internal__EntityWrapperT_ampl__VariantRef_t", "ampl::internal::EntityWrapper< ampl::VariantRef > *", 0, 0, (void*)&SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__VariantRef_t_clientdata, 0};
static swig_type_info _swigt__p_ampl__internal__EnvironmentIterator = {"_p_ampl__internal__EnvironmentIterator", "ampl::internal::EnvironmentIterator *", 0, 0, (void*)&SwigPyBuiltin__ampl__internal__EnvironmentIterator_clientdata, 0};
static swig_type_info _swigt__p_ampl__internal__SliceT_false_t = {"_p_ampl__internal__SliceT_false_t", "ampl::DataFrame::Column *|ampl::internal::Slice< false > *", 0, 0, (void*)&SwigPyBuiltin__ampl__internal__SliceT_false_t_clientdata, 0};
static swig_type_info _swigt__p_ampl__internal__SliceT_false_t__iterator = {"_p_ampl__internal__SliceT_false_t__iterator", "ampl::internal::Slice< false >::iterator *", 0, 0, (void*)&SwigPyBuiltin__ampl__internal__SliceT_false_t__iterator_clientdata, 0};
static swig_type_info _swigt__p_ampl__internal__SliceT_true_t = {"_p_ampl__internal__SliceT_true_t", "ampl::internal::Slice< true > *|ampl::DataFrame::Row *", 0, 0, (void*)&SwigPyBuiltin__ampl__internal__SliceT_true_t_clientdata, 0};
static swig_type_info _swigt__p_ampl__internal__SliceT_true_t__iterator = {"_p_ampl__internal__SliceT_true_t__iterator", "ampl::internal::Slice< true >::iterator *", 0, 0, (void*)&SwigPyBuiltin__ampl__internal__SliceT_true_t__iterator_clientdata, 0};
static swig_type_info _swigt__p_char = {"_p_char", "char *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_double = {"_p_double", "double *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_iterator = {"_p_iterator", "iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_char = {"_p_p_char", "char **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__runtime_error = {"_p_std__runtime_error", "std::runtime_error *", 0, 0, (void*)&SwigPyBuiltin__std__runtime_error_clientdata, 0};
static swig_type_info _swigt__p_unsigned_int = {"_p_unsigned_int", "std::size_t *|unsigned int *", 0, 0, (void*)0, 0};

static swig_type_info *swig_type_initial[] = {
  &_swigt__p_Column,
  &_swigt__p_EntityArray,
  &_swigt__p_InstanceType,
  &_swigt__p_KeyType,
  &_swigt__p_Row,
  &_swigt__p_SwigPyObject,
  &_swigt__p_TupleArray,
  &_swigt__p_ValueType,
  &_swigt__p_VariantArray,
  &_swigt__p_ampl__AMPL,
  &_swigt__p_ampl__AMPLException,
  &_swigt__p_ampl__BasicEntityT_ampl__ConstraintInstance_t,
  &_swigt__p_ampl__BasicEntityT_ampl__ObjectiveInstance_t,
  &_swigt__p_ampl__BasicEntityT_ampl__SetInstance_t,
  &_swigt__p_ampl__BasicEntityT_ampl__VariableInstance_t,
  &_swigt__p_ampl__BasicEntityT_ampl__VariantRef_t,
  &_swigt__p_ampl__Constraint,
  &_swigt__p_ampl__ConstraintInstance,
  &_swigt__p_ampl__DataFrame,
  &_swigt__p_ampl__Entity,
  &_swigt__p_ampl__EntityArgs,
  &_swigt__p_ampl__EntityMapT_ampl__Constraint_t,
  &_swigt__p_ampl__EntityMapT_ampl__Constraint_t__iterator,
  &_swigt__p_ampl__EntityMapT_ampl__Objective_t,
  &_swigt__p_ampl__EntityMapT_ampl__Objective_t__iterator,
  &_swigt__p_ampl__EntityMapT_ampl__Parameter_t,
  &_swigt__p_ampl__EntityMapT_ampl__Parameter_t__iterator,
  &_swigt__p_ampl__EntityMapT_ampl__Set_t,
  &_swigt__p_ampl__EntityMapT_ampl__Set_t__iterator,
  &_swigt__p_ampl__EntityMapT_ampl__Variable_t,
  &_swigt__p_ampl__EntityMapT_ampl__Variable_t__iterator,
  &_swigt__p_ampl__Environment,
  &_swigt__p_ampl__ErrorHandler,
  &_swigt__p_ampl__FileIOException,
  &_swigt__p_ampl__Instance,
  &_swigt__p_ampl__InvalidSubscriptException,
  &_swigt__p_ampl__LicenseException,
  &_swigt__p_ampl__NoDataException,
  &_swigt__p_ampl__Objective,
  &_swigt__p_ampl__ObjectiveInstance,
  &_swigt__p_ampl__OptionalT_bool_t,
  &_swigt__p_ampl__OptionalT_double_t,
  &_swigt__p_ampl__OptionalT_int_t,
  &_swigt__p_ampl__OptionalT_std__string_t,
  &_swigt__p_ampl__OutputHandler,
  &_swigt__p_ampl__Parameter,
  &_swigt__p_ampl__Runnable,
  &_swigt__p_ampl__Set,
  &_swigt__p_ampl__SetInstance,
  &_swigt__p_ampl__SetInstance__MemberRange,
  &_swigt__p_ampl__SetInstance__MemberRange__iterator,
  &_swigt__p_ampl__StringArray,
  &_swigt__p_ampl__StringRefArray,
  &_swigt__p_ampl__SyntaxErrorException,
  &_swigt__p_ampl__Tuple,
  &_swigt__p_ampl__TupleRef,
  &_swigt__p_ampl__UnsupportedOperationException,
  &_swigt__p_ampl__Variable,
  &_swigt__p_ampl__VariableInstance,
  &_swigt__p_ampl__Variant,
  &_swigt__p_ampl__VariantRef,
  &_swigt__p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t,
  &_swigt__p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t,
  &_swigt__p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t,
  &_swigt__p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t,
  &_swigt__p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t,
  &_swigt__p_ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t,
  &_swigt__p_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t,
  &_swigt__p_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t,
  &_swigt__p_ampl__internal__EntityWrapperT_ampl__SetInstance_t,
  &_swigt__p_ampl__internal__EntityWrapperT_ampl__VariableInstance_t,
  &_swigt__p_ampl__internal__EntityWrapperT_ampl__VariantRef_t,
  &_swigt__p_ampl__internal__EnvironmentIterator,
  &_swigt__p_ampl__internal__SliceT_false_t,
  &_swigt__p_ampl__internal__SliceT_false_t__iterator,
  &_swigt__p_ampl__internal__SliceT_true_t,
  &_swigt__p_ampl__internal__SliceT_true_t__iterator,
  &_swigt__p_char,
  &_swigt__p_double,
  &_swigt__p_iterator,
  &_swigt__p_p_char,
  &_swigt__p_std__runtime_error,
  &_swigt__p_unsigned_int,
};

static swig_cast_info _swigc__p_Column[] = {  {&_swigt__p_Column, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_EntityArray[] = {  {&_swigt__p_EntityArray, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_InstanceType[] = {  {&_swigt__p_InstanceType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_KeyType[] = {  {&_swigt__p_KeyType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Row[] = {  {&_swigt__p_Row, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SwigPyObject[] = {  {&_swigt__p_SwigPyObject, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_TupleArray[] = {  {&_swigt__p_TupleArray, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ValueType[] = {  {&_swigt__p_ValueType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_VariantArray[] = {  {&_swigt__p_VariantArray, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__AMPL[] = {  {&_swigt__p_ampl__AMPL, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__AMPLException[] = {  {&_swigt__p_ampl__AMPLException, 0, 0, 0},  {&_swigt__p_ampl__InvalidSubscriptException, _p_ampl__InvalidSubscriptExceptionTo_p_ampl__AMPLException, 0, 0},  {&_swigt__p_ampl__SyntaxErrorException, _p_ampl__SyntaxErrorExceptionTo_p_ampl__AMPLException, 0, 0},  {&_swigt__p_ampl__NoDataException, _p_ampl__NoDataExceptionTo_p_ampl__AMPLException, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__BasicEntityT_ampl__ConstraintInstance_t[] = {  {&_swigt__p_ampl__BasicEntityT_ampl__ConstraintInstance_t, 0, 0, 0},  {&_swigt__p_ampl__Constraint, _p_ampl__ConstraintTo_p_ampl__BasicEntityT_ampl__ConstraintInstance_t, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__BasicEntityT_ampl__ObjectiveInstance_t[] = {  {&_swigt__p_ampl__BasicEntityT_ampl__ObjectiveInstance_t, 0, 0, 0},  {&_swigt__p_ampl__Objective, _p_ampl__ObjectiveTo_p_ampl__BasicEntityT_ampl__ObjectiveInstance_t, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__BasicEntityT_ampl__SetInstance_t[] = {  {&_swigt__p_ampl__BasicEntityT_ampl__SetInstance_t, 0, 0, 0},  {&_swigt__p_ampl__Set, _p_ampl__SetTo_p_ampl__BasicEntityT_ampl__SetInstance_t, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__BasicEntityT_ampl__VariableInstance_t[] = {  {&_swigt__p_ampl__BasicEntityT_ampl__VariableInstance_t, 0, 0, 0},  {&_swigt__p_ampl__Variable, _p_ampl__VariableTo_p_ampl__BasicEntityT_ampl__VariableInstance_t, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__BasicEntityT_ampl__VariantRef_t[] = {  {&_swigt__p_ampl__BasicEntityT_ampl__VariantRef_t, 0, 0, 0},  {&_swigt__p_ampl__Parameter, _p_ampl__ParameterTo_p_ampl__BasicEntityT_ampl__VariantRef_t, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__Constraint[] = {  {&_swigt__p_ampl__Constraint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__ConstraintInstance[] = {  {&_swigt__p_ampl__ConstraintInstance, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__DataFrame[] = {  {&_swigt__p_ampl__DataFrame, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__Entity[] = {  {&_swigt__p_EntityArray, _p_EntityArrayTo_p_ampl__Entity, 0, 0},  {&_swigt__p_ampl__Constraint, _p_ampl__ConstraintTo_p_ampl__Entity, 0, 0},  {&_swigt__p_ampl__Variable, _p_ampl__VariableTo_p_ampl__Entity, 0, 0},  {&_swigt__p_ampl__BasicEntityT_ampl__VariableInstance_t, _p_ampl__BasicEntityT_ampl__VariableInstance_tTo_p_ampl__Entity, 0, 0},  {&_swigt__p_ampl__BasicEntityT_ampl__ConstraintInstance_t, _p_ampl__BasicEntityT_ampl__ConstraintInstance_tTo_p_ampl__Entity, 0, 0},  {&_swigt__p_ampl__BasicEntityT_ampl__SetInstance_t, _p_ampl__BasicEntityT_ampl__SetInstance_tTo_p_ampl__Entity, 0, 0},  {&_swigt__p_ampl__BasicEntityT_ampl__ObjectiveInstance_t, _p_ampl__BasicEntityT_ampl__ObjectiveInstance_tTo_p_ampl__Entity, 0, 0},  {&_swigt__p_ampl__BasicEntityT_ampl__VariantRef_t, _p_ampl__BasicEntityT_ampl__VariantRef_tTo_p_ampl__Entity, 0, 0},  {&_swigt__p_ampl__Parameter, _p_ampl__ParameterTo_p_ampl__Entity, 0, 0},  {&_swigt__p_ampl__Set, _p_ampl__SetTo_p_ampl__Entity, 0, 0},  {&_swigt__p_ampl__Entity, 0, 0, 0},  {&_swigt__p_ampl__Objective, _p_ampl__ObjectiveTo_p_ampl__Entity, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__EntityArgs[] = {  {&_swigt__p_ampl__EntityArgs, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__EntityMapT_ampl__Constraint_t[] = {  {&_swigt__p_ampl__EntityMapT_ampl__Constraint_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__EntityMapT_ampl__Constraint_t__iterator[] = {  {&_swigt__p_ampl__EntityMapT_ampl__Constraint_t__iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__EntityMapT_ampl__Objective_t[] = {  {&_swigt__p_ampl__EntityMapT_ampl__Objective_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__EntityMapT_ampl__Objective_t__iterator[] = {  {&_swigt__p_ampl__EntityMapT_ampl__Objective_t__iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__EntityMapT_ampl__Parameter_t[] = {  {&_swigt__p_ampl__EntityMapT_ampl__Parameter_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__EntityMapT_ampl__Parameter_t__iterator[] = {  {&_swigt__p_ampl__EntityMapT_ampl__Parameter_t__iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__EntityMapT_ampl__Set_t[] = {  {&_swigt__p_ampl__EntityMapT_ampl__Set_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__EntityMapT_ampl__Set_t__iterator[] = {  {&_swigt__p_ampl__EntityMapT_ampl__Set_t__iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__EntityMapT_ampl__Variable_t[] = {  {&_swigt__p_ampl__EntityMapT_ampl__Variable_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__EntityMapT_ampl__Variable_t__iterator[] = {  {&_swigt__p_ampl__EntityMapT_ampl__Variable_t__iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__Environment[] = {  {&_swigt__p_ampl__Environment, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__ErrorHandler[] = {  {&_swigt__p_ampl__ErrorHandler, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__FileIOException[] = {  {&_swigt__p_ampl__FileIOException, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__Instance[] = {  {&_swigt__p_ampl__Instance, 0, 0, 0},  {&_swigt__p_ampl__SetInstance, _p_ampl__SetInstanceTo_p_ampl__Instance, 0, 0},  {&_swigt__p_ampl__ObjectiveInstance, _p_ampl__ObjectiveInstanceTo_p_ampl__Instance, 0, 0},  {&_swigt__p_ampl__VariableInstance, _p_ampl__VariableInstanceTo_p_ampl__Instance, 0, 0},  {&_swigt__p_ampl__ConstraintInstance, _p_ampl__ConstraintInstanceTo_p_ampl__Instance, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__InvalidSubscriptException[] = {  {&_swigt__p_ampl__InvalidSubscriptException, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__LicenseException[] = {  {&_swigt__p_ampl__LicenseException, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__NoDataException[] = {  {&_swigt__p_ampl__NoDataException, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__Objective[] = {  {&_swigt__p_ampl__Objective, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__ObjectiveInstance[] = {  {&_swigt__p_ampl__ObjectiveInstance, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__OptionalT_bool_t[] = {  {&_swigt__p_ampl__OptionalT_bool_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__OptionalT_double_t[] = {  {&_swigt__p_ampl__OptionalT_double_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__OptionalT_int_t[] = {  {&_swigt__p_ampl__OptionalT_int_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__OptionalT_std__string_t[] = {  {&_swigt__p_ampl__OptionalT_std__string_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__OutputHandler[] = {  {&_swigt__p_ampl__OutputHandler, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__Parameter[] = {  {&_swigt__p_ampl__Parameter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__Runnable[] = {  {&_swigt__p_ampl__Runnable, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__Set[] = {  {&_swigt__p_ampl__Set, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__SetInstance[] = {  {&_swigt__p_ampl__SetInstance, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__SetInstance__MemberRange[] = {  {&_swigt__p_ampl__SetInstance__MemberRange, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__SetInstance__MemberRange__iterator[] = {  {&_swigt__p_ampl__SetInstance__MemberRange__iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__StringArray[] = {  {&_swigt__p_ampl__StringArray, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__StringRefArray[] = {  {&_swigt__p_ampl__StringRefArray, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__SyntaxErrorException[] = {  {&_swigt__p_ampl__SyntaxErrorException, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__Tuple[] = {  {&_swigt__p_TupleArray, _p_TupleArrayTo_p_ampl__Tuple, 0, 0},  {&_swigt__p_ampl__Tuple, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__TupleRef[] = {  {&_swigt__p_ampl__TupleRef, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__UnsupportedOperationException[] = {  {&_swigt__p_ampl__UnsupportedOperationException, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__Variable[] = {  {&_swigt__p_ampl__Variable, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__VariableInstance[] = {  {&_swigt__p_ampl__VariableInstance, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__Variant[] = {  {&_swigt__p_VariantArray, _p_VariantArrayTo_p_ampl__Variant, 0, 0},  {&_swigt__p_ampl__Variant, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__VariantRef[] = {  {&_swigt__p_ampl__VariantRef, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t[] = {  {&_swigt__p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t[] = {  {&_swigt__p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t[] = {  {&_swigt__p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t[] = {  {&_swigt__p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t[] = {  {&_swigt__p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t[] = {  {&_swigt__p_ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t[] = {  {&_swigt__p_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t[] = {  {&_swigt__p_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__internal__EntityWrapperT_ampl__SetInstance_t[] = {  {&_swigt__p_ampl__internal__EntityWrapperT_ampl__SetInstance_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__internal__EntityWrapperT_ampl__VariableInstance_t[] = {  {&_swigt__p_ampl__internal__EntityWrapperT_ampl__VariableInstance_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__internal__EntityWrapperT_ampl__VariantRef_t[] = {  {&_swigt__p_ampl__internal__EntityWrapperT_ampl__VariantRef_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__internal__EnvironmentIterator[] = {  {&_swigt__p_ampl__internal__EnvironmentIterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__internal__SliceT_false_t[] = {  {&_swigt__p_ampl__internal__SliceT_false_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__internal__SliceT_false_t__iterator[] = {  {&_swigt__p_ampl__internal__SliceT_false_t__iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__internal__SliceT_true_t[] = {  {&_swigt__p_ampl__internal__SliceT_true_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ampl__internal__SliceT_true_t__iterator[] = {  {&_swigt__p_ampl__internal__SliceT_true_t__iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_char[] = {  {&_swigt__p_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_double[] = {  {&_swigt__p_double, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_iterator[] = {  {&_swigt__p_iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_char[] = {  {&_swigt__p_p_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__runtime_error[] = {  {&_swigt__p_std__runtime_error, 0, 0, 0},  {&_swigt__p_ampl__AMPLException, _p_ampl__AMPLExceptionTo_p_std__runtime_error, 0, 0},  {&_swigt__p_ampl__InvalidSubscriptException, _p_ampl__InvalidSubscriptExceptionTo_p_std__runtime_error, 0, 0},  {&_swigt__p_ampl__SyntaxErrorException, _p_ampl__SyntaxErrorExceptionTo_p_std__runtime_error, 0, 0},  {&_swigt__p_ampl__NoDataException, _p_ampl__NoDataExceptionTo_p_std__runtime_error, 0, 0},  {&_swigt__p_ampl__LicenseException, _p_ampl__LicenseExceptionTo_p_std__runtime_error, 0, 0},  {&_swigt__p_ampl__FileIOException, _p_ampl__FileIOExceptionTo_p_std__runtime_error, 0, 0},  {&_swigt__p_ampl__UnsupportedOperationException, _p_ampl__UnsupportedOperationExceptionTo_p_std__runtime_error, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_unsigned_int[] = {  {&_swigt__p_unsigned_int, 0, 0, 0},{0, 0, 0, 0}};

static swig_cast_info *swig_cast_initial[] = {
  _swigc__p_Column,
  _swigc__p_EntityArray,
  _swigc__p_InstanceType,
  _swigc__p_KeyType,
  _swigc__p_Row,
  _swigc__p_SwigPyObject,
  _swigc__p_TupleArray,
  _swigc__p_ValueType,
  _swigc__p_VariantArray,
  _swigc__p_ampl__AMPL,
  _swigc__p_ampl__AMPLException,
  _swigc__p_ampl__BasicEntityT_ampl__ConstraintInstance_t,
  _swigc__p_ampl__BasicEntityT_ampl__ObjectiveInstance_t,
  _swigc__p_ampl__BasicEntityT_ampl__SetInstance_t,
  _swigc__p_ampl__BasicEntityT_ampl__VariableInstance_t,
  _swigc__p_ampl__BasicEntityT_ampl__VariantRef_t,
  _swigc__p_ampl__Constraint,
  _swigc__p_ampl__ConstraintInstance,
  _swigc__p_ampl__DataFrame,
  _swigc__p_ampl__Entity,
  _swigc__p_ampl__EntityArgs,
  _swigc__p_ampl__EntityMapT_ampl__Constraint_t,
  _swigc__p_ampl__EntityMapT_ampl__Constraint_t__iterator,
  _swigc__p_ampl__EntityMapT_ampl__Objective_t,
  _swigc__p_ampl__EntityMapT_ampl__Objective_t__iterator,
  _swigc__p_ampl__EntityMapT_ampl__Parameter_t,
  _swigc__p_ampl__EntityMapT_ampl__Parameter_t__iterator,
  _swigc__p_ampl__EntityMapT_ampl__Set_t,
  _swigc__p_ampl__EntityMapT_ampl__Set_t__iterator,
  _swigc__p_ampl__EntityMapT_ampl__Variable_t,
  _swigc__p_ampl__EntityMapT_ampl__Variable_t__iterator,
  _swigc__p_ampl__Environment,
  _swigc__p_ampl__ErrorHandler,
  _swigc__p_ampl__FileIOException,
  _swigc__p_ampl__Instance,
  _swigc__p_ampl__InvalidSubscriptException,
  _swigc__p_ampl__LicenseException,
  _swigc__p_ampl__NoDataException,
  _swigc__p_ampl__Objective,
  _swigc__p_ampl__ObjectiveInstance,
  _swigc__p_ampl__OptionalT_bool_t,
  _swigc__p_ampl__OptionalT_double_t,
  _swigc__p_ampl__OptionalT_int_t,
  _swigc__p_ampl__OptionalT_std__string_t,
  _swigc__p_ampl__OutputHandler,
  _swigc__p_ampl__Parameter,
  _swigc__p_ampl__Runnable,
  _swigc__p_ampl__Set,
  _swigc__p_ampl__SetInstance,
  _swigc__p_ampl__SetInstance__MemberRange,
  _swigc__p_ampl__SetInstance__MemberRange__iterator,
  _swigc__p_ampl__StringArray,
  _swigc__p_ampl__StringRefArray,
  _swigc__p_ampl__SyntaxErrorException,
  _swigc__p_ampl__Tuple,
  _swigc__p_ampl__TupleRef,
  _swigc__p_ampl__UnsupportedOperationException,
  _swigc__p_ampl__Variable,
  _swigc__p_ampl__VariableInstance,
  _swigc__p_ampl__Variant,
  _swigc__p_ampl__VariantRef,
  _swigc__p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t,
  _swigc__p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t,
  _swigc__p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t,
  _swigc__p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t,
  _swigc__p_ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t,
  _swigc__p_ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t,
  _swigc__p_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t,
  _swigc__p_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t,
  _swigc__p_ampl__internal__EntityWrapperT_ampl__SetInstance_t,
  _swigc__p_ampl__internal__EntityWrapperT_ampl__VariableInstance_t,
  _swigc__p_ampl__internal__EntityWrapperT_ampl__VariantRef_t,
  _swigc__p_ampl__internal__EnvironmentIterator,
  _swigc__p_ampl__internal__SliceT_false_t,
  _swigc__p_ampl__internal__SliceT_false_t__iterator,
  _swigc__p_ampl__internal__SliceT_true_t,
  _swigc__p_ampl__internal__SliceT_true_t__iterator,
  _swigc__p_char,
  _swigc__p_double,
  _swigc__p_iterator,
  _swigc__p_p_char,
  _swigc__p_std__runtime_error,
  _swigc__p_unsigned_int,
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */

static swig_const_info swig_const_table[] = {
{0, 0, 0, 0.0, 0, 0}};

#ifdef __cplusplus
}
#endif
static PyTypeObject *builtin_bases[3];

/* -----------------------------------------------------------------------------
 * Type initialization:
 * This problem is tough by the requirement that no dynamic
 * memory is used. Also, since swig_type_info structures store pointers to
 * swig_cast_info structures and swig_cast_info structures store pointers back
 * to swig_type_info structures, we need some lookup code at initialization.
 * The idea is that swig generates all the structures that are needed.
 * The runtime then collects these partially filled structures.
 * The SWIG_InitializeModule function takes these initial arrays out of
 * swig_module, and does all the lookup, filling in the swig_module.types
 * array with the correct data and linking the correct swig_cast_info
 * structures together.
 *
 * The generated swig_type_info structures are assigned statically to an initial
 * array. We just loop through that array, and handle each type individually.
 * First we lookup if this type has been already loaded, and if so, use the
 * loaded structure instead of the generated one. Then we have to fill in the
 * cast linked list. The cast data is initially stored in something like a
 * two-dimensional array. Each row corresponds to a type (there are the same
 * number of rows as there are in the swig_type_initial array). Each entry in
 * a column is one of the swig_cast_info structures for that type.
 * The cast_initial array is actually an array of arrays, because each row has
 * a variable number of columns. So to actually build the cast linked list,
 * we find the array of casts associated with the type, and loop through it
 * adding the casts to the list. The one last trick we need to do is making
 * sure the type pointer in the swig_cast_info struct is correct.
 *
 * First off, we lookup the cast->type name to see if it is already loaded.
 * There are three cases to handle:
 *  1) If the cast->type has already been loaded AND the type we are adding
 *     casting info to has not been loaded (it is in this module), THEN we
 *     replace the cast->type pointer with the type pointer that has already
 *     been loaded.
 *  2) If BOTH types (the one we are adding casting info to, and the
 *     cast->type) are loaded, THEN the cast info has already been loaded by
 *     the previous module so we just ignore it.
 *  3) Finally, if cast->type has not already been loaded, then we add that
 *     swig_cast_info to the linked list (because the cast->type) pointer will
 *     be correct.
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#if 0
} /* c-mode */
#endif
#endif

#if 0
#define SWIGRUNTIME_DEBUG
#endif


SWIGRUNTIME void
SWIG_InitializeModule(void *clientdata) {
  size_t i;
  swig_module_info *module_head, *iter;
  int init;
  
  /* check to see if the circular list has been setup, if not, set it up */
  if (swig_module.next==0) {
    /* Initialize the swig_module */
    swig_module.type_initial = swig_type_initial;
    swig_module.cast_initial = swig_cast_initial;
    swig_module.next = &swig_module;
    init = 1;
  } else {
    init = 0;
  }
  
  /* Try and load any already created modules */
  module_head = SWIG_GetModule(clientdata);
  if (!module_head) {
    /* This is the first module loaded for this interpreter */
    /* so set the swig module into the interpreter */
    SWIG_SetModule(clientdata, &swig_module);
  } else {
    /* the interpreter has loaded a SWIG module, but has it loaded this one? */
    iter=module_head;
    do {
      if (iter==&swig_module) {
        /* Our module is already in the list, so there's nothing more to do. */
        return;
      }
      iter=iter->next;
    } while (iter!= module_head);
    
    /* otherwise we must add our module into the list */
    swig_module.next = module_head->next;
    module_head->next = &swig_module;
  }
  
  /* When multiple interpreters are used, a module could have already been initialized in
       a different interpreter, but not yet have a pointer in this interpreter.
       In this case, we do not want to continue adding types... everything should be
       set up already */
  if (init == 0) return;
  
  /* Now work on filling in swig_module.types */
#ifdef SWIGRUNTIME_DEBUG
  printf("SWIG_InitializeModule: size %d\n", swig_module.size);
#endif
  for (i = 0; i < swig_module.size; ++i) {
    swig_type_info *type = 0;
    swig_type_info *ret;
    swig_cast_info *cast;
    
#ifdef SWIGRUNTIME_DEBUG
    printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
#endif
    
    /* if there is another module already loaded */
    if (swig_module.next != &swig_module) {
      type = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, swig_module.type_initial[i]->name);
    }
    if (type) {
      /* Overwrite clientdata field */
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: found type %s\n", type->name);
#endif
      if (swig_module.type_initial[i]->clientdata) {
        type->clientdata = swig_module.type_initial[i]->clientdata;
#ifdef SWIGRUNTIME_DEBUG
        printf("SWIG_InitializeModule: found and overwrite type %s \n", type->name);
#endif
      }
    } else {
      type = swig_module.type_initial[i];
    }
    
    /* Insert casting types */
    cast = swig_module.cast_initial[i];
    while (cast->type) {
      /* Don't need to add information already in the list */
      ret = 0;
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: look cast %s\n", cast->type->name);
#endif
      if (swig_module.next != &swig_module) {
        ret = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, cast->type->name);
#ifdef SWIGRUNTIME_DEBUG
        if (ret) printf("SWIG_InitializeModule: found cast %s\n", ret->name);
#endif
      }
      if (ret) {
        if (type == swig_module.type_initial[i]) {
#ifdef SWIGRUNTIME_DEBUG
          printf("SWIG_InitializeModule: skip old type %s\n", ret->name);
#endif
          cast->type = ret;
          ret = 0;
        } else {
          /* Check for casting already in the list */
          swig_cast_info *ocast = SWIG_TypeCheck(ret->name, type);
#ifdef SWIGRUNTIME_DEBUG
          if (ocast) printf("SWIG_InitializeModule: skip old cast %s\n", ret->name);
#endif
          if (!ocast) ret = 0;
        }
      }
      
      if (!ret) {
#ifdef SWIGRUNTIME_DEBUG
        printf("SWIG_InitializeModule: adding cast %s\n", cast->type->name);
#endif
        if (type->cast) {
          type->cast->prev = cast;
          cast->next = type->cast;
        }
        type->cast = cast;
      }
      cast++;
    }
    /* Set entry in modules->types array equal to the type */
    swig_module.types[i] = type;
  }
  swig_module.types[i] = 0;
  
#ifdef SWIGRUNTIME_DEBUG
  printf("**** SWIG_InitializeModule: Cast List ******\n");
  for (i = 0; i < swig_module.size; ++i) {
    int j = 0;
    swig_cast_info *cast = swig_module.cast_initial[i];
    printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
    while (cast->type) {
      printf("SWIG_InitializeModule: cast type %s\n", cast->type->name);
      cast++;
      ++j;
    }
    printf("---- Total casts: %d\n",j);
  }
  printf("**** SWIG_InitializeModule: Cast List ******\n");
#endif
}

/* This function will propagate the clientdata field of type to
* any new swig_type_info structures that have been added into the list
* of equivalent types.  It is like calling
* SWIG_TypeClientData(type, clientdata) a second time.
*/
SWIGRUNTIME void
SWIG_PropagateClientData(void) {
  size_t i;
  swig_cast_info *equiv;
  static int init_run = 0;
  
  if (init_run) return;
  init_run = 1;
  
  for (i = 0; i < swig_module.size; i++) {
    if (swig_module.types[i]->clientdata) {
      equiv = swig_module.types[i]->cast;
      while (equiv) {
        if (!equiv->converter) {
          if (equiv->type && !equiv->type->clientdata)
          SWIG_TypeClientData(equiv->type, swig_module.types[i]->clientdata);
        }
        equiv = equiv->next;
      }
    }
  }
}

#ifdef __cplusplus
#if 0
{
  /* c-mode */
#endif
}
#endif



#ifdef __cplusplus
extern "C" {
#endif
  
  /* Python-specific SWIG API */
#define SWIG_newvarlink()                             SWIG_Python_newvarlink()
#define SWIG_addvarlink(p, name, get_attr, set_attr)  SWIG_Python_addvarlink(p, name, get_attr, set_attr)
#define SWIG_InstallConstants(d, constants)           SWIG_Python_InstallConstants(d, constants)
  
  /* -----------------------------------------------------------------------------
   * global variable support code.
   * ----------------------------------------------------------------------------- */
  
  typedef struct swig_globalvar {
    char       *name;                  /* Name of global variable */
    PyObject *(*get_attr)(void);       /* Return the current value */
    int       (*set_attr)(PyObject *); /* Set the value */
    struct swig_globalvar *next;
  } swig_globalvar;
  
  typedef struct swig_varlinkobject {
    PyObject_HEAD
    swig_globalvar *vars;
  } swig_varlinkobject;
  
  SWIGINTERN PyObject *
  swig_varlink_repr(swig_varlinkobject *SWIGUNUSEDPARM(v)) {
#if PY_VERSION_HEX >= 0x03000000
    return PyUnicode_InternFromString("<Swig global variables>");
#else
    return PyString_FromString("<Swig global variables>");
#endif
  }
  
  SWIGINTERN PyObject *
  swig_varlink_str(swig_varlinkobject *v) {
#if PY_VERSION_HEX >= 0x03000000
    PyObject *str = PyUnicode_InternFromString("(");
    PyObject *tail;
    PyObject *joined;
    swig_globalvar *var;
    for (var = v->vars; var; var=var->next) {
      tail = PyUnicode_FromString(var->name);
      joined = PyUnicode_Concat(str, tail);
      Py_DecRef(str);
      Py_DecRef(tail);
      str = joined;
      if (var->next) {
        tail = PyUnicode_InternFromString(", ");
        joined = PyUnicode_Concat(str, tail);
        Py_DecRef(str);
        Py_DecRef(tail);
        str = joined;
      }
    }
    tail = PyUnicode_InternFromString(")");
    joined = PyUnicode_Concat(str, tail);
    Py_DecRef(str);
    Py_DecRef(tail);
    str = joined;
#else
    PyObject *str = PyString_FromString("(");
    swig_globalvar *var;
    for (var = v->vars; var; var=var->next) {
      PyString_ConcatAndDel(&str,PyString_FromString(var->name));
      if (var->next) PyString_ConcatAndDel(&str,PyString_FromString(", "));
    }
    PyString_ConcatAndDel(&str,PyString_FromString(")"));
#endif
    return str;
  }
  
  SWIGINTERN int
  swig_varlink_print(swig_varlinkobject *v, FILE *fp, int SWIGUNUSEDPARM(flags)) {
    char *tmp;
    PyObject *str = swig_varlink_str(v);
    fprintf(fp,"Swig global variables ");
    fprintf(fp,"%s\n", tmp = SWIG_Python_str_AsChar(str));
    SWIG_Python_str_DelForPy3(tmp);
    Py_DECREF(str);
    return 0;
  }
  
  SWIGINTERN void
  swig_varlink_dealloc(swig_varlinkobject *v) {
    swig_globalvar *var = v->vars;
    while (var) {
      swig_globalvar *n = var->next;
      free(var->name);
      free(var);
      var = n;
    }
  }
  
  SWIGINTERN PyObject *
  swig_varlink_getattr(swig_varlinkobject *v, char *n) {
    PyObject *res = NULL;
    swig_globalvar *var = v->vars;
    while (var) {
      if (strcmp(var->name,n) == 0) {
        res = (*var->get_attr)();
        break;
      }
      var = var->next;
    }
    if (res == NULL && !PyErr_Occurred()) {
      PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
    }
    return res;
  }
  
  SWIGINTERN int
  swig_varlink_setattr(swig_varlinkobject *v, char *n, PyObject *p) {
    int res = 1;
    swig_globalvar *var = v->vars;
    while (var) {
      if (strcmp(var->name,n) == 0) {
        res = (*var->set_attr)(p);
        break;
      }
      var = var->next;
    }
    if (res == 1 && !PyErr_Occurred()) {
      PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
    }
    return res;
  }
  
  SWIGINTERN PyTypeObject*
  swig_varlink_type(void) {
    static char varlink__doc__[] = "Swig var link object";
    static PyTypeObject varlink_type;
    static int type_init = 0;
    if (!type_init) {
      const PyTypeObject tmp = {
        /* PyObject header changed in Python 3 */
#if PY_VERSION_HEX >= 0x03000000
        PyVarObject_HEAD_INIT(NULL, 0)
#else
        PyObject_HEAD_INIT(NULL)
        0,                                  /* ob_size */
#endif
        (char *)"swigvarlink",              /* tp_name */
        sizeof(swig_varlinkobject),         /* tp_basicsize */
        0,                                  /* tp_itemsize */
        (destructor) swig_varlink_dealloc,  /* tp_dealloc */
        (printfunc) swig_varlink_print,     /* tp_print */
        (getattrfunc) swig_varlink_getattr, /* tp_getattr */
        (setattrfunc) swig_varlink_setattr, /* tp_setattr */
        0,                                  /* tp_compare */
        (reprfunc) swig_varlink_repr,       /* tp_repr */
        0,                                  /* tp_as_number */
        0,                                  /* tp_as_sequence */
        0,                                  /* tp_as_mapping */
        0,                                  /* tp_hash */
        0,                                  /* tp_call */
        (reprfunc) swig_varlink_str,        /* tp_str */
        0,                                  /* tp_getattro */
        0,                                  /* tp_setattro */
        0,                                  /* tp_as_buffer */
        0,                                  /* tp_flags */
        varlink__doc__,                     /* tp_doc */
        0,                                  /* tp_traverse */
        0,                                  /* tp_clear */
        0,                                  /* tp_richcompare */
        0,                                  /* tp_weaklistoffset */
#if PY_VERSION_HEX >= 0x02020000
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* tp_iter -> tp_weaklist */
#endif
#if PY_VERSION_HEX >= 0x02030000
        0,                                  /* tp_del */
#endif
#if PY_VERSION_HEX >= 0x02060000
        0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
        0,                                  /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
        0,                                  /* tp_allocs */
        0,                                  /* tp_frees */
        0,                                  /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
        0,                                  /* tp_prev */
#endif
        0                                   /* tp_next */
#endif
      };
      varlink_type = tmp;
      type_init = 1;
#if PY_VERSION_HEX < 0x02020000
      varlink_type.ob_type = &PyType_Type;
#else
      if (PyType_Ready(&varlink_type) < 0)
      return NULL;
#endif
    }
    return &varlink_type;
  }
  
  /* Create a variable linking object for use later */
  SWIGINTERN PyObject *
  SWIG_Python_newvarlink(void) {
    swig_varlinkobject *result = PyObject_NEW(swig_varlinkobject, swig_varlink_type());
    if (result) {
      result->vars = 0;
    }
    return ((PyObject*) result);
  }
  
  SWIGINTERN void 
  SWIG_Python_addvarlink(PyObject *p, char *name, PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p)) {
    swig_varlinkobject *v = (swig_varlinkobject *) p;
    swig_globalvar *gv = (swig_globalvar *) malloc(sizeof(swig_globalvar));
    if (gv) {
      size_t size = strlen(name)+1;
      gv->name = (char *)malloc(size);
      if (gv->name) {
        strncpy(gv->name,name,size);
        gv->get_attr = get_attr;
        gv->set_attr = set_attr;
        gv->next = v->vars;
      }
    }
    v->vars = gv;
  }
  
  SWIGINTERN PyObject *
  SWIG_globals(void) {
    static PyObject *_SWIG_globals = 0; 
    if (!_SWIG_globals) _SWIG_globals = SWIG_newvarlink();  
    return _SWIG_globals;
  }
  
  /* -----------------------------------------------------------------------------
   * constants/methods manipulation
   * ----------------------------------------------------------------------------- */
  
  /* Install Constants */
  SWIGINTERN void
  SWIG_Python_InstallConstants(PyObject *d, swig_const_info constants[]) {
    PyObject *obj = 0;
    size_t i;
    for (i = 0; constants[i].type; ++i) {
      switch(constants[i].type) {
      case SWIG_PY_POINTER:
        obj = SWIG_InternalNewPointerObj(constants[i].pvalue, *(constants[i]).ptype,0);
        break;
      case SWIG_PY_BINARY:
        obj = SWIG_NewPackedObj(constants[i].pvalue, constants[i].lvalue, *(constants[i].ptype));
        break;
      default:
        obj = 0;
        break;
      }
      if (obj) {
        PyDict_SetItemString(d, constants[i].name, obj);
        Py_DECREF(obj);
      }
    }
  }
  
  /* -----------------------------------------------------------------------------*/
  /* Fix SwigMethods to carry the callback ptrs when needed */
  /* -----------------------------------------------------------------------------*/
  
  SWIGINTERN void
  SWIG_Python_FixMethods(PyMethodDef *methods,
    swig_const_info *const_table,
    swig_type_info **types,
    swig_type_info **types_initial) {
    size_t i;
    for (i = 0; methods[i].ml_name; ++i) {
      const char *c = methods[i].ml_doc;
      if (!c) continue;
      c = strstr(c, "swig_ptr: ");
      if (c) {
        int j;
        swig_const_info *ci = 0;
        const char *name = c + 10;
        for (j = 0; const_table[j].type; ++j) {
          if (strncmp(const_table[j].name, name, 
              strlen(const_table[j].name)) == 0) {
            ci = &(const_table[j]);
            break;
          }
        }
        if (ci) {
          void *ptr = (ci->type == SWIG_PY_POINTER) ? ci->pvalue : 0;
          if (ptr) {
            size_t shift = (ci->ptype) - types;
            swig_type_info *ty = types_initial[shift];
            size_t ldoc = (c - methods[i].ml_doc);
            size_t lptr = strlen(ty->name)+2*sizeof(void*)+2;
            char *ndoc = (char*)malloc(ldoc + lptr + 10);
            if (ndoc) {
              char *buff = ndoc;
              strncpy(buff, methods[i].ml_doc, ldoc);
              buff += ldoc;
              strncpy(buff, "swig_ptr: ", 10);
              buff += 10;
              SWIG_PackVoidPtr(buff, ptr, ty->name, lptr);
              methods[i].ml_doc = ndoc;
            }
          }
        }
      }
    }
  } 
  
#ifdef __cplusplus
}
#endif

/* -----------------------------------------------------------------------------*
 *  Partial Init method
 * -----------------------------------------------------------------------------*/

#ifdef __cplusplus
extern "C"
#endif

SWIGEXPORT 
#if PY_VERSION_HEX >= 0x03000000
PyObject*
#else
void
#endif
SWIG_init(void) {
  PyObject *m, *d, *md;
#if PY_VERSION_HEX >= 0x03000000
  static struct PyModuleDef SWIG_module = {
# if PY_VERSION_HEX >= 0x03020000
    PyModuleDef_HEAD_INIT,
# else
    {
      PyObject_HEAD_INIT(NULL)
      NULL, /* m_init */
      0,    /* m_index */
      NULL, /* m_copy */
    },
# endif
    (char *) SWIG_name,
    NULL,
    -1,
    SwigMethods,
    NULL,
    NULL,
    NULL,
    NULL
  };
#endif
  
#if defined(SWIGPYTHON_BUILTIN)
  static SwigPyClientData SwigPyObject_clientdata = {
    0, 0, 0, 0, 0, 0, 0
  };
  static PyGetSetDef this_getset_def = {
    (char *)"this", &SwigPyBuiltin_ThisClosure, NULL, NULL, NULL
  };
  static SwigPyGetSet thisown_getset_closure = {
    (PyCFunction) SwigPyObject_own,
    (PyCFunction) SwigPyObject_own
  };
  static PyGetSetDef thisown_getset_def = {
    (char *)"thisown", SwigPyBuiltin_GetterClosure, SwigPyBuiltin_SetterClosure, NULL, &thisown_getset_closure
  };
  PyObject *metatype_args;
  PyTypeObject *builtin_pytype;
  int builtin_base_count;
  swig_type_info *builtin_basetype;
  PyObject *tuple;
  PyGetSetDescrObject *static_getset;
  PyTypeObject *metatype;
  SwigPyClientData *cd;
  PyObject *public_interface, *public_symbol;
  PyObject *this_descr;
  PyObject *thisown_descr;
  PyObject *self = 0;
  int i;
  
  (void)builtin_pytype;
  (void)builtin_base_count;
  (void)builtin_basetype;
  (void)tuple;
  (void)static_getset;
  (void)self;
  
  /* metatype is used to implement static member variables. */
  metatype_args = Py_BuildValue("(s(O){})", "SwigPyObjectType", &PyType_Type);
  assert(metatype_args);
  metatype = (PyTypeObject *) PyType_Type.tp_call((PyObject *) &PyType_Type, metatype_args, NULL);
  assert(metatype);
  Py_DECREF(metatype_args);
  metatype->tp_setattro = (setattrofunc) &SwigPyObjectType_setattro;
  assert(PyType_Ready(metatype) >= 0);
#endif
  
  /* Fix SwigMethods to carry the callback ptrs when needed */
  SWIG_Python_FixMethods(SwigMethods, swig_const_table, swig_types, swig_type_initial);
  
#if PY_VERSION_HEX >= 0x03000000
  m = PyModule_Create(&SWIG_module);
#else
  m = Py_InitModule((char *) SWIG_name, SwigMethods);
#endif
  
  md = d = PyModule_GetDict(m);
  (void)md;
  
  SWIG_InitializeModule(0);
  
#ifdef SWIGPYTHON_BUILTIN
  SwigPyObject_stype = SWIG_MangledTypeQuery("_p_SwigPyObject");
  assert(SwigPyObject_stype);
  cd = (SwigPyClientData*) SwigPyObject_stype->clientdata;
  if (!cd) {
    SwigPyObject_stype->clientdata = &SwigPyObject_clientdata;
    SwigPyObject_clientdata.pytype = SwigPyObject_TypeOnce();
  } else if (SwigPyObject_TypeOnce()->tp_basicsize != cd->pytype->tp_basicsize) {
    PyErr_SetString(PyExc_RuntimeError, "Import error: attempted to load two incompatible swig-generated modules.");
# if PY_VERSION_HEX >= 0x03000000
    return NULL;
# else
    return;
# endif
  }
  
  /* All objects have a 'this' attribute */
  this_descr = PyDescr_NewGetSet(SwigPyObject_type(), &this_getset_def);
  (void)this_descr;
  
  /* All objects have a 'thisown' attribute */
  thisown_descr = PyDescr_NewGetSet(SwigPyObject_type(), &thisown_getset_def);
  (void)thisown_descr;
  
  public_interface = PyList_New(0);
  public_symbol = 0;
  (void)public_symbol;
  
  PyDict_SetItemString(md, "__all__", public_interface);
  Py_DECREF(public_interface);
  for (i = 0; SwigMethods[i].ml_name != NULL; ++i)
  SwigPyBuiltin_AddPublicSymbol(public_interface, SwigMethods[i].ml_name);
  for (i = 0; swig_const_table[i].name != 0; ++i)
  SwigPyBuiltin_AddPublicSymbol(public_interface, swig_const_table[i].name);
#endif
  
  SWIG_InstallConstants(d,swig_const_table);
  
  
  /* type 'ampl::StringArray' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__StringArray_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'StringArray'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "StringArray", (PyObject*) builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "StringArray");
  d = md;
  
  /* type 'ampl::StringRefArray' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__StringRefArray_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'StringRefArray'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "StringRefArray", (PyObject*) builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "StringRefArray");
  d = md;
  
  /* type 'std::runtime_error' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__std__runtime_error_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'runtime_error'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "runtime_error", (PyObject*) builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "runtime_error");
  d = md;
  
  /* type '::VariantArray' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__VariantArray_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'VariantArray'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "VariantArray", (PyObject*) builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "VariantArray");
  d = md;
  
  /* type '::TupleArray' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__TupleArray_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'TupleArray'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "TupleArray", (PyObject*) builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "TupleArray");
  d = md;
  
  /* type 'ampl::Optional< int >' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__OptionalT_int_t_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'OptionalInt'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "OptionalInt", (PyObject*) builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "OptionalInt");
  d = md;
  
  /* type 'ampl::Optional< std::string >' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__OptionalT_std__string_t_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'OptionalString'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "OptionalString", (PyObject*) builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "OptionalString");
  d = md;
  
  /* type 'ampl::Optional< bool >' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__OptionalT_bool_t_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'OptionalBool'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "OptionalBool", (PyObject*) builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "OptionalBool");
  d = md;
  
  /* type 'ampl::Optional< double >' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__OptionalT_double_t_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'OptionalDouble'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "OptionalDouble", (PyObject*) builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "OptionalDouble");
  d = md;
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "EMPTY",SWIG_From_int(static_cast< int >(ampl::EMPTY)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "NUMERIC",SWIG_From_int(static_cast< int >(ampl::NUMERIC)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "STRING",SWIG_From_int(static_cast< int >(ampl::STRING)));
  
  /* type 'ampl::Variant' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__Variant_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'Variant'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "Variant", (PyObject*) builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "Variant");
  d = md;
  
  /* type 'ampl::VariantRef' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__VariantRef_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'VariantRef'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "VariantRef", (PyObject*) builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "VariantRef");
  d = md;
  
  /* type 'ampl::TupleRef' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__TupleRef_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'TupleRef'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "TupleRef", (PyObject*) builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "TupleRef");
  d = md;
  
  /* type 'ampl::Tuple' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__Tuple_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'Tuple'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "Tuple", (PyObject*) builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "Tuple");
  d = md;
  
  /* type 'ampl::DataFrame' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__DataFrame_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'DataFrame'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "DataFrame", (PyObject*) builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "DataFrame");
  d = md;
  
  /* type 'ampl::internal::Slice< false >' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__internal__SliceT_false_t_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'DataFrameColumn'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "DataFrameColumn", (PyObject*) builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "DataFrameColumn");
  d = md;
  
  /* type 'ampl::internal::Slice< false >::iterator' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__internal__SliceT_false_t__iterator_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'ColIterator'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "ColIterator", (PyObject*) builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "ColIterator");
  d = md;
  
  /* type 'ampl::internal::Slice< true >' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__internal__SliceT_true_t_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'DataFrameRow'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "DataFrameRow", (PyObject*) builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "DataFrameRow");
  d = md;
  
  /* type 'ampl::internal::Slice< true >::iterator' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__internal__SliceT_true_t__iterator_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'RowIterator'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "RowIterator", (PyObject*) builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "RowIterator");
  d = md;
  
  /* type 'ampl::Instance' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__Instance_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'Instance'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "Instance", (PyObject*) builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "Instance");
  d = md;
  
  /* type 'ampl::SetInstance' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__SetInstance_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_basetype = SWIG_MangledTypeQuery("_p_ampl__Instance");
  if (builtin_basetype && builtin_basetype->clientdata && ((SwigPyClientData*) builtin_basetype->clientdata)->pytype) {
    builtin_bases[builtin_base_count++] = ((SwigPyClientData*) builtin_basetype->clientdata)->pytype;
  } else {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'SetInstance' as base 'ampl::Instance' has not been initialized.\n");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'SetInstance'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "SetInstance", (PyObject*) builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "SetInstance");
  d = md;
  
  /* type 'ampl::SetInstance::MemberRange' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__SetInstance__MemberRange_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'MemberRange'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "MemberRange", (PyObject*) builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "MemberRange");
  d = md;
  
  /* type 'ampl::SetInstance::MemberRange::iterator' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__SetInstance__MemberRange__iterator_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'iterator'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "iterator", (PyObject*) builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "iterator");
  d = md;
  
  /* type 'ampl::ObjectiveInstance' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__ObjectiveInstance_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_basetype = SWIG_MangledTypeQuery("_p_ampl__Instance");
  if (builtin_basetype && builtin_basetype->clientdata && ((SwigPyClientData*) builtin_basetype->clientdata)->pytype) {
    builtin_bases[builtin_base_count++] = ((SwigPyClientData*) builtin_basetype->clientdata)->pytype;
  } else {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'ObjectiveInstance' as base 'ampl::Instance' has not been initialized.\n");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'ObjectiveInstance'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "ObjectiveInstance", (PyObject*) builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "ObjectiveInstance");
  d = md;
  
  /* type 'ampl::VariableInstance' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__VariableInstance_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_basetype = SWIG_MangledTypeQuery("_p_ampl__Instance");
  if (builtin_basetype && builtin_basetype->clientdata && ((SwigPyClientData*) builtin_basetype->clientdata)->pytype) {
    builtin_bases[builtin_base_count++] = ((SwigPyClientData*) builtin_basetype->clientdata)->pytype;
  } else {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'VariableInstance' as base 'ampl::Instance' has not been initialized.\n");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'VariableInstance'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "VariableInstance", (PyObject*) builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "VariableInstance");
  d = md;
  
  /* type 'ampl::ConstraintInstance' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__ConstraintInstance_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_basetype = SWIG_MangledTypeQuery("_p_ampl__Instance");
  if (builtin_basetype && builtin_basetype->clientdata && ((SwigPyClientData*) builtin_basetype->clientdata)->pytype) {
    builtin_bases[builtin_base_count++] = ((SwigPyClientData*) builtin_basetype->clientdata)->pytype;
  } else {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'ConstraintInstance' as base 'ampl::Instance' has not been initialized.\n");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'ConstraintInstance'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "ConstraintInstance", (PyObject*) builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "ConstraintInstance");
  d = md;
  
  /* type '::EntityArray' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__EntityArray_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'EntityArray'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "EntityArray", (PyObject*) builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "EntityArray");
  d = md;
  
  /* type 'ampl::Entity' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__Entity_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'Entity'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "Entity", (PyObject*) builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "Entity");
  d = md;
  
  /* type 'ampl::EntityArgs' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__EntityArgs_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'EntityArgs'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "EntityArgs", (PyObject*) builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "EntityArgs");
  d = md;
  
  /* type 'ampl::BasicEntity< ampl::VariableInstance >' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__BasicEntityT_ampl__VariableInstance_t_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_basetype = SWIG_MangledTypeQuery("_p_ampl__Entity");
  if (builtin_basetype && builtin_basetype->clientdata && ((SwigPyClientData*) builtin_basetype->clientdata)->pytype) {
    builtin_bases[builtin_base_count++] = ((SwigPyClientData*) builtin_basetype->clientdata)->pytype;
  } else {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'BasicEntityVariable' as base 'ampl::Entity' has not been initialized.\n");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'BasicEntityVariable'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "BasicEntityVariable", (PyObject*) builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "BasicEntityVariable");
  d = md;
  
  /* type 'ampl::BasicEntity< ampl::ConstraintInstance >' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__BasicEntityT_ampl__ConstraintInstance_t_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_basetype = SWIG_MangledTypeQuery("_p_ampl__Entity");
  if (builtin_basetype && builtin_basetype->clientdata && ((SwigPyClientData*) builtin_basetype->clientdata)->pytype) {
    builtin_bases[builtin_base_count++] = ((SwigPyClientData*) builtin_basetype->clientdata)->pytype;
  } else {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'BasicEntityConstraint' as base 'ampl::Entity' has not been initialized.\n");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'BasicEntityConstraint'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "BasicEntityConstraint", (PyObject*) builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "BasicEntityConstraint");
  d = md;
  
  /* type 'ampl::BasicEntity< ampl::SetInstance >' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__BasicEntityT_ampl__SetInstance_t_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_basetype = SWIG_MangledTypeQuery("_p_ampl__Entity");
  if (builtin_basetype && builtin_basetype->clientdata && ((SwigPyClientData*) builtin_basetype->clientdata)->pytype) {
    builtin_bases[builtin_base_count++] = ((SwigPyClientData*) builtin_basetype->clientdata)->pytype;
  } else {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'BasicEntitySet' as base 'ampl::Entity' has not been initialized.\n");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'BasicEntitySet'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "BasicEntitySet", (PyObject*) builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "BasicEntitySet");
  d = md;
  
  /* type 'ampl::BasicEntity< ampl::ObjectiveInstance >' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__BasicEntityT_ampl__ObjectiveInstance_t_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_basetype = SWIG_MangledTypeQuery("_p_ampl__Entity");
  if (builtin_basetype && builtin_basetype->clientdata && ((SwigPyClientData*) builtin_basetype->clientdata)->pytype) {
    builtin_bases[builtin_base_count++] = ((SwigPyClientData*) builtin_basetype->clientdata)->pytype;
  } else {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'BasicEntityObjective' as base 'ampl::Entity' has not been initialized.\n");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'BasicEntityObjective'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "BasicEntityObjective", (PyObject*) builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "BasicEntityObjective");
  d = md;
  
  /* type 'ampl::BasicEntity< ampl::VariantRef >' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__BasicEntityT_ampl__VariantRef_t_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_basetype = SWIG_MangledTypeQuery("_p_ampl__Entity");
  if (builtin_basetype && builtin_basetype->clientdata && ((SwigPyClientData*) builtin_basetype->clientdata)->pytype) {
    builtin_bases[builtin_base_count++] = ((SwigPyClientData*) builtin_basetype->clientdata)->pytype;
  } else {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'BasicEntityParameter' as base 'ampl::Entity' has not been initialized.\n");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'BasicEntityParameter'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "BasicEntityParameter", (PyObject*) builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "BasicEntityParameter");
  d = md;
  
  /* type 'ampl::Constraint' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__Constraint_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_basetype = SWIG_MangledTypeQuery("_p_ampl__BasicEntityT_ampl__ConstraintInstance_t");
  if (builtin_basetype && builtin_basetype->clientdata && ((SwigPyClientData*) builtin_basetype->clientdata)->pytype) {
    builtin_bases[builtin_base_count++] = ((SwigPyClientData*) builtin_basetype->clientdata)->pytype;
  } else {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'Constraint' as base 'ampl::BasicEntity<(ampl::ConstraintInstance)>' has not been initialized.\n");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'Constraint'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "Constraint", (PyObject*) builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "Constraint");
  d = md;
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "CONTINUOUS",SWIG_From_int(static_cast< int >(ampl::var::CONTINUOUS)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "BINARY",SWIG_From_int(static_cast< int >(ampl::var::BINARY)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "INTEGER",SWIG_From_int(static_cast< int >(ampl::var::INTEGER)));
  
  /* type 'ampl::Variable' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__Variable_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_basetype = SWIG_MangledTypeQuery("_p_ampl__BasicEntityT_ampl__VariableInstance_t");
  if (builtin_basetype && builtin_basetype->clientdata && ((SwigPyClientData*) builtin_basetype->clientdata)->pytype) {
    builtin_bases[builtin_base_count++] = ((SwigPyClientData*) builtin_basetype->clientdata)->pytype;
  } else {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'Variable' as base 'ampl::BasicEntity<(ampl::VariableInstance)>' has not been initialized.\n");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'Variable'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "Variable", (PyObject*) builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "Variable");
  d = md;
  
  /* type 'ampl::Objective' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__Objective_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_basetype = SWIG_MangledTypeQuery("_p_ampl__BasicEntityT_ampl__ObjectiveInstance_t");
  if (builtin_basetype && builtin_basetype->clientdata && ((SwigPyClientData*) builtin_basetype->clientdata)->pytype) {
    builtin_bases[builtin_base_count++] = ((SwigPyClientData*) builtin_basetype->clientdata)->pytype;
  } else {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'Objective' as base 'ampl::BasicEntity<(ampl::ObjectiveInstance)>' has not been initialized.\n");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'Objective'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "Objective", (PyObject*) builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "Objective");
  d = md;
  
  /* type 'ampl::Set' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__Set_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_basetype = SWIG_MangledTypeQuery("_p_ampl__BasicEntityT_ampl__SetInstance_t");
  if (builtin_basetype && builtin_basetype->clientdata && ((SwigPyClientData*) builtin_basetype->clientdata)->pytype) {
    builtin_bases[builtin_base_count++] = ((SwigPyClientData*) builtin_basetype->clientdata)->pytype;
  } else {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'Set' as base 'ampl::BasicEntity<(ampl::SetInstance)>' has not been initialized.\n");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'Set'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "Set", (PyObject*) builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "Set");
  d = md;
  
  /* type 'ampl::Parameter' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__Parameter_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_basetype = SWIG_MangledTypeQuery("_p_ampl__BasicEntityT_ampl__VariantRef_t");
  if (builtin_basetype && builtin_basetype->clientdata && ((SwigPyClientData*) builtin_basetype->clientdata)->pytype) {
    builtin_bases[builtin_base_count++] = ((SwigPyClientData*) builtin_basetype->clientdata)->pytype;
  } else {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'Parameter' as base 'ampl::BasicEntity<(ampl::VariantRef)>' has not been initialized.\n");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'Parameter'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "Parameter", (PyObject*) builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "Parameter");
  d = md;
  
  /* type 'ampl::internal::EntityWrapper< ampl::VariableInstance >' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__VariableInstance_t_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'VariableIteratorWrapper'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "VariableIteratorWrapper", (PyObject*) builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "VariableIteratorWrapper");
  d = md;
  
  /* type 'ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariableInstance > >' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariableInstance_t_t_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'VariableIterator'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "VariableIterator", (PyObject*) builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "VariableIterator");
  d = md;
  
  /* type 'ampl::internal::EntityWrapper< ampl::ConstraintInstance >' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'ConstraintIteratorWrapper'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "ConstraintIteratorWrapper", (PyObject*) builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "ConstraintIteratorWrapper");
  d = md;
  
  /* type 'ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ConstraintInstance > >' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ConstraintInstance_t_t_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'ConstraintIterator'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "ConstraintIterator", (PyObject*) builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "ConstraintIterator");
  d = md;
  
  /* type 'ampl::internal::EntityWrapper< ampl::ObjectiveInstance >' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'ObjectiveIteratorWrapper'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "ObjectiveIteratorWrapper", (PyObject*) builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "ObjectiveIteratorWrapper");
  d = md;
  
  /* type 'ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::ObjectiveInstance > >' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__ObjectiveInstance_t_t_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'ObjectiveIterator'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "ObjectiveIterator", (PyObject*) builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "ObjectiveIterator");
  d = md;
  
  /* type 'ampl::internal::EntityWrapper< ampl::SetInstance >' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__SetInstance_t_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'SetIteratorWrapper'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "SetIteratorWrapper", (PyObject*) builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "SetIteratorWrapper");
  d = md;
  
  /* type 'ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::SetInstance > >' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__SetInstance_t_t_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'SetIterator'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "SetIterator", (PyObject*) builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "SetIterator");
  d = md;
  
  /* type 'ampl::internal::EntityWrapper< ampl::VariantRef >' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__internal__EntityWrapperT_ampl__VariantRef_t_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'ParameterIteratorWrapper'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "ParameterIteratorWrapper", (PyObject*) builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "ParameterIteratorWrapper");
  d = md;
  
  /* type 'ampl::internal::CountedIterator< ampl::internal::EntityWrapper< ampl::VariantRef > >' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EntityWrapperT_ampl__VariantRef_t_t_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'ParameterIterator'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "ParameterIterator", (PyObject*) builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "ParameterIterator");
  d = md;
  
  /* type 'ampl::EntityMap< ampl::Variable >' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__EntityMapT_ampl__Variable_t_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'EntityMapVariable'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "EntityMapVariable", (PyObject*) builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "EntityMapVariable");
  d = md;
  
  /* type 'ampl::EntityMap< ampl::Variable >::iterator' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__EntityMapT_ampl__Variable_t__iterator_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'EntityMapVariableIterator'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "EntityMapVariableIterator", (PyObject*) builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "EntityMapVariableIterator");
  d = md;
  
  /* type 'ampl::EntityMap< ampl::Constraint >' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__EntityMapT_ampl__Constraint_t_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'EntityMapConstraint'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "EntityMapConstraint", (PyObject*) builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "EntityMapConstraint");
  d = md;
  
  /* type 'ampl::EntityMap< ampl::Constraint >::iterator' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__EntityMapT_ampl__Constraint_t__iterator_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'EntityMapConstraintIterator'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "EntityMapConstraintIterator", (PyObject*) builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "EntityMapConstraintIterator");
  d = md;
  
  /* type 'ampl::EntityMap< ampl::Objective >' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__EntityMapT_ampl__Objective_t_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'EntityMapObjective'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "EntityMapObjective", (PyObject*) builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "EntityMapObjective");
  d = md;
  
  /* type 'ampl::EntityMap< ampl::Objective >::iterator' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__EntityMapT_ampl__Objective_t__iterator_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'EntityMapObjectiveIterator'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "EntityMapObjectiveIterator", (PyObject*) builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "EntityMapObjectiveIterator");
  d = md;
  
  /* type 'ampl::EntityMap< ampl::Set >' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__EntityMapT_ampl__Set_t_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'EntityMapSet'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "EntityMapSet", (PyObject*) builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "EntityMapSet");
  d = md;
  
  /* type 'ampl::EntityMap< ampl::Set >::iterator' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__EntityMapT_ampl__Set_t__iterator_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'EntityMapSetIterator'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "EntityMapSetIterator", (PyObject*) builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "EntityMapSetIterator");
  d = md;
  
  /* type 'ampl::EntityMap< ampl::Parameter >' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__EntityMapT_ampl__Parameter_t_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'EntityMapParameter'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "EntityMapParameter", (PyObject*) builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "EntityMapParameter");
  d = md;
  
  /* type 'ampl::EntityMap< ampl::Parameter >::iterator' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__EntityMapT_ampl__Parameter_t__iterator_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'EntityMapParameterIterator'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "EntityMapParameterIterator", (PyObject*) builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "EntityMapParameterIterator");
  d = md;
  
  /* type 'ampl::AMPLException' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__AMPLException_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_basetype = SWIG_MangledTypeQuery("_p_std__runtime_error");
  if (builtin_basetype && builtin_basetype->clientdata && ((SwigPyClientData*) builtin_basetype->clientdata)->pytype) {
    builtin_bases[builtin_base_count++] = ((SwigPyClientData*) builtin_basetype->clientdata)->pytype;
  } else {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'AMPLException' as base 'std::runtime_error' has not been initialized.\n");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'AMPLException'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "AMPLException", (PyObject*) builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "AMPLException");
  d = md;
  
  /* type 'ampl::LicenseException' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__LicenseException_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_basetype = SWIG_MangledTypeQuery("_p_std__runtime_error");
  if (builtin_basetype && builtin_basetype->clientdata && ((SwigPyClientData*) builtin_basetype->clientdata)->pytype) {
    builtin_bases[builtin_base_count++] = ((SwigPyClientData*) builtin_basetype->clientdata)->pytype;
  } else {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'LicenseException' as base 'std::runtime_error' has not been initialized.\n");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'LicenseException'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "LicenseException", (PyObject*) builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "LicenseException");
  d = md;
  
  /* type 'ampl::FileIOException' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__FileIOException_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_basetype = SWIG_MangledTypeQuery("_p_std__runtime_error");
  if (builtin_basetype && builtin_basetype->clientdata && ((SwigPyClientData*) builtin_basetype->clientdata)->pytype) {
    builtin_bases[builtin_base_count++] = ((SwigPyClientData*) builtin_basetype->clientdata)->pytype;
  } else {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'FileIOException' as base 'std::runtime_error' has not been initialized.\n");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'FileIOException'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "FileIOException", (PyObject*) builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "FileIOException");
  d = md;
  
  /* type 'ampl::UnsupportedOperationException' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__UnsupportedOperationException_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_basetype = SWIG_MangledTypeQuery("_p_std__runtime_error");
  if (builtin_basetype && builtin_basetype->clientdata && ((SwigPyClientData*) builtin_basetype->clientdata)->pytype) {
    builtin_bases[builtin_base_count++] = ((SwigPyClientData*) builtin_basetype->clientdata)->pytype;
  } else {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'UnsupportedOperationException' as base 'std::runtime_error' has not been initialized.\n");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'UnsupportedOperationException'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "UnsupportedOperationException", (PyObject*) builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "UnsupportedOperationException");
  d = md;
  
  /* type 'ampl::InvalidSubscriptException' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__InvalidSubscriptException_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_basetype = SWIG_MangledTypeQuery("_p_ampl__AMPLException");
  if (builtin_basetype && builtin_basetype->clientdata && ((SwigPyClientData*) builtin_basetype->clientdata)->pytype) {
    builtin_bases[builtin_base_count++] = ((SwigPyClientData*) builtin_basetype->clientdata)->pytype;
  } else {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'InvalidSubscriptException' as base 'ampl::AMPLException' has not been initialized.\n");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'InvalidSubscriptException'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "InvalidSubscriptException", (PyObject*) builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "InvalidSubscriptException");
  d = md;
  
  /* type 'ampl::SyntaxErrorException' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__SyntaxErrorException_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_basetype = SWIG_MangledTypeQuery("_p_ampl__AMPLException");
  if (builtin_basetype && builtin_basetype->clientdata && ((SwigPyClientData*) builtin_basetype->clientdata)->pytype) {
    builtin_bases[builtin_base_count++] = ((SwigPyClientData*) builtin_basetype->clientdata)->pytype;
  } else {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'SyntaxErrorException' as base 'ampl::AMPLException' has not been initialized.\n");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'SyntaxErrorException'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "SyntaxErrorException", (PyObject*) builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "SyntaxErrorException");
  d = md;
  
  /* type 'ampl::NoDataException' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__NoDataException_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_basetype = SWIG_MangledTypeQuery("_p_ampl__AMPLException");
  if (builtin_basetype && builtin_basetype->clientdata && ((SwigPyClientData*) builtin_basetype->clientdata)->pytype) {
    builtin_bases[builtin_base_count++] = ((SwigPyClientData*) builtin_basetype->clientdata)->pytype;
  } else {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'NoDataException' as base 'ampl::AMPLException' has not been initialized.\n");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'NoDataException'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "NoDataException", (PyObject*) builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "NoDataException");
  d = md;
  
  /* type 'ampl::ErrorHandler' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__ErrorHandler_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'ErrorHandler'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "ErrorHandler", (PyObject*) builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "ErrorHandler");
  d = md;
  
  /* type 'ampl::Runnable' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__Runnable_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'Runnable'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "Runnable", (PyObject*) builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "Runnable");
  d = md;
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "WAITING",SWIG_From_int(static_cast< int >(ampl::output::WAITING)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "BREAK",SWIG_From_int(static_cast< int >(ampl::output::BREAK)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "CD",SWIG_From_int(static_cast< int >(ampl::output::CD)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "DISPLAY",SWIG_From_int(static_cast< int >(ampl::output::DISPLAY)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "EXIT",SWIG_From_int(static_cast< int >(ampl::output::EXIT)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "EXPAND",SWIG_From_int(static_cast< int >(ampl::output::EXPAND)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "LOAD",SWIG_From_int(static_cast< int >(ampl::output::LOAD)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "OPTION",SWIG_From_int(static_cast< int >(ampl::output::OPTION)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "PRINT",SWIG_From_int(static_cast< int >(ampl::output::PRINT)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "PROMPT",SWIG_From_int(static_cast< int >(ampl::output::PROMPT)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "SOLUTION",SWIG_From_int(static_cast< int >(ampl::output::SOLUTION)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "SOLVE",SWIG_From_int(static_cast< int >(ampl::output::SOLVE)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "SHOW",SWIG_From_int(static_cast< int >(ampl::output::SHOW)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "XREF",SWIG_From_int(static_cast< int >(ampl::output::XREF)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "SHELL_OUTPUT",SWIG_From_int(static_cast< int >(ampl::output::SHELL_OUTPUT)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "SHELL_MESSAGE",SWIG_From_int(static_cast< int >(ampl::output::SHELL_MESSAGE)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "MISC",SWIG_From_int(static_cast< int >(ampl::output::MISC)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "WRITE_TABLE",SWIG_From_int(static_cast< int >(ampl::output::WRITE_TABLE)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "READ_TABLE",SWIG_From_int(static_cast< int >(ampl::output::READ_TABLE)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "_READTABLE",SWIG_From_int(static_cast< int >(ampl::output::_READTABLE)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "_WRITETABLE",SWIG_From_int(static_cast< int >(ampl::output::_WRITETABLE)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "BREAKPOINT",SWIG_From_int(static_cast< int >(ampl::output::BREAKPOINT)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "CALL",SWIG_From_int(static_cast< int >(ampl::output::CALL)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "CHECK",SWIG_From_int(static_cast< int >(ampl::output::CHECK)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "CLOSE",SWIG_From_int(static_cast< int >(ampl::output::CLOSE)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "COMMANDS",SWIG_From_int(static_cast< int >(ampl::output::COMMANDS)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "CONTINUE",SWIG_From_int(static_cast< int >(ampl::output::CONTINUE)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "DATA",SWIG_From_int(static_cast< int >(ampl::output::DATA)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "DELETECMD",SWIG_From_int(static_cast< int >(ampl::output::DELETECMD)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "DROP",SWIG_From_int(static_cast< int >(ampl::output::DROP)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "DROP_OR_RESTORE_ALL",SWIG_From_int(static_cast< int >(ampl::output::DROP_OR_RESTORE_ALL)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "ELSE",SWIG_From_int(static_cast< int >(ampl::output::ELSE)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "ELSE_CHECK",SWIG_From_int(static_cast< int >(ampl::output::ELSE_CHECK)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "ENDIF",SWIG_From_int(static_cast< int >(ampl::output::ENDIF)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "ENVIRON",SWIG_From_int(static_cast< int >(ampl::output::ENVIRON)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "FIX",SWIG_From_int(static_cast< int >(ampl::output::FIX)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "FOR",SWIG_From_int(static_cast< int >(ampl::output::FOR)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "IF",SWIG_From_int(static_cast< int >(ampl::output::IF)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "LET",SWIG_From_int(static_cast< int >(ampl::output::LET)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "LOOPEND",SWIG_From_int(static_cast< int >(ampl::output::LOOPEND)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "OBJECTIVE",SWIG_From_int(static_cast< int >(ampl::output::OBJECTIVE)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "OPTION_RESET",SWIG_From_int(static_cast< int >(ampl::output::OPTION_RESET)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "PRINTF",SWIG_From_int(static_cast< int >(ampl::output::PRINTF)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "PROBLEM",SWIG_From_int(static_cast< int >(ampl::output::PROBLEM)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "PURGE",SWIG_From_int(static_cast< int >(ampl::output::PURGE)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "RBRACE",SWIG_From_int(static_cast< int >(ampl::output::RBRACE)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "READ",SWIG_From_int(static_cast< int >(ampl::output::READ)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "RELOAD",SWIG_From_int(static_cast< int >(ampl::output::RELOAD)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "REMOVE",SWIG_From_int(static_cast< int >(ampl::output::REMOVE)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "REPEAT",SWIG_From_int(static_cast< int >(ampl::output::REPEAT)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "REPEAT_END",SWIG_From_int(static_cast< int >(ampl::output::REPEAT_END)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "RESET",SWIG_From_int(static_cast< int >(ampl::output::RESET)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "RESTORE",SWIG_From_int(static_cast< int >(ampl::output::RESTORE)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "RUN_ARGS",SWIG_From_int(static_cast< int >(ampl::output::RUN_ARGS)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "SEMICOLON",SWIG_From_int(static_cast< int >(ampl::output::SEMICOLON)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "SSTEP",SWIG_From_int(static_cast< int >(ampl::output::SSTEP)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "THEN",SWIG_From_int(static_cast< int >(ampl::output::THEN)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "UNFIX",SWIG_From_int(static_cast< int >(ampl::output::UNFIX)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "UNLOAD",SWIG_From_int(static_cast< int >(ampl::output::UNLOAD)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "UPDATE",SWIG_From_int(static_cast< int >(ampl::output::UPDATE)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "WRITE",SWIG_From_int(static_cast< int >(ampl::output::WRITE)));
  
  /* type 'ampl::OutputHandler' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__OutputHandler_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'OutputHandler'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "OutputHandler", (PyObject*) builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "OutputHandler");
  d = md;
  
  /* type 'ampl::internal::EnvironmentIterator' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__internal__EnvironmentIterator_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'EnvironmentIterator'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "EnvironmentIterator", (PyObject*) builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "EnvironmentIterator");
  d = md;
  
  /* type 'ampl::Environment' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__Environment_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'Environment'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "Environment", (PyObject*) builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "Environment");
  d = md;
  
  /* type 'ampl::internal::CountedIterator< ampl::internal::EnvironmentIterator >' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__internal__CountedIteratorT_ampl__internal__EnvironmentIterator_t_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'EnvironmentIteratorTemplate'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "EnvironmentIteratorTemplate", (PyObject*) builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "EnvironmentIteratorTemplate");
  d = md;
  
  /* type 'ampl::AMPL' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ampl__AMPL_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'AMPL'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "AMPL", (PyObject*) builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "AMPL");
  d = md;
#if PY_VERSION_HEX >= 0x03000000
  return m;
#else
  return;
#endif
}

